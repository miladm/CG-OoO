commit.cpp:                CAMtable<dynInstruction*>* iROB,
commit.cpp:    _iROB = iROB;
commit.cpp:        if (_iROB->getTableState () == EMPTY_BUFF) break;
commit.cpp:        if (!_iROB->hasFreeRdPort (clk.now ())) break;
commit.cpp:        dynInstruction* ins = _iROB->getFront ();
commit.cpp:        ins = _iROB->popFront();
commit.cpp:    if (_iROB->getTableSize() == 0) return;
commit.cpp:    LENGTH start_indx = 0, stop_indx = _iROB->getTableSize() - 1;
commit.cpp:    for (LENGTH i = 0; i < _iROB->getTableSize(); i++) {
commit.cpp:        if (_iROB->getTableSize() == 0) break;
commit.cpp:        ins = _iROB->getNth_unsafe (i);
commit.cpp:    Assert (_iROB->getTableSize() > stop_indx && stop_indx >= start_indx && start_indx >= 0);
commit.cpp:    for (LENGTH i = _iROB->getTableSize() - 1; i > stop_indx; i--) {
commit.cpp:        if (_iROB->getTableSize() == 0) break;
commit.cpp:        ins = _iROB->getNth_unsafe (i);
commit.cpp:        _iROB->removeNth_unsafe (i);
commit.cpp:        if (_iROB->getTableSize() == 0) break;
commit.cpp:        ins = _iROB->getNth_unsafe (i);
commit.cpp:        _iROB->removeNth_unsafe (i);
commit.cpp:    //_iROB->regStat ();
commit.h:                CAMtable<dynInstruction*>* iROB,
commit.h:        CAMtable<dynInstruction*>* _iROB;
execution.cpp:                      CAMtable<dynInstruction*>* iROB,
execution.cpp:    _iROB = iROB;
execution.cpp:    } else if (g_var.g_pipe_state == PIPE_DRAIN && _iROB->hasFreeRdPort (clk.now ()) && 
execution.cpp:               _iROB->getFront()->getInsID () >= g_var.g_squash_seq_num) {
execution.cpp:    } else if (g_var.g_pipe_state == PIPE_SQUASH_ROB && _iROB->getTableSize() == 0) {
execution.h:                   CAMtable<dynInstruction*>* iROB,
execution.h:        CAMtable<dynInstruction*>* _iROB;
memory.cpp:                CAMtable<dynInstruction*>* iROB,
memory.cpp:    _iROB = iROB;
memory.h:                CAMtable<dynInstruction*>* iROB,
memory.h:        CAMtable<dynInstruction*>* _iROB;
schedulers.cpp:                      CAMtable<dynInstruction*>* iROB,
schedulers.cpp:    _iROB = iROB;
schedulers.cpp:            if (_iROB->getTableState () == FULL_BUFF) break;
schedulers.cpp:            if (!_iROB->hasFreeWrPort (clk.now ())) break;
schedulers.cpp:            _iROB->pushBack (ins);
schedulers.h:                   CAMtable<dynInstruction*>* iROB,
schedulers.h:        CAMtable<dynInstruction*>* _iROB;
sysCore.cpp:    _iROB = new CAMtable<dynInstruction*>(100, 32, 32, "iROB");
sysCore.cpp:    _scheduler = new o3_scheduler (_decode_to_scheduler_port, _execution_to_scheduler_port, _memory_to_scheduler_port, _scheduler_to_execution_port, _iROB, scheduler_width, "schedule");
sysCore.cpp:    _execution = new o3_execution (_scheduler_to_execution_port, _execution_to_scheduler_port, _execution_to_memory_port, _iROB, execution_width, "execution");
sysCore.cpp:    _memory = new o3_memory (_execution_to_memory_port, _memory_to_scheduler_port, _iROB, memory_width, "memory");
sysCore.cpp:    _commit = new o3_commit (_commit_to_bp_port, _commit_to_scheduler_port, _iROB, commit_width, "commit");
sysCore.cpp:    delete _iROB;
sysCore.h:        CAMtable<dynInstruction*>* _iROB;
