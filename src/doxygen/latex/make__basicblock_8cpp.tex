\hypertarget{make__basicblock_8cpp}{
\section{/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/make\_\-basicblock.cpp File Reference}
\label{make__basicblock_8cpp}\index{/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/make\_\-basicblock.cpp@{/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/make\_\-basicblock.cpp}}
}
{\ttfamily \#include \char`\"{}make\_\-basicblock.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}listSchedule.h\char`\"{}}\par
Include dependency graph for make\_\-basicblock.cpp:
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{make__basicblock_8cpp_a765669fc41b8885a39c1ec0df0df96ca}{make\_\-basicblock} (\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$insList, \hyperlink{classList}{List}$<$ \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$bbList, map$<$ int, \hyperlink{classvariable}{variable} $\ast$ $>$ \&varList, set$<$ \hyperlink{binaryTranslator_2global_8h_aa4557b0650cb21e57e3e4623410832c6}{ADDR} $>$ $\ast$brDstSet, map$<$ \hyperlink{binaryTranslator_2global_8h_aa4557b0650cb21e57e3e4623410832c6}{ADDR}, \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$bbMap, map$<$ \hyperlink{binaryTranslator_2global_8h_aa4557b0650cb21e57e3e4623410832c6}{ADDR}, \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$insAddrMap)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{make__basicblock_8cpp_a765669fc41b8885a39c1ec0df0df96ca}{
\index{make\_\-basicblock.cpp@{make\_\-basicblock.cpp}!make\_\-basicblock@{make\_\-basicblock}}
\index{make\_\-basicblock@{make\_\-basicblock}!make_basicblock.cpp@{make\_\-basicblock.cpp}}
\subsubsection[{make\_\-basicblock}]{\setlength{\rightskip}{0pt plus 5cm}void make\_\-basicblock (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{insList, }
\item[{{\bf List}$<$ {\bf basicblock} $\ast$ $>$ $\ast$}]{bbList, }
\item[{map$<$ int, {\bf variable} $\ast$ $>$ \&}]{varList, }
\item[{set$<$ {\bf ADDR} $>$ $\ast$}]{brDstSet, }
\item[{map$<$ {\bf ADDR}, {\bf basicblock} $\ast$ $>$ $\ast$}]{bbMap, }
\item[{map$<$ {\bf ADDR}, {\bf instruction} $\ast$ $>$ $\ast$}]{insAddrMap}
\end{DoxyParamCaption}
)}}
\label{make__basicblock_8cpp_a765669fc41b8885a39c1ec0df0df96ca}

\begin{DoxyCode}
                                                                              {
        // Construct BB's
        set<long int> use_set, def_set, diff_set;
        for (int i = 0; i < insList->NumElements(); i++) {
                instruction* ins = insList->Nth(i);
                //Construct the destination instruction address set (stat info)
                for (int j = 0; j < ins->getNumReg(); j++) {
                        if (ins->getNthRegType(j) == READ)
                                use_set.insert(ins->getNthReg(j));
                        else if (ins->getNthRegType(j) == WRITE)
                                def_set.insert(ins->getNthReg(j));
                }
                //Construct new Basicblock or add ins to an existing one 
                //printf("Type: %c\n", insList->Nth(i)->getType());
                if (i == 0 ||
                    brDstSet->find(ins->getInsAddr()) != brDstSet->end()) {
                        basicblock* newBB;
                        if (i == 0 || bbList->Nth(bbList->NumElements()-1)->getBb
      Size() > 0) {
                                newBB = new basicblock;
                                newBB->setListIndx(bbList->NumElements());
                                bbList->Append(newBB);
                        } else {
                                //avoid making empty BB's
                                newBB = bbList->Nth(bbList->NumElements()-1);
                        }
                        newBB->addIns(ins);
                        bbMap->insert(pair <ADDR, basicblock*>(newBB->getID(), ne
      wBB));
                        //The case with a single branch/jump/call instruction in 
      BB (closing BB)
                        if (ins->getType() == 'j' || ins->getType() == 'b' || ins
      ->getType() == 'r') {
                                bbList->Nth(bbList->NumElements()-1)->setBBbrHead
      er(ins->getInsAddr());
                                newBB = new basicblock;
                                newBB->setListIndx(bbList->NumElements());
                                bbList->Append(newBB);
                        }
                        //printf("%llx, %llx\n", ins->getInsAddr(), newBB->getID(
      ));
                } else if (ins->getType() == 'j' || ins->getType() == 'b' || ins-
      >getType() == 'r') {
                        bbList->Nth(bbList->NumElements()-1)->setBBbrHeader(ins->
      getInsAddr());
                        bbList->Nth(bbList->NumElements()-1)->addIns(ins);
                        basicblock* newBB = new basicblock;
                        newBB->setListIndx(bbList->NumElements());
                        bbList->Append(newBB);
                        //printf("%llx\n", ins->getInsAddr());
                } else {
                        basicblock *bb = bbList->Nth(bbList->NumElements()-1);
                        bb->addIns(ins);
                        if (bb->getBbSize() == 1) {
                                bbMap->insert(pair <ADDR, basicblock*>(bb->getID(
      ), bb));
                                //printf("%llx, %llx\n", ins->getInsAddr(), bb->g
      etID());
                        } //else
                                //printf("%llx\n", ins->getInsAddr());
                }
        }
        printf("\tNum BB before Dead BB Elimination: %d\n",bbList->NumElements())
      ;
        //get rid of empty basicblocks (shouldn't find any empty ones - just prec
      aution)
        set<ADDR> toRemoveInsSet;
        for (int i = bbList->NumElements()-1; i >= 0; i--) {
                if (bbList->Nth(i)->getBbSize() == 0) {
                        // delete bbList->Nth(i);
                        bbList->RemoveAt(i);
                } else if (bbList->Nth(i)->getBbSize() == 1) {
                        instruction* ins = bbList->Nth(i)->getLastIns();
                        string str(ins->getOpCode());
                        if (str.compare("#NOP\n") == 0) {
                                toRemoveInsSet.insert(ins->getInsAddr());
                                // delete bbList->Nth(i);
                                bbList->RemoveAt(i);
                        }
                }
        }
        printf("\tNum BB after Dead BB Elimination: %d\n",bbList->NumElements());
      
        //Remove NOP instructions from insList
        for (int i = insList->NumElements()-1; i >= 0; i--) {
                instruction* ins = insList->Nth(i);
                if (toRemoveInsSet.find(ins->getInsAddr()) != toRemoveInsSet.end(
      )) {
                        // delete insList->Nth(i);
                        insList->RemoveAt(i);
                        insAddrMap->erase(ins->getInsAddr());
                }
        }
        // Setup BB Dependencies
        for (int i = 0; i < bbList->NumElements(); i++) {
                basicblock* bb = bbList->Nth(i);
                Assert(bb->getBbSize() > 0 && "Invalid BB Size.");
                instruction* ins = bb->getLastIns();
                char type = ins->getType();
                if (type == 'j') { //unconditional jump 
                        ADDR insDst = bb->getLastInsDst();
                        basicblock* bbDst;
                        if (bbMap->find(insDst) != bbMap->end()) {
                                bbDst = (*bbMap)[insDst];
                                bb->setDescendent(bbDst);
                                bb->setTakenTarget(bbDst);
                        } else {
                                printf("\tERROR: Didn't find destination bb, %llx
       (%s, line: %d)\n", insDst , __FILE__, __LINE__);
                                //exit(1);
                                continue;
                        }
                } else if (type == 'o' || type == 'M') { //non-jump
                        if (i+1 < bbList->NumElements()) {                              
                                bb->setDescendent(bbList->Nth(i+1));
                                bb->setFallThrough(bbList->Nth(i+1));
                        }
                } else if (type == 'b') { //conditional jump
                        if (i+1 < bbList->NumElements()) {
                                bb->setDescendent(bbList->Nth(i+1));
                                bb->setFallThrough(bbList->Nth(i+1));
                        }
                        ADDR insDst = bb->getLastInsDst();
                        basicblock* bbDst;
                        if (bbMap->find(insDst) != bbMap->end()) {
                                bbDst = (*bbMap)[insDst];
                                bb->setDescendent(bbDst);
                                bb->setTakenTarget(bbDst);
                        } else {
                                printf("\tERROR: Didn't find destination bb, %llx
       (%s, line: %d)\n", insDst , __FILE__, __LINE__);
                                //exit(1);
                                continue;
                        }
                } else if (type == 'c') { //func call
                        // Assumptions on function calls 
                        // Call does not terminate BB's
                        // The CFG links to function called is not established
                        // Call does not disturb the CFG flow and dependency b/w 
      BB's
                        if (i+1 < bbList->NumElements()) {                              
                                bb->setDescendent(bbList->Nth(i+1));
                                bb->setFallThrough(bbList->Nth(i+1));
                        }
                } else if (type == 'r') { //func return
                        ;//do nothing on return. must have been the end of functi
      on
                } else {
                        printf("Wrong Ins Type: %c\n", type);
                        Assert (true == false && "WRONG INSTRUTION. Terminating..
      .");
                }
        }       
        // Perform List Scheduling on BB
        /*for (int i = 0; i < bbList->NumElements(); i++) {
                basicblock* bb = bbList->Nth(i);
                listSchedule(bb); //why does this affect BB structure?
        }*/
        std::set_difference(use_set.begin(), use_set.end(), def_set.begin(), def_
      set.end(), std::inserter(diff_set, diff_set.begin()));
        printf("\tDiff Set: %d %d %d\n", def_set.size(), use_set.size(), diff_set
      .size());
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


