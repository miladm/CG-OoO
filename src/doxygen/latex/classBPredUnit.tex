\hypertarget{classBPredUnit}{
\section{BPredUnit$<$ Impl $>$ Class Template Reference}
\label{classBPredUnit}\index{BPredUnit@{BPredUnit}}
}


{\ttfamily \#include $<$bpred\_\-unit.h$>$}

\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct {\bfseries PredictorHistory}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
const std::string \& \hyperlink{classBPredUnit_aeaaeb15f110f0ed58cc3161d6f6ace22}{name} () const 
\item 
void \hyperlink{classBPredUnit_a0cffcea165538b2e7fd554a92b8d9b85}{regStats} ()
\item 
void \hyperlink{classBPredUnit_ac33c3d29c7b6aca9578fc416eb34e60e}{switchOut} ()
\item 
void \hyperlink{classBPredUnit_a9011bcc9143d2396dfec49828484a645}{takeOverFrom} ()
\item 
bool \hyperlink{classBPredUnit_add836c4a521ed2bd12eca4d1dee13620}{predict} (DynInstPtr \&inst, TheISA::PCState \&pc, ThreadID tid, bool odbpStatic, bool predTaken, int positionInFetchGroup, int positionInLine, bool \&allPredStatic, int oracleBP)
\item 
void \hyperlink{classBPredUnit_a89690e897bb5661ee868f659a06515c9}{increase\_\-BP\_\-lookup} (int)
\item 
void \hyperlink{classBPredUnit_a471a1acb994d07a6d57b2f39ce56e6a4}{increase\_\-BP\_\-lookup\_\-and\_\-update} (int)
\item 
void \hyperlink{classBPredUnit_a41ecb08c99f45538eaf1de4e184905b4}{increase\_\-BTB\_\-lookup} ()
\item 
void \hyperlink{classBPredUnit_a24bfe00e5e8c2a318930a6474ed60173}{BPUncond} (void $\ast$\&bp\_\-history)
\item 
void \hyperlink{classBPredUnit_a282f0c689c4cedfb52221c1ce96b4084}{BP\_\-onDemand} (void $\ast$\&bp\_\-history, bool taken)
\item 
void \hyperlink{classBPredUnit_aa154b29fbf52ad49d89a046e94b53ac9}{update} (const InstSeqNum \&done\_\-sn, ThreadID tid)
\item 
void \hyperlink{classBPredUnit_a94a04b4bdf8f6b9b3cf33882bc16067b}{squash} (const InstSeqNum \&squashed\_\-sn, ThreadID tid)
\item 
void \hyperlink{classBPredUnit_a78e6f48f8a11db90daab850527d48aa7}{squash} (const InstSeqNum \&squashed\_\-sn, const TheISA::PCState \&corr\_\-target, bool actually\_\-taken, ThreadID tid)
\item 
void \hyperlink{classBPredUnit_a14a43c5f5bc8c64c07a075ce1608f9c3}{BPSquash} (void $\ast$bp\_\-history)
\item 
bool \hyperlink{classBPredUnit_aafefe8c8d85f49d118e825fa0c1c0176}{BPLookup} (Addr instPC, void $\ast$\&bp\_\-history, int positionInFetchGroup, bool onDemand, bool \&choicePred)
\item 
void \hyperlink{classBPredUnit_af5b3e6db0cf1f00dee290e16765f28f8}{noBPLookup} (Addr instPC, void $\ast$\&bp\_\-history, int positionInLine)
\item 
void \hyperlink{classBPredUnit_a55a6608f958c4e70360c34bd48c57032}{BPBTBUpdate} (Addr instPC, void $\ast$\&bp\_\-history)
\item 
bool \hyperlink{classBPredUnit_a66a1f6f9cdd28b38b005a666a9976ed7}{BTBValid} (Addr instPC)
\item 
TheISA::PCState \hyperlink{classBPredUnit_a31024f2d92bfd7e778a790f4c6f61498}{BTBLookup} (Addr instPC)
\item 
void \hyperlink{classBPredUnit_a35c57ae0661f1d5dd2169e919741d47b}{BPUpdate} (Addr instPC, bool taken, void $\ast$bp\_\-history, bool squashed)
\item 
void \hyperlink{classBPredUnit_a16de9793a28ee07dcf26d89c03328555}{BPHistUpdate} (Addr instPC, bool taken, void $\ast$bp\_\-history, bool squashed)
\item 
void \hyperlink{classBPredUnit_a9268abcbddfdfd6e6a076ecd343a3de5}{BPHistGarbageCollect} (void $\ast$bp\_\-history)
\item 
void \hyperlink{classBPredUnit_a5afe025cde23c608d745e8daca63e8a6}{BTBUpdate} (Addr instPC, const TheISA::PCState \&target)
\item 
const std::string \& \hyperlink{classBPredUnit_aeaaeb15f110f0ed58cc3161d6f6ace22}{name} () const 
\item 
void \hyperlink{classBPredUnit_a0cffcea165538b2e7fd554a92b8d9b85}{regStats} ()
\item 
void \hyperlink{classBPredUnit_ac33c3d29c7b6aca9578fc416eb34e60e}{switchOut} ()
\item 
void \hyperlink{classBPredUnit_a9011bcc9143d2396dfec49828484a645}{takeOverFrom} ()
\item 
bool \hyperlink{classBPredUnit_add836c4a521ed2bd12eca4d1dee13620}{predict} (DynInstPtr \&inst, TheISA::PCState \&pc, ThreadID tid, bool odbpStatic, bool predTaken, int positionInFetchGroup, int positionInLine, bool \&allPredStatic, int oracleBP)
\item 
void \hyperlink{classBPredUnit_a89690e897bb5661ee868f659a06515c9}{increase\_\-BP\_\-lookup} (int)
\item 
void \hyperlink{classBPredUnit_a471a1acb994d07a6d57b2f39ce56e6a4}{increase\_\-BP\_\-lookup\_\-and\_\-update} (int)
\item 
void \hyperlink{classBPredUnit_a41ecb08c99f45538eaf1de4e184905b4}{increase\_\-BTB\_\-lookup} ()
\item 
void \hyperlink{classBPredUnit_a24bfe00e5e8c2a318930a6474ed60173}{BPUncond} (void $\ast$\&bp\_\-history)
\item 
void \hyperlink{classBPredUnit_a282f0c689c4cedfb52221c1ce96b4084}{BP\_\-onDemand} (void $\ast$\&bp\_\-history, bool taken)
\item 
void \hyperlink{classBPredUnit_aa154b29fbf52ad49d89a046e94b53ac9}{update} (const InstSeqNum \&done\_\-sn, ThreadID tid)
\item 
void \hyperlink{classBPredUnit_a94a04b4bdf8f6b9b3cf33882bc16067b}{squash} (const InstSeqNum \&squashed\_\-sn, ThreadID tid)
\item 
void \hyperlink{classBPredUnit_a78e6f48f8a11db90daab850527d48aa7}{squash} (const InstSeqNum \&squashed\_\-sn, const TheISA::PCState \&corr\_\-target, bool actually\_\-taken, ThreadID tid)
\item 
void \hyperlink{classBPredUnit_a14a43c5f5bc8c64c07a075ce1608f9c3}{BPSquash} (void $\ast$bp\_\-history)
\item 
bool \hyperlink{classBPredUnit_aafefe8c8d85f49d118e825fa0c1c0176}{BPLookup} (Addr instPC, void $\ast$\&bp\_\-history, int positionInFetchGroup, bool onDemand, bool \&choicePred)
\item 
void \hyperlink{classBPredUnit_af5b3e6db0cf1f00dee290e16765f28f8}{noBPLookup} (Addr instPC, void $\ast$\&bp\_\-history, int positionInLine)
\item 
void \hyperlink{classBPredUnit_a55a6608f958c4e70360c34bd48c57032}{BPBTBUpdate} (Addr instPC, void $\ast$\&bp\_\-history)
\item 
bool \hyperlink{classBPredUnit_a66a1f6f9cdd28b38b005a666a9976ed7}{BTBValid} (Addr instPC)
\item 
TheISA::PCState \hyperlink{classBPredUnit_a31024f2d92bfd7e778a790f4c6f61498}{BTBLookup} (Addr instPC)
\item 
void \hyperlink{classBPredUnit_a35c57ae0661f1d5dd2169e919741d47b}{BPUpdate} (Addr instPC, bool taken, void $\ast$bp\_\-history, bool squashed)
\item 
void \hyperlink{classBPredUnit_a16de9793a28ee07dcf26d89c03328555}{BPHistUpdate} (Addr instPC, bool taken, void $\ast$bp\_\-history, bool squashed)
\item 
void \hyperlink{classBPredUnit_a9268abcbddfdfd6e6a076ecd343a3de5}{BPHistGarbageCollect} (void $\ast$bp\_\-history)
\item 
void \hyperlink{classBPredUnit_a5afe025cde23c608d745e8daca63e8a6}{BTBUpdate} (Addr instPC, const TheISA::PCState \&target)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$class Impl$>$class BPredUnit$<$ Impl $>$}

Basically a wrapper class to hold both the branch predictor and the BTB. 

\subsection{Member Function Documentation}
\hypertarget{classBPredUnit_a282f0c689c4cedfb52221c1ce96b4084}{
\index{BPredUnit@{BPredUnit}!BP\_\-onDemand@{BP\_\-onDemand}}
\index{BP\_\-onDemand@{BP\_\-onDemand}!BPredUnit@{BPredUnit}}
\subsubsection[{BP\_\-onDemand}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BP\_\-onDemand (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{bp\_\-history, }
\item[{bool}]{taken}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a282f0c689c4cedfb52221c1ce96b4084}
\hypertarget{classBPredUnit_a282f0c689c4cedfb52221c1ce96b4084}{
\index{BPredUnit@{BPredUnit}!BP\_\-onDemand@{BP\_\-onDemand}}
\index{BP\_\-onDemand@{BP\_\-onDemand}!BPredUnit@{BPredUnit}}
\subsubsection[{BP\_\-onDemand}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BP\_\-onDemand (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{bp\_\-history, }
\item[{bool}]{taken}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a282f0c689c4cedfb52221c1ce96b4084}
\hypertarget{classBPredUnit_a55a6608f958c4e70360c34bd48c57032}{
\index{BPredUnit@{BPredUnit}!BPBTBUpdate@{BPBTBUpdate}}
\index{BPBTBUpdate@{BPBTBUpdate}!BPredUnit@{BPredUnit}}
\subsubsection[{BPBTBUpdate}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BPBTBUpdate (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC, }
\item[{void $\ast$\&}]{bp\_\-history}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a55a6608f958c4e70360c34bd48c57032}
If a branch is not taken, because the BTB address is invalid or missing, this function sets the appropriate counter in the global and local predictors to not taken. 
\begin{DoxyParams}{Parameters}
{\em inst\_\-PC} & The PC to look up the local predictor. \\
\hline
{\em bp\_\-history} & Pointer that will be set to an object that has the branch predictor state associated with the lookup. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
{
    if (predictor == Local) {
        return localBP->BTBUpdate(instPC, bp_history);
    } else if (predictor == Hybrid) {
        return hybridbp->BTBUpdate(instPC, bp_history);
    } else if (predictor == HybridSkew) {
        return hybridSkewbp->BTBUpdate(instPC, bp_history);
    } else {
        panic("Predictor type is unexpected value!");
    }
}
\end{DoxyCode}
\hypertarget{classBPredUnit_a55a6608f958c4e70360c34bd48c57032}{
\index{BPredUnit@{BPredUnit}!BPBTBUpdate@{BPBTBUpdate}}
\index{BPBTBUpdate@{BPBTBUpdate}!BPredUnit@{BPredUnit}}
\subsubsection[{BPBTBUpdate}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BPBTBUpdate (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC, }
\item[{void $\ast$\&}]{bp\_\-history}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a55a6608f958c4e70360c34bd48c57032}
If a branch is not taken, because the BTB address is invalid or missing, this function sets the appropriate counter in the global and local predictors to not taken. 
\begin{DoxyParams}{Parameters}
{\em inst\_\-PC} & The PC to look up the local predictor. \\
\hline
{\em bp\_\-history} & Pointer that will be set to an object that has the branch predictor state associated with the lookup. \\
\hline
\end{DoxyParams}
\hypertarget{classBPredUnit_a9268abcbddfdfd6e6a076ecd343a3de5}{
\index{BPredUnit@{BPredUnit}!BPHistGarbageCollect@{BPHistGarbageCollect}}
\index{BPHistGarbageCollect@{BPHistGarbageCollect}!BPredUnit@{BPredUnit}}
\subsubsection[{BPHistGarbageCollect}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BPHistGarbageCollect (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{bp\_\-history}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a9268abcbddfdfd6e6a076ecd343a3de5}

\begin{DoxyCode}
{
    if (predictor == Local) {
        assert(false && "this function is not supported for loacl prediction - (s
      ee Milad!)");
    } else if (predictor == Hybrid) {
        hybridbp->histGarbageCollect(bp_history);
    } else if (predictor == HybridSkew) {
        hybridSkewbp->histGarbageCollect(bp_history);
    } else {
        panic("Predictor type is unexpected value!");
    }
}
\end{DoxyCode}
\hypertarget{classBPredUnit_a9268abcbddfdfd6e6a076ecd343a3de5}{
\index{BPredUnit@{BPredUnit}!BPHistGarbageCollect@{BPHistGarbageCollect}}
\index{BPHistGarbageCollect@{BPHistGarbageCollect}!BPredUnit@{BPredUnit}}
\subsubsection[{BPHistGarbageCollect}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BPHistGarbageCollect (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{bp\_\-history}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a9268abcbddfdfd6e6a076ecd343a3de5}
\hypertarget{classBPredUnit_a16de9793a28ee07dcf26d89c03328555}{
\index{BPredUnit@{BPredUnit}!BPHistUpdate@{BPHistUpdate}}
\index{BPHistUpdate@{BPHistUpdate}!BPredUnit@{BPredUnit}}
\subsubsection[{BPHistUpdate}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BPHistUpdate (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC, }
\item[{bool}]{taken, }
\item[{void $\ast$}]{bp\_\-history, }
\item[{bool}]{squashed}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a16de9793a28ee07dcf26d89c03328555}
\hypertarget{classBPredUnit_a16de9793a28ee07dcf26d89c03328555}{
\index{BPredUnit@{BPredUnit}!BPHistUpdate@{BPHistUpdate}}
\index{BPHistUpdate@{BPHistUpdate}!BPredUnit@{BPredUnit}}
\subsubsection[{BPHistUpdate}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BPHistUpdate (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC, }
\item[{bool}]{taken, }
\item[{void $\ast$}]{bp\_\-history, }
\item[{bool}]{squashed}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a16de9793a28ee07dcf26d89c03328555}

\begin{DoxyCode}
{
    if (predictor == Local) {
        assert(false && "this function is not supported for loacl prediction - (s
      ee Milad!)");
    } else if (predictor == Hybrid) {
        hybridbp->histUpdate(instPC, taken, bp_history, squashed);
    } else if (predictor == HybridSkew) {
        hybridSkewbp->histUpdate(instPC, taken, bp_history, squashed);
    } else {
        panic("Predictor type is unexpected value!");
    }
}
\end{DoxyCode}
\hypertarget{classBPredUnit_aafefe8c8d85f49d118e825fa0c1c0176}{
\index{BPredUnit@{BPredUnit}!BPLookup@{BPLookup}}
\index{BPLookup@{BPLookup}!BPredUnit@{BPredUnit}}
\subsubsection[{BPLookup}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ bool {\bf BPredUnit}$<$ Impl $>$::BPLookup (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC, }
\item[{void $\ast$\&}]{bp\_\-history, }
\item[{int}]{positionInFetchGroup, }
\item[{bool}]{onDemand, }
\item[{bool \&}]{choicePred}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_aafefe8c8d85f49d118e825fa0c1c0176}
Looks up a given PC in the BP to see if it is taken or not taken. 
\begin{DoxyParams}{Parameters}
{\em inst\_\-PC} & The PC to look up. \\
\hline
{\em bp\_\-history} & Pointer that will be set to an object that has the branch predictor state associated with the lookup. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether the branch is taken or not taken. 
\end{DoxyReturn}
\hypertarget{classBPredUnit_aafefe8c8d85f49d118e825fa0c1c0176}{
\index{BPredUnit@{BPredUnit}!BPLookup@{BPLookup}}
\index{BPLookup@{BPLookup}!BPredUnit@{BPredUnit}}
\subsubsection[{BPLookup}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ bool {\bf BPredUnit}$<$ Impl $>$::BPLookup (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC, }
\item[{void $\ast$\&}]{bp\_\-history, }
\item[{int}]{positionInFetchGroup, }
\item[{bool}]{onDemand, }
\item[{bool \&}]{choicePred}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_aafefe8c8d85f49d118e825fa0c1c0176}
Looks up a given PC in the BP to see if it is taken or not taken. 
\begin{DoxyParams}{Parameters}
{\em inst\_\-PC} & The PC to look up. \\
\hline
{\em bp\_\-history} & Pointer that will be set to an object that has the branch predictor state associated with the lookup. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether the branch is taken or not taken. 
\end{DoxyReturn}

\begin{DoxyCode}
{
    if (predictor == Local) {
        return localBP->lookup(instPC, bp_history);
    } else if (predictor == Hybrid) {
        bool prediction = hybridbp->lookup(instPC, bp_history, (unsigned)position
      InLine, onDemand, choicePred);
        return prediction;
    } else if (predictor == HybridSkew) {
        bool prediction = hybridSkewbp->lookup(instPC, bp_history, (unsigned)posi
      tionInLine, onDemand, choicePred);
        return prediction;
    } else {
        panic("Predictor type is unexpected value!");
    }
}
\end{DoxyCode}
\hypertarget{classBPredUnit_a14a43c5f5bc8c64c07a075ce1608f9c3}{
\index{BPredUnit@{BPredUnit}!BPSquash@{BPSquash}}
\index{BPSquash@{BPSquash}!BPredUnit@{BPredUnit}}
\subsubsection[{BPSquash}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BPSquash (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{bp\_\-history}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a14a43c5f5bc8c64c07a075ce1608f9c3}

\begin{DoxyParams}{Parameters}
{\em bp\_\-history} & Pointer to the history object. The predictor will need to update any state and delete the object. \\
\hline
\end{DoxyParams}
\hypertarget{classBPredUnit_a14a43c5f5bc8c64c07a075ce1608f9c3}{
\index{BPredUnit@{BPredUnit}!BPSquash@{BPSquash}}
\index{BPSquash@{BPSquash}!BPredUnit@{BPredUnit}}
\subsubsection[{BPSquash}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BPSquash (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{bp\_\-history}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a14a43c5f5bc8c64c07a075ce1608f9c3}

\begin{DoxyParams}{Parameters}
{\em bp\_\-history} & Pointer to the history object. The predictor will need to update any state and delete the object. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
{
    if (predictor == Local) {
        localBP->squash(bp_history);
    } else if (predictor == Hybrid) {
        hybridbp->squash(bp_history);
    } else if (predictor == HybridSkew) {
        hybridSkewbp->squash(bp_history);
    } else {
        panic("Predictor type is unexpected value!");
    }
}
\end{DoxyCode}
\hypertarget{classBPredUnit_a24bfe00e5e8c2a318930a6474ed60173}{
\index{BPredUnit@{BPredUnit}!BPUncond@{BPUncond}}
\index{BPUncond@{BPUncond}!BPredUnit@{BPredUnit}}
\subsubsection[{BPUncond}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BPUncond (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{bp\_\-history}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a24bfe00e5e8c2a318930a6474ed60173}

\begin{DoxyCode}
{
    // Only the hybrid predictor cares about unconditional branches.
    if (predictor == Hybrid) {
        hybridbp->uncondBr(bp_history);
    } else if (predictor == HybridSkew) {
        hybridSkewbp->uncondBr(bp_history);
    }
}
\end{DoxyCode}
\hypertarget{classBPredUnit_a24bfe00e5e8c2a318930a6474ed60173}{
\index{BPredUnit@{BPredUnit}!BPUncond@{BPUncond}}
\index{BPUncond@{BPUncond}!BPredUnit@{BPredUnit}}
\subsubsection[{BPUncond}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BPUncond (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{bp\_\-history}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a24bfe00e5e8c2a318930a6474ed60173}
\hypertarget{classBPredUnit_a35c57ae0661f1d5dd2169e919741d47b}{
\index{BPredUnit@{BPredUnit}!BPUpdate@{BPUpdate}}
\index{BPUpdate@{BPUpdate}!BPredUnit@{BPredUnit}}
\subsubsection[{BPUpdate}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BPUpdate (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC, }
\item[{bool}]{taken, }
\item[{void $\ast$}]{bp\_\-history, }
\item[{bool}]{squashed}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a35c57ae0661f1d5dd2169e919741d47b}
Updates the BP with taken/not taken information. 
\begin{DoxyParams}{Parameters}
{\em inst\_\-PC} & The branch's PC that will be updated. \\
\hline
{\em taken} & Whether the branch was taken or not taken. \\
\hline
{\em bp\_\-history} & Pointer to the branch predictor state that is associated with the branch lookup that is being updated. \\
\hline
{\em squashed} & Set to true when this function is called during a squash operation. \\
\hline
\end{DoxyParams}
\begin{Desc}
\item[\hyperlink{todo__todo000001}{Todo}]Make this update flexible enough to handle a global predictor. \end{Desc}

\begin{DoxyCode}
{
    if (predictor == Local) {
        localBP->update(instPC, taken, bp_history);
    } else if (predictor == Hybrid) {
        hybridbp->update(instPC, taken, bp_history, squashed);
    } else if (predictor == HybridSkew) {
        hybridSkewbp->update(instPC, taken, bp_history, squashed);
    } else {
        panic("Predictor type is unexpected value!");
    }
        increase_BP_lookup_and_update(1);
}
\end{DoxyCode}
\hypertarget{classBPredUnit_a35c57ae0661f1d5dd2169e919741d47b}{
\index{BPredUnit@{BPredUnit}!BPUpdate@{BPUpdate}}
\index{BPUpdate@{BPUpdate}!BPredUnit@{BPredUnit}}
\subsubsection[{BPUpdate}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BPUpdate (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC, }
\item[{bool}]{taken, }
\item[{void $\ast$}]{bp\_\-history, }
\item[{bool}]{squashed}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a35c57ae0661f1d5dd2169e919741d47b}
Updates the BP with taken/not taken information. 
\begin{DoxyParams}{Parameters}
{\em inst\_\-PC} & The branch's PC that will be updated. \\
\hline
{\em taken} & Whether the branch was taken or not taken. \\
\hline
{\em bp\_\-history} & Pointer to the branch predictor state that is associated with the branch lookup that is being updated. \\
\hline
{\em squashed} & Set to true when this function is called during a squash operation. \\
\hline
\end{DoxyParams}
\begin{Desc}
\item[\hyperlink{todo__todo000002}{Todo}]Make this update flexible enough to handle a global predictor. \end{Desc}
\hypertarget{classBPredUnit_a31024f2d92bfd7e778a790f4c6f61498}{
\index{BPredUnit@{BPredUnit}!BTBLookup@{BTBLookup}}
\index{BTBLookup@{BTBLookup}!BPredUnit@{BPredUnit}}
\subsubsection[{BTBLookup}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ TheISA::PCState {\bf BPredUnit}$<$ Impl $>$::BTBLookup (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBPredUnit_a31024f2d92bfd7e778a790f4c6f61498}
Looks up a given PC in the BTB to get the predicted target. 
\begin{DoxyParams}{Parameters}
{\em inst\_\-PC} & The PC to look up. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The address of the target of the branch. 
\end{DoxyReturn}

\begin{DoxyCode}
    { return BTB.lookup(instPC, 0); }
\end{DoxyCode}
\hypertarget{classBPredUnit_a31024f2d92bfd7e778a790f4c6f61498}{
\index{BPredUnit@{BPredUnit}!BTBLookup@{BTBLookup}}
\index{BTBLookup@{BTBLookup}!BPredUnit@{BPredUnit}}
\subsubsection[{BTBLookup}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ TheISA::PCState {\bf BPredUnit}$<$ Impl $>$::BTBLookup (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBPredUnit_a31024f2d92bfd7e778a790f4c6f61498}
Looks up a given PC in the BTB to get the predicted target. 
\begin{DoxyParams}{Parameters}
{\em inst\_\-PC} & The PC to look up. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The address of the target of the branch. 
\end{DoxyReturn}

\begin{DoxyCode}
    { return BTB.lookup(instPC, 0); }
\end{DoxyCode}
\hypertarget{classBPredUnit_a5afe025cde23c608d745e8daca63e8a6}{
\index{BPredUnit@{BPredUnit}!BTBUpdate@{BTBUpdate}}
\index{BTBUpdate@{BTBUpdate}!BPredUnit@{BPredUnit}}
\subsubsection[{BTBUpdate}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BTBUpdate (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC, }
\item[{const TheISA::PCState \&}]{target}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBPredUnit_a5afe025cde23c608d745e8daca63e8a6}
Updates the BTB with the target of a branch. 
\begin{DoxyParams}{Parameters}
{\em inst\_\-PC} & The branch's PC that will be updated. \\
\hline
{\em target\_\-PC} & The branch's target that will be added to the BTB. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
    { BTB.update(instPC, target, 0); }
\end{DoxyCode}
\hypertarget{classBPredUnit_a5afe025cde23c608d745e8daca63e8a6}{
\index{BPredUnit@{BPredUnit}!BTBUpdate@{BTBUpdate}}
\index{BTBUpdate@{BTBUpdate}!BPredUnit@{BPredUnit}}
\subsubsection[{BTBUpdate}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::BTBUpdate (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC, }
\item[{const TheISA::PCState \&}]{target}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBPredUnit_a5afe025cde23c608d745e8daca63e8a6}
Updates the BTB with the target of a branch. 
\begin{DoxyParams}{Parameters}
{\em inst\_\-PC} & The branch's PC that will be updated. \\
\hline
{\em target\_\-PC} & The branch's target that will be added to the BTB. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
    { BTB.update(instPC, target, 0); }
\end{DoxyCode}
\hypertarget{classBPredUnit_a66a1f6f9cdd28b38b005a666a9976ed7}{
\index{BPredUnit@{BPredUnit}!BTBValid@{BTBValid}}
\index{BTBValid@{BTBValid}!BPredUnit@{BPredUnit}}
\subsubsection[{BTBValid}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ bool {\bf BPredUnit}$<$ Impl $>$::BTBValid (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBPredUnit_a66a1f6f9cdd28b38b005a666a9976ed7}
Looks up a given PC in the BTB to see if a matching entry exists. 
\begin{DoxyParams}{Parameters}
{\em inst\_\-PC} & The PC to look up. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether the BTB contains the given PC. 
\end{DoxyReturn}

\begin{DoxyCode}
    { return BTB.valid(instPC, 0); }
\end{DoxyCode}
\hypertarget{classBPredUnit_a66a1f6f9cdd28b38b005a666a9976ed7}{
\index{BPredUnit@{BPredUnit}!BTBValid@{BTBValid}}
\index{BTBValid@{BTBValid}!BPredUnit@{BPredUnit}}
\subsubsection[{BTBValid}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ bool {\bf BPredUnit}$<$ Impl $>$::BTBValid (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBPredUnit_a66a1f6f9cdd28b38b005a666a9976ed7}
Looks up a given PC in the BTB to see if a matching entry exists. 
\begin{DoxyParams}{Parameters}
{\em inst\_\-PC} & The PC to look up. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether the BTB contains the given PC. 
\end{DoxyReturn}

\begin{DoxyCode}
    { return BTB.valid(instPC, 0); }
\end{DoxyCode}
\hypertarget{classBPredUnit_a89690e897bb5661ee868f659a06515c9}{
\index{BPredUnit@{BPredUnit}!increase\_\-BP\_\-lookup@{increase\_\-BP\_\-lookup}}
\index{increase\_\-BP\_\-lookup@{increase\_\-BP\_\-lookup}!BPredUnit@{BPredUnit}}
\subsubsection[{increase\_\-BP\_\-lookup}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::increase\_\-BP\_\-lookup (
\begin{DoxyParamCaption}
\item[{int}]{lookupCnt}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a89690e897bb5661ee868f659a06515c9}

\begin{DoxyCode}
{
  lookups += lookupCnt;
}
\end{DoxyCode}
\hypertarget{classBPredUnit_a89690e897bb5661ee868f659a06515c9}{
\index{BPredUnit@{BPredUnit}!increase\_\-BP\_\-lookup@{increase\_\-BP\_\-lookup}}
\index{increase\_\-BP\_\-lookup@{increase\_\-BP\_\-lookup}!BPredUnit@{BPredUnit}}
\subsubsection[{increase\_\-BP\_\-lookup}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::increase\_\-BP\_\-lookup (
\begin{DoxyParamCaption}
\item[{int}]{}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a89690e897bb5661ee868f659a06515c9}
\hypertarget{classBPredUnit_a471a1acb994d07a6d57b2f39ce56e6a4}{
\index{BPredUnit@{BPredUnit}!increase\_\-BP\_\-lookup\_\-and\_\-update@{increase\_\-BP\_\-lookup\_\-and\_\-update}}
\index{increase\_\-BP\_\-lookup\_\-and\_\-update@{increase\_\-BP\_\-lookup\_\-and\_\-update}!BPredUnit@{BPredUnit}}
\subsubsection[{increase\_\-BP\_\-lookup\_\-and\_\-update}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::increase\_\-BP\_\-lookup\_\-and\_\-update (
\begin{DoxyParamCaption}
\item[{int}]{}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a471a1acb994d07a6d57b2f39ce56e6a4}
\hypertarget{classBPredUnit_a471a1acb994d07a6d57b2f39ce56e6a4}{
\index{BPredUnit@{BPredUnit}!increase\_\-BP\_\-lookup\_\-and\_\-update@{increase\_\-BP\_\-lookup\_\-and\_\-update}}
\index{increase\_\-BP\_\-lookup\_\-and\_\-update@{increase\_\-BP\_\-lookup\_\-and\_\-update}!BPredUnit@{BPredUnit}}
\subsubsection[{increase\_\-BP\_\-lookup\_\-and\_\-update}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::increase\_\-BP\_\-lookup\_\-and\_\-update (
\begin{DoxyParamCaption}
\item[{int}]{lookupCnt}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a471a1acb994d07a6d57b2f39ce56e6a4}

\begin{DoxyCode}
{
  lookup_and_updates += lookupCnt;
}
\end{DoxyCode}
\hypertarget{classBPredUnit_a41ecb08c99f45538eaf1de4e184905b4}{
\index{BPredUnit@{BPredUnit}!increase\_\-BTB\_\-lookup@{increase\_\-BTB\_\-lookup}}
\index{increase\_\-BTB\_\-lookup@{increase\_\-BTB\_\-lookup}!BPredUnit@{BPredUnit}}
\subsubsection[{increase\_\-BTB\_\-lookup}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::increase\_\-BTB\_\-lookup (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a41ecb08c99f45538eaf1de4e184905b4}

\begin{DoxyCode}
{
  BTBLookups++;
  usedRAS++;
}
\end{DoxyCode}
\hypertarget{classBPredUnit_a41ecb08c99f45538eaf1de4e184905b4}{
\index{BPredUnit@{BPredUnit}!increase\_\-BTB\_\-lookup@{increase\_\-BTB\_\-lookup}}
\index{increase\_\-BTB\_\-lookup@{increase\_\-BTB\_\-lookup}!BPredUnit@{BPredUnit}}
\subsubsection[{increase\_\-BTB\_\-lookup}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::increase\_\-BTB\_\-lookup (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a41ecb08c99f45538eaf1de4e184905b4}
\hypertarget{classBPredUnit_aeaaeb15f110f0ed58cc3161d6f6ace22}{
\index{BPredUnit@{BPredUnit}!name@{name}}
\index{name@{name}!BPredUnit@{BPredUnit}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ const std::string\& {\bf BPredUnit}$<$ Impl $>$::name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBPredUnit_aeaaeb15f110f0ed58cc3161d6f6ace22}

\begin{DoxyCode}
{ return _name; }
\end{DoxyCode}
\hypertarget{classBPredUnit_aeaaeb15f110f0ed58cc3161d6f6ace22}{
\index{BPredUnit@{BPredUnit}!name@{name}}
\index{name@{name}!BPredUnit@{BPredUnit}}
\subsubsection[{name}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ const std::string\& {\bf BPredUnit}$<$ Impl $>$::name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classBPredUnit_aeaaeb15f110f0ed58cc3161d6f6ace22}

\begin{DoxyCode}
{ return _name; }
\end{DoxyCode}
\hypertarget{classBPredUnit_af5b3e6db0cf1f00dee290e16765f28f8}{
\index{BPredUnit@{BPredUnit}!noBPLookup@{noBPLookup}}
\index{noBPLookup@{noBPLookup}!BPredUnit@{BPredUnit}}
\subsubsection[{noBPLookup}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::noBPLookup (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC, }
\item[{void $\ast$\&}]{bp\_\-history, }
\item[{int}]{positionInLine}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_af5b3e6db0cf1f00dee290e16765f28f8}
\hypertarget{classBPredUnit_af5b3e6db0cf1f00dee290e16765f28f8}{
\index{BPredUnit@{BPredUnit}!noBPLookup@{noBPLookup}}
\index{noBPLookup@{noBPLookup}!BPredUnit@{BPredUnit}}
\subsubsection[{noBPLookup}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::noBPLookup (
\begin{DoxyParamCaption}
\item[{Addr}]{instPC, }
\item[{void $\ast$\&}]{bp\_\-history, }
\item[{int}]{positionInLine}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_af5b3e6db0cf1f00dee290e16765f28f8}

\begin{DoxyCode}
{
        assert(onDemand);
    if (predictor == Local) {
        assert(false && "this function is not supported for loacl prediction - (s
      ee Milad!)");
    } else if (predictor == Hybrid) {
        return hybridbp->onDemandBr(instPC, bp_history, (unsigned)positionInLine)
      ;
    } else if (predictor == HybridSkew) {
        return hybridSkewbp->onDemandBr(instPC, bp_history, (unsigned)positionInL
      ine);
    } else {
        panic("Predictor type is unexpected value!");
    }
}
\end{DoxyCode}
\hypertarget{classBPredUnit_add836c4a521ed2bd12eca4d1dee13620}{
\index{BPredUnit@{BPredUnit}!predict@{predict}}
\index{predict@{predict}!BPredUnit@{BPredUnit}}
\subsubsection[{predict}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ bool {\bf BPredUnit}$<$ Impl $>$::predict (
\begin{DoxyParamCaption}
\item[{DynInstPtr \&}]{inst, }
\item[{TheISA::PCState \&}]{pc, }
\item[{ThreadID}]{tid, }
\item[{bool}]{odbpStatic, }
\item[{bool}]{predTaken, }
\item[{int}]{positionInFetchGroup, }
\item[{int}]{positionInLine, }
\item[{bool \&}]{allPredStatic, }
\item[{int}]{oracleBP}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_add836c4a521ed2bd12eca4d1dee13620}
Predicts whether or not the instruction is a taken branch, and the target of the branch if it is taken. 
\begin{DoxyParams}{Parameters}
{\em inst} & The branch instruction. \\
\hline
{\em PC} & The predicted PC is passed back through this parameter. \\
\hline
{\em tid} & The thread id. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns if the branch is taken or not. 
\end{DoxyReturn}

\begin{DoxyCode}
{
    // See if branch predictor predicts taken.
    // If so, get its target addr either from the BTB or the RAS.
    // Save off record of branch stuff so the RAS can be fixed
    // up once it's done.

    bool pred_taken = false;
    TheISA::PCState target = pc;

    void *bp_history = NULL;
        static bool firstDY = true;
        if (onDemand && positionInFetchGroup == 0)
                firstDY = true;

    //if (inst->isUncondCtrl())
    //{
    //    DPRINTF(Fetch, "BranchPred: [tid:%i]: Unconditional control.\n", tid);
    //    pred_taken = true;
    //    // Tell the BP there was an unconditional branch.
    //    BPUncond(bp_history);
    //}
    //else
    //{
      ++condPredicted;
                bool choicePred;
        if (!onDemand) { //BASEBP
                        //Addr indx = ((pc.instAddr()>>4)<<2)+positionInLine;
                        //if (bpIndxHist.find(indx) != bpIndxHist.end()) { bpIndx
      Hist[indx]++;
                        //} else { bpIndxHist[indx] = 1; }
                        pred_taken = BPLookup(pc.instAddr(), bp_history, position
      InLine, onDemand, choicePred);
                        DPRINTF(Fetch, "BranchPred: [tid:%i]: Branch predictor pr
      edicted %i for PC %s\n", tid, pred_taken, inst->pcState());
                        if (positionInFetchGroup == 0) {
                                increase_BP_lookup(fetchWidth);
                                increase_BP_lookup_and_update(fetchWidth);
                                BTBLookups+=fetchWidth;
                        }
                        //inst->setWasBPlookup(true); TODO put this back
                        inst->setDyPredUsed(choicePred);
        } else { //ODBP
                        if (odbpStatic)
                        {
                            pred_taken = predTaken;
                                if (pred_taken) {
                                        //hybridbp->updateGlobalHistTaken();
                                        BTBLookups++;
                                //} else {
                                        //Addr tempPC = ((pc.instAddr()>>totalIns
      tShiftAmt)<<totalInstShiftAmt)+((Addr)pow(instShiftAmt,2))*(fetchWidth-1); //Crea
      te the addr of last ins in cacheline
                                        //if (pc.instAddr() == tempPC)
                                        //hybridbp->updateGlobalHistNotTaken();
                                }
                                noBPLookup(pc.instAddr(), bp_history, positionInL
      ine);
                                inst->setWasBPlookup(false);
                        }
                        else if (!odbpStatic)
                        {
                                //Addr indx = ((pc.instAddr()>>4)<<2)+positionInL
      ine;
                                //if (bpIndxHist.find(indx) != bpIndxHist.end()) 
      { bpIndxHist[indx]++;
                                //} else { bpIndxHist[indx] = 1; }
                            pred_taken = BPLookup(pc.instAddr(), bp_history, posi
      tionInLine, onDemand, choicePred);
                                allPredStatic = false; //had at least one DY in f
      etch group
                            DPRINTF(Fetch, "BranchPred: [tid:%i]: Branch predicto
      r predicted %i for PC %s\n", tid, pred_taken, inst->pcState());
                                if (firstDY) {
                                        increase_BP_lookup(fetchWidth);
                                        increase_BP_lookup_and_update(fetchWidth)
      ;
                                        firstDY=false;
                                }
                                BTBLookups++;
                                inst->setWasBPlookup(true);
                                inst->setDyPredUsed(choicePred);
                        } else {
                                assert(true && "this should have never run");
                            pred_taken = false; //Turn DY or ST into SN - no upda
      te of PHT here
                                noBPLookup(pc.instAddr(), bp_history, positionInL
      ine);
                                if (odbpStatic && predTaken)    ST_treated_SN++;
                                else if (!odbpStatic)                   DY_treate
      d_SN++;
                                inst->setWasBPlookup(false);
                        }
        }
    //}

    DPRINTF(Fetch, "BranchPred: [tid:%i]: [sn:%i] Creating prediction history "
                "for PC %s\n",
            tid, inst->seqNum, inst->pcState());

    PredictorHistory predict_record(inst->seqNum, pc.instAddr(),
                                    pred_taken, bp_history, tid);
        if (onDemand) {
                predict_record.wasControl = inst->isControl();
                predict_record.wasStatic = odbpStatic;
                predict_record.wasST = predTaken; //This is the "original" static
       prediction
        }

    // Now lookup in the BTB or RAS.
    if (pred_taken)
    {
        ++usedRAS; //RAS read or write
        if (inst->isReturn()) //look up RAS
        {
            predict_record.wasReturn = true;
            // If it's a function return call, then look up the address
            // in the RAS.
            TheISA::PCState rasTop = RAS[tid].top();
            target = TheISA::buildRetPC(pc, rasTop);

            // Record the top entry of the RAS, and its index.
            predict_record.usedRAS = true;
            predict_record.RASIndex = RAS[tid].topIdx();
            predict_record.RASTarget = rasTop;

            assert(predict_record.RASIndex < 16);

            RAS[tid].pop();

            DPRINTF(Fetch, "BranchPred: [tid:%i]: Instruction %s is a return, "
                    "RAS predicted target: %s, RAS index: %i.\n",
                    tid, inst->pcState(), target, predict_record.RASIndex);
        }
        else //Look up BTB
        {
            if (inst->isCall()) {
                RAS[tid].push(pc);

                // Record that it was a call so that the top RAS entry can
                // be popped off if the speculation is incorrect.
                predict_record.wasCall = true;

                DPRINTF(Fetch, "BranchPred: [tid:%i]: Instruction %s was a "
                        "call, adding %s to the RAS index: %i.\n",
                        tid, inst->pcState(), pc, RAS[tid].topIdx());
            }

            if (BTB.valid(pc.instAddr(), tid)) {
                ++BTBHits;
                predict_record.validBTB = true;

                // If it's not a return, use the BTB to get the target addr.
                target = BTB.lookup(pc.instAddr(), tid);

                DPRINTF(Fetch, "BranchPred: [tid:%i]: Instruction %s predicted"
                        " target is %s.\n", tid, inst->pcState(), target);

            } else { //missed in RAS and BTB
                DPRINTF(Fetch, "BranchPred: [tid:%i]: BTB doesn't have a "
                        "valid entry.\n",tid);
                pred_taken = false;
                // The Direction of the branch predictor is altered because the
                // BTB did not have an entry
                // The predictor needs to be updated accordingly
              //if (!inst->isCall() && !inst->isReturn()) {
                      BPBTBUpdate(pc.instAddr(), bp_history);
                      DPRINTF(Fetch, "BranchPred: [tid:%i]:[sn:%i] BPBTBUpdate"
                              " called for %s\n",
                              tid, inst->seqNum, inst->pcState());
              //} else if (inst->isCall() && !inst->isUncondCtrl()) {
              //      RAS[tid].pop();
              //}
                TheISA::advancePC(target, inst->staticInst);
            }

        }
    } else { //predict not taken
        if (inst->isReturn()) {
           predict_record.wasReturn = true;
        }
        TheISA::advancePC(target, inst->staticInst);
    }

        predict_record.predTaken = pred_taken;
    pc = target;

    predHist[tid].push_front(predict_record);

    DPRINTF(Fetch, "BranchPred: [tid:%i]: [sn:%i]: History entry added."
            "predHist.size(): %i\n", tid, inst->seqNum, predHist[tid].size());

    return pred_taken;
}
\end{DoxyCode}
\hypertarget{classBPredUnit_add836c4a521ed2bd12eca4d1dee13620}{
\index{BPredUnit@{BPredUnit}!predict@{predict}}
\index{predict@{predict}!BPredUnit@{BPredUnit}}
\subsubsection[{predict}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ bool {\bf BPredUnit}$<$ Impl $>$::predict (
\begin{DoxyParamCaption}
\item[{DynInstPtr \&}]{inst, }
\item[{TheISA::PCState \&}]{pc, }
\item[{ThreadID}]{tid, }
\item[{bool}]{odbpStatic, }
\item[{bool}]{predTaken, }
\item[{int}]{positionInFetchGroup, }
\item[{int}]{positionInLine, }
\item[{bool \&}]{allPredStatic, }
\item[{int}]{oracleBP}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_add836c4a521ed2bd12eca4d1dee13620}
Predicts whether or not the instruction is a taken branch, and the target of the branch if it is taken. 
\begin{DoxyParams}{Parameters}
{\em inst} & The branch instruction. \\
\hline
{\em PC} & The predicted PC is passed back through this parameter. \\
\hline
{\em tid} & The thread id. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns if the branch is taken or not. 
\end{DoxyReturn}
\hypertarget{classBPredUnit_a0cffcea165538b2e7fd554a92b8d9b85}{
\index{BPredUnit@{BPredUnit}!regStats@{regStats}}
\index{regStats@{regStats}!BPredUnit@{BPredUnit}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::regStats (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a0cffcea165538b2e7fd554a92b8d9b85}
Registers statistics. \hypertarget{classBPredUnit_a0cffcea165538b2e7fd554a92b8d9b85}{
\index{BPredUnit@{BPredUnit}!regStats@{regStats}}
\index{regStats@{regStats}!BPredUnit@{BPredUnit}}
\subsubsection[{regStats}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::regStats (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a0cffcea165538b2e7fd554a92b8d9b85}
Registers statistics. \hypertarget{classBPredUnit_a94a04b4bdf8f6b9b3cf33882bc16067b}{
\index{BPredUnit@{BPredUnit}!squash@{squash}}
\index{squash@{squash}!BPredUnit@{BPredUnit}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::squash (
\begin{DoxyParamCaption}
\item[{const InstSeqNum \&}]{squashed\_\-sn, }
\item[{ThreadID}]{tid}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a94a04b4bdf8f6b9b3cf33882bc16067b}
Squashes all outstanding updates until a given sequence number. 
\begin{DoxyParams}{Parameters}
{\em squashed\_\-sn} & The sequence number to squash any younger updates up until. \\
\hline
{\em tid} & The thread id. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
{
    History &pred_hist = predHist[tid];

    while (!pred_hist.empty() &&
           pred_hist.front().seqNum > squashed_sn) {
        if (pred_hist.front().usedRAS) {
            DPRINTF(Fetch, "BranchPred: [tid:%i]: Restoring top of RAS to: %i,"
                    " target: %s.\n", tid,
                    pred_hist.front().RASIndex, pred_hist.front().RASTarget);

            RAS[tid].restore(pred_hist.front().RASIndex,
                             pred_hist.front().RASTarget);
        } else if(pred_hist.front().wasCall && pred_hist.front().validBTB) {
            // Was a call but predicated false. Pop RAS here
            DPRINTF(Fetch, "BranchPred: [tid: %i] Squashing"
                    "  Call [sn:%i] PC: %s Popping RAS\n", tid,
                    pred_hist.front().seqNum, pred_hist.front().pc);
            RAS[tid].pop();
        }

        // This call should delete the bpHistory.
        BPSquash(pred_hist.front().bpHistory);

        DPRINTF(Fetch, "BranchPred: [tid:%i]: Removing history for [sn:%i] "
                "PC %s.\n", tid, pred_hist.front().seqNum,
                pred_hist.front().pc);

        pred_hist.pop_front();

        DPRINTF(Fetch, "[tid:%i]: predHist.size(): %i\n",
                tid, predHist[tid].size());
    }

}
\end{DoxyCode}
\hypertarget{classBPredUnit_a78e6f48f8a11db90daab850527d48aa7}{
\index{BPredUnit@{BPredUnit}!squash@{squash}}
\index{squash@{squash}!BPredUnit@{BPredUnit}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::squash (
\begin{DoxyParamCaption}
\item[{const InstSeqNum \&}]{squashed\_\-sn, }
\item[{const TheISA::PCState \&}]{corr\_\-target, }
\item[{bool}]{actually\_\-taken, }
\item[{ThreadID}]{tid}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a78e6f48f8a11db90daab850527d48aa7}
Squashes all outstanding updates until a given sequence number, and corrects that sn's update with the proper address and taken/not taken. 
\begin{DoxyParams}{Parameters}
{\em squashed\_\-sn} & The sequence number to squash any younger updates up until. \\
\hline
{\em corr\_\-target} & The correct branch target. \\
\hline
{\em actually\_\-taken} & The correct branch direction. \\
\hline
{\em tid} & The thread id. \\
\hline
\end{DoxyParams}
\hypertarget{classBPredUnit_a78e6f48f8a11db90daab850527d48aa7}{
\index{BPredUnit@{BPredUnit}!squash@{squash}}
\index{squash@{squash}!BPredUnit@{BPredUnit}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::squash (
\begin{DoxyParamCaption}
\item[{const InstSeqNum \&}]{squashed\_\-sn, }
\item[{const TheISA::PCState \&}]{corr\_\-target, }
\item[{bool}]{actually\_\-taken, }
\item[{ThreadID}]{tid}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a78e6f48f8a11db90daab850527d48aa7}
Squashes all outstanding updates until a given sequence number, and corrects that sn's update with the proper address and taken/not taken. 
\begin{DoxyParams}{Parameters}
{\em squashed\_\-sn} & The sequence number to squash any younger updates up until. \\
\hline
{\em corr\_\-target} & The correct branch target. \\
\hline
{\em actually\_\-taken} & The correct branch direction. \\
\hline
{\em tid} & The thread id. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
{
    // Now that we know that a branch was mispredicted, we need to undo
    // all the branches that have been seen up until this branch and
    // fix up everything.
    // NOTE: This should be call conceivably in 2 scenarios:
    // (1) After an branch is executed, it updates its status in the ROB
    //     The commit stage then checks the ROB update and sends a signal to
    //     the fetch stage to squash history after the mispredict
    // (2) In the decode stage, you can find out early if a unconditional
    //     PC-relative, branch was predicted incorrectly. If so, a signal
    //     to the fetch stage is sent to squash history after the mispredict

    History &pred_hist = predHist[tid];

    ++condIncorrect;

    DPRINTF(Fetch, "BranchPred: [tid:%i]: Squashing from sequence number %i, "
            "setting target to %s.\n",
            tid, squashed_sn, corrTarget);

    // Squash All Branches AFTER this mispredicted branch
    squash(squashed_sn, tid);

    // If there's a squash due to a syscall, there may not be an entry
    // corresponding to the squash.  In that case, don't bother trying to
    // fix up the entry.
    if (!pred_hist.empty()) {

        HistoryIt hist_it = pred_hist.begin();
        //HistoryIt hist_it = find(pred_hist.begin(), pred_hist.end(),
        //                       squashed_sn);

        //assert(hist_it != pred_hist.end());
        if (pred_hist.front().seqNum != squashed_sn) {
            DPRINTF(Fetch, "Front sn %i != Squash sn %i\n",
                    pred_hist.front().seqNum, squashed_sn);

            assert(pred_hist.front().seqNum == squashed_sn);
        }

        if ((*hist_it).usedRAS) {
            ++RASIncorrect;
        }

                if (!onDemand || 
                    (onDemand && 
                         !pred_hist.front().wasStatic &&
                         pred_hist.front().wasControl)) {
                        BPUpdate((*hist_it).pc, actually_taken,
                                 pred_hist.front().bpHistory, true);
                }

                BPHistUpdate((*hist_it).pc, actually_taken,
                                        pred_hist.front().bpHistory, true);

        if (actually_taken) {
            if (hist_it->wasReturn && !hist_it->usedRAS) {
                 DPRINTF(Fetch, "BranchPred: [tid: %i] Incorrectly predicted"
                           "  return [sn:%i] PC: %s\n", tid, hist_it->seqNum,
                            hist_it->pc);
                 RAS[tid].pop();
            }
        } else {
           //Actually not Taken
           if (hist_it->usedRAS) {
                DPRINTF(Fetch,"BranchPred: [tid: %i] Incorrectly predicted"
                           "  return [sn:%i] PC: %s Restoring RAS\n", tid,
                           hist_it->seqNum, hist_it->pc);
                DPRINTF(Fetch, "BranchPred: [tid:%i]: Restoring top of RAS"
                               " to: %i, target: %s.\n", tid,
                              hist_it->RASIndex, hist_it->RASTarget);
                RAS[tid].restore(hist_it->RASIndex, hist_it->RASTarget);

           } else if (hist_it->wasCall && hist_it->validBTB) {
                 //Was a Call but predicated false. Pop RAS here
                 DPRINTF(Fetch, "BranchPred: [tid: %i] Incorrectly predicted"
                           "  Call [sn:%i] PC: %s Popping RAS\n", tid,
                           hist_it->seqNum, hist_it->pc);
                 RAS[tid].pop();
           }
        }
                if (onDemand && 
                    (pred_hist.front().wasST || !pred_hist.front().wasStatic) && 
      
                        !pred_hist.front().wasControl) {
                        BTB.invalidate((*hist_it).pc);
                } else  if (actually_taken) {
                        DPRINTF(Fetch,"BranchPred: [tid: %i] BTB Update called fo
      r [sn:%i]"
                          " PC: %s\n", tid,hist_it->seqNum, hist_it->pc);
                        BTB.update((*hist_it).pc, corrTarget, tid);
                        BTBLookups++;
            DPRINTF(Fetch,"BranchPred: [tid: %i] BTB Update called for [sn:%i]"
                            " PC: %s\n", tid,hist_it->seqNum, hist_it->pc);
                }

        DPRINTF(Fetch, "BranchPred: [tid:%i]: Removing history for [sn:%i]"
                       " PC %s  Actually Taken: %i\n", tid, hist_it->seqNum,
                       hist_it->pc, actually_taken);

        pred_hist.erase(hist_it);

        DPRINTF(Fetch, "[tid:%i]: predHist.size(): %i\n", tid, predHist[tid].size
      ());
    }
}
\end{DoxyCode}
\hypertarget{classBPredUnit_a94a04b4bdf8f6b9b3cf33882bc16067b}{
\index{BPredUnit@{BPredUnit}!squash@{squash}}
\index{squash@{squash}!BPredUnit@{BPredUnit}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::squash (
\begin{DoxyParamCaption}
\item[{const InstSeqNum \&}]{squashed\_\-sn, }
\item[{ThreadID}]{tid}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a94a04b4bdf8f6b9b3cf33882bc16067b}
Squashes all outstanding updates until a given sequence number. 
\begin{DoxyParams}{Parameters}
{\em squashed\_\-sn} & The sequence number to squash any younger updates up until. \\
\hline
{\em tid} & The thread id. \\
\hline
\end{DoxyParams}
\hypertarget{classBPredUnit_ac33c3d29c7b6aca9578fc416eb34e60e}{
\index{BPredUnit@{BPredUnit}!switchOut@{switchOut}}
\index{switchOut@{switchOut}!BPredUnit@{BPredUnit}}
\subsubsection[{switchOut}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::switchOut (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_ac33c3d29c7b6aca9578fc416eb34e60e}
\hypertarget{classBPredUnit_ac33c3d29c7b6aca9578fc416eb34e60e}{
\index{BPredUnit@{BPredUnit}!switchOut@{switchOut}}
\index{switchOut@{switchOut}!BPredUnit@{BPredUnit}}
\subsubsection[{switchOut}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::switchOut (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_ac33c3d29c7b6aca9578fc416eb34e60e}
\hypertarget{classBPredUnit_a9011bcc9143d2396dfec49828484a645}{
\index{BPredUnit@{BPredUnit}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!BPredUnit@{BPredUnit}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::takeOverFrom (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a9011bcc9143d2396dfec49828484a645}
\hypertarget{classBPredUnit_a9011bcc9143d2396dfec49828484a645}{
\index{BPredUnit@{BPredUnit}!takeOverFrom@{takeOverFrom}}
\index{takeOverFrom@{takeOverFrom}!BPredUnit@{BPredUnit}}
\subsubsection[{takeOverFrom}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::takeOverFrom (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_a9011bcc9143d2396dfec49828484a645}
\hypertarget{classBPredUnit_aa154b29fbf52ad49d89a046e94b53ac9}{
\index{BPredUnit@{BPredUnit}!update@{update}}
\index{update@{update}!BPredUnit@{BPredUnit}}
\subsubsection[{update}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::update (
\begin{DoxyParamCaption}
\item[{const InstSeqNum \&}]{done\_\-sn, }
\item[{ThreadID}]{tid}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_aa154b29fbf52ad49d89a046e94b53ac9}
Tells the branch predictor to commit any updates until the given sequence number. 
\begin{DoxyParams}{Parameters}
{\em done\_\-sn} & The sequence number to commit any older updates up until. \\
\hline
{\em tid} & The thread id. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
{
    DPRINTF(Fetch, "BranchPred: [tid:%i]: Committing branches until "
            "[sn:%lli].\n", tid, done_sn);

    while (!predHist[tid].empty() &&
           predHist[tid].back().seqNum <= done_sn) {
        // Update the branch predictor with the correct results.
                DPRINTF(Fetch, "BranchPred: [tid:%i]: Committing branch "
                        "[sn:%lli].\n", tid, predHist[tid].back().seqNum);
        if (!onDemand || 
                (onDemand && 
                 !predHist[tid].back().wasStatic &&
                 predHist[tid].back().wasControl)) {
                BPUpdate(predHist[tid].back().pc,
                         predHist[tid].back().predTaken,
                         predHist[tid].back().bpHistory, false);
            }
                BPHistUpdate(predHist[tid].back().pc, //should not do anything
                 predHist[tid].back().predTaken,
                 predHist[tid].back().bpHistory, false);

        predHist[tid].pop_back();
    }
    DPRINTF(Fetch, "BranchPred: [tid:%i]: Done Committing branches\n", tid);

}
\end{DoxyCode}
\hypertarget{classBPredUnit_aa154b29fbf52ad49d89a046e94b53ac9}{
\index{BPredUnit@{BPredUnit}!update@{update}}
\index{update@{update}!BPredUnit@{BPredUnit}}
\subsubsection[{update}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Impl $>$ void {\bf BPredUnit}$<$ Impl $>$::update (
\begin{DoxyParamCaption}
\item[{const InstSeqNum \&}]{done\_\-sn, }
\item[{ThreadID}]{tid}
\end{DoxyParamCaption}
)}}
\label{classBPredUnit_aa154b29fbf52ad49d89a046e94b53ac9}
Tells the branch predictor to commit any updates until the given sequence number. 
\begin{DoxyParams}{Parameters}
{\em done\_\-sn} & The sequence number to commit any older updates up until. \\
\hline
{\em tid} & The thread id. \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
/home/milad/esc\_\-project/svn/PARS/src/backend/\hyperlink{backend_2bpred__unit_8h}{bpred\_\-unit.h}\item 
/home/milad/esc\_\-project/svn/PARS/src/forLater/\hyperlink{forLater_2bpred__unit_8h}{bpred\_\-unit.h}\item 
/home/milad/esc\_\-project/svn/PARS/src/backend/\hyperlink{backend_2bpred__unit__ctr_8h}{bpred\_\-unit\_\-ctr.h}\item 
/home/milad/esc\_\-project/svn/PARS/src/forLater/\hyperlink{forLater_2bpred__unit__ctr_8h}{bpred\_\-unit\_\-ctr.h}\end{DoxyCompactItemize}
