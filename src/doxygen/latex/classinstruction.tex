\hypertarget{classinstruction}{
\section{instruction Class Reference}
\label{classinstruction}\index{instruction@{instruction}}
}


{\ttfamily \#include $<$instruction.h$>$}



Collaboration diagram for instruction:
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classinstruction_a2e0bfed549166dbfa1ce77ec084ea310}{instruction} ()
\item 
\hyperlink{classinstruction_a4f9c54b6376cf77565179728fa6f68fa}{$\sim$instruction} ()
\item 
void \hyperlink{classinstruction_a7a4adbec8d2e9a2cb6090168530e336c}{setOpCode} (const char $\ast$)
\item 
void \hyperlink{classinstruction_affb2525016712f3bac93120d4d81961d}{setInsAddr} (\hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR})
\item 
void \hyperlink{classinstruction_a3ee6f1e5c349643f6734df78619c86f9}{setInsDstAddr} (\hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR}, bool)
\item 
void \hyperlink{classinstruction_ab0119dd691b88e7cedb51d4f48c829a9}{setInsFallThruAddr} (\hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR}, bool)
\item 
void \hyperlink{classinstruction_a7cd565022bab4e05dfe1e0b4637731d5}{setInsDst} (\hyperlink{classinstruction}{instruction} $\ast$)
\item 
void \hyperlink{classinstruction_afb8fdf4968223005eaf2eb18709f2ce5}{setInsFallThru} (\hyperlink{classinstruction}{instruction} $\ast$)
\item 
void \hyperlink{classinstruction_ae28df36b635c5359fa48a6476eebc425}{setInsAsm} (const char $\ast$)
\item 
void \hyperlink{classinstruction_aa6ff7d5323483cf18c10687ed8c1dc73}{setType} (const char)
\item 
void \hyperlink{classinstruction_aabc818127836c8403b9c691985ca6d14}{setBrTakenBias} (double brBias)
\item 
void \hyperlink{classinstruction_a613fd5dcaabf9a68596545679b17ffd8}{setBPaccuracy} (double bpAccuracy)
\item 
void \hyperlink{classinstruction_a5052a04bf5db0d0e1519eb54f343bdc6}{setLdMissRate} (double missRate)
\item 
void \hyperlink{classinstruction_a456de8aa26ff79d2b7cd203f7c59f2cb}{setRegister} (long int $\ast$r, int $\ast$rt)
\item 
void \hyperlink{classinstruction_a3623f439924f86cba8f9e115e19e7514}{setSSAregister} (long int $\ast$r, int $\ast$rt)
\item 
void \hyperlink{classinstruction_ae171d8892a0c330d2fa475346e321724}{setSpecialRegister} (long int $\ast$r, int $\ast$rt)
\item 
void \hyperlink{classinstruction_a093ff19f17baaf84d4539ea395468265}{setReadVar} (int var, int subscript)
\item 
void \hyperlink{classinstruction_a67c584522eaa68d46a495170ce8a3bbd}{setWriteVar} (int var, int subscript)
\item 
void \hyperlink{classinstruction_a8e201444f39b8a779022284e280fdf23}{setArchReg} (long int r)
\item 
void \hyperlink{classinstruction_a1a85e010b731e20bcd25310a26eabd98}{setWrMemType} ()
\item 
void \hyperlink{classinstruction_a0d47af8822438b6e838c08dbd31cc02c}{setRdMemType} ()
\item 
void \hyperlink{classinstruction_ab36280a1a2cd3339e45c8271deaa23d0}{setMemAccessSize} (int memSize)
\item 
const char $\ast$ \hyperlink{classinstruction_a47d6ca18417d4f185495eb9be2844f07}{getOpCode} ()
\item 
void \hyperlink{classinstruction_aadbc60fe35dec68a1a8589cfc9fcc022}{resetInsDst} ()
\item 
void \hyperlink{classinstruction_ac796f0f05fa4011d7c05c2155020c5bb}{resetInsFallThru} ()
\item 
\hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR} \hyperlink{classinstruction_ac1fabe854c85726785052c7a5ebf6d39}{getInsAddr} ()
\item 
\hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR} \hyperlink{classinstruction_a600fd1454a34eca9a64057e3c019a795}{getInsDstAddr} ()
\item 
\hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR} \hyperlink{classinstruction_a6b94ce0e75e6676de23c2a87a19eecd3}{getInsFallThruAddr} ()
\item 
\hyperlink{classinstruction}{instruction} $\ast$ \hyperlink{classinstruction_a989b1f1fcfe6b80e1566f035e408b03d}{getInsFallThru} ()
\item 
\hyperlink{classinstruction}{instruction} $\ast$ \hyperlink{classinstruction_a1e19a31455d12c43d0f48d071f3e0e5c}{getInsDst} ()
\item 
const char $\ast$ \hyperlink{classinstruction_a9404c158382339e863846837c9b252aa}{getInsAsm} ()
\item 
const char \hyperlink{classinstruction_a47623362d505a662b974624f81288389}{getType} ()
\item 
double \hyperlink{classinstruction_ac2be260e8fce5e0615bd68bed97cb591}{getBrTakenBias} ()
\item 
double \hyperlink{classinstruction_a023333937041baf6bc2985c94f88c9e5}{getBPaccuracy} ()
\item 
double \hyperlink{classinstruction_a14d57791b666452fdb91973e35c39c2e}{getLdMissRate} ()
\item 
int \hyperlink{classinstruction_a842fd50e52a3e3d31fcf8b7a180a32bd}{getLatency} ()
\item 
int \hyperlink{classinstruction_a9701f53aafaf1b2298378665059cef33}{getNthRegType} (int i)
\item 
int \hyperlink{classinstruction_a4210fe4a5a94f67cdcd7c25075e8f23b}{getNthSpecialRegType} (int i)
\item 
long int \hyperlink{classinstruction_a54412da0ee022e05101d4fb92ee879b9}{getNthReg} (int i)
\item 
long int \hyperlink{classinstruction_a9f05970767f31d158fdb6beb0ae6a3df}{getNthSpecialReg} (int i)
\item 
void \hyperlink{classinstruction_aa52dbeed6a59d58a132a885cfabc70fb}{replaceWriteArchReg} (long int, long int)
\item 
long int \hyperlink{classinstruction_a7d49a66c0f3b426f1cf8fd335a5f3b6a}{getNthArchReg} (int indx)
\item 
long int \hyperlink{classinstruction_ad7dce7bff9bfecd11b0e7119738d0994}{getNthOldWriteReg} (int i)
\item 
long int \hyperlink{classinstruction_a0a5ddbb986096245d7742472c49d14b2}{getNthReadReg} (int i)
\item 
long int \hyperlink{classinstruction_a29e8de9d3cd22cee464512f9bbc1972c}{getNthWriteReg} (int i)
\item 
void \hyperlink{classinstruction_aabb46003e886f87cd3bc918f05a3682f}{removeNthRegister} (int i)
\item 
int \hyperlink{classinstruction_af64e1265e882da7e152bd47cb7794c3b}{getNumReg} ()
\item 
int \hyperlink{classinstruction_ae0a1ee97e6ba7920c41dd35f97b1715a}{getNumReadReg} ()
\item 
int \hyperlink{classinstruction_a293a8975be22485ec002ef7cc0466d0a}{getNumWriteReg} ()
\item 
int \hyperlink{classinstruction_a123544344e4578778985e3b6a34dea8c}{getNumSpecialReg} ()
\item 
long int \hyperlink{classinstruction_a7824d148fcdeb6a1b7cafd68a7ce99ef}{getReadRegSubscript} (long int var)
\item 
long int \hyperlink{classinstruction_a1253eafd0173b6daef17fed2311c6bcf}{getWriteRegSubscript} (long int var)
\item 
void \hyperlink{classinstruction_ae406e3e00f408b7b54510867c88b1b5d}{makeUniqueRegs} ()
\item 
string \hyperlink{classinstruction_acd4f756120e0bd6cdb127715c295a5e7}{getRegisterStr} ()
\item 
string \hyperlink{classinstruction_a4cbd72801622336cca5bf1061f3cda6a}{getArchRegisterStr} ()
\item 
int \hyperlink{classinstruction_a7811c2dd5418e30c53d2da2460e0d47c}{getMemAccessSize} ()
\item 
bool \hyperlink{classinstruction_abf5f8947b16c91c4e21b82bec378008f}{isRdMemType} ()
\item 
bool \hyperlink{classinstruction_a0eab1a0a392f17d7ec46e6dbf1ce21fb}{isWrMemType} ()
\item 
bool \hyperlink{classinstruction_ac0f0a724c1207fd9c2aad8897f3c9842}{hasDst} ()
\item 
bool \hyperlink{classinstruction_a2d7b01a0443263782d84906eb8c35ccc}{hasFallThru} ()
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{classinstruction_ad1af63e7f1bfa160b0719027c2a0b8ce}{getDependents} ()
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{classinstruction_af6165d6c8ba00c6806eda36e36cb3366}{getAncestors} ()
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{classinstruction_a90450afccd1b4b07bd28b2ee8aabdf6d}{getRegAncestors} ()
\item 
void \hyperlink{classinstruction_ab2ba6828f1256186a787d933a6ca0868}{setAsDependent} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_aee7e55cf32812b46267a22bcb53da670}{setAsAncestor} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_ab89bab28eb321e32fddfb44354c8245f}{setAsRegAncestor} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_ab21a5713ecebfd1b6b6c8aeed06e4679}{dependencyTableCheck} (\hyperlink{classdependencyTable}{dependencyTable} $\ast$depTables)
\item 
bool \hyperlink{classinstruction_ab367eab50dc74c47b70de127fc633c9b}{isInsRepeated} (\hyperlink{classinstruction}{instruction} $\ast$ins, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ancestors)
\item 
void \hyperlink{classinstruction_a379cbb0fb6bbe15168c6eac05a37114f}{setRdAddrSet} (set$<$ \hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR} $>$ \&addrSet)
\item 
void \hyperlink{classinstruction_a8928d9fe638fd7307606fac71a31b681}{setWrAddrSet} (set$<$ \hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR} $>$ \&addrSet)
\item 
int \hyperlink{classinstruction_a2e29e3536ad20c65b6c7b76ba6e37ad8}{getNumAncestors} ()
\item 
int \hyperlink{classinstruction_adb8073eb7167fc23a3c846db8129b068}{getNumDependents} ()
\item 
bool \hyperlink{classinstruction_a65493a2688efea847fc17e08df019af9}{isUPLDdep} ()
\item 
void \hyperlink{classinstruction_a9e341ec4d383ed7a70104164904651f2}{setUPLDdep} ()
\item 
void \hyperlink{classinstruction_adcf44cfcb7a8c267da71a1ef7b2f4b91}{setUPLDins} ()
\item 
bool \hyperlink{classinstruction_ab54ef1118b6422bd1f953b9244b64f10}{updateUPLDbit} ()
\item 
bool \hyperlink{classinstruction_a4e7c293557754da06684c7b04c4aaf5c}{isUPLD} ()
\item 
void \hyperlink{classinstruction_abce03a3d46f53f28cdeed1f77638e74f}{assignUPLDroot} (\hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR})
\item 
set$<$ \hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR} $>$ \hyperlink{classinstruction_a31ab0646fc31903f5b192cfc5b7e3aa8}{getUPLDroots} ()
\item 
void \hyperlink{classinstruction_aabd61e186e80af7dd343e0f142741ed6}{renameWriteReg} (int indx, long int reg)
\item 
void \hyperlink{classinstruction_ae9760e334e7829c4f8504bc8436e2dfb}{renameReadReg} (int indx, long int renReg)
\item 
long int \hyperlink{classinstruction_a35b2a3db2dc9a22bbdcbce797d510c85}{getRenamedReg} (long int reg)
\item 
bool \hyperlink{classinstruction_a8d938a7c74c2bd36d0e5565cf933d9d5}{isRepeated} (\hyperlink{classinstruction}{instruction} $\ast$temp, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ancestors)
\item 
bool \hyperlink{classinstruction_adc11181683114bd444eff11f1a810c89}{isLongestPathSet} ()
\item 
int \hyperlink{classinstruction_af4d93f837096be4e0dd2fe8951b1114e}{getLongestPath} ()
\item 
void \hyperlink{classinstruction_af6d861b0ad792c3136431c3ef99509ba}{resetLongestPath} ()
\item 
void \hyperlink{classinstruction_a46127cea18a5a4ec73566038a2454ecf}{setLongestPath} (int longestPath)
\item 
void \hyperlink{classinstruction_af78c579e9c3b74dfc72c5bbfb573deab}{setMy\_\-BBorPB\_\-id} (\hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR} id)
\item 
void \hyperlink{classinstruction_aba1a4de7cc3e25e0090c69c51b15d6b4}{resetMy\_\-BBorPB\_\-id} ()
\item 
\hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR} \hyperlink{classinstruction_aee7e5e20a8bbb42a9efe26289a40eb89}{getMy\_\-BB\_\-id} ()
\item 
set$<$ \hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR} $>$ \hyperlink{classinstruction_a0e94c2270b46d453299f66a72b7c80de}{getMy\_\-PB\_\-id} ()
\item 
\hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR} \hyperlink{classinstruction_a36e1dd2192e97d1c771be8d0f0779d8c}{getMy\_\-first\_\-PB\_\-id} ()
\item 
void \hyperlink{classinstruction_a729d403d579a7f910a6ebfd6500ad5e9}{allocatedRegister} (long int r\_\-allocated, \hyperlink{binaryTranslator_2global_8h_a8981b18ef48c0d2dbf747e5e63e46038}{regKind} rk)
\item 
bool \hyperlink{classinstruction_ab5e9dd71fbc48781b528341a9a371a95}{isAlreadyAssignedArcRegs} ()
\item 
void \hyperlink{classinstruction_a7c5699deabae9d06e77ca5f9a6368e1b}{setup\_\-locGlbUseSet} (set$<$ long int $>$ \&)
\item 
void \hyperlink{classinstruction_ab4d650144a6a91370a440977b6c67a9a}{setup\_\-locGlbDefSet} (set$<$ long int $>$ \&)
\item 
void \hyperlink{classinstruction_a33901636d2350a413a4d245f6d16e6a6}{update\_\-locGlbSet} (set$<$ long int $>$ \&, std::map$<$ int, long int $>$ \&, std::map$<$ int, long int $>$ \&, int)
\item 
set$<$ long int $>$ \hyperlink{classinstruction_ae25624ad14ee474a22819a8831732ec6}{setup\_\-locToGlbUseSet} (set$<$ long int $>$ \&, set$<$ long int $>$ \&)
\item 
set$<$ long int $>$ \hyperlink{classinstruction_a057247b6632a4fa3eb672d7b7bcb85b1}{setup\_\-locToGlbDefSet} (set$<$ long int $>$ \&)
\item 
void \hyperlink{classinstruction_a8c177bf836da2d16fca731375b07fc35}{update\_\-locToGlbSet} (set$<$ long int $>$ \&, std::map$<$ int, long int $>$ \&, std::map$<$ int, long int $>$ \&, int)
\item 
void \hyperlink{classinstruction_af50b9f329ee94315d1fbff3a151cbd45}{setupLocSet} (\hyperlink{binaryTranslator_2global_8h_ae3190c0c46d1384e80f94a61ad275092}{PUSH\_\-LOCATION})
\item 
bool \hyperlink{classinstruction_a173a23e5f292232055dec69475b3fd92}{update\_\-InOutSet} (\hyperlink{binaryTranslator_2global_8h_a78dd04e0a4364ff551d83095f9bc0264}{REG\_\-ALLOC\_\-MODE}, set$<$ long int $>$ \&, bool)
\item 
set$<$ long int $>$ \hyperlink{classinstruction_aaba4ffcf984873d13a0ecea71a0ebad3}{update\_\-locToGlb} (set$<$ long int $>$ \&, set$<$ long int $>$ \&)
\item 
void \hyperlink{classinstruction_a7c577242cd5b190a00a9f433222b8e0b}{resetSets} ()
\item 
void \hyperlink{classinstruction_ad8aba4b11bc32a8e52866c79c8dc47e6}{setupDefUseSets} ()
\item 
void \hyperlink{classinstruction_aac67c9bd51efdf37963fbfc5da8fb737}{renameAllInsRegs} ()
\item 
set$<$ long int $>$ \hyperlink{classinstruction_ab9bf2478b915e5b209d671afd85f0519}{getInSet} ()
\item 
set$<$ long int $>$ \hyperlink{classinstruction_adf7cb55183c08b9f5a04d798847e2564}{getOutSet} ()
\item 
set$<$ long int $>$ \hyperlink{classinstruction_a3dcec0ff81cf6877120874d4f81d3f96}{getUseSet} ()
\item 
set$<$ long int $>$ \hyperlink{classinstruction_a20123ce67f40f03e304b71660a69ae37}{getDefSet} ()
\item 
set$<$ long int $>$ \hyperlink{classinstruction_aea1abd278018fcde9421574191dff2be}{getLocalRegSet} ()
\item 
bool \hyperlink{classinstruction_a81b2460340a76935143e7dc03a8be7da}{isInLocalRegSet} (long int reg)
\item 
int \hyperlink{classinstruction_a387c647a12b4ce2a04d01fdc92d9f87a}{getLiveVarSize} ()
\item 
void \hyperlink{classinstruction_acd7b6fdbe6803ae7cddfc81c9afa9c50}{setInsertedMovOp} ()
\item 
bool \hyperlink{classinstruction_a0e1d97e3a863986a9691164517b155b8}{isInsertedMovOp} ()
\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classinstruction_a2e0bfed549166dbfa1ce77ec084ea310}{
\index{instruction@{instruction}!instruction@{instruction}}
\index{instruction@{instruction}!instruction@{instruction}}
\subsubsection[{instruction}]{\setlength{\rightskip}{0pt plus 5cm}instruction::instruction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a2e0bfed549166dbfa1ce77ec084ea310}

\begin{DoxyCode}
                          {
        _insAddr = -1;
        _insDstAddr = -1;
        _insFallThruAddr = -1;
        _insDst = NULL;
        _insFallThru = NULL;
        _memSize = 0;
        _memWrite = false;
        _memRead = false;
        _latency = -1;
        _insType = 'x'; //Place holder
        _brBias = -1.0; //Place holder
        _bpAccuracy = -1.0; //Place holder
        _missRate = 0.0;
        _longestPath = -1;
    _mem_sch_mode = LOAD_STORE_ORDER;
    _hasFallThru = false;
    _hasDst = false;
    _upld_dep = false;
    _upld_ins = false;
    _is_inserted_mov_op = false;

    /*-- OBJ INSTANTIATIONS --*/
        _r_read  = new List<long int>;
        _r_write = new List<long int>;
        _r_write_old = new List<long int>;
        _r  = new List<long int>;
        _sr  = new List<long int>;
        _r_allocated = new List<long int>;
        _rt = new List<int>;
        _srt = new List<int>;
        _rk = new List<regKind>;
        _ancestors = new List<instruction*>;
        _regAncestors = new List<instruction*>;
        _dependents = new List<instruction*>;
}
\end{DoxyCode}
\hypertarget{classinstruction_a4f9c54b6376cf77565179728fa6f68fa}{
\index{instruction@{instruction}!$\sim$instruction@{$\sim$instruction}}
\index{$\sim$instruction@{$\sim$instruction}!instruction@{instruction}}
\subsubsection[{$\sim$instruction}]{\setlength{\rightskip}{0pt plus 5cm}instruction::$\sim$instruction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a4f9c54b6376cf77565179728fa6f68fa}

\begin{DoxyCode}
                           {
        delete _r_read;
        delete _r_write;
        delete _r_write_old;
        delete _r;
        delete _sr;
        delete _r_allocated;
        delete _rt;
        delete _srt;
        delete _rk;
        delete _ancestors;
        delete _dependents;
        delete _regAncestors;
}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{classinstruction_a729d403d579a7f910a6ebfd6500ad5e9}{
\index{instruction@{instruction}!allocatedRegister@{allocatedRegister}}
\index{allocatedRegister@{allocatedRegister}!instruction@{instruction}}
\subsubsection[{allocatedRegister}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::allocatedRegister (
\begin{DoxyParamCaption}
\item[{long int}]{r\_\-allocated, }
\item[{{\bf regKind}}]{rk}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a729d403d579a7f910a6ebfd6500ad5e9}

\begin{DoxyCode}
                                                                     {
        Assert ((rk == LRF || rk == GRF) && "Register Kind is undefined");
        Assert (((r_allocated >= LRF_LO && r_allocated <= LRF_HI) ||
           (r_allocated >= GRF_LO && r_allocated <= GRF_HI)) &&
           "Out of bound register allocation");
        _r_allocated->Append (r_allocated);
        _rk->Append (rk);
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{classinstruction_abce03a3d46f53f28cdeed1f77638e74f}{
\index{instruction@{instruction}!assignUPLDroot@{assignUPLDroot}}
\index{assignUPLDroot@{assignUPLDroot}!instruction@{instruction}}
\subsubsection[{assignUPLDroot}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::assignUPLDroot (
\begin{DoxyParamCaption}
\item[{{\bf ADDR}}]{upld\_\-id}
\end{DoxyParamCaption}
)}}
\label{classinstruction_abce03a3d46f53f28cdeed1f77638e74f}

\begin{DoxyCode}
                                              {
    _upld_roots.insert (upld_id);
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_ab21a5713ecebfd1b6b6c8aeed06e4679}{
\index{instruction@{instruction}!dependencyTableCheck@{dependencyTableCheck}}
\index{dependencyTableCheck@{dependencyTableCheck}!instruction@{instruction}}
\subsubsection[{dependencyTableCheck}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::dependencyTableCheck (
\begin{DoxyParamCaption}
\item[{{\bf dependencyTable} $\ast$}]{depTables}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab21a5713ecebfd1b6b6c8aeed06e4679}

\begin{DoxyCode}
                                                                  {
        //Register true dependency check for all instruction types
        for (int i = 0; i < getNumReg (); i++) {
                if (getNthRegType (i) == READ) { //TODO Does this line make sense
      ? (int vs. memType)
                        instruction *ins = depTables->regLookup (getNthReg (i),
      REG_WRITE);//RAW
                        if (ins != NULL) {
                                if (isInsRepeated (ins,_ancestors)==false) {
                                        ins->setAsDependent (this);
                                        setAsAncestor (ins);
                                        setAsRegAncestor (ins);
                                }
//                              long int renReg = temp->getRenamedReg (getNthReg 
      (i)); //TODO no longer necessary in a compiler I think
//                              renameReadReg (i,renReg);
                        }
        /* ----------------------------------- */
        /* THE CODE BELOW IS NOT NEEDED ON SSA */
                // } else if (getNthRegType (i) == WRITE) {
                //      instruction *temp = depTables->regLookup (getNthReg (i),R
      EG_READ);//WAR
                //      if (temp != NULL && isInsRepeated (temp,_ancestors)==fals
      e) {
                //              temp->setAsDependent (this);
                //              setAsAncestor (temp);
                //      }
                //      temp = depTables->regLookup (getNthReg (i),REG_WRITE);//W
      AW
                //      if (temp != NULL && isInsRepeated (temp,_ancestors)==fals
      e) {
                //              temp->setAsDependent (this);
                //              setAsAncestor (temp);
                //      }
        /* ----------------------------------- */
                }
        }
        List<instruction*>* stList = depTables->wrLookup ();
    if (_mem_sch_mode == LOAD_STORE_ORDER) {
            /*-- MEMORY DEPENDENCY (NO MEMORY DISAMBIGUATION) --*/
        if (getType () == 'M' && stList->NumElements () > 0) {
            instruction *storeOp = stList->Last ();
            storeOp->setAsDependent (this);
            setAsAncestor (storeOp);
        }
    } else if (_mem_sch_mode == STORE_ORDER) {
        if (getType () == 'M' && isWrMemType () && stList->NumElements () > 0) {
            instruction *storeOp = stList->Last ();
            storeOp->setAsDependent (this);
            setAsAncestor (storeOp);
        }
    } else { Assert (0 && "Invalid memory scheduling options"); }

        if (getType () == 'M' && isWrMemType ()) {
                depTables->addWr (this);
        }
        //Update write register table (must be done last to avoid deadlock/wrong 
      dependency)
        for (int i = 0; i < getNumReg (); i++) {
                if (getNthRegType (i) == WRITE) {
                        depTables->addReg (i, getNthReg (i), this, REG_WRITE); //
      overwrites existing table entry for reg
                // } else if (coreType == NO_CORE && getNthRegType (i) == READ) {
       //TODO register renaming breaks this block of code
                } else if (getNthRegType (i) == READ) { //TODO register renaming 
      breaks this block of code
                        depTables->addReg (i, getNthReg (i), this, REG_READ); //o
      verwrites existing table entry for reg
                }
        }
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{classinstruction_af6165d6c8ba00c6806eda36e36cb3366}{
\index{instruction@{instruction}!getAncestors@{getAncestors}}
\index{getAncestors@{getAncestors}!instruction@{instruction}}
\subsubsection[{getAncestors}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$ instruction::getAncestors (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af6165d6c8ba00c6806eda36e36cb3366}

\begin{DoxyCode}
{ return _ancestors; }
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a4cbd72801622336cca5bf1061f3cda6a}{
\index{instruction@{instruction}!getArchRegisterStr@{getArchRegisterStr}}
\index{getArchRegisterStr@{getArchRegisterStr}!instruction@{instruction}}
\subsubsection[{getArchRegisterStr}]{\setlength{\rightskip}{0pt plus 5cm}std::string instruction::getArchRegisterStr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a4cbd72801622336cca5bf1061f3cda6a}

\begin{DoxyCode}
                                           {
        std::stringstream ss;
        std::string s;
        if (getNumReg () == 0 && getNumSpecialReg () == 0) {
                ss << "\n";
    } else {
        /* INTEGRATE GENERAL PURPOSE REGISTERS */
        for (int i = 0; i < getNumReg (); i++) {
            long int archReg = getNthArchReg (i);
            int regType = getNthRegType (i);
            ss << archReg << "#" << regType << ",";
        }

        /* INTEGRATE SPECIAL REGISTERS */
        for (int j = 0; j < getNumSpecialReg (); j++) {
            long int archReg = getNthSpecialReg (j);
            int regType = getNthSpecialRegType (j);
            ss << archReg << "#" << regType << ",";
        }
        ss << "\n";
    }
        s = ss.str ();
        return s;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a023333937041baf6bc2985c94f88c9e5}{
\index{instruction@{instruction}!getBPaccuracy@{getBPaccuracy}}
\index{getBPaccuracy@{getBPaccuracy}!instruction@{instruction}}
\subsubsection[{getBPaccuracy}]{\setlength{\rightskip}{0pt plus 5cm}double instruction::getBPaccuracy (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a023333937041baf6bc2985c94f88c9e5}

\begin{DoxyCode}
                                   {
        Assert ((_bpAccuracy >= 0.0 && _bpAccuracy <= 1.0) && "_bpAccuracy value 
      is not recognized.");
        return _bpAccuracy;
}
\end{DoxyCode}
\hypertarget{classinstruction_ac2be260e8fce5e0615bd68bed97cb591}{
\index{instruction@{instruction}!getBrTakenBias@{getBrTakenBias}}
\index{getBrTakenBias@{getBrTakenBias}!instruction@{instruction}}
\subsubsection[{getBrTakenBias}]{\setlength{\rightskip}{0pt plus 5cm}double instruction::getBrTakenBias (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ac2be260e8fce5e0615bd68bed97cb591}

\begin{DoxyCode}
                                    {
        Assert ((_brBias >= 0.0 && _brBias <= 1.0) && "_brBias value is not recog
      nized.");
        return _brBias;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a20123ce67f40f03e304b71660a69ae37}{
\index{instruction@{instruction}!getDefSet@{getDefSet}}
\index{getDefSet@{getDefSet}!instruction@{instruction}}
\subsubsection[{getDefSet}]{\setlength{\rightskip}{0pt plus 5cm}set$<$ long int $>$ instruction::getDefSet (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a20123ce67f40f03e304b71660a69ae37}

\begin{DoxyCode}
                                      {
        return _defSet;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_ad1af63e7f1bfa160b0719027c2a0b8ce}{
\index{instruction@{instruction}!getDependents@{getDependents}}
\index{getDependents@{getDependents}!instruction@{instruction}}
\subsubsection[{getDependents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$ instruction::getDependents (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ad1af63e7f1bfa160b0719027c2a0b8ce}

\begin{DoxyCode}
{ return _dependents; }
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_ac1fabe854c85726785052c7a5ebf6d39}{
\index{instruction@{instruction}!getInsAddr@{getInsAddr}}
\index{getInsAddr@{getInsAddr}!instruction@{instruction}}
\subsubsection[{getInsAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ADDR} instruction::getInsAddr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ac1fabe854c85726785052c7a5ebf6d39}

\begin{DoxyCode}
                              {
        Assert (_insAddr >= 0 && "insAddr must be larger than zero.");
        return _insAddr;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a9404c158382339e863846837c9b252aa}{
\index{instruction@{instruction}!getInsAsm@{getInsAsm}}
\index{getInsAsm@{getInsAsm}!instruction@{instruction}}
\subsubsection[{getInsAsm}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ instruction::getInsAsm (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9404c158382339e863846837c9b252aa}

\begin{DoxyCode}
{return _command;}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a1e19a31455d12c43d0f48d071f3e0e5c}{
\index{instruction@{instruction}!getInsDst@{getInsDst}}
\index{getInsDst@{getInsDst}!instruction@{instruction}}
\subsubsection[{getInsDst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf instruction} $\ast$ instruction::getInsDst (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a1e19a31455d12c43d0f48d071f3e0e5c}

\begin{DoxyCode}
                                     {
        Assert (_insDst != NULL && "insDst must not be NULL.");
        return _insDst;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a600fd1454a34eca9a64057e3c019a795}{
\index{instruction@{instruction}!getInsDstAddr@{getInsDstAddr}}
\index{getInsDstAddr@{getInsDstAddr}!instruction@{instruction}}
\subsubsection[{getInsDstAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ADDR} instruction::getInsDstAddr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a600fd1454a34eca9a64057e3c019a795}

\begin{DoxyCode}
                                 {
        Assert (_insDstAddr >= 0 && "insDstAddr must be larger than zero.");
        return _insDstAddr;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_ab9bf2478b915e5b209d671afd85f0519}{
\index{instruction@{instruction}!getInSet@{getInSet}}
\index{getInSet@{getInSet}!instruction@{instruction}}
\subsubsection[{getInSet}]{\setlength{\rightskip}{0pt plus 5cm}set$<$ long int $>$ instruction::getInSet (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab9bf2478b915e5b209d671afd85f0519}

\begin{DoxyCode}
                                     {
        return _inSet;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a989b1f1fcfe6b80e1566f035e408b03d}{
\index{instruction@{instruction}!getInsFallThru@{getInsFallThru}}
\index{getInsFallThru@{getInsFallThru}!instruction@{instruction}}
\subsubsection[{getInsFallThru}]{\setlength{\rightskip}{0pt plus 5cm}{\bf instruction} $\ast$ instruction::getInsFallThru (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a989b1f1fcfe6b80e1566f035e408b03d}

\begin{DoxyCode}
                                          {
        Assert (_insFallThru != NULL && "insFallThru must not be NULL.");
        return _insFallThru;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a6b94ce0e75e6676de23c2a87a19eecd3}{
\index{instruction@{instruction}!getInsFallThruAddr@{getInsFallThruAddr}}
\index{getInsFallThruAddr@{getInsFallThruAddr}!instruction@{instruction}}
\subsubsection[{getInsFallThruAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ADDR} instruction::getInsFallThruAddr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a6b94ce0e75e6676de23c2a87a19eecd3}

\begin{DoxyCode}
                                      {
        Assert (_insFallThruAddr >= 0 && "insFallThruAddr must be larger than zer
      o.");
        return _insFallThruAddr;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a842fd50e52a3e3d31fcf8b7a180a32bd}{
\index{instruction@{instruction}!getLatency@{getLatency}}
\index{getLatency@{getLatency}!instruction@{instruction}}
\subsubsection[{getLatency}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getLatency (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a842fd50e52a3e3d31fcf8b7a180a32bd}

\begin{DoxyCode}
                             {
    return _latency;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a14d57791b666452fdb91973e35c39c2e}{
\index{instruction@{instruction}!getLdMissRate@{getLdMissRate}}
\index{getLdMissRate@{getLdMissRate}!instruction@{instruction}}
\subsubsection[{getLdMissRate}]{\setlength{\rightskip}{0pt plus 5cm}double instruction::getLdMissRate (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a14d57791b666452fdb91973e35c39c2e}

\begin{DoxyCode}
                                   {
        Assert (_missRate >= 0 && _missRate <= 1 && "Invalid miss rate value\n");
      
        return _missRate;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a387c647a12b4ce2a04d01fdc92d9f87a}{
\index{instruction@{instruction}!getLiveVarSize@{getLiveVarSize}}
\index{getLiveVarSize@{getLiveVarSize}!instruction@{instruction}}
\subsubsection[{getLiveVarSize}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getLiveVarSize (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classinstruction_a387c647a12b4ce2a04d01fdc92d9f87a}

\begin{DoxyCode}
{ return _inSet.size ()+_defSet.size (); }
\end{DoxyCode}
\hypertarget{classinstruction_aea1abd278018fcde9421574191dff2be}{
\index{instruction@{instruction}!getLocalRegSet@{getLocalRegSet}}
\index{getLocalRegSet@{getLocalRegSet}!instruction@{instruction}}
\subsubsection[{getLocalRegSet}]{\setlength{\rightskip}{0pt plus 5cm}set$<$ long int $>$ instruction::getLocalRegSet (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aea1abd278018fcde9421574191dff2be}

\begin{DoxyCode}
                                           {
        return _localRegSet;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_af4d93f837096be4e0dd2fe8951b1114e}{
\index{instruction@{instruction}!getLongestPath@{getLongestPath}}
\index{getLongestPath@{getLongestPath}!instruction@{instruction}}
\subsubsection[{getLongestPath}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getLongestPath (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af4d93f837096be4e0dd2fe8951b1114e}

\begin{DoxyCode}
                                 {
        Assert (_longestPath > 0 && "Invalid longest path value.");
        return _longestPath;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a7811c2dd5418e30c53d2da2460e0d47c}{
\index{instruction@{instruction}!getMemAccessSize@{getMemAccessSize}}
\index{getMemAccessSize@{getMemAccessSize}!instruction@{instruction}}
\subsubsection[{getMemAccessSize}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getMemAccessSize (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a7811c2dd5418e30c53d2da2460e0d47c}

\begin{DoxyCode}
                                   { //in bytes
        Assert (_memSize > 0 && "invalid _memSize value");
        // Assert ((_memSize == 1 || _memSize == 2 || _memSize == 4 || _memSize =
      = 8 || _memSize == 16 || _memSize == 32) && "invalid _memSize value");
        return _memSize;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_aee7e5e20a8bbb42a9efe26289a40eb89}{
\index{instruction@{instruction}!getMy\_\-BB\_\-id@{getMy\_\-BB\_\-id}}
\index{getMy\_\-BB\_\-id@{getMy\_\-BB\_\-id}!instruction@{instruction}}
\subsubsection[{getMy\_\-BB\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ADDR} instruction::getMy\_\-BB\_\-id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aee7e5e20a8bbb42a9efe26289a40eb89}

\begin{DoxyCode}
                               {
    if (_myBBs.size () != 1) cout << _myBBs.size () << endl;
        Assert (_myBBs.size () == 1 && "Instruction belongs to too many BB's.");
        set<ADDR>::iterator it = _myBBs.begin ();
        return *it;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a36e1dd2192e97d1c771be8d0f0779d8c}{
\index{instruction@{instruction}!getMy\_\-first\_\-PB\_\-id@{getMy\_\-first\_\-PB\_\-id}}
\index{getMy\_\-first\_\-PB\_\-id@{getMy\_\-first\_\-PB\_\-id}!instruction@{instruction}}
\subsubsection[{getMy\_\-first\_\-PB\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ADDR} instruction::getMy\_\-first\_\-PB\_\-id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a36e1dd2192e97d1c771be8d0f0779d8c}

\begin{DoxyCode}
                                     {
        set<ADDR>::iterator it = _myBBs.begin ();
        return *it;
}
\end{DoxyCode}
\hypertarget{classinstruction_a0e94c2270b46d453299f66a72b7c80de}{
\index{instruction@{instruction}!getMy\_\-PB\_\-id@{getMy\_\-PB\_\-id}}
\index{getMy\_\-PB\_\-id@{getMy\_\-PB\_\-id}!instruction@{instruction}}
\subsubsection[{getMy\_\-PB\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}set$<$ {\bf ADDR} $>$ instruction::getMy\_\-PB\_\-id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a0e94c2270b46d453299f66a72b7c80de}

\begin{DoxyCode}
                                    {
        Assert (_myBBs.size () > 0 && "Instruction must belong to a BB.");
        return _myBBs;
}
\end{DoxyCode}
\hypertarget{classinstruction_a7d49a66c0f3b426f1cf8fd335a5f3b6a}{
\index{instruction@{instruction}!getNthArchReg@{getNthArchReg}}
\index{getNthArchReg@{getNthArchReg}!instruction@{instruction}}
\subsubsection[{getNthArchReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getNthArchReg (
\begin{DoxyParamCaption}
\item[{int}]{indx}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a7d49a66c0f3b426f1cf8fd335a5f3b6a}

\begin{DoxyCode}
                                             {
        if (indx >= _r_allocated->NumElements ()) cout << getInsAddr () << " " <<
       indx << " " << _r_allocated->NumElements () << " " << _r->NumElements () << endl
      ;
        Assert (indx < _r_allocated->NumElements () && indx >= 0 && "Out of range
       architectural register access.");
        return _r_allocated->Nth (indx);
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_ad7dce7bff9bfecd11b0e7119738d0994}{
\index{instruction@{instruction}!getNthOldWriteReg@{getNthOldWriteReg}}
\index{getNthOldWriteReg@{getNthOldWriteReg}!instruction@{instruction}}
\subsubsection[{getNthOldWriteReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getNthOldWriteReg (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ad7dce7bff9bfecd11b0e7119738d0994}

\begin{DoxyCode}
                                              {
    Assert (i < _r_write_old->NumElements () && i >= 0);
    return _r_write_old->Nth (i);
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{classinstruction_a0a5ddbb986096245d7742472c49d14b2}{
\index{instruction@{instruction}!getNthReadReg@{getNthReadReg}}
\index{getNthReadReg@{getNthReadReg}!instruction@{instruction}}
\subsubsection[{getNthReadReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getNthReadReg (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a0a5ddbb986096245d7742472c49d14b2}

\begin{DoxyCode}
                                          { 
    Assert (i < _r_read->NumElements () && i >= 0);
    return _r_read->Nth (i);
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{classinstruction_a54412da0ee022e05101d4fb92ee879b9}{
\index{instruction@{instruction}!getNthReg@{getNthReg}}
\index{getNthReg@{getNthReg}!instruction@{instruction}}
\subsubsection[{getNthReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getNthReg (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a54412da0ee022e05101d4fb92ee879b9}

\begin{DoxyCode}
                                      { 
    Assert (i < getNumReg () && i >= 0);
    return _r->Nth (i);
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a9701f53aafaf1b2298378665059cef33}{
\index{instruction@{instruction}!getNthRegType@{getNthRegType}}
\index{getNthRegType@{getNthRegType}!instruction@{instruction}}
\subsubsection[{getNthRegType}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNthRegType (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9701f53aafaf1b2298378665059cef33}

\begin{DoxyCode}
                                     { 
    Assert (i < _rt->NumElements () && i >= 0);
    return _rt->Nth (i);
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a9f05970767f31d158fdb6beb0ae6a3df}{
\index{instruction@{instruction}!getNthSpecialReg@{getNthSpecialReg}}
\index{getNthSpecialReg@{getNthSpecialReg}!instruction@{instruction}}
\subsubsection[{getNthSpecialReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getNthSpecialReg (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9f05970767f31d158fdb6beb0ae6a3df}

\begin{DoxyCode}
                                             { 
    Assert (i < _sr->NumElements () && i >= 0);
    return _sr->Nth (i);
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a4210fe4a5a94f67cdcd7c25075e8f23b}{
\index{instruction@{instruction}!getNthSpecialRegType@{getNthSpecialRegType}}
\index{getNthSpecialRegType@{getNthSpecialRegType}!instruction@{instruction}}
\subsubsection[{getNthSpecialRegType}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNthSpecialRegType (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a4210fe4a5a94f67cdcd7c25075e8f23b}

\begin{DoxyCode}
                                            { 
    Assert (i < _srt->NumElements () && i >= 0);
    return _srt->Nth (i);
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a29e8de9d3cd22cee464512f9bbc1972c}{
\index{instruction@{instruction}!getNthWriteReg@{getNthWriteReg}}
\index{getNthWriteReg@{getNthWriteReg}!instruction@{instruction}}
\subsubsection[{getNthWriteReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getNthWriteReg (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a29e8de9d3cd22cee464512f9bbc1972c}

\begin{DoxyCode}
                                           { 
    Assert (i < _r_write->NumElements () && i >= 0);
    return _r_write->Nth (i);
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{classinstruction_a2e29e3536ad20c65b6c7b76ba6e37ad8}{
\index{instruction@{instruction}!getNumAncestors@{getNumAncestors}}
\index{getNumAncestors@{getNumAncestors}!instruction@{instruction}}
\subsubsection[{getNumAncestors}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumAncestors (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a2e29e3536ad20c65b6c7b76ba6e37ad8}

\begin{DoxyCode}
{ return _ancestors->NumElements (); }
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_adb8073eb7167fc23a3c846db8129b068}{
\index{instruction@{instruction}!getNumDependents@{getNumDependents}}
\index{getNumDependents@{getNumDependents}!instruction@{instruction}}
\subsubsection[{getNumDependents}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumDependents (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_adb8073eb7167fc23a3c846db8129b068}

\begin{DoxyCode}
{ return _dependents->NumElements (); }
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_ae0a1ee97e6ba7920c41dd35f97b1715a}{
\index{instruction@{instruction}!getNumReadReg@{getNumReadReg}}
\index{getNumReadReg@{getNumReadReg}!instruction@{instruction}}
\subsubsection[{getNumReadReg}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumReadReg (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae0a1ee97e6ba7920c41dd35f97b1715a}

\begin{DoxyCode}
                                {
    return _r_read->NumElements ();
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{classinstruction_af64e1265e882da7e152bd47cb7794c3b}{
\index{instruction@{instruction}!getNumReg@{getNumReg}}
\index{getNumReg@{getNumReg}!instruction@{instruction}}
\subsubsection[{getNumReg}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumReg (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af64e1265e882da7e152bd47cb7794c3b}

\begin{DoxyCode}
                            {
    Assert (_r->NumElements () == _rt->NumElements () && "Number of registers and
       reg-types don't match");
    return _r->NumElements ();
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a123544344e4578778985e3b6a34dea8c}{
\index{instruction@{instruction}!getNumSpecialReg@{getNumSpecialReg}}
\index{getNumSpecialReg@{getNumSpecialReg}!instruction@{instruction}}
\subsubsection[{getNumSpecialReg}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumSpecialReg (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a123544344e4578778985e3b6a34dea8c}

\begin{DoxyCode}
                                   {
    return _sr->NumElements ();
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a293a8975be22485ec002ef7cc0466d0a}{
\index{instruction@{instruction}!getNumWriteReg@{getNumWriteReg}}
\index{getNumWriteReg@{getNumWriteReg}!instruction@{instruction}}
\subsubsection[{getNumWriteReg}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumWriteReg (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a293a8975be22485ec002ef7cc0466d0a}

\begin{DoxyCode}
                                 {
    return _r_write->NumElements ();
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{classinstruction_a47d6ca18417d4f185495eb9be2844f07}{
\index{instruction@{instruction}!getOpCode@{getOpCode}}
\index{getOpCode@{getOpCode}!instruction@{instruction}}
\subsubsection[{getOpCode}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ instruction::getOpCode (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a47d6ca18417d4f185495eb9be2844f07}

\begin{DoxyCode}
{return _opCode;}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_adf7cb55183c08b9f5a04d798847e2564}{
\index{instruction@{instruction}!getOutSet@{getOutSet}}
\index{getOutSet@{getOutSet}!instruction@{instruction}}
\subsubsection[{getOutSet}]{\setlength{\rightskip}{0pt plus 5cm}set$<$ long int $>$ instruction::getOutSet (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_adf7cb55183c08b9f5a04d798847e2564}

\begin{DoxyCode}
                                      {
        return _outSet;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a7824d148fcdeb6a1b7cafd68a7ce99ef}{
\index{instruction@{instruction}!getReadRegSubscript@{getReadRegSubscript}}
\index{getReadRegSubscript@{getReadRegSubscript}!instruction@{instruction}}
\subsubsection[{getReadRegSubscript}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getReadRegSubscript (
\begin{DoxyParamCaption}
\item[{long int}]{var}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a7824d148fcdeb6a1b7cafd68a7ce99ef}

\begin{DoxyCode}
                                                       { 
        // return _readVar.size ();
        if (_readVar.find (var) != _readVar.end ())
                return _readVar[var];
        else
                return -1;
}
\end{DoxyCode}
\hypertarget{classinstruction_a90450afccd1b4b07bd28b2ee8aabdf6d}{
\index{instruction@{instruction}!getRegAncestors@{getRegAncestors}}
\index{getRegAncestors@{getRegAncestors}!instruction@{instruction}}
\subsubsection[{getRegAncestors}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$ instruction::getRegAncestors (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a90450afccd1b4b07bd28b2ee8aabdf6d}

\begin{DoxyCode}
{ return _regAncestors; }
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_acd4f756120e0bd6cdb127715c295a5e7}{
\index{instruction@{instruction}!getRegisterStr@{getRegisterStr}}
\index{getRegisterStr@{getRegisterStr}!instruction@{instruction}}
\subsubsection[{getRegisterStr}]{\setlength{\rightskip}{0pt plus 5cm}std::string instruction::getRegisterStr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_acd4f756120e0bd6cdb127715c295a5e7}

\begin{DoxyCode}
                                       {
        std::stringstream ss;
        std::string s;
        if (getNumReg () == 0) {
                ss << "\n";
        } else {
                for (int i = 0; i < getNumReg (); i++) {
                        if (getNthRegType (i) == WRITE && getRenamedReg (
      getNthReg (i)) != -1)
                                ss << getRenamedReg (getNthReg (i)) << "#" << 
      getNthRegType (i) << ",";
                        else
                                ss << getNthReg (i) << "#" << getNthRegType (i) <
      < ",";
                }
                ss << "\n";
        }
        s = ss.str ();
        return s;
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{classinstruction_a35b2a3db2dc9a22bbdcbce797d510c85}{
\index{instruction@{instruction}!getRenamedReg@{getRenamedReg}}
\index{getRenamedReg@{getRenamedReg}!instruction@{instruction}}
\subsubsection[{getRenamedReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getRenamedReg (
\begin{DoxyParamCaption}
\item[{long int}]{reg}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a35b2a3db2dc9a22bbdcbce797d510c85}

\begin{DoxyCode}
                                                 {
    if (writeRegRenMap.count (reg) > 0)
        return writeRegRenMap.find (reg)->second;
    else
        return -1; //reg is not returned
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a47623362d505a662b974624f81288389}{
\index{instruction@{instruction}!getType@{getType}}
\index{getType@{getType}!instruction@{instruction}}
\subsubsection[{getType}]{\setlength{\rightskip}{0pt plus 5cm}const char instruction::getType (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a47623362d505a662b974624f81288389}

\begin{DoxyCode}
                                 {
        Assert ((_insType == 'j' || _insType == 'o' || _insType == 'n' || _insTyp
      e == 'c' || 
                 _insType == 'r' || _insType == 'b' || _insType == 'M' || _insTyp
      e == 's') && "insType value is invalid.");
        return _insType;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a31ab0646fc31903f5b192cfc5b7e3aa8}{
\index{instruction@{instruction}!getUPLDroots@{getUPLDroots}}
\index{getUPLDroots@{getUPLDroots}!instruction@{instruction}}
\subsubsection[{getUPLDroots}]{\setlength{\rightskip}{0pt plus 5cm}set$<$ {\bf ADDR} $>$ instruction::getUPLDroots (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a31ab0646fc31903f5b192cfc5b7e3aa8}

\begin{DoxyCode}
                                     {
    return _upld_roots;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a3dcec0ff81cf6877120874d4f81d3f96}{
\index{instruction@{instruction}!getUseSet@{getUseSet}}
\index{getUseSet@{getUseSet}!instruction@{instruction}}
\subsubsection[{getUseSet}]{\setlength{\rightskip}{0pt plus 5cm}set$<$ long int $>$ instruction::getUseSet (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a3dcec0ff81cf6877120874d4f81d3f96}

\begin{DoxyCode}
                                      {
        return _useSet;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a1253eafd0173b6daef17fed2311c6bcf}{
\index{instruction@{instruction}!getWriteRegSubscript@{getWriteRegSubscript}}
\index{getWriteRegSubscript@{getWriteRegSubscript}!instruction@{instruction}}
\subsubsection[{getWriteRegSubscript}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getWriteRegSubscript (
\begin{DoxyParamCaption}
\item[{long int}]{var}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a1253eafd0173b6daef17fed2311c6bcf}

\begin{DoxyCode}
                                                        { 
        // return _writeVar.size ();
        if (_writeVar.find (var) != _writeVar.end ())
                return _writeVar[var];
        else
                return -1;
}
\end{DoxyCode}
\hypertarget{classinstruction_ac0f0a724c1207fd9c2aad8897f3c9842}{
\index{instruction@{instruction}!hasDst@{hasDst}}
\index{hasDst@{hasDst}!instruction@{instruction}}
\subsubsection[{hasDst}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::hasDst (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ac0f0a724c1207fd9c2aad8897f3c9842}

\begin{DoxyCode}
                          {
    if ((getType () == 's' || getType () == 'o' || 
         getType () == 'n' || getType () == 'r') && _hasDst) {
        cout << "*** Instruction Address: " << hex << getInsAddr () << endl;
        Assert (0 && "A destination must not have existed");
    }
        return _hasDst;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a2d7b01a0443263782d84906eb8c35ccc}{
\index{instruction@{instruction}!hasFallThru@{hasFallThru}}
\index{hasFallThru@{hasFallThru}!instruction@{instruction}}
\subsubsection[{hasFallThru}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::hasFallThru (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a2d7b01a0443263782d84906eb8c35ccc}

\begin{DoxyCode}
                               {
    if ((getType () == 's' || getType () == 'r' || 
         getType () == 'j') && _hasFallThru) {
        cout << "*** Instruction Address: " << hex << getInsAddr () << endl;
        Assert (0 && "A fall-through must not have existed");
    }
        return _hasFallThru;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_ab5e9dd71fbc48781b528341a9a371a95}{
\index{instruction@{instruction}!isAlreadyAssignedArcRegs@{isAlreadyAssignedArcRegs}}
\index{isAlreadyAssignedArcRegs@{isAlreadyAssignedArcRegs}!instruction@{instruction}}
\subsubsection[{isAlreadyAssignedArcRegs}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isAlreadyAssignedArcRegs (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab5e9dd71fbc48781b528341a9a371a95}

\begin{DoxyCode}
                                            {
        if (_r_allocated->NumElements () == getNumReg ()) return true;
        else return false;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a81b2460340a76935143e7dc03a8be7da}{
\index{instruction@{instruction}!isInLocalRegSet@{isInLocalRegSet}}
\index{isInLocalRegSet@{isInLocalRegSet}!instruction@{instruction}}
\subsubsection[{isInLocalRegSet}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isInLocalRegSet (
\begin{DoxyParamCaption}
\item[{long int}]{reg}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a81b2460340a76935143e7dc03a8be7da}

\begin{DoxyCode}
                                               {
        if  (_localRegSet.find (reg) == _localRegSet.end ())
                return false;
        else
                return true;
}
\end{DoxyCode}
\hypertarget{classinstruction_a0e1d97e3a863986a9691164517b155b8}{
\index{instruction@{instruction}!isInsertedMovOp@{isInsertedMovOp}}
\index{isInsertedMovOp@{isInsertedMovOp}!instruction@{instruction}}
\subsubsection[{isInsertedMovOp}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isInsertedMovOp (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a0e1d97e3a863986a9691164517b155b8}

\begin{DoxyCode}
                                   {
    return _is_inserted_mov_op;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_ab367eab50dc74c47b70de127fc633c9b}{
\index{instruction@{instruction}!isInsRepeated@{isInsRepeated}}
\index{isInsRepeated@{isInsRepeated}!instruction@{instruction}}
\subsubsection[{isInsRepeated}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isInsRepeated (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{ancestors}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab367eab50dc74c47b70de127fc633c9b}

\begin{DoxyCode}
                                                                                {
      
        Assert (ins != NULL);
        for (int i = 0; i < _ancestors->NumElements (); i++)
                if (_ancestors->Nth (i)->getInsAddr () == ins->getInsAddr ()) {
                        return true;
                }
        return false;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_adc11181683114bd444eff11f1a810c89}{
\index{instruction@{instruction}!isLongestPathSet@{isLongestPathSet}}
\index{isLongestPathSet@{isLongestPathSet}!instruction@{instruction}}
\subsubsection[{isLongestPathSet}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isLongestPathSet (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_adc11181683114bd444eff11f1a810c89}

\begin{DoxyCode}
                                    {
        if (_longestPath == -1) return false;
        else return true;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_abf5f8947b16c91c4e21b82bec378008f}{
\index{instruction@{instruction}!isRdMemType@{isRdMemType}}
\index{isRdMemType@{isRdMemType}!instruction@{instruction}}
\subsubsection[{isRdMemType}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isRdMemType (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_abf5f8947b16c91c4e21b82bec378008f}

\begin{DoxyCode}
                               {
        return _memRead;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a8d938a7c74c2bd36d0e5565cf933d9d5}{
\index{instruction@{instruction}!isRepeated@{isRepeated}}
\index{isRepeated@{isRepeated}!instruction@{instruction}}
\subsubsection[{isRepeated}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isRepeated (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{temp, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{ancestors}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a8d938a7c74c2bd36d0e5565cf933d9d5}
\hypertarget{classinstruction_a4e7c293557754da06684c7b04c4aaf5c}{
\index{instruction@{instruction}!isUPLD@{isUPLD}}
\index{isUPLD@{isUPLD}!instruction@{instruction}}
\subsubsection[{isUPLD}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isUPLD (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a4e7c293557754da06684c7b04c4aaf5c}

\begin{DoxyCode}
                          {
    return _upld_ins;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a65493a2688efea847fc17e08df019af9}{
\index{instruction@{instruction}!isUPLDdep@{isUPLDdep}}
\index{isUPLDdep@{isUPLDdep}!instruction@{instruction}}
\subsubsection[{isUPLDdep}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isUPLDdep (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a65493a2688efea847fc17e08df019af9}

\begin{DoxyCode}
                             {
    return _upld_dep;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a0eab1a0a392f17d7ec46e6dbf1ce21fb}{
\index{instruction@{instruction}!isWrMemType@{isWrMemType}}
\index{isWrMemType@{isWrMemType}!instruction@{instruction}}
\subsubsection[{isWrMemType}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isWrMemType (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a0eab1a0a392f17d7ec46e6dbf1ce21fb}

\begin{DoxyCode}
                               {
        return _memWrite;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_ae406e3e00f408b7b54510867c88b1b5d}{
\index{instruction@{instruction}!makeUniqueRegs@{makeUniqueRegs}}
\index{makeUniqueRegs@{makeUniqueRegs}!instruction@{instruction}}
\subsubsection[{makeUniqueRegs}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::makeUniqueRegs (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae406e3e00f408b7b54510867c88b1b5d}

\begin{DoxyCode}
                                  {
        for (int i = getNumReg () - 1; i >= 0; i--) {
                long int reg = getNthReg (i);
                int regT = getNthRegType (i);
                long int ssa;
                //printf ("%d,%d,%d,%llx\n",regT,_readVar.find (reg) != _readVar.
      end (),_writeVar.find (reg) != _writeVar.end (), getInsAddr ());
                if (regT == READ) {
                        Assert (_readVar.find (reg) != _readVar.end ());
                        ssa = _readVar[reg] * OFFSET_LARGER_THAN_X86_REG_CNT + re
      g;
                } else if (regT == WRITE) {
                        Assert (_writeVar.find (reg) != _writeVar.end ());
                        ssa = _writeVar[reg] * OFFSET_LARGER_THAN_X86_REG_CNT + r
      eg;
                } else {
                        Assert ( 0 && "Invalid register type.");
                }
        if (getInsAddr () == 0x403424)
            cout << i << " " << reg << " " << ssa << getNthReg (i) << " ";
                _r->RemoveAt (i);
                _r->InsertAt (ssa,i);
        if (getInsAddr () == 0x403424)
            cout << getNthReg (i) << endl;
        
        }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_aabb46003e886f87cd3bc918f05a3682f}{
\index{instruction@{instruction}!removeNthRegister@{removeNthRegister}}
\index{removeNthRegister@{removeNthRegister}!instruction@{instruction}}
\subsubsection[{removeNthRegister}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::removeNthRegister (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aabb46003e886f87cd3bc918f05a3682f}

\begin{DoxyCode}
                                          { 
    Assert (i < getNumReg () && i >= 0 && "Invalid index to access instruction re
      gisters");
    _r->RemoveAt (i);
    _rt->RemoveAt (i);
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_aac67c9bd51efdf37963fbfc5da8fb737}{
\index{instruction@{instruction}!renameAllInsRegs@{renameAllInsRegs}}
\index{renameAllInsRegs@{renameAllInsRegs}!instruction@{instruction}}
\subsubsection[{renameAllInsRegs}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::renameAllInsRegs (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aac67c9bd51efdf37963fbfc5da8fb737}

\begin{DoxyCode}
                                    {
    _defSet.clear ();
    _useSet.clear ();
    makeUniqueRegs ();
    //printf ("ins %llx\n",ins->getInsAddr ());
    for  (int j = 0; j < getNumReg (); j++) {
        long int reg = getNthReg (j);
        if  (getNthRegType (j) == READ) {
            //second condition avoids ud-chains within a BB from propagating
            updateUseSet (reg);
        } else if  (getNthRegType (j) == WRITE) {
            updateDefSet (reg);
        } else {
            Assert (0 && "Invalid register type");
        }
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_ae9760e334e7829c4f8504bc8436e2dfb}{
\index{instruction@{instruction}!renameReadReg@{renameReadReg}}
\index{renameReadReg@{renameReadReg}!instruction@{instruction}}
\subsubsection[{renameReadReg}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::renameReadReg (
\begin{DoxyParamCaption}
\item[{int}]{indx, }
\item[{long int}]{renReg}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae9760e334e7829c4f8504bc8436e2dfb}

\begin{DoxyCode}
                                                          {
    Assert (getNthRegType (indx) == READ);
    int num1 = getNumReg ();
    if (renReg != -1) {
        _r->RemoveAt (indx);
        _r->InsertAt (renReg,indx);
    }
    int num2 = getNumReg ();
    Assert (num1 == num2);
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{classinstruction_aabd61e186e80af7dd343e0f142741ed6}{
\index{instruction@{instruction}!renameWriteReg@{renameWriteReg}}
\index{renameWriteReg@{renameWriteReg}!instruction@{instruction}}
\subsubsection[{renameWriteReg}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::renameWriteReg (
\begin{DoxyParamCaption}
\item[{int}]{indx, }
\item[{long int}]{reg}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aabd61e186e80af7dd343e0f142741ed6}

\begin{DoxyCode}
                                                        {
    nextRenReg++;
    Assert (reg <= NUM_REGISTERS && "Invalid Register Number");
    Assert (nextRenReg > INIT_RENAME_REG_NUM && "Invalid Rename Register Number")
      ;
        if (writeRegRenMap.count (reg) > 0)
                writeRegRenMap.erase (reg);
    _r->RemoveAt (indx);
    _r->InsertAt (nextRenReg,indx);
    writeRegRenMap.insert (pair<long int,long int> (reg,nextRenReg));
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{classinstruction_aa52dbeed6a59d58a132a885cfabc70fb}{
\index{instruction@{instruction}!replaceWriteArchReg@{replaceWriteArchReg}}
\index{replaceWriteArchReg@{replaceWriteArchReg}!instruction@{instruction}}
\subsubsection[{replaceWriteArchReg}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::replaceWriteArchReg (
\begin{DoxyParamCaption}
\item[{long int}]{old\_\-reg, }
\item[{long int}]{new\_\-reg}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aa52dbeed6a59d58a132a885cfabc70fb}

\begin{DoxyCode}
                                                                         {
        Assert (getNumReg () == _r_allocated->NumElements () && "Out of range arc
      hitectural register access.");
    bool replaced = false;
    for (int i = 0; i < getNumReg (); i++) {
        if (getNthRegType (i) == WRITE && getNthArchReg (i) == old_reg) {
            _r_allocated->RemoveAt (i);
            _r_allocated->InsertAt (new_reg, i);
            replaced = true;
            break; /* ASSUMING ONE WIRTE TO EACH REG / INS */
        }
    }
    Assert (replaced == true);
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_aadbc60fe35dec68a1a8589cfc9fcc022}{
\index{instruction@{instruction}!resetInsDst@{resetInsDst}}
\index{resetInsDst@{resetInsDst}!instruction@{instruction}}
\subsubsection[{resetInsDst}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::resetInsDst (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aadbc60fe35dec68a1a8589cfc9fcc022}

\begin{DoxyCode}
                               {
    _hasDst = false;
        _insDstAddr = -1;
        _insDst = NULL;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_ac796f0f05fa4011d7c05c2155020c5bb}{
\index{instruction@{instruction}!resetInsFallThru@{resetInsFallThru}}
\index{resetInsFallThru@{resetInsFallThru}!instruction@{instruction}}
\subsubsection[{resetInsFallThru}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::resetInsFallThru (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ac796f0f05fa4011d7c05c2155020c5bb}

\begin{DoxyCode}
                                    {
    _hasFallThru = false;
        _insFallThruAddr = -1;
        _insFallThru = NULL;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_af6d861b0ad792c3136431c3ef99509ba}{
\index{instruction@{instruction}!resetLongestPath@{resetLongestPath}}
\index{resetLongestPath@{resetLongestPath}!instruction@{instruction}}
\subsubsection[{resetLongestPath}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::resetLongestPath (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af6d861b0ad792c3136431c3ef99509ba}

\begin{DoxyCode}
{ _longestPath = -1; }
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_aba1a4de7cc3e25e0090c69c51b15d6b4}{
\index{instruction@{instruction}!resetMy\_\-BBorPB\_\-id@{resetMy\_\-BBorPB\_\-id}}
\index{resetMy\_\-BBorPB\_\-id@{resetMy\_\-BBorPB\_\-id}!instruction@{instruction}}
\subsubsection[{resetMy\_\-BBorPB\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::resetMy\_\-BBorPB\_\-id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aba1a4de7cc3e25e0090c69c51b15d6b4}

\begin{DoxyCode}
{ _myBBs.clear (); }
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a7c577242cd5b190a00a9f433222b8e0b}{
\index{instruction@{instruction}!resetSets@{resetSets}}
\index{resetSets@{resetSets}!instruction@{instruction}}
\subsubsection[{resetSets}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::resetSets (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a7c577242cd5b190a00a9f433222b8e0b}

\begin{DoxyCode}
                             {
    _outSet.clear ();
    _inSet.clear ();
    _localRegSet.clear ();
    _bbUseSet.clear ();
    _bbDefSet.clear ();
    _insLocDefSet.clear ();
    _insMultiUseSet.clear ();
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a8e201444f39b8a779022284e280fdf23}{
\index{instruction@{instruction}!setArchReg@{setArchReg}}
\index{setArchReg@{setArchReg}!instruction@{instruction}}
\subsubsection[{setArchReg}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setArchReg (
\begin{DoxyParamCaption}
\item[{long int}]{r}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a8e201444f39b8a779022284e280fdf23}

\begin{DoxyCode}
                                        {
        if (! ((r <= GRF_HI && r >= GRF_LO) || (r <= LRF_HI && r >= LRF_LO))) pri
      ntf ("invalid arch register value: %d\n",r);
        Assert (((r <= GRF_HI && r >= GRF_LO) || (r <= LRF_HI && r >= LRF_LO)) &&
       "Invalid architectural register assignment.");
        Assert (_r_allocated->NumElements () <= getNumReg ());
        _r_allocated->Append (r);
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{classinstruction_aee7e55cf32812b46267a22bcb53da670}{
\index{instruction@{instruction}!setAsAncestor@{setAsAncestor}}
\index{setAsAncestor@{setAsAncestor}!instruction@{instruction}}
\subsubsection[{setAsAncestor}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setAsAncestor (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aee7e55cf32812b46267a22bcb53da670}

\begin{DoxyCode}
                                                 {
//      if (ins->getInsAddr () > getInsAddr ()) printf ("\tAncestor Address %llx 
      > Descendent Address %llx (%s, line: %d)\n", ins->getInsAddr (), getInsAddr (), _
      _FILE__, __LINE__);
        _ancestors->Append (ins);
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_ab2ba6828f1256186a787d933a6ca0868}{
\index{instruction@{instruction}!setAsDependent@{setAsDependent}}
\index{setAsDependent@{setAsDependent}!instruction@{instruction}}
\subsubsection[{setAsDependent}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setAsDependent (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab2ba6828f1256186a787d933a6ca0868}

\begin{DoxyCode}
                                                  {
        _dependents->Append (ins);
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_ab89bab28eb321e32fddfb44354c8245f}{
\index{instruction@{instruction}!setAsRegAncestor@{setAsRegAncestor}}
\index{setAsRegAncestor@{setAsRegAncestor}!instruction@{instruction}}
\subsubsection[{setAsRegAncestor}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setAsRegAncestor (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab89bab28eb321e32fddfb44354c8245f}

\begin{DoxyCode}
                                                    {
//      if (ins->getInsAddr () > getInsAddr ()) printf ("\tAncestor Address %llx 
      > Descendent Address %llx (%s, line: %d)\n", ins->getInsAddr (), getInsAddr (), _
      _FILE__, __LINE__);
        _regAncestors->Append (ins);
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a613fd5dcaabf9a68596545679b17ffd8}{
\index{instruction@{instruction}!setBPaccuracy@{setBPaccuracy}}
\index{setBPaccuracy@{setBPaccuracy}!instruction@{instruction}}
\subsubsection[{setBPaccuracy}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setBPaccuracy (
\begin{DoxyParamCaption}
\item[{double}]{bpAccuracy}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a613fd5dcaabf9a68596545679b17ffd8}

\begin{DoxyCode}
                                                  {
        Assert ((bpAccuracy >= 0.0 && bpAccuracy <= 1.0) && "bpAccuracy value is 
      not recognized.");
        _bpAccuracy = bpAccuracy;
}
\end{DoxyCode}
\hypertarget{classinstruction_aabc818127836c8403b9c691985ca6d14}{
\index{instruction@{instruction}!setBrTakenBias@{setBrTakenBias}}
\index{setBrTakenBias@{setBrTakenBias}!instruction@{instruction}}
\subsubsection[{setBrTakenBias}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setBrTakenBias (
\begin{DoxyParamCaption}
\item[{double}]{brBias}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aabc818127836c8403b9c691985ca6d14}

\begin{DoxyCode}
                                               {
        Assert ((brBias >= 0.0 && brBias <= 1.0) && "brBias value is not recogniz
      ed.");
        _brBias = brBias;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_affb2525016712f3bac93120d4d81961d}{
\index{instruction@{instruction}!setInsAddr@{setInsAddr}}
\index{setInsAddr@{setInsAddr}!instruction@{instruction}}
\subsubsection[{setInsAddr}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setInsAddr (
\begin{DoxyParamCaption}
\item[{{\bf ADDR}}]{insAddr}
\end{DoxyParamCaption}
)}}
\label{classinstruction_affb2525016712f3bac93120d4d81961d}

\begin{DoxyCode}
                                          {
        Assert (insAddr >= 0 && "insAddr must be larger than zero.");
        _insAddr = insAddr;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_ae28df36b635c5359fa48a6476eebc425}{
\index{instruction@{instruction}!setInsAsm@{setInsAsm}}
\index{setInsAsm@{setInsAsm}!instruction@{instruction}}
\subsubsection[{setInsAsm}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setInsAsm (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{command}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae28df36b635c5359fa48a6476eebc425}

\begin{DoxyCode}
{strcpy (_command, command);}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a7cd565022bab4e05dfe1e0b4637731d5}{
\index{instruction@{instruction}!setInsDst@{setInsDst}}
\index{setInsDst@{setInsDst}!instruction@{instruction}}
\subsubsection[{setInsDst}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setInsDst (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{insDst}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a7cd565022bab4e05dfe1e0b4637731d5}

\begin{DoxyCode}
                                                {
    if (_hasDst) { _insDst = insDst; }
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a3ee6f1e5c349643f6734df78619c86f9}{
\index{instruction@{instruction}!setInsDstAddr@{setInsDstAddr}}
\index{setInsDstAddr@{setInsDstAddr}!instruction@{instruction}}
\subsubsection[{setInsDstAddr}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setInsDstAddr (
\begin{DoxyParamCaption}
\item[{{\bf ADDR}}]{insDstAddr, }
\item[{bool}]{hasDst}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a3ee6f1e5c349643f6734df78619c86f9}

\begin{DoxyCode}
                                                             {
        _hasDst = hasDst;
    if (_hasDst) {
            Assert (insDstAddr >= 0 && "insDstAddr must be larger than zero.");
        _insDstAddr = insDstAddr;
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_acd7b6fdbe6803ae7cddfc81c9afa9c50}{
\index{instruction@{instruction}!setInsertedMovOp@{setInsertedMovOp}}
\index{setInsertedMovOp@{setInsertedMovOp}!instruction@{instruction}}
\subsubsection[{setInsertedMovOp}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setInsertedMovOp (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_acd7b6fdbe6803ae7cddfc81c9afa9c50}

\begin{DoxyCode}
                                    {
    Assert (_is_inserted_mov_op == false);
    _is_inserted_mov_op = true;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_afb8fdf4968223005eaf2eb18709f2ce5}{
\index{instruction@{instruction}!setInsFallThru@{setInsFallThru}}
\index{setInsFallThru@{setInsFallThru}!instruction@{instruction}}
\subsubsection[{setInsFallThru}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setInsFallThru (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{insFallThru}
\end{DoxyParamCaption}
)}}
\label{classinstruction_afb8fdf4968223005eaf2eb18709f2ce5}

\begin{DoxyCode}
                                                          {
    if (_hasFallThru) { _insFallThru = insFallThru; }
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_ab0119dd691b88e7cedb51d4f48c829a9}{
\index{instruction@{instruction}!setInsFallThruAddr@{setInsFallThruAddr}}
\index{setInsFallThruAddr@{setInsFallThruAddr}!instruction@{instruction}}
\subsubsection[{setInsFallThruAddr}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setInsFallThruAddr (
\begin{DoxyParamCaption}
\item[{{\bf ADDR}}]{insFallThruAddr, }
\item[{bool}]{hasFallThru}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab0119dd691b88e7cedb51d4f48c829a9}

\begin{DoxyCode}
                                                                            {
        _hasFallThru = hasFallThru;
    if (_hasFallThru) {
            Assert (insFallThruAddr >= 0 && "insFallThruAddr must be larger than 
      zero.");
        _insFallThruAddr = insFallThruAddr;
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a5052a04bf5db0d0e1519eb54f343bdc6}{
\index{instruction@{instruction}!setLdMissRate@{setLdMissRate}}
\index{setLdMissRate@{setLdMissRate}!instruction@{instruction}}
\subsubsection[{setLdMissRate}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setLdMissRate (
\begin{DoxyParamCaption}
\item[{double}]{missRate}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a5052a04bf5db0d0e1519eb54f343bdc6}

\begin{DoxyCode}
                                                {
        Assert (missRate >= 0 && missRate <= 1 && "Invalid miss rate fetched\n");
      
        _missRate = missRate;

        Assert (_latency != -1 && "Invalid latency value detected.");
        if (_missRate > UPLD_THRESHOLD) _latency = L2_LATENCY;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a46127cea18a5a4ec73566038a2454ecf}{
\index{instruction@{instruction}!setLongestPath@{setLongestPath}}
\index{setLongestPath@{setLongestPath}!instruction@{instruction}}
\subsubsection[{setLongestPath}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setLongestPath (
\begin{DoxyParamCaption}
\item[{int}]{longestPath}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a46127cea18a5a4ec73566038a2454ecf}

\begin{DoxyCode}
                                                 {
        Assert (_longestPath == -1 && longestPath > 0 && "Invalid longest path va
      lue.");
        _longestPath = longestPath;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_ab36280a1a2cd3339e45c8271deaa23d0}{
\index{instruction@{instruction}!setMemAccessSize@{setMemAccessSize}}
\index{setMemAccessSize@{setMemAccessSize}!instruction@{instruction}}
\subsubsection[{setMemAccessSize}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setMemAccessSize (
\begin{DoxyParamCaption}
\item[{int}]{memSize}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab36280a1a2cd3339e45c8271deaa23d0}

\begin{DoxyCode}
                                               { //in bytes
        Assert (memSize > 0 && "invalid memSize value");
        // Assert ((memSize == 1 || memSize == 2 || memSize == 4 || memSize == 8 
      || memSize == 16 || memSize == 32) && "invalid memSize value");
        _memSize = memSize; //TODO this way of assigning memory sizes is wrong. y
      ou should do this based on dynamic execution informaiton
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_af78c579e9c3b74dfc72c5bbfb573deab}{
\index{instruction@{instruction}!setMy\_\-BBorPB\_\-id@{setMy\_\-BBorPB\_\-id}}
\index{setMy\_\-BBorPB\_\-id@{setMy\_\-BBorPB\_\-id}!instruction@{instruction}}
\subsubsection[{setMy\_\-BBorPB\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setMy\_\-BBorPB\_\-id (
\begin{DoxyParamCaption}
\item[{{\bf ADDR}}]{id}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af78c579e9c3b74dfc72c5bbfb573deab}

\begin{DoxyCode}
                                          {
        Assert (id > 0 && "BB or PB id is invalid.");
        _myBBs.insert (id);
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a7a4adbec8d2e9a2cb6090168530e336c}{
\index{instruction@{instruction}!setOpCode@{setOpCode}}
\index{setOpCode@{setOpCode}!instruction@{instruction}}
\subsubsection[{setOpCode}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setOpCode (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{opCode}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a7a4adbec8d2e9a2cb6090168530e336c}

\begin{DoxyCode}
{strcpy (_opCode, opCode);}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a379cbb0fb6bbe15168c6eac05a37114f}{
\index{instruction@{instruction}!setRdAddrSet@{setRdAddrSet}}
\index{setRdAddrSet@{setRdAddrSet}!instruction@{instruction}}
\subsubsection[{setRdAddrSet}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setRdAddrSet (
\begin{DoxyParamCaption}
\item[{set$<$ {\bf ADDR} $>$ \&}]{addrSet}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a379cbb0fb6bbe15168c6eac05a37114f}

\begin{DoxyCode}
                                                  {
        _memRdAddr = addrSet;
        printf ("debug: read set of ins %llx: %d\n", getInsAddr (), _memRdAddr.si
      ze ());
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a0d47af8822438b6e838c08dbd31cc02c}{
\index{instruction@{instruction}!setRdMemType@{setRdMemType}}
\index{setRdMemType@{setRdMemType}!instruction@{instruction}}
\subsubsection[{setRdMemType}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setRdMemType (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a0d47af8822438b6e838c08dbd31cc02c}

\begin{DoxyCode}
                                {
        Assert (_memRead == false && "invalid _memWrite value");
        _memRead = true;        
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a093ff19f17baaf84d4539ea395468265}{
\index{instruction@{instruction}!setReadVar@{setReadVar}}
\index{setReadVar@{setReadVar}!instruction@{instruction}}
\subsubsection[{setReadVar}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setReadVar (
\begin{DoxyParamCaption}
\item[{int}]{var, }
\item[{int}]{subscript}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a093ff19f17baaf84d4539ea395468265}

\begin{DoxyCode}
                                                    {
        Assert ((var <= X86_REG_HI && var >= X86_REG_LO) && "Invalid architectura
      l register assignment.");
        Assert ((subscript >= 0 || subscript == -2) && "Invalid SSA register assi
      gnment value");
        // printf ("ins (%llx): %d_%d\n", getInsAddr (),var,subscript);
        if (_readVar.find (var) != _readVar.end () && subscript != _readVar[var])
       
                printf ("\t\tWARNING: Rewriting an already assigned READ reg (old
      :%d,new:%d)\n", subscript,_readVar[var]);
        if (_readVar.find (var) != _readVar.end () && subscript!=-2 && _readVar[v
      ar]==-2)
                _readVar.erase (var);
        _readVar.insert (pair<int,int> (var,subscript));
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a456de8aa26ff79d2b7cd203f7c59f2cb}{
\index{instruction@{instruction}!setRegister@{setRegister}}
\index{setRegister@{setRegister}!instruction@{instruction}}
\subsubsection[{setRegister}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setRegister (
\begin{DoxyParamCaption}
\item[{long int $\ast$}]{r, }
\item[{int $\ast$}]{rt}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a456de8aa26ff79d2b7cd203f7c59f2cb}

\begin{DoxyCode}
                                                   {
    long int tempR = *r;
    int tempRT = *rt; 
        if (! (tempR <= X86_REG_HI && tempR >= X86_REG_LO)) printf ("invalid reg:
       %d\n",tempR);
    //Assert (tempR >= 1); //TODO this is remved to enable instruction injection
    Assert (tempRT == READ || tempRT == WRITE);
        Assert (tempR <= X86_REG_HI && tempR >= X86_REG_LO && "Invalid register v
      alue");
    (_r)->Append (tempR);
    (_rt)->Append (tempRT);
        if (tempRT == READ) {
                 (_r_read)->Append (tempR);
        } else if (tempRT == WRITE) {
                 (_r_write)->Append (tempR);
                 (_r_write_old)->Append (tempR);
        }
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_ae171d8892a0c330d2fa475346e321724}{
\index{instruction@{instruction}!setSpecialRegister@{setSpecialRegister}}
\index{setSpecialRegister@{setSpecialRegister}!instruction@{instruction}}
\subsubsection[{setSpecialRegister}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setSpecialRegister (
\begin{DoxyParamCaption}
\item[{long int $\ast$}]{r, }
\item[{int $\ast$}]{rt}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae171d8892a0c330d2fa475346e321724}

\begin{DoxyCode}
                                                          {
    long int tempR = *r;
    int tempRT = *rt; 
    Assert (tempRT == READ || tempRT == WRITE);
        Assert (tempR <= X86_SPECIAL_REG_HI && tempR >= X86_SPECIAL_REG_LO && "In
      valid register value");

    /* RENAME SPECIAL REGISTER TO THE APPROPRIATE REG SPACE NAME */
    tempR = (tempR - 1) + SGRF_LO;
        Assert (tempR <= SGRF_HI && tempR >= SGRF_LO && "Invalid register value")
      ;

    (_sr)->Append (tempR);
    (_srt)->Append (tempRT);
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a3623f439924f86cba8f9e115e19e7514}{
\index{instruction@{instruction}!setSSAregister@{setSSAregister}}
\index{setSSAregister@{setSSAregister}!instruction@{instruction}}
\subsubsection[{setSSAregister}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setSSAregister (
\begin{DoxyParamCaption}
\item[{long int $\ast$}]{r, }
\item[{int $\ast$}]{rt}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a3623f439924f86cba8f9e115e19e7514}

\begin{DoxyCode}
                                                      {
    long int tempR = *r;
    int tempRT = *rt; 
    Assert (tempRT == READ || tempRT == WRITE);
    (_r)->Append (tempR);
    (_rt)->Append (tempRT);
        if (tempRT == READ) {
                 (_r_read)->Append (tempR);
        } else if (tempRT == WRITE) {
                 (_r_write)->Append (tempR);
                 (_r_write_old)->Append (tempR);
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_aa6ff7d5323483cf18c10687ed8c1dc73}{
\index{instruction@{instruction}!setType@{setType}}
\index{setType@{setType}!instruction@{instruction}}
\subsubsection[{setType}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setType (
\begin{DoxyParamCaption}
\item[{const char}]{insType}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aa6ff7d5323483cf18c10687ed8c1dc73}

\begin{DoxyCode}
                                             {
        Assert ((insType == 'j' || insType == 'o' || insType == 'n' || insType ==
       'c' || 
                 insType == 'r' || insType == 'b' || insType == 'M' || insType ==
       's') && "insType value is not recognized.");
        if (_insType != 'x') return; //Do not set type more than once
        Assert (_latency == -1 && "Invalid latency value detected.");
        _insType = insType;
        if (getType () == 'b') {
                _brBias = 0.5;
                _bpAccuracy = 0.5;
                _latency = BR_LATENCY;
        } else if (getType ()  == 'c' || getType ()  == 'j' || getType ()  == 's'
      ) {
                _brBias = 1.0;
                _bpAccuracy = 1.0;
                _latency = ALU_LATENCY;
        } else if (getType () == 'M' && isRdMemType ()) {
                _brBias = 0.0;
                _bpAccuracy = 1.0;
                _latency = L1_LATENCY;
        } else if (getType () == 'M' && isWrMemType ()) {
                _brBias = 0.0;
                _bpAccuracy = 1.0;
                _latency = ST_LATENCY;
        } else if (getType () == 'M') {
        Assert (0 && "Invalid memory type");
        } else { //NOTE: in this not wrong to do? covers fall through paths that 
      are not all branch ops
                _brBias = 0.0;
                _bpAccuracy = 1.0;
                _latency = ALU_LATENCY;
        }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_ab4d650144a6a91370a440977b6c67a9a}{
\index{instruction@{instruction}!setup\_\-locGlbDefSet@{setup\_\-locGlbDefSet}}
\index{setup\_\-locGlbDefSet@{setup\_\-locGlbDefSet}!instruction@{instruction}}
\subsubsection[{setup\_\-locGlbDefSet}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setup\_\-locGlbDefSet (
\begin{DoxyParamCaption}
\item[{set$<$ long int $>$ \&}]{bbDefSet}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab4d650144a6a91370a440977b6c67a9a}

\begin{DoxyCode}
                                                             {
    Assert (_bbDefSet.size () == 0);
    _bbDefSet = bbDefSet;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a7c5699deabae9d06e77ca5f9a6368e1b}{
\index{instruction@{instruction}!setup\_\-locGlbUseSet@{setup\_\-locGlbUseSet}}
\index{setup\_\-locGlbUseSet@{setup\_\-locGlbUseSet}!instruction@{instruction}}
\subsubsection[{setup\_\-locGlbUseSet}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setup\_\-locGlbUseSet (
\begin{DoxyParamCaption}
\item[{set$<$ long int $>$ \&}]{bbUseSet}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a7c5699deabae9d06e77ca5f9a6368e1b}

\begin{DoxyCode}
                                                             {
    Assert (_bbUseSet.size () == 0);
    _bbUseSet = bbUseSet;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a057247b6632a4fa3eb672d7b7bcb85b1}{
\index{instruction@{instruction}!setup\_\-locToGlbDefSet@{setup\_\-locToGlbDefSet}}
\index{setup\_\-locToGlbDefSet@{setup\_\-locToGlbDefSet}!instruction@{instruction}}
\subsubsection[{setup\_\-locToGlbDefSet}]{\setlength{\rightskip}{0pt plus 5cm}set$<$ long int $>$ instruction::setup\_\-locToGlbDefSet (
\begin{DoxyParamCaption}
\item[{set$<$ long int $>$ \&}]{bbMultiUseSet}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a057247b6632a4fa3eb672d7b7bcb85b1}

\begin{DoxyCode}
                                                                             {
    set<long int> temp0;
    std::set_intersection (bbMultiUseSet.begin (), bbMultiUseSet.end (),
                           _useSet.begin (), _useSet.end (), 
                           std::inserter (temp0, temp0.begin ()));
    _insLocDefSet = temp0;
    return _insLocDefSet;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_ae25624ad14ee474a22819a8831732ec6}{
\index{instruction@{instruction}!setup\_\-locToGlbUseSet@{setup\_\-locToGlbUseSet}}
\index{setup\_\-locToGlbUseSet@{setup\_\-locToGlbUseSet}!instruction@{instruction}}
\subsubsection[{setup\_\-locToGlbUseSet}]{\setlength{\rightskip}{0pt plus 5cm}set$<$ long int $>$ instruction::setup\_\-locToGlbUseSet (
\begin{DoxyParamCaption}
\item[{set$<$ long int $>$ \&}]{bbUseSet, }
\item[{set$<$ long int $>$ \&}]{bbInSet}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae25624ad14ee474a22819a8831732ec6}

\begin{DoxyCode}
                                                                                 
                     {
    set<long int> temp0, temp1;
    temp0.clear ();
    temp1.clear ();
    std::set_intersection (_useSet.begin (), _useSet.end (),
                           bbUseSet.begin (), bbUseSet.end (), 
                           std::inserter (temp0, temp0.begin ()));
    std::set_intersection (temp0.begin (), temp0.end (),
                           bbInSet.begin (), bbInSet.end (), 
                           std::inserter (temp1, temp1.begin ()));
    _insMultiUseSet = temp1;
    return _insMultiUseSet;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_ad8aba4b11bc32a8e52866c79c8dc47e6}{
\index{instruction@{instruction}!setupDefUseSets@{setupDefUseSets}}
\index{setupDefUseSets@{setupDefUseSets}!instruction@{instruction}}
\subsubsection[{setupDefUseSets}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setupDefUseSets (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ad8aba4b11bc32a8e52866c79c8dc47e6}

\begin{DoxyCode}
                                   {
    for  (int j = 0; j < getNumReg (); j++) {
        long int reg = getNthReg (j);
        if  (getNthRegType (j) == READ) {
            //second condition avoids ud-chains within a BB from propagating
            updateUseSet (reg);
        } else if  (getNthRegType (j) == WRITE) {
            updateDefSet (reg);
        } else {
            Assert (0 && "Invalid register type");
        }
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a9e341ec4d383ed7a70104164904651f2}{
\index{instruction@{instruction}!setUPLDdep@{setUPLDdep}}
\index{setUPLDdep@{setUPLDdep}!instruction@{instruction}}
\subsubsection[{setUPLDdep}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setUPLDdep (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9e341ec4d383ed7a70104164904651f2}

\begin{DoxyCode}
                              {
    _upld_dep = true;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_adcf44cfcb7a8c267da71a1ef7b2f4b91}{
\index{instruction@{instruction}!setUPLDins@{setUPLDins}}
\index{setUPLDins@{setUPLDins}!instruction@{instruction}}
\subsubsection[{setUPLDins}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setUPLDins (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_adcf44cfcb7a8c267da71a1ef7b2f4b91}

\begin{DoxyCode}
                              {
    _upld_ins = true;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_af50b9f329ee94315d1fbff3a151cbd45}{
\index{instruction@{instruction}!setupLocSet@{setupLocSet}}
\index{setupLocSet@{setupLocSet}!instruction@{instruction}}
\subsubsection[{setupLocSet}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setupLocSet (
\begin{DoxyParamCaption}
\item[{{\bf PUSH\_\-LOCATION}}]{push\_\-location}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af50b9f329ee94315d1fbff3a151cbd45}

\begin{DoxyCode}
                                                          {
    if (push_location == PUSH_TO_TOP) {
        for  (int j = 0; j < getNumReg (); j++) {
            if  (getNthRegType (j) == WRITE) {
                _localRegSet.insert (getNthReg (j));
            }
        }
    } else if (push_location == PUSH_TO_BOTTOM) {
        for  (int j = 0; j < getNumReg (); j++) {
            if  (getNthRegType (j) == READ) {
                _localRegSet.insert (getNthReg (j));
            }
        }
    } else {
        Assert (0 && "invalid push location specified");
    }
     
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{classinstruction_a8928d9fe638fd7307606fac71a31b681}{
\index{instruction@{instruction}!setWrAddrSet@{setWrAddrSet}}
\index{setWrAddrSet@{setWrAddrSet}!instruction@{instruction}}
\subsubsection[{setWrAddrSet}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setWrAddrSet (
\begin{DoxyParamCaption}
\item[{set$<$ {\bf ADDR} $>$ \&}]{addrSet}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a8928d9fe638fd7307606fac71a31b681}

\begin{DoxyCode}
                                                  {
        _memWrAddr = addrSet;
        printf ("debug: write set of ins %llx: %d\n", getInsAddr (), _memWrAddr.s
      ize ());
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a67c584522eaa68d46a495170ce8a3bbd}{
\index{instruction@{instruction}!setWriteVar@{setWriteVar}}
\index{setWriteVar@{setWriteVar}!instruction@{instruction}}
\subsubsection[{setWriteVar}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setWriteVar (
\begin{DoxyParamCaption}
\item[{int}]{var, }
\item[{int}]{subscript}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a67c584522eaa68d46a495170ce8a3bbd}

\begin{DoxyCode}
                                                     {
        Assert ((var <= X86_REG_HI && var >= X86_REG_LO) && "Invalid architectura
      l register assignment.");
        Assert (subscript >= 0 && "Invalid SSA register assignment value");
        if (_writeVar.find (var) != _writeVar.end ()) 
        printf ("\t\tWARNING: Trying to rewrite an already assigned write registe
      r (old:%d,new:%d)\n", subscript,_writeVar[var]);
        if (_writeVar.find (var) != _writeVar.end () && subscript>0 && _writeVar[
      var]==0)
                _writeVar.erase (var);
        _writeVar.insert (pair<int,int> (var,subscript));
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a1a85e010b731e20bcd25310a26eabd98}{
\index{instruction@{instruction}!setWrMemType@{setWrMemType}}
\index{setWrMemType@{setWrMemType}!instruction@{instruction}}
\subsubsection[{setWrMemType}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setWrMemType (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a1a85e010b731e20bcd25310a26eabd98}

\begin{DoxyCode}
                                {
        Assert (_memWrite == false && "invalid _memWrite value");
        _memWrite = true;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{classinstruction_a173a23e5f292232055dec69475b3fd92}{
\index{instruction@{instruction}!update\_\-InOutSet@{update\_\-InOutSet}}
\index{update\_\-InOutSet@{update\_\-InOutSet}!instruction@{instruction}}
\subsubsection[{update\_\-InOutSet}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::update\_\-InOutSet (
\begin{DoxyParamCaption}
\item[{{\bf REG\_\-ALLOC\_\-MODE}}]{reg\_\-alloc\_\-mode, }
\item[{set$<$ long int $>$ \&}]{bbDefSet, }
\item[{bool}]{isLastInsInBB}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a173a23e5f292232055dec69475b3fd92}

\begin{DoxyCode}
                                                                                 
                                  {
    set<long int> oldOutSet = _outSet;
    set<long int> oldInSet = _inSet;
    set<long int> oldLocalSet = _localRegSet;

    /*-- UPDATE _outSet --*/
    set<long int> tempSet;
    set<long int> succInSet;

    /* DESTINATION */
    if (_hasDst && 
       (getType () == 'j' || getType () == 'b')) {
        tempSet.clear ();
        succInSet.clear ();
        Assert (_insDst != NULL);
        succInSet = _insDst->getInSet ();
        std::set_union (succInSet.begin (), succInSet.end (), 
                        _outSet.begin (), _outSet.end (), 
                        std::inserter (tempSet, tempSet.begin ()));
        _outSet = tempSet;
    }

    /* FALL-THROUGH */
    if (_hasFallThru &&
        !(getType () == 'r' || getType () == 'j' || getType () == 's')) {
        tempSet.clear ();
        succInSet.clear ();
        Assert (_insFallThru != NULL);
        succInSet = _insFallThru->getInSet ();
        std::set_union (succInSet.begin (), succInSet.end (), 
                        _outSet.begin (), _outSet.end (), 
                        std::inserter (tempSet, tempSet.begin ()));
        _outSet = tempSet;
    }

    /*-- UPDATE _inSet --*/
    set<long int> outMinusDef;
    std::set_difference (_outSet.begin (), _outSet.end (), 
                         _defSet.begin (), _defSet.end (), 
                         std::inserter (outMinusDef, outMinusDef.begin ()));
    std::set_union (outMinusDef.begin (), outMinusDef.end (), 
                    _useSet.begin (), _useSet.end (), 
                    std::inserter (_inSet, _inSet.begin ()));


    /*-- CALCULATE LOCAL REGISTER SET --*/
    if (reg_alloc_mode == LOCAL_GLOBAL) {
//        cout << "- " << bbDefSet.size () << " " << _outSet.size () << endl;
        set<long int> temp, temp0, temp1, temp2, temp3;
        if (!isLastInsInBB) {
            if (hasFallThru ()) {
                _localRegSet = _insFallThru->getLocalRegSet ();
                std::set_union (_defSet.begin (), _defSet.end (), 
                        bbDefSet.begin (), bbDefSet.end (), 
                        std::inserter (temp, temp.begin ()));
                std::set_intersection (_localRegSet.begin (), _localRegSet.end ()
      , 
                        temp.begin (), temp.end (), 
                        std::inserter (temp0, temp0.begin ()));
                _localRegSet = temp0;
            } else if (hasDst ()) {
                _localRegSet = _insDst->getLocalRegSet ();
                std::set_union (_defSet.begin (), _defSet.end (), 
                        bbDefSet.begin (), bbDefSet.end (), 
                        std::inserter (temp, temp.begin ()));
                std::set_intersection (_localRegSet.begin (), _localRegSet.end ()
      , 
                        temp.begin (), temp.end (), 
                        std::inserter (temp0, temp0.begin ()));
                _localRegSet = temp0;
            }
        } else {
            _localRegSet.clear ();
        }
        std::set_difference (_useSet.begin (), _useSet.end (), 
                             _outSet.begin (), _outSet.end (), 
                             std::inserter (temp1, temp1.begin ()));
        std::set_intersection (bbDefSet.begin (), bbDefSet.end (), 
                               temp1.begin (), temp1.end (),
                               std::inserter (temp2, temp2.begin ()));
        std::set_union (_localRegSet.begin (), _localRegSet.end (), 
                        temp2.begin (), temp2.end (), 
                        std::inserter (temp3, temp3.begin ()));
        _localRegSet = temp3;
    }

    /*-- ANY CHANGE IN THE BB SETS? --*/
    bool change;
    set<long int> inDiff, outDiff;
    std::set_difference (_outSet.begin (), _outSet.end (), 
                         oldOutSet.begin (), oldOutSet.end (), 
                         std::inserter (outDiff, outDiff.begin ()));
    std::set_difference (_inSet.begin (), _inSet.end (), 
                         oldInSet.begin (), oldInSet.end (), 
                         std::inserter (inDiff, inDiff.begin ()));
    if (reg_alloc_mode == LOCAL_GLOBAL) {
        set<long int> localDiff;
        std::set_difference (_localRegSet.begin (), _localRegSet.end (), 
                             oldLocalSet.begin (), oldLocalSet.end (), 
                             std::inserter (localDiff, localDiff.begin ()));
        if (oldOutSet.size () != _outSet.size () || 
            oldInSet.size () != _inSet.size () || 
            oldLocalSet.size () != _localRegSet.size () ||
            outDiff.size () != 0 || 
            inDiff.size () != 0 || 
            localDiff.size () != 0)
            change = true;
        else
            change = false;
    } else {
        if (oldOutSet.size () != _outSet.size () || 
            oldInSet.size () != _inSet.size () || 
            outDiff.size () != 0 || 
            inDiff.size () != 0)
            change = true;
        else
            change = false;
    }
    return change;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_a33901636d2350a413a4d245f6d16e6a6}{
\index{instruction@{instruction}!update\_\-locGlbSet@{update\_\-locGlbSet}}
\index{update\_\-locGlbSet@{update\_\-locGlbSet}!instruction@{instruction}}
\subsubsection[{update\_\-locGlbSet}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::update\_\-locGlbSet (
\begin{DoxyParamCaption}
\item[{set$<$ long int $>$ \&}]{bbOutSet, }
\item[{std::map$<$ int, long int $>$ \&}]{movOpSrcRegs, }
\item[{std::map$<$ int, long int $>$ \&}]{movOpDstRegs, }
\item[{int}]{indx}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a33901636d2350a413a4d245f6d16e6a6}

\begin{DoxyCode}
                                                                                 
                                                                    {
    set<long int> temp0, temp1, temp2;
    set<long int> locGlbDefSet, locGlbUseSet, locGlbRegSet;

    /* HANDLE DEF SET */
    temp0.clear ();
    temp1.clear ();
    std::set_intersection (_defSet.begin (), _defSet.end (),
                           bbOutSet.begin (), bbOutSet.end (),
                           std::inserter (temp0, temp0.begin ()));
    std::set_intersection (temp0.begin (), temp0.end (),
                           _bbUseSet.begin (), _bbUseSet.end (), 
                           std::inserter (temp1, temp1.begin ()));
    locGlbDefSet = temp1;
    for (set<long int>::iterator it = locGlbDefSet.begin (); it != locGlbDefSet.e
      nd (); it++) {
        bool removed_reg = false;
        int reg_type = WRITE;
        long int reg = (*it);
        long int new_reg = reg * LARGE_NUMBER;
        Assert (_localRegSet.find (reg) == _localRegSet.end ());
        locGlbRegSet.insert (new_reg);
        /* REMOVE THE OTHER READ REGISTER CORRESPONDING TO THE SAME OPERAND */
        for (int i = getNumReg () - 1; i >= 0; i--) {
            if (getNthReg (i) == reg && getNthRegType (i) == WRITE) {
                removeNthRegister (i);
                removed_reg = true;
                break;
            }
        }
        Assert (removed_reg == true);
        _r->Append (new_reg);
        _rt->Append (reg_type);
        replaceDefSetElem (reg, new_reg);
        int next_indx = indx + 1;
        movOpSrcRegs.insert (pair<int, long int> (next_indx, new_reg));
        movOpDstRegs.insert (pair<int, long int> (next_indx, reg));
    }

    /* HANDLE USE SET */
    temp0.clear ();
    temp1.clear ();
    std::set_intersection (_useSet.begin (), _useSet.end (),
                           bbOutSet.begin (), bbOutSet.end (),
                           std::inserter (temp0, temp0.begin ()));
    std::set_intersection (temp0.begin (), temp0.end (),
                           _bbDefSet.begin (), _bbDefSet.end (), 
                           std::inserter (temp1, temp1.begin ()));
    locGlbUseSet = temp1;
    for (set<long int>::iterator it = locGlbUseSet.begin (); it != locGlbUseSet.e
      nd (); it++) {
        int removed_reg = 0;
        int reg_type = READ;
        long int reg = (*it);
        long int new_reg = reg * LARGE_NUMBER;
        locGlbRegSet.insert (new_reg);
        Assert (_localRegSet.find (reg) == _localRegSet.end ());
        /* REMOVE THE OTHER READ REGISTER CORRESPONDING TO THE SAME OPERAND */
        for (int i = getNumReg () - 1; i >= 0; i--) {
//            cout << getNthReg(i) << "(" << getNthRegType (i) << ") ";
            if (getNthReg (i) == reg && getNthRegType (i) == READ) {
                removeNthRegister (i);
                removed_reg++;
            }
        }
//        cout << endl << hex << getInsAddr () << dec << " " << reg << " " << new
      _reg << endl;
        if (removed_reg == 0) cout << reg << " " << new_reg << endl;
        Assert (removed_reg > 0);
        for (int i = 0; i < removed_reg; i++) {
            _r->Append (new_reg);
            _rt->Append (reg_type);
        }
        replaceUseSetElem (reg, new_reg);
    }

    /* UPDATE THE LOCAL REGISTER SET */
    temp2.clear ();
    std::set_union (locGlbRegSet.begin (), locGlbRegSet.end (),
                    _localRegSet.begin (), _localRegSet.end (),
                    std::inserter (temp2, temp2.begin ()));
    _localRegSet = temp2;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_aaba4ffcf984873d13a0ecea71a0ebad3}{
\index{instruction@{instruction}!update\_\-locToGlb@{update\_\-locToGlb}}
\index{update\_\-locToGlb@{update\_\-locToGlb}!instruction@{instruction}}
\subsubsection[{update\_\-locToGlb}]{\setlength{\rightskip}{0pt plus 5cm}set$<$long int$>$ instruction::update\_\-locToGlb (
\begin{DoxyParamCaption}
\item[{set$<$ long int $>$ \&}]{, }
\item[{set$<$ long int $>$ \&}]{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aaba4ffcf984873d13a0ecea71a0ebad3}
\hypertarget{classinstruction_a8c177bf836da2d16fca731375b07fc35}{
\index{instruction@{instruction}!update\_\-locToGlbSet@{update\_\-locToGlbSet}}
\index{update\_\-locToGlbSet@{update\_\-locToGlbSet}!instruction@{instruction}}
\subsubsection[{update\_\-locToGlbSet}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::update\_\-locToGlbSet (
\begin{DoxyParamCaption}
\item[{set$<$ long int $>$ \&}]{bbLocDefSet, }
\item[{std::map$<$ int, long int $>$ \&}]{movOpSrcRegs, }
\item[{std::map$<$ int, long int $>$ \&}]{movOpDstRegs, }
\item[{int}]{indx}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a8c177bf836da2d16fca731375b07fc35}

\begin{DoxyCode}
                                                                                 
                                                                         {
    set<long int>::iterator it;

    for (it = _insMultiUseSet.begin (); it != _insMultiUseSet.end (); it++) {
        int removed_reg = 0;
        long int reg_type = READ;
        long int reg = (*it);
        long int new_reg = reg * LARGE_NUMBER;
        Assert (_localRegSet.find (reg) == _localRegSet.end ());
//        Assert (_localRegSet.find (new_reg) == _localRegSet.end ());
        Assert (bbLocDefSet.find (reg) != bbLocDefSet.end ());
        /* REMOVE THE OTHER READ REGISTER CORRESPONDING TO THE SAME OPERAND */
        for (int i = getNumReg () - 1; i >= 0; i--) {
            if (getNthReg (i) == reg && getNthRegType (i) == READ) {
                removeNthRegister (i);
                removed_reg++;
            }
        }
//        Assert (removed_reg > 0);
        for (int i = 0; i < removed_reg; i++) {
            _r->Append (new_reg);
            _rt->Append (reg_type);
        }
        _localRegSet.insert (new_reg);
        replaceUseSetElem (reg, new_reg);
    }

    for (it = _insLocDefSet.begin (); it != _insLocDefSet.end (); it++) {
        int removed_reg = 0;
        long int reg_type = READ;
        long int reg = (*it);
        long int new_reg = reg * LARGE_NUMBER;
        Assert (_localRegSet.find (reg) == _localRegSet.end ());
//        Assert (_localRegSet.find (new_reg) == _localRegSet.end ());
        /* REMOVE THE OTHER READ REGISTER CORRESPONDING TO THE SAME OPERAND */
        for (int i = getNumReg () - 1; i >= 0; i--) {
            if (getNthReg (i) == reg && getNthRegType (i) == READ) {
                removeNthRegister (i);
                removed_reg++;
            }
        }
//        Assert (removed_reg > 0);
        for (int i = 0; i < removed_reg; i++) {
            _r->Append (new_reg);
            _rt->Append (reg_type);
        }
        _localRegSet.insert (new_reg);
        _r->Append (new_reg);
        _rt->Append (reg_type);
        movOpSrcRegs.insert (pair<int, long int> (indx, reg));
        movOpDstRegs.insert (pair<int, long int> (indx, new_reg));
        replaceUseSetElem (reg, new_reg);
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{classinstruction_ab54ef1118b6422bd1f953b9244b64f10}{
\index{instruction@{instruction}!updateUPLDbit@{updateUPLDbit}}
\index{updateUPLDbit@{updateUPLDbit}!instruction@{instruction}}
\subsubsection[{updateUPLDbit}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::updateUPLDbit (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab54ef1118b6422bd1f953b9244b64f10}

\begin{DoxyCode}
                                 {
    bool change = false;
    if (_upld_ins || _upld_dep) {
        for (int i = 0; i < _dependents->NumElements (); i++) {
            instruction* dep = _dependents->Nth (i);
            if (dep->getMy_BB_id () != -1 && getMy_BB_id () != -1 &&
                dep->getMy_BB_id () == getMy_BB_id () && 
                !dep->isUPLDdep ()) {
                dep->setUPLDdep ();
                change = true;
            }
        }
    }
    return change;
}
\end{DoxyCode}


Here is the call graph for this function:




The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/\hyperlink{instruction_8h}{instruction.h}\item 
/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/\hyperlink{instruction_8cpp}{instruction.cpp}\end{DoxyCompactItemize}
