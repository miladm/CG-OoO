\hypertarget{classinstruction}{
\section{instruction Class Reference}
\label{classinstruction}\index{instruction@{instruction}}
}


{\ttfamily \#include $<$instruction.h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classinstruction_a2e0bfed549166dbfa1ce77ec084ea310}{instruction} ()
\item 
\hyperlink{classinstruction_a4f9c54b6376cf77565179728fa6f68fa}{$\sim$instruction} ()
\item 
void \hyperlink{classinstruction_a69e75dc34c4197b03e33a0032ae03e8f}{setMemAddr} (\hyperlink{global_2global_8h_a7ea74bb9ffd2e4d41550ae2383dd25bc}{ADDRS} memAddr)
\item 
void \hyperlink{classinstruction_ac39145295a94852d0a3efe8c8247473d}{setInsAddr} (\hyperlink{global_2global_8h_a7ea74bb9ffd2e4d41550ae2383dd25bc}{ADDRS} insAddr)
\item 
void \hyperlink{classinstruction_a4e1387f9782160c95597c81694ec0775}{setMemAccessSize} (long int memAccessSize)
\item 
void \hyperlink{classinstruction_a456de8aa26ff79d2b7cd203f7c59f2cb}{setRegister} (long int $\ast$r, int $\ast$rt)
\item 
long int \hyperlink{classinstruction_a54412da0ee022e05101d4fb92ee879b9}{getNthReg} (int i)
\item 
int \hyperlink{classinstruction_a9701f53aafaf1b2298378665059cef33}{getNthRegType} (int i)
\item 
void \hyperlink{classinstruction_aabb46003e886f87cd3bc918f05a3682f}{removeNthRegister} (int i)
\item 
int \hyperlink{classinstruction_af64e1265e882da7e152bd47cb7794c3b}{getNumReg} ()
\item 
int \hyperlink{classinstruction_abe651f9e294dd53e1f515c6856e7e8a3}{getNumWrReg} ()
\item 
int \hyperlink{classinstruction_a71809c767dba335b3bbdad04cb24d43c}{getNumLRFreg} ()
\item 
void \hyperlink{classinstruction_ad9c7d979b5f4b00189973e47caa3411f}{setType} (\hyperlink{binaryTranslator_2global_8h_a7aead736a07eaf25623ad7bfa1f0ee2d}{type} insType)
\item 
void \hyperlink{classinstruction_ab4b1bbe98c775d3a1fab0ed281a4ad4f}{setStatus} (\hyperlink{global_2global_8h_a015eb90e0de9f16e87bd149d4b9ce959}{status} insStatus, long int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, int latency)
\item 
void \hyperlink{classinstruction_a818803cc54cb0b34c373ad6537976014}{updateLatency} (long int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, int latency)
\item 
void \hyperlink{classinstruction_a6c57d75878f06764457f4faaabe5de00}{setMemType} (\hyperlink{binaryTranslator_2global_8h_a94b8423a23b95a7adac22848b81e7c0c}{memType} readORwrite)
\item 
\hyperlink{binaryTranslator_2global_8h_a7aead736a07eaf25623ad7bfa1f0ee2d}{type} \hyperlink{classinstruction_a47623362d505a662b974624f81288389}{getType} ()
\item 
\hyperlink{global_2global_8h_a015eb90e0de9f16e87bd149d4b9ce959}{status} \hyperlink{classinstruction_ae93f7b1b0385897bb15fc795ee654c37}{getStatus} ()
\item 
int \hyperlink{classinstruction_a842fd50e52a3e3d31fcf8b7a180a32bd}{getLatency} ()
\item 
long int \hyperlink{classinstruction_a509352a63d4ffd931dd5a0a48f4451ba}{getCompleteCycle} ()
\item 
long int \hyperlink{classinstruction_af7c6a53cc4270140e47c885d51e55845}{getMemAddrCompCompleteCycle} ()
\item 
long int \hyperlink{classinstruction_a85915959a0db53205b721c2593941785}{getExecuteCycle} ()
\item 
long int \hyperlink{classinstruction_a6731a49c3bca293edf8fd1eb57fda995}{getMyReg} (int i)
\item 
\hyperlink{global_2global_8h_a7ea74bb9ffd2e4d41550ae2383dd25bc}{ADDRS} \hyperlink{classinstruction_a507811b2f10f679c90ac79ff64929272}{getMemAddr} ()
\item 
\hyperlink{global_2global_8h_a7ea74bb9ffd2e4d41550ae2383dd25bc}{ADDRS} \hyperlink{classinstruction_ac1fabe854c85726785052c7a5ebf6d39}{getInsAddr} ()
\item 
long int \hyperlink{classinstruction_a7811c2dd5418e30c53d2da2460e0d47c}{getMemAccessSize} ()
\item 
int \hyperlink{classinstruction_a0f74a2a6cca80ebc2286daa72e1dfbbd}{getMyRegType} (int i)
\item 
\hyperlink{binaryTranslator_2global_8h_a94b8423a23b95a7adac22848b81e7c0c}{memType} \hyperlink{classinstruction_a8051847b8731d697107d682564a7385f}{getMemType} ()
\item 
char $\ast$ \hyperlink{classinstruction_a95d2dc965b2b6bb037d31af748b98d30}{getCmdStr} ()
\item 
void \hyperlink{classinstruction_adc61c4f03b740668fa8bf4b3e213f8f3}{setCmdStr} (const char $\ast$cmd)
\item 
void \hyperlink{classinstruction_a3ad74e598e69178490590655303466a1}{setInsID} (\hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} id)
\item 
\hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} \hyperlink{classinstruction_a0856c8a7411c298a51cd8d8d5e2f8b12}{getInsID} ()
\item 
int \hyperlink{classinstruction_a6691b4bcb64ecd50e0aea3a0558137d0}{getPipelineLat} ()
\item 
void \hyperlink{classinstruction_a331fb003e92ca7a8b86d95157ecbd122}{setPiepelineLat} (int pipeLineLat)
\item 
void \hyperlink{classinstruction_a94d61291db685cc1c3abb2bb72481b3a}{importCacheHitLevel} (int \hyperlink{cacheCtrl_8cpp_a60025585bccd1055da0bdf1b5877a3fe}{hitLevel})
\item 
void \hyperlink{classinstruction_a060fa401d6b45027f08d827ef2ceb114}{setCacheHitLevel} (int hitLat)
\item 
int \hyperlink{classinstruction_a722d3e54a39d82832a6f9769602ff967}{getCacheHitLevel} ()
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{classinstruction_ad1af63e7f1bfa160b0719027c2a0b8ce}{getDependents} ()
\item 
void \hyperlink{classinstruction_ab2ba6828f1256186a787d933a6ca0868}{setAsDependent} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_a4d6726de4186f3010dd064582d4637d4}{notifyAllDepICompleted} ()
\item 
void \hyperlink{classinstruction_a6308dc145beb4a8ee6ccace0ed9f8cdd}{notifyAllDepICompleted\_\-light} ()
\item 
void \hyperlink{classinstruction_abe8f9b353e303a39ab97f1d4bebba101}{notifyAllAncISquashed} ()
\item 
void \hyperlink{classinstruction_aeb756cec429aca99a341f069df268465}{addDep} ()
\item 
void \hyperlink{classinstruction_a9c036772123e1dcf59239cd5fd065f0f}{releaseDep} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_a2efa8c5533c25ab4cf5fc812b65a0dc7}{releaseDep\_\-light} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_a9643852ed74b72636a5327a6278fe12f}{squashDep} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
bool \hyperlink{classinstruction_a3d3c5926b3f74fa012e77011f6d65a57}{isReady} (long int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{classinstruction_ae98b3fc0943715a103b91ab8bf272758}{goToReadyList} ()
\item 
void \hyperlink{classinstruction_a21509e081fdfd3665c30d1bab3e1fd45}{setReadyLists} (\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$rootALUins, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$rootMEMins)
\item 
void \hyperlink{classinstruction_aa97fc6d29e3d841baede2a83414b3997}{delDepTableEntris} (\hyperlink{classdependencyTable}{dependencyTable} $\ast$\hyperlink{vliwScheduler_8cpp_ab1dae06b10269a1b683512c8ecb25def}{depTables}, int \hyperlink{vliwScheduler_8cpp_a617ce1763c0446f48a6d3a158d507f46}{coreType}, bool \hyperlink{bkEnd_8cpp_a24de26574dd41fb459f4e9c7eef97d2d}{perfectRegRen})
\item 
void \hyperlink{classinstruction_ae2485787a9240cab1aa5d9f87df01a04}{delDepTableEntris\_\-LRF} (\hyperlink{classdependencyTable}{dependencyTable} $\ast$\hyperlink{vliwScheduler_8cpp_ab1dae06b10269a1b683512c8ecb25def}{depTables}, int \hyperlink{vliwScheduler_8cpp_a617ce1763c0446f48a6d3a158d507f46}{coreType}, bool \hyperlink{bkEnd_8cpp_a24de26574dd41fb459f4e9c7eef97d2d}{perfectRegRen})
\item 
void \hyperlink{classinstruction_a578f14a412f7d77a1e87aa52af78eade}{br\_\-dependencyTable} (\hyperlink{classdependencyTable}{dependencyTable} $\ast$\hyperlink{vliwScheduler_8cpp_ab1dae06b10269a1b683512c8ecb25def}{depTables})
\item 
void \hyperlink{classinstruction_a213dc8dc75e0df8b8be759462b3cb8b9}{perfect\_\-MemDependencyTable} (\hyperlink{classdependencyTable}{dependencyTable} $\ast$\hyperlink{vliwScheduler_8cpp_ab1dae06b10269a1b683512c8ecb25def}{depTables}, int \hyperlink{vliwScheduler_8cpp_a617ce1763c0446f48a6d3a158d507f46}{coreType}, int \hyperlink{backend_2parser_8cpp_a33b052a847ffe72153acdfeaa15c48da}{numSideBuffs})
\item 
void \hyperlink{classinstruction_a939213a50cdd3a5e31f6d543d5408b15}{totalOrder\_\-MemDependencyTable} (\hyperlink{classlsq}{lsq} $\ast$totalOrderLSQ)
\item 
void \hyperlink{classinstruction_ab817675ba27852b024c813bb5387b058}{storeOrder\_\-MemDependencyTable} (\hyperlink{classinstruction}{instruction} $\ast$ancestor)
\item 
void \hyperlink{classinstruction_a096c7696da9989235116d28996b34143}{noRRdependencyTable} (\hyperlink{classdependencyTable}{dependencyTable} $\ast$\hyperlink{vliwScheduler_8cpp_ab1dae06b10269a1b683512c8ecb25def}{depTables}, int \hyperlink{vliwScheduler_8cpp_a617ce1763c0446f48a6d3a158d507f46}{coreType})
\item 
void \hyperlink{classinstruction_ab04c4389f9057613f1ca69d89509f531}{infRegdependencyTable} (\hyperlink{classdependencyTable}{dependencyTable} $\ast$\hyperlink{vliwScheduler_8cpp_ab1dae06b10269a1b683512c8ecb25def}{depTables}, int \hyperlink{vliwScheduler_8cpp_a617ce1763c0446f48a6d3a158d507f46}{coreType})
\item 
void \hyperlink{classinstruction_a8ef95c2bb6b131c4ce3f33cfc124c748}{updateDepTableEntris} (\hyperlink{classdependencyTable}{dependencyTable} $\ast$\hyperlink{vliwScheduler_8cpp_ab1dae06b10269a1b683512c8ecb25def}{depTables}, int \hyperlink{vliwScheduler_8cpp_a617ce1763c0446f48a6d3a158d507f46}{coreType}, \hyperlink{classinstruction}{instruction} $\ast$replaceIns)
\item 
bool \hyperlink{classinstruction_a6dfbd578c46bb88f5b7ac61b74b7fba4}{renameRegs} (\hyperlink{classregisterRename}{registerRename} $\ast$GRF, int \hyperlink{vliwScheduler_8cpp_a617ce1763c0446f48a6d3a158d507f46}{coreType})
\item 
void \hyperlink{classinstruction_a9b291777fca7e332002d3509c448afe6}{completeRegs} (\hyperlink{classregisterRename}{registerRename} $\ast$GRF)
\item 
void \hyperlink{classinstruction_a9860d38bd4eed33f9047b7829173d183}{squashRenameReg} (\hyperlink{classregisterRename}{registerRename} $\ast$GRF)
\item 
void \hyperlink{classinstruction_a5f510bd70b679028a0a343c91558552d}{commitRegs} (\hyperlink{classregisterRename}{registerRename} $\ast$GRF)
\item 
void \hyperlink{classinstruction_af0d1e76bd95a84ef5629548391264b4e}{goToSideBuff} ()
\item 
void \hyperlink{classinstruction_a081e816b22818a5d9b150678c29d64b3}{getOutSideBuff} ()
\item 
bool \hyperlink{classinstruction_aa6a5b8a0b7f5af780d1593890e87d6a1}{isGotoSideBuff} ()
\item 
void \hyperlink{classinstruction_ae57b38a2a8bfab07e1bc6de8add821ae}{notifyAllDepGoToSideBuff} (int sb, \hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} causeOfSBinsID, int \hyperlink{backend_2parser_8cpp_a33b052a847ffe72153acdfeaa15c48da}{numSideBuffs})
\item 
long int \hyperlink{classinstruction_aed884db7d433b78579a964299889823f}{notifyAllDepGetOutSideBuff} (int sb, \hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} causeOfSBinsID, int \hyperlink{backend_2parser_8cpp_a33b052a847ffe72153acdfeaa15c48da}{numSideBuffs})
\item 
int \hyperlink{classinstruction_ae70e85f10d54bf8f323110dd8ecd7d14}{getSideBuffNum} ()
\item 
\hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} \hyperlink{classinstruction_a985a2aa4c8de04b094e19706661db0a3}{getCauseOfSBinsID} ()
\item 
void \hyperlink{classinstruction_a4806e5843e16d1893f218756ea3a8a94}{delMySB} (int sb, \hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} causeOfSBinsID, int \hyperlink{backend_2parser_8cpp_a33b052a847ffe72153acdfeaa15c48da}{numSideBuffs})
\item 
void \hyperlink{classinstruction_a3498bf7e8b209d7912ef7c0bc977b5b2}{addAsMySB} (int sb, \hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} causeOfSBinsID, int \hyperlink{backend_2parser_8cpp_a33b052a847ffe72153acdfeaa15c48da}{numSideBuffs})
\item 
int \hyperlink{classinstruction_a7415b29e4aaa425287031bc867951d55}{findLongestPath} (long int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, bool UPLDhoisting, long int myPhraseID)
\item 
int \hyperlink{classinstruction_af85171b971c2f1f691f82501d29f3cdf}{findLongestPathDynamicly} (long int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, bool UPLDhoisting)
\item 
int \hyperlink{classinstruction_af4d93f837096be4e0dd2fe8951b1114e}{getLongestPath} ()
\item 
void \hyperlink{classinstruction_aad7cdb8a4cb4aa3f6fa92ceba462a106}{lookUpANDsetPathLen} ()
\item 
int \hyperlink{classinstruction_a48dbb40a5b7bc9bd36b3990fc61f20b2}{getMyPathLen} ()
\item 
int \hyperlink{classinstruction_ac773a71d9b69171d092da07080735421}{getPathLen} ()
\item 
bool \hyperlink{classinstruction_ae047caa60b7297cd7b07fa773003ba71}{isOnCritiPath} (int candidatePhID)
\item 
void \hyperlink{classinstruction_a696b4ec387bfeb56d4266d08e7bb1627}{renameWriteReg} (long int reg)
\item 
void \hyperlink{classinstruction_ae9760e334e7829c4f8504bc8436e2dfb}{renameReadReg} (int indx, long int renReg)
\item 
long int \hyperlink{classinstruction_a35b2a3db2dc9a22bbdcbce797d510c85}{getRenamedReg} (long int reg)
\item 
bool \hyperlink{classinstruction_a8d938a7c74c2bd36d0e5565cf933d9d5}{isRepeated} (\hyperlink{classinstruction}{instruction} $\ast$temp, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ancestors)
\item 
void \hyperlink{classinstruction_a32e2f2aa8991ac0d69ce22e728bdea4d}{printToFile} (FILE $\ast$\hyperlink{bkEnd_8cpp_a0e5f51d6a6b1d82437b223b600c984c2}{reScheduleFile}, bool recordHitMiss)
\item 
\hyperlink{classinstruction}{instruction} $\ast$ \hyperlink{classinstruction_aee9c18eaa3dfe56eacc82ac31b8231d5}{getNthAncestor} (int i)
\item 
int \hyperlink{classinstruction_a2e29e3536ad20c65b6c7b76ba6e37ad8}{getNumAncestors} ()
\item 
void \hyperlink{classinstruction_aee7e55cf32812b46267a22bcb53da670}{setAsAncestor} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
\hyperlink{classinstruction}{instruction} $\ast$ \hyperlink{classinstruction_ade9345ce46d71d566971798ea924a325}{getNthMemRdAncestor} (int i)
\item 
int \hyperlink{classinstruction_aca2f7cc96da470bc99d4c1f0a66646ed}{getNthMemRdAncestorID} (int i)
\item 
int \hyperlink{classinstruction_a2a1e30e887dabbb7b60cc71a1d466105}{getNumMemRdAncestors} ()
\item 
void \hyperlink{classinstruction_a558367dae55d2970723dc81c6b498be2}{genAllPhraseAncestorsList} (\hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} causeOfPhraseinsID, \hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_af5a1d9e1a8a25f768c3dadf66fb83362}{genPhraseAncestorsList} (int causeOfPhraseinsID, \hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_aed4714151da7fbcbe65485e5699cd72c}{findPhraseAncestors} ()
\item 
void \hyperlink{classinstruction_a70d88f6c0d2cc47b2c18acd3118de671}{addAsPhraseAncestor} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
\hyperlink{classphrase}{phrase} $\ast$ \hyperlink{classinstruction_a127fdc66c20261ea6558b0167f19d5ea}{getMyPhrase} ()
\item 
void \hyperlink{classinstruction_aa2c3a45485ab0112df0187f08fd8a143}{setMyPhrase} (\hyperlink{classphrase}{phrase} $\ast$ph)
\item 
void \hyperlink{classinstruction_a9cf32c7fceaedc65fc68fc8711eef824}{setMyPhraseID} (int id)
\item 
int \hyperlink{classinstruction_a5047f83c94ed37bcae844d295ba0e6e4}{getMyPhraseID} ()
\item 
void \hyperlink{classinstruction_a5e29538d1a3dd4e92132212155dab21b}{addDepPhrase} (\hyperlink{classphrase}{phrase} $\ast$ph)
\item 
void \hyperlink{classinstruction_aa8c56a4a880638422bb8d1d1e5d24e8e}{notifyMyDepPhrasesICompleted} ()
\item 
void \hyperlink{classinstruction_a229c73b0e852f8b2ab3617b4bc4cb988}{notifyDepICommited} ()
\item 
void \hyperlink{classinstruction_a6fd66b22a3d589e5f366ec6addc62a3e}{releaseDepFromUPLD} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_a9006b031450e7290dc089f9edbc213c3}{setCauseOfFragInsID} (\hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} causeOfFragInsID)
\item 
\hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} \hyperlink{classinstruction_a547b08ed7230d48cdc4f2eb5561acac8}{getCauseOfFragInsID} ()
\item 
void \hyperlink{classinstruction_a9d82ae4388d743b3fecea8c3cded36f4}{addDepFrag} (\hyperlink{classfragment}{fragment} $\ast$fr)
\item 
void \hyperlink{classinstruction_a9ece958dee811e62fc0bf63d35bd88d8}{notifyMyDepFragsICompleted} ()
\item 
void \hyperlink{classinstruction_a8fb8324e5524fb201e1377ad3e8e2c3b}{setMyFrag} (\hyperlink{classfragment}{fragment} $\ast$ph)
\item 
int \hyperlink{classinstruction_aab5d4a97c106ad3a04bca6dc2ff8e11c}{getMyFragID} ()
\item 
\hyperlink{classfragment}{fragment} $\ast$ \hyperlink{classinstruction_a2057b72a13418796e55377b1cee14439}{getMyFrag} ()
\item 
void \hyperlink{classinstruction_a0b5a3de8a08da1f9e0c9d8cbff5ba8ce}{setMissRate} (double missRate)
\item 
double \hyperlink{classinstruction_a7f04521e22bec22c519fdc44d7c8b83a}{getMissrate} ()
\item 
bool \hyperlink{classinstruction_aa523eec9522b3dfa68918b24c378fcc2}{getDepOnUPLD} ()
\item 
void \hyperlink{classinstruction_a99ed8de1173de1012b31333788a3e1a9}{setDepOnUPLD} ()
\item 
void \hyperlink{classinstruction_abb70bf9067cbb8427efa16050c1fd34a}{setBrTarget} (long int brTarget)
\item 
void \hyperlink{classinstruction_a0cdb2aa4ff688f48a627a3e03baa6aad}{setBrSide} (long int brTaken)
\item 
void \hyperlink{classinstruction_a4e4a5a2f74a5c8420543cd42a0097d64}{setBrForward} ()
\item 
void \hyperlink{classinstruction_a0ee9ec109536e821189c53b82af33000}{setBrBias} (float brBias)
\item 
void \hyperlink{classinstruction_afa5bc75d50f79d6e6af4bf940086357a}{setBrAccuracy} (float brBias)
\item 
bool \hyperlink{classinstruction_a817d20194ce6f6b0d902f965129b5bc7}{getBrSide} ()
\item 
void \hyperlink{classinstruction_ad37eea00676b66636402b18826c4ca2c}{findMissPrediction} (bool missPred)
\item 
bool \hyperlink{classinstruction_a8968b6df9999fd346e9ad67dbb3c24a6}{getMissPrediction} ()
\item 
void \hyperlink{classinstruction_ad7dcd18feb686b41ab57e15e00cf04a6}{setBrMode} (\hyperlink{global_2global_8h_a01e05efee3068c759b10b6181a6065e1}{brMode} \hyperlink{backend_2parser_8cpp_ac7bd9648b0cf77fbafdeb4490e46e7de}{branchMode})
\item 
\hyperlink{global_2global_8h_a01e05efee3068c759b10b6181a6065e1}{brMode} \hyperlink{classinstruction_a5ec270309f416ce62db5ea8e6478819d}{getBrMode} ()
\item 
float \hyperlink{classinstruction_ac75c130a63a934b5e7e6ea4317a92a73}{getBrBias} ()
\item 
float \hyperlink{classinstruction_a4637c7dbd150ddfb700132aba98a8d16}{getBrAccuracy} ()
\item 
\hyperlink{classinstruction}{instruction} $\ast$ \hyperlink{classinstruction_a3956b91225afe4381adb46e8630df104}{getNthBrAncestor} (int i)
\item 
int \hyperlink{classinstruction_aea5ab3c5f62740194e3bc9d3335676a2}{getNumBrAncestors} ()
\item 
void \hyperlink{classinstruction_a508aeb795698276978932acb2d81cfe2}{setAsBrAncestor} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_af3e4f5b3744955fa671e22f75da8b0a5}{setAsBrDependent} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_a8a4fb5b938939b6988c7d76a1808ef0c}{releaseBrDep} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_ad515289a10c6e269fda95c07dd7112bb}{squashBrDep} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_acf0ac8f3266fa128a76b3b287e2d305d}{delBrDependent} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_a335a34cb7652d3f3c6f63c011dd10185}{delNthBrAncestor} (int i)
\item 
void \hyperlink{classinstruction_a004b3ed6bdd168e05d4deb6d9dcb6080}{notifyAllBrAncestorsICompleted} ()
\item 
void \hyperlink{classinstruction_a3ad24eb0105af8c9f593642c3961236f}{releaseBrAncestors} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_a435d34db2d195bc1a3c451f0132151c1}{removeFromInsMap} ()
\item 
void \hyperlink{classinstruction_afb7103d520a07bdd63d69f5d36d04c38}{insertToInsMap} ()
\item 
void \hyperlink{classinstruction_ab2079e0fa9269a24ae4597eaaad67918}{setVliwScheduler} (\hyperlink{classvliwScheduler}{vliwScheduler} $\ast$\hyperlink{classscheduler}{scheduler})
\item 
void \hyperlink{classinstruction_a71e3f3ce675bfada57fa6ece90336880}{setPredHistObj} (void $\ast$bp\_\-hist)
\item 
void $\ast$ \hyperlink{classinstruction_ab78ac4674a2ff497fe482cbbac926ca9}{getPredHistObj} ()
\item 
void \hyperlink{classinstruction_afc0e97320e3110a0c3870f4537b913fe}{setPrediction} (bool brPred)
\item 
bool \hyperlink{classinstruction_a02c4c1da37bc53bbe65fb85ccfd3ee52}{getPrediction} ()
\item 
bool \hyperlink{classinstruction_ab72dc8a4eae39e0ae3f7317fa88d66d7}{isBBtail} ()
\item 
bool \hyperlink{classinstruction_a62b80293d12bff3fca6bb0e052ab710c}{isBBhead} ()
\item 
void \hyperlink{classinstruction_a19971c1a97eb166b20b04085842f5fef}{setBrHeaderAddr} (\hyperlink{global_2global_8h_a1d35a3946fb219a5e6a04417d1930e40}{INS\_\-ADDR} brAddr)
\item 
void \hyperlink{classinstruction_ae47d1153ed4be0ce3ba8e3c5b007e331}{setBBtail} ()
\item 
void \hyperlink{classinstruction_a85be485a728d6539088c71dab3cdec0d}{setBBhead} ()
\item 
\hyperlink{global_2global_8h_a1d35a3946fb219a5e6a04417d1930e40}{INS\_\-ADDR} \hyperlink{classinstruction_a87aa9628956122d77e3b1f6144f7e6e9}{getBrHeaderAddr} ()
\item 
\hyperlink{classinstruction_a2e0bfed549166dbfa1ce77ec084ea310}{instruction} ()
\item 
\hyperlink{classinstruction_a4f9c54b6376cf77565179728fa6f68fa}{$\sim$instruction} ()
\item 
void \hyperlink{classinstruction_a7a4adbec8d2e9a2cb6090168530e336c}{setOpCode} (const char $\ast$)
\item 
void \hyperlink{classinstruction_affb2525016712f3bac93120d4d81961d}{setInsAddr} (\hyperlink{binaryTranslator_2global_8h_aa4557b0650cb21e57e3e4623410832c6}{ADDR})
\item 
void \hyperlink{classinstruction_aeeee9fa55e89a75f59d160c0aad34a52}{setBrDst} (\hyperlink{binaryTranslator_2global_8h_aa4557b0650cb21e57e3e4623410832c6}{ADDR})
\item 
void \hyperlink{classinstruction_ae28df36b635c5359fa48a6476eebc425}{setInsAsm} (const char $\ast$)
\item 
void \hyperlink{classinstruction_aa6ff7d5323483cf18c10687ed8c1dc73}{setType} (const char)
\item 
void \hyperlink{classinstruction_aabc818127836c8403b9c691985ca6d14}{setBrTakenBias} (double brBias)
\item 
void \hyperlink{classinstruction_a613fd5dcaabf9a68596545679b17ffd8}{setBPaccuracy} (double bpAccuracy)
\item 
void \hyperlink{classinstruction_a5052a04bf5db0d0e1519eb54f343bdc6}{setLdMissRate} (double missRate)
\item 
void \hyperlink{classinstruction_a456de8aa26ff79d2b7cd203f7c59f2cb}{setRegister} (long int $\ast$r, int $\ast$rt)
\item 
void \hyperlink{classinstruction_a093ff19f17baaf84d4539ea395468265}{setReadVar} (int var, int subscript)
\item 
void \hyperlink{classinstruction_a67c584522eaa68d46a495170ce8a3bbd}{setWriteVar} (int var, int subscript)
\item 
void \hyperlink{classinstruction_a8e201444f39b8a779022284e280fdf23}{setArchReg} (long int r)
\item 
void \hyperlink{classinstruction_a1a85e010b731e20bcd25310a26eabd98}{setWrMemType} ()
\item 
void \hyperlink{classinstruction_a0d47af8822438b6e838c08dbd31cc02c}{setRdMemType} ()
\item 
void \hyperlink{classinstruction_ab36280a1a2cd3339e45c8271deaa23d0}{setMemAccessSize} (int memSize)
\item 
const char $\ast$ \hyperlink{classinstruction_a47d6ca18417d4f185495eb9be2844f07}{getOpCode} ()
\item 
\hyperlink{binaryTranslator_2global_8h_aa4557b0650cb21e57e3e4623410832c6}{ADDR} \hyperlink{classinstruction_ac1fabe854c85726785052c7a5ebf6d39}{getInsAddr} ()
\item 
\hyperlink{binaryTranslator_2global_8h_aa4557b0650cb21e57e3e4623410832c6}{ADDR} \hyperlink{classinstruction_ad9d2ab40d6cf65d68172316c37438497}{getBrDst} ()
\item 
const char $\ast$ \hyperlink{classinstruction_a9404c158382339e863846837c9b252aa}{getInsAsm} ()
\item 
const char \hyperlink{classinstruction_a47623362d505a662b974624f81288389}{getType} ()
\item 
double \hyperlink{classinstruction_ac2be260e8fce5e0615bd68bed97cb591}{getBrTakenBias} ()
\item 
double \hyperlink{classinstruction_a023333937041baf6bc2985c94f88c9e5}{getBPaccuracy} ()
\item 
double \hyperlink{classinstruction_a14d57791b666452fdb91973e35c39c2e}{getLdMissRate} ()
\item 
int \hyperlink{classinstruction_a842fd50e52a3e3d31fcf8b7a180a32bd}{getLatency} ()
\item 
int \hyperlink{classinstruction_a9701f53aafaf1b2298378665059cef33}{getNthRegType} (int i)
\item 
long int \hyperlink{classinstruction_a54412da0ee022e05101d4fb92ee879b9}{getNthReg} (int i)
\item 
long int \hyperlink{classinstruction_a7d49a66c0f3b426f1cf8fd335a5f3b6a}{getNthArchReg} (int indx)
\item 
long int \hyperlink{classinstruction_ad7dce7bff9bfecd11b0e7119738d0994}{getNthOldWriteReg} (int i)
\item 
long int \hyperlink{classinstruction_a0a5ddbb986096245d7742472c49d14b2}{getNthReadReg} (int i)
\item 
long int \hyperlink{classinstruction_a29e8de9d3cd22cee464512f9bbc1972c}{getNthWriteReg} (int i)
\item 
void \hyperlink{classinstruction_aabb46003e886f87cd3bc918f05a3682f}{removeNthRegister} (int i)
\item 
int \hyperlink{classinstruction_af64e1265e882da7e152bd47cb7794c3b}{getNumReg} ()
\item 
int \hyperlink{classinstruction_ae0a1ee97e6ba7920c41dd35f97b1715a}{getNumReadReg} ()
\item 
int \hyperlink{classinstruction_a293a8975be22485ec002ef7cc0466d0a}{getNumWriteReg} ()
\item 
long int \hyperlink{classinstruction_a7824d148fcdeb6a1b7cafd68a7ce99ef}{getReadRegSubscript} (long int var)
\item 
long int \hyperlink{classinstruction_a1253eafd0173b6daef17fed2311c6bcf}{getWriteRegSubscript} (long int var)
\item 
void \hyperlink{classinstruction_ae406e3e00f408b7b54510867c88b1b5d}{makeUniqueRegs} ()
\item 
string \hyperlink{classinstruction_acd4f756120e0bd6cdb127715c295a5e7}{getRegisterStr} ()
\item 
string \hyperlink{classinstruction_a4cbd72801622336cca5bf1061f3cda6a}{getArchRegisterStr} ()
\item 
int \hyperlink{classinstruction_a7811c2dd5418e30c53d2da2460e0d47c}{getMemAccessSize} ()
\item 
bool \hyperlink{classinstruction_abf5f8947b16c91c4e21b82bec378008f}{isRdMemType} ()
\item 
bool \hyperlink{classinstruction_a0eab1a0a392f17d7ec46e6dbf1ce21fb}{isWrMemType} ()
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{classinstruction_a93d58b1d8d2969d30dec5184ea22f988}{getDependents} ()
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{classinstruction_af6165d6c8ba00c6806eda36e36cb3366}{getAncestors} ()
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{classinstruction_a90450afccd1b4b07bd28b2ee8aabdf6d}{getRegAncestors} ()
\item 
void \hyperlink{classinstruction_ab2ba6828f1256186a787d933a6ca0868}{setAsDependent} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_aee7e55cf32812b46267a22bcb53da670}{setAsAncestor} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_ab89bab28eb321e32fddfb44354c8245f}{setAsRegAncestor} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classinstruction_ab21a5713ecebfd1b6b6c8aeed06e4679}{dependencyTableCheck} (\hyperlink{classdependencyTable}{dependencyTable} $\ast$\hyperlink{vliwScheduler_8cpp_ab1dae06b10269a1b683512c8ecb25def}{depTables})
\item 
bool \hyperlink{classinstruction_ab367eab50dc74c47b70de127fc633c9b}{isInsRepeated} (\hyperlink{classinstruction}{instruction} $\ast$ins, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ancestors)
\item 
void \hyperlink{classinstruction_a379cbb0fb6bbe15168c6eac05a37114f}{setRdAddrSet} (set$<$ \hyperlink{binaryTranslator_2global_8h_aa4557b0650cb21e57e3e4623410832c6}{ADDR} $>$ \&addrSet)
\item 
void \hyperlink{classinstruction_a8928d9fe638fd7307606fac71a31b681}{setWrAddrSet} (set$<$ \hyperlink{binaryTranslator_2global_8h_aa4557b0650cb21e57e3e4623410832c6}{ADDR} $>$ \&addrSet)
\item 
int \hyperlink{classinstruction_a2e29e3536ad20c65b6c7b76ba6e37ad8}{getNumAncestors} ()
\item 
int \hyperlink{classinstruction_adb8073eb7167fc23a3c846db8129b068}{getNumDependents} ()
\item 
void \hyperlink{classinstruction_aabd61e186e80af7dd343e0f142741ed6}{renameWriteReg} (int indx, long int reg)
\item 
void \hyperlink{classinstruction_ae9760e334e7829c4f8504bc8436e2dfb}{renameReadReg} (int indx, long int renReg)
\item 
long int \hyperlink{classinstruction_a35b2a3db2dc9a22bbdcbce797d510c85}{getRenamedReg} (long int reg)
\item 
bool \hyperlink{classinstruction_a8d938a7c74c2bd36d0e5565cf933d9d5}{isRepeated} (\hyperlink{classinstruction}{instruction} $\ast$temp, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ancestors)
\item 
bool \hyperlink{classinstruction_adc11181683114bd444eff11f1a810c89}{isLongestPathSet} ()
\item 
int \hyperlink{classinstruction_af4d93f837096be4e0dd2fe8951b1114e}{getLongestPath} ()
\item 
void \hyperlink{classinstruction_af6d861b0ad792c3136431c3ef99509ba}{resetLongestPath} ()
\item 
void \hyperlink{classinstruction_a46127cea18a5a4ec73566038a2454ecf}{setLongestPath} (int longestPath)
\item 
void \hyperlink{classinstruction_af78c579e9c3b74dfc72c5bbfb573deab}{setMy\_\-BBorPB\_\-id} (\hyperlink{binaryTranslator_2global_8h_aa4557b0650cb21e57e3e4623410832c6}{ADDR} id)
\item 
\hyperlink{binaryTranslator_2global_8h_aa4557b0650cb21e57e3e4623410832c6}{ADDR} \hyperlink{classinstruction_aee7e5e20a8bbb42a9efe26289a40eb89}{getMy\_\-BB\_\-id} ()
\item 
set$<$ \hyperlink{binaryTranslator_2global_8h_aa4557b0650cb21e57e3e4623410832c6}{ADDR} $>$ \hyperlink{classinstruction_a0e94c2270b46d453299f66a72b7c80de}{getMy\_\-PB\_\-id} ()
\item 
\hyperlink{binaryTranslator_2global_8h_aa4557b0650cb21e57e3e4623410832c6}{ADDR} \hyperlink{classinstruction_a36e1dd2192e97d1c771be8d0f0779d8c}{getMy\_\-first\_\-PB\_\-id} ()
\item 
void \hyperlink{classinstruction_a729d403d579a7f910a6ebfd6500ad5e9}{allocatedRegister} (long int r\_\-allocated, \hyperlink{binaryTranslator_2global_8h_a8981b18ef48c0d2dbf747e5e63e46038}{regKind} rk)
\item 
bool \hyperlink{classinstruction_ab5e9dd71fbc48781b528341a9a371a95}{isAlreadyAssignedArcRegs} ()
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classinstruction_a060702a038491fdd3e98661fec166fa4}{\_\-guardian}
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{classinstruction_a50304cae9052c65b138274a96edfbca0}{\_\-dependents}
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{classinstruction_ac1dd06cf09542ab004237f1dddd1da02}{\_\-ancestors}
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{classinstruction_a728468d228311067d26e390b263dc140}{\_\-phraseAncestors}
\item 
\hyperlink{classList}{List}$<$ int $>$ $\ast$ \hyperlink{classinstruction_a2631d0b5947d06f6ff13170e6dc88f78}{\_\-phraseAncestorsID}
\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classinstruction_a2e0bfed549166dbfa1ce77ec084ea310}{
\index{instruction@{instruction}!instruction@{instruction}}
\index{instruction@{instruction}!instruction@{instruction}}
\subsubsection[{instruction}]{\setlength{\rightskip}{0pt plus 5cm}instruction::instruction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a2e0bfed549166dbfa1ce77ec084ea310}

\begin{DoxyCode}
                         {
        _insType   = noType;
        _insStatus = NO_STAGE;
        _readORwrite = none;

        _r  = new List<long int>;
        _pr  = new List<long int>;
        _rt = new List<int>;
        _numWriteReg = 0;
        _memAddr = 0;
        _insAddr = 0;
        _memAccessSize = 0;

        _brTarget = 0;
        _missPred = true; //stay conservative in case of error
        _brTaken = false;
        _brForward = false;
        
        _executeCycle  = -1;
        _latency     = -1;
        _completeCycle = -1;
        _memAddrCompCompleteCycle = -1;
        _pipeLineLat = -1;
        _fetchEndCycle = -1;

        _guardian = 0;
        _dependents      = new List<instruction*>;
        _ancestors       = new List<instruction*>;
        _depPhrases      = new List<phrase*>;
        _depFrags        = new List<fragment*>;
        _phraseAncestors = new List<instruction*>;
        _phraseAncestorsID = new List<int>;
        _brAncestors     = new List<instruction*>;
        _brDependents    = new List<instruction*>;
        _branchMode = noBrMode;
        _brBias = 1.0; //assume taken
        _brAccuracy = 0.5; //assume half way accurate
        _brPred = false;

        _inSideBuff = false;
        _mySBnum  = new List<int>;
        _causeOfSBinsID = new List<INS_ID>;
        _currentMySBnum = -1;
        _currentCauseOfSBinsID = 0;
        _causeOfFragInsID = -1;

        _addFlag = -1;
        _delFlag = -1;
        _findLPflag = -1;
        _phraseAddFlag = -1;

        _critPathLen = -1;
        _pathLen = -1;
        _hitLevel = -2;

        _myPhraseID = -1;
        _myFragID   = -1;

        _missRate = 0.0;
        _hasUPLDancestor = false;

        _bp_hist = NULL;

        _bbTail = false;
        _bbHead = false;
        _brHeaderAddr = 0;
}
\end{DoxyCode}
\hypertarget{classinstruction_a4f9c54b6376cf77565179728fa6f68fa}{
\index{instruction@{instruction}!$\sim$instruction@{$\sim$instruction}}
\index{$\sim$instruction@{$\sim$instruction}!instruction@{instruction}}
\subsubsection[{$\sim$instruction}]{\setlength{\rightskip}{0pt plus 5cm}instruction::$\sim$instruction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a4f9c54b6376cf77565179728fa6f68fa}

\begin{DoxyCode}
                          {
        while(_r->NumElements() > 0) {
            _r->RemoveAt(0);
        }
        while(_rt->NumElements() > 0) {
            _rt->RemoveAt(0);
        }
        while(_depPhrases->NumElements() > 0) {
            _depPhrases->RemoveAt(0);
        }
        while(_depFrags->NumElements() > 0) {
            _depFrags->RemoveAt(0);
        }
        //TODO chekc this out later
        //while(_dependents->NumElements() > 0) {
        //    _dependents->RemoveAt(0);
        //}
        delete _r;
        delete _pr;
        delete _rt;
        delete _dependents;
        delete _ancestors;
        delete _phraseAncestors;
        delete _phraseAncestorsID;
        delete _mySBnum;
        delete _causeOfSBinsID;
        delete _brAncestors;
        delete _brDependents;
        delete _depPhrases;
        delete _depFrags;
}
\end{DoxyCode}
\hypertarget{classinstruction_a2e0bfed549166dbfa1ce77ec084ea310}{
\index{instruction@{instruction}!instruction@{instruction}}
\index{instruction@{instruction}!instruction@{instruction}}
\subsubsection[{instruction}]{\setlength{\rightskip}{0pt plus 5cm}instruction::instruction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a2e0bfed549166dbfa1ce77ec084ea310}
\hypertarget{classinstruction_a4f9c54b6376cf77565179728fa6f68fa}{
\index{instruction@{instruction}!$\sim$instruction@{$\sim$instruction}}
\index{$\sim$instruction@{$\sim$instruction}!instruction@{instruction}}
\subsubsection[{$\sim$instruction}]{\setlength{\rightskip}{0pt plus 5cm}instruction::$\sim$instruction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a4f9c54b6376cf77565179728fa6f68fa}


\subsection{Member Function Documentation}
\hypertarget{classinstruction_a3498bf7e8b209d7912ef7c0bc977b5b2}{
\index{instruction@{instruction}!addAsMySB@{addAsMySB}}
\index{addAsMySB@{addAsMySB}!instruction@{instruction}}
\subsubsection[{addAsMySB}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::addAsMySB (
\begin{DoxyParamCaption}
\item[{int}]{sb, }
\item[{{\bf INS\_\-ID}}]{causeOfSBinsID, }
\item[{int}]{numSideBuffs}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a3498bf7e8b209d7912ef7c0bc977b5b2}

\begin{DoxyCode}
                                                                           {
        Assert (sb >= 0 && sb < numSideBuffs);
        Assert (_mySBnum->NumElements() == _causeOfSBinsID->NumElements());
        if (_currentCauseOfSBinsID < causeOfSBinsID) {
                _currentMySBnum = sb;
                _currentCauseOfSBinsID = causeOfSBinsID;
        }
        _mySBnum->Append(sb);
        _causeOfSBinsID->Append(causeOfSBinsID);
}
\end{DoxyCode}
\hypertarget{classinstruction_a70d88f6c0d2cc47b2c18acd3118de671}{
\index{instruction@{instruction}!addAsPhraseAncestor@{addAsPhraseAncestor}}
\index{addAsPhraseAncestor@{addAsPhraseAncestor}!instruction@{instruction}}
\subsubsection[{addAsPhraseAncestor}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::addAsPhraseAncestor (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a70d88f6c0d2cc47b2c18acd3118de671}

\begin{DoxyCode}
                                                      {
        Assert(ins->getMemType() == READ);
        //Assert(ins->getInsID() < getInsID());
        _phraseAncestors->Append(ins);
        _phraseAncestorsID->Append(ins->getInsID());
}
\end{DoxyCode}
\hypertarget{classinstruction_aeb756cec429aca99a341f069df268465}{
\index{instruction@{instruction}!addDep@{addDep}}
\index{addDep@{addDep}!instruction@{instruction}}
\subsubsection[{addDep}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::addDep (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aeb756cec429aca99a341f069df268465}

\begin{DoxyCode}
                         {
        _guardian++;
        //TODO might need upper bound assert
}
\end{DoxyCode}
\hypertarget{classinstruction_a9d82ae4388d743b3fecea8c3cded36f4}{
\index{instruction@{instruction}!addDepFrag@{addDepFrag}}
\index{addDepFrag@{addDepFrag}!instruction@{instruction}}
\subsubsection[{addDepFrag}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::addDepFrag (
\begin{DoxyParamCaption}
\item[{{\bf fragment} $\ast$}]{fr}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9d82ae4388d743b3fecea8c3cded36f4}

\begin{DoxyCode}
                                         {
        _depFrags->Append(fr);
}
\end{DoxyCode}
\hypertarget{classinstruction_a5e29538d1a3dd4e92132212155dab21b}{
\index{instruction@{instruction}!addDepPhrase@{addDepPhrase}}
\index{addDepPhrase@{addDepPhrase}!instruction@{instruction}}
\subsubsection[{addDepPhrase}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::addDepPhrase (
\begin{DoxyParamCaption}
\item[{{\bf phrase} $\ast$}]{ph}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a5e29538d1a3dd4e92132212155dab21b}

\begin{DoxyCode}
                                         {
        _depPhrases->Append(ph);
}
\end{DoxyCode}
\hypertarget{classinstruction_a729d403d579a7f910a6ebfd6500ad5e9}{
\index{instruction@{instruction}!allocatedRegister@{allocatedRegister}}
\index{allocatedRegister@{allocatedRegister}!instruction@{instruction}}
\subsubsection[{allocatedRegister}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::allocatedRegister (
\begin{DoxyParamCaption}
\item[{long int}]{r\_\-allocated, }
\item[{{\bf regKind}}]{rk}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a729d403d579a7f910a6ebfd6500ad5e9}

\begin{DoxyCode}
                                                                    {
        Assert((rk == LRF || rk == GRF) && "Register Kind is undefined");
        Assert(((r_allocated >= LRF_LO && r_allocated <= LRF_HI) ||
           (r_allocated >= GRF_LO && r_allocated <= GRF_HI)) &&
           "Out of bound register allocation");
        _r_allocated->Append(r_allocated);
        _rk->Append(rk);
}
\end{DoxyCode}
\hypertarget{classinstruction_a578f14a412f7d77a1e87aa52af78eade}{
\index{instruction@{instruction}!br\_\-dependencyTable@{br\_\-dependencyTable}}
\index{br\_\-dependencyTable@{br\_\-dependencyTable}!instruction@{instruction}}
\subsubsection[{br\_\-dependencyTable}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::br\_\-dependencyTable (
\begin{DoxyParamCaption}
\item[{{\bf dependencyTable} $\ast$}]{depTables}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a578f14a412f7d77a1e87aa52af78eade}

\begin{DoxyCode}
                                                                {
        // Branch dependency check for all instruction types
        if (getBrMode() != noBr) {
        //if (getBrMode() == lowBiasBr && (getBrBias() >= 0.05 && getBrBias() <= 
      0.95)) {
                //if (getBrMode() == lowBiasBr && (getBrBias() < 0.05 || getBrBia
      s() > 0.95)) {
                //}
                List<instruction*>* brList = depTables->brLookup();
                for (int i = 0; i < brList->NumElements(); i++) {
                        instruction *tempBr = brList->Nth(i);
                        if ( getBrMode() == allBr          || 
                             getBrMode() == dynPredBr  || 
                             getBrMode() == statPredBr || 
                            (getBrMode() == lowBiasBr) || // && (getBrBias() >= 0
      .05 && getBrBias() <= 0.95)) || 
                            (getBrMode() == scheduleBr && !(getMemType() == READ 
      && getMissrate() > unpredMemOpThreshold))) {
                            //(getBrMode() == scheduleBr && (getMemType() == WRIT
      E || getType() == BR || getType() == ASSIGN))) {// || getType() == ALU))) {
                                tempBr->setAsDependent(this);
                                addDep();
                                setAsAncestor(tempBr);
                        }
                        setAsBrAncestor(tempBr);
                        tempBr->setAsBrDependent(this);
                }
                if (getBrMode() == statPredBr || getBrMode() == dynPredBr) {
                        if (getType() == BR && _missPred == true) {depTables->
      addBr(this);} //Static branch prediction
                } else if (getBrMode() == allBr || getBrMode() == scheduleBr || (
      getBrMode() == lowBiasBr&& (getBrBias() >= 0.05 && getBrBias() <= 0.95))) {
                        if (getType() == BR) {depTables->addBr(this);} //No Stati
      c branch prediction
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a5f510bd70b679028a0a343c91558552d}{
\index{instruction@{instruction}!commitRegs@{commitRegs}}
\index{commitRegs@{commitRegs}!instruction@{instruction}}
\subsubsection[{commitRegs}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::commitRegs (
\begin{DoxyParamCaption}
\item[{{\bf registerRename} $\ast$}]{GRF}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a5f510bd70b679028a0a343c91558552d}

\begin{DoxyCode}
                                                {
        // Process Write Refisters @complete
        for (int i = 0; i < _pr->NumElements(); i++) {
                PR p_reg = _pr->Nth(i);
                AR a_reg = _pTOaRegMap[p_reg];
                Assert(_pTOaRegMap.find(p_reg) != _pTOaRegMap.end());
                PR old_pr = GRF->getARST(p_reg);
                GRF->updatePRFSM(p_reg,ARCH_REG);
                GRF->updatePRFSM(old_pr,AVAILABLE);
                GRF->update_cRAT(a_reg,p_reg);
                GRF->setAsAvailablePR(old_pr);
                GRF->eraseARST(p_reg);
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a9b291777fca7e332002d3509c448afe6}{
\index{instruction@{instruction}!completeRegs@{completeRegs}}
\index{completeRegs@{completeRegs}!instruction@{instruction}}
\subsubsection[{completeRegs}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::completeRegs (
\begin{DoxyParamCaption}
\item[{{\bf registerRename} $\ast$}]{GRF}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9b291777fca7e332002d3509c448afe6}

\begin{DoxyCode}
                                                  {
        // Process Write Refisters @complete
        for (int i = 0; i < _pr->NumElements(); i++) {
                PR p_reg = _pr->Nth(i);
                GRF->updatePRFSM(p_reg,RENAMED_VALID);
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_acf0ac8f3266fa128a76b3b287e2d305d}{
\index{instruction@{instruction}!delBrDependent@{delBrDependent}}
\index{delBrDependent@{delBrDependent}!instruction@{instruction}}
\subsubsection[{delBrDependent}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::delBrDependent (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_acf0ac8f3266fa128a76b3b287e2d305d}

\begin{DoxyCode}
                                                 {
        Assert(ins->getInsID() > _id      && 
               //ins->getMemType() != WRITE &&
               //ins->getType()    != BR    &&
               //ins->getType()    != ASSIGN);
               ins->getMemType() == READ && 
               ins->getMissrate() > unpredMemOpThreshold);

        for (int i = _brDependents->NumElements()-1; i >= 0 ; i--) {
                if (ins->getInsID() == _brDependents->Nth(i)->getInsID() &&
                    ins->getType()  == _brDependents->Nth(i)->getType()) {
                        _brDependents->RemoveAt(i);
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_aa97fc6d29e3d841baede2a83414b3997}{
\index{instruction@{instruction}!delDepTableEntris@{delDepTableEntris}}
\index{delDepTableEntris@{delDepTableEntris}!instruction@{instruction}}
\subsubsection[{delDepTableEntris}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::delDepTableEntris (
\begin{DoxyParamCaption}
\item[{{\bf dependencyTable} $\ast$}]{depTables, }
\item[{int}]{coreType, }
\item[{bool}]{perfectRegRen}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aa97fc6d29e3d841baede2a83414b3997}

\begin{DoxyCode}
                                                                                 
                     {
        for (int i = 0; i < _r->NumElements(); i++) {
                if (perfectRegRen == false && coreType == PHRASEBLOCK && (_r->
      Nth(i) >= LARF_LO && _r->Nth(i) <= LARF_HI)) continue;
                if (coreType == IN_ORDER    && !(_r->Nth(i) >= LARF_LO && _r->
      Nth(i) <= GARF_HI)) Assert(true == false && "Invalid register value.");
                if (_rt->Nth(i) == WRITE && (coreType == PHRASEBLOCK || coreType 
      == IN_ORDER || perfectRegRen == true)) {
                        depTables->delReg(_r->Nth(i), this, REG_WRITE);
                } else if ( _rt->Nth(i) == READ && coreType == IN_ORDER) {
                        depTables->delReg(_r->Nth(i), this, REG_READ);
                }
        }
        if (_readORwrite == READ) {
                depTables->delAddr(_memAddr, this, MEM_READ);
        } else if (_readORwrite == WRITE) {
                depTables->delAddr(_memAddr, this, MEM_WRITE);
        }

        if ((getBrMode() == statPredBr || getBrMode() == dynPredBr) && (getType()
       == BR && _missPred == true)) {
                //Static branch prediction
                depTables->delBr(this);
        } else if ((getBrMode() == allBr || getBrMode() == scheduleBr || (
      getBrMode() == lowBiasBr&& (getBrBias() >= 0.05 && getBrBias() <= 0.95))) && 
      getType() == BR) {
                //No Static branch prediction
                depTables->delBr(this);
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_ae2485787a9240cab1aa5d9f87df01a04}{
\index{instruction@{instruction}!delDepTableEntris\_\-LRF@{delDepTableEntris\_\-LRF}}
\index{delDepTableEntris\_\-LRF@{delDepTableEntris\_\-LRF}!instruction@{instruction}}
\subsubsection[{delDepTableEntris\_\-LRF}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::delDepTableEntris\_\-LRF (
\begin{DoxyParamCaption}
\item[{{\bf dependencyTable} $\ast$}]{depTables, }
\item[{int}]{coreType, }
\item[{bool}]{perfectRegRen}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae2485787a9240cab1aa5d9f87df01a04}

\begin{DoxyCode}
                                                                                 
                         {
        Assert(coreType == PHRASEBLOCK);
        if (perfectRegRen == true) return; //don't use this func in perfectRR mod
      e
        for (int i = 0; i < _r->NumElements(); i++) {
                if (!(_r->Nth(i) >= LARF_LO && _r->Nth(i) <= LARF_HI)) continue;
                if (_rt->Nth(i) == WRITE) {
                        depTables->delReg(_r->Nth(i), this, REG_WRITE);
                } else if (_rt->Nth(i) == READ) {
                        depTables->delReg(_r->Nth(i), this, REG_READ);
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a4806e5843e16d1893f218756ea3a8a94}{
\index{instruction@{instruction}!delMySB@{delMySB}}
\index{delMySB@{delMySB}!instruction@{instruction}}
\subsubsection[{delMySB}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::delMySB (
\begin{DoxyParamCaption}
\item[{int}]{sb, }
\item[{{\bf INS\_\-ID}}]{causeOfSBinsID, }
\item[{int}]{numSideBuffs}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a4806e5843e16d1893f218756ea3a8a94}

\begin{DoxyCode}
                                                                         {
        Assert (sb >= 0 && sb < numSideBuffs);
        Assert (_mySBnum->NumElements() == _causeOfSBinsID->NumElements());
        bool findNewVal = false;
        if (_currentMySBnum == sb && _currentCauseOfSBinsID == causeOfSBinsID) {
                findNewVal = true;
                _currentMySBnum = -1;
                _currentCauseOfSBinsID = 0;
                //find a new current value
        }
        for (int i = _causeOfSBinsID->NumElements()-1; i>= 0; i--) {
                if (_causeOfSBinsID->Nth(i) == causeOfSBinsID && _mySBnum->Nth(i)
       == sb) {
                        //Remove the SB that just completed
                        _mySBnum->RemoveAt(i);
                        _causeOfSBinsID->RemoveAt(i);
                } else if (findNewVal==true && _currentCauseOfSBinsID < _causeOfS
      BinsID->Nth(i)) {
                        //Find the youngest long lat instruction & its SB
                        _currentMySBnum = _mySBnum->Nth(i);
                        _currentCauseOfSBinsID = _causeOfSBinsID->Nth(i);
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a335a34cb7652d3f3c6f63c011dd10185}{
\index{instruction@{instruction}!delNthBrAncestor@{delNthBrAncestor}}
\index{delNthBrAncestor@{delNthBrAncestor}!instruction@{instruction}}
\subsubsection[{delNthBrAncestor}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::delNthBrAncestor (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a335a34cb7652d3f3c6f63c011dd10185}

\begin{DoxyCode}
                                        {
        _brAncestors->RemoveAt(i);
}
\end{DoxyCode}
\hypertarget{classinstruction_ab21a5713ecebfd1b6b6c8aeed06e4679}{
\index{instruction@{instruction}!dependencyTableCheck@{dependencyTableCheck}}
\index{dependencyTableCheck@{dependencyTableCheck}!instruction@{instruction}}
\subsubsection[{dependencyTableCheck}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::dependencyTableCheck (
\begin{DoxyParamCaption}
\item[{{\bf dependencyTable} $\ast$}]{depTables}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab21a5713ecebfd1b6b6c8aeed06e4679}

\begin{DoxyCode}
                                                                  {
        //Register true dependency check for all instruction types
        for (int i = 0; i < _r->NumElements(); i++) {
                if (_rt->Nth(i) == READ) { //TODO Does this line make sense? (int
       vs. memType)
                        instruction *temp = depTables->regLookup(_r->Nth(i),
      REG_WRITE);//RAW
                        if (temp != NULL) {
                                if (isInsRepeated(temp,_ancestors)==false) {
                                        temp->setAsDependent(this);
                                        setAsAncestor(temp);
                                        setAsRegAncestor(temp);
                                }
                                long int renReg = temp->getRenamedReg(_r->Nth(i))
      ;
                                renameReadReg(i,renReg);
                        }
                // } else if (_rt->Nth(i) == WRITE) {
                //      instruction *temp = depTables->regLookup(_r->Nth(i),REG_R
      EAD);//WAR
                //      if (temp != NULL && isInsRepeated(temp,_ancestors)==false
      ) {
                //              temp->setAsDependent(this);
                //              setAsAncestor(temp);
                //      }
                //      temp = depTables->regLookup(_r->Nth(i),REG_WRITE);//WAW
                //      if (temp != NULL && isInsRepeated(temp,_ancestors)==false
      ) {
                //              temp->setAsDependent(this);
                //              setAsAncestor(temp);
                //      }
                }
        }
        //Memory dependency (no memory disambiguation)
        List<instruction*>* stList = depTables->wrLookup();
        if (getType() == 'M' && stList->NumElements() > 0) {
                instruction *storeOp = stList->Nth(stList->NumElements()-1);
                storeOp->setAsDependent(this);
                setAsAncestor(storeOp);
        }
        if (getType() == 'M' && isWrMemType() == true) {
                depTables->addWr(this);
        }
        //Update write register table (must be done last to avoid deadlock/wrong 
      dependency)
        for (int i = 0; i < _r->NumElements(); i++) {
                if (_rt->Nth(i) == WRITE) {
                        depTables->addReg(i, _r->Nth(i), this, REG_WRITE); //over
      writes existing table entry for reg
                // } else if (coreType == NO_CORE && _rt->Nth(i) == READ) { //TOD
      O register renaming breaks this block of code
                } else if (_rt->Nth(i) == READ) { //TODO register renaming breaks
       this block of code
                        depTables->addReg(i, _r->Nth(i), this, REG_READ); //overw
      rites existing table entry for reg
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a7415b29e4aaa425287031bc867951d55}{
\index{instruction@{instruction}!findLongestPath@{findLongestPath}}
\index{findLongestPath@{findLongestPath}!instruction@{instruction}}
\subsubsection[{findLongestPath}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::findLongestPath (
\begin{DoxyParamCaption}
\item[{long int}]{cycle, }
\item[{bool}]{UPLDhoisting, }
\item[{long int}]{myPhraseID}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a7415b29e4aaa425287031bc867951d55}

\begin{DoxyCode}
                                                                                 
            {
        //only access the children one, per cycle to aviud runtime performance lo
      ss
        if (_myPhraseID == myPhraseID) {
                if (_findLPflag != (INS_ID) cycle) {
                        //printf ("%d - %s", getInsID(), getCmdStr());
                        _critPathLen = -1;
                        for (int i = 0; i < _dependents->NumElements(); i++) {
                                int pathLength = _dependents->Nth(i)->
      findLongestPath(cycle, UPLDhoisting, myPhraseID);
                                if (_critPathLen < pathLength) {
                                        _critPathLen = pathLength;
                                }
                        }
                        if (_critPathLen == -1) {
                                if (UPLDhoisting == true
                                    && getMissrate() > unpredMemOpThreshold
                                    && _readORwrite == READ) {
                                        _critPathLen = cacheLat[1];
                                } else {
                                        _critPathLen = getPipelineLat();
                                }
                        } else { 
                                if (UPLDhoisting == true
                                    && getMissrate() > unpredMemOpThreshold
                                    && _readORwrite == READ) {
                                        _critPathLen += cacheLat[1];
                                } else {
                                        _critPathLen += getPipelineLat();
                                }
                        }
                        _findLPflag = cycle;
                }
                Assert (_findLPflag != 0 && _critPathLen > 0);
                return _critPathLen;
        } else {
                return 0;
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_af85171b971c2f1f691f82501d29f3cdf}{
\index{instruction@{instruction}!findLongestPathDynamicly@{findLongestPathDynamicly}}
\index{findLongestPathDynamicly@{findLongestPathDynamicly}!instruction@{instruction}}
\subsubsection[{findLongestPathDynamicly}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::findLongestPathDynamicly (
\begin{DoxyParamCaption}
\item[{long int}]{cycle, }
\item[{bool}]{UPLDhoisting}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af85171b971c2f1f691f82501d29f3cdf}

\begin{DoxyCode}
                                                                           {
        //only access the children one, per cycle to aviud runtime performance lo
      ss
        if (_findLPflag != (INS_ID)cycle) {
                _critPathLen = -1;
                for (int i = 0; i < _dependents->NumElements(); i++) {
                        int pathLength = _dependents->Nth(i)->
      findLongestPathDynamicly(cycle, UPLDhoisting);
                        if (_critPathLen < pathLength) {
                                _critPathLen = pathLength;
                        }
                }
                if (_critPathLen == -1) {
                        if (UPLDhoisting == true
                            && getMissrate() > unpredMemOpThreshold
                            && _readORwrite == READ) {
                                _critPathLen = cacheLat[1];
                        } else {
                                _critPathLen = getPipelineLat();
                        }
                } else {
                        if (UPLDhoisting == true
                            && getMissrate() > unpredMemOpThreshold
                            && _readORwrite == READ) {
                                _critPathLen += cacheLat[1];
                        } else {
                                _critPathLen += getPipelineLat();
                        }
                }
                //TODO an experiment ------------------
                //if (_critPathLen < _dependents->NumElements()) {
                //      //printf("%d, %d, %d\n",_id, _critPathLen,_dependents->Nu
      mElements());
                //      _critPathLen = _dependents->NumElements();
                //}
                //TODO an experiment ------------------
                _findLPflag = cycle;
        }
        Assert (_findLPflag != 0 && _critPathLen > 0);
        return _critPathLen;
}
\end{DoxyCode}
\hypertarget{classinstruction_ad37eea00676b66636402b18826c4ca2c}{
\index{instruction@{instruction}!findMissPrediction@{findMissPrediction}}
\index{findMissPrediction@{findMissPrediction}!instruction@{instruction}}
\subsubsection[{findMissPrediction}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::findMissPrediction (
\begin{DoxyParamCaption}
\item[{bool}]{missPred}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ad37eea00676b66636402b18826c4ca2c}

\begin{DoxyCode}
                                                  {
        if (getBrMode() == dynPredBr) { //dynamic pred
                _missPred = missPred;
        } else { //static pred
                if ((_brForward == true  && _brTaken == true) ||
                    (_brForward == false && _brTaken == false)) {
                        _missPred = true; //Static predictor failed
                } else {
                        _missPred = false;//Correct prediction
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_aed4714151da7fbcbe65485e5699cd72c}{
\index{instruction@{instruction}!findPhraseAncestors@{findPhraseAncestors}}
\index{findPhraseAncestors@{findPhraseAncestors}!instruction@{instruction}}
\subsubsection[{findPhraseAncestors}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::findPhraseAncestors (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aed4714151da7fbcbe65485e5699cd72c}

\begin{DoxyCode}
                                      {
        genPhraseAncestorsList(_id, this);
        //Check if 'any' of its ancestors has ever been a UPLD
        for (int i = 0; i < _ancestors->NumElements(); i++) {
                if (_ancestors->Nth(i)->getDepOnUPLD() == true) {
                        setDepOnUPLD();
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a558367dae55d2970723dc81c6b498be2}{
\index{instruction@{instruction}!genAllPhraseAncestorsList@{genAllPhraseAncestorsList}}
\index{genAllPhraseAncestorsList@{genAllPhraseAncestorsList}!instruction@{instruction}}
\subsubsection[{genAllPhraseAncestorsList}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::genAllPhraseAncestorsList (
\begin{DoxyParamCaption}
\item[{{\bf INS\_\-ID}}]{causeOfPhraseinsID, }
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a558367dae55d2970723dc81c6b498be2}

\begin{DoxyCode}
                                                                                 
            {
        if (_phraseAddFlag != causeOfPhraseinsID) {
                //printf("hit level = %d\n", _hitLevel);
                if (getMemType() == READ && _hitLevel > 1 && _id != ins->
      getInsID()) {
                        ins->addAsPhraseAncestor(this);
                }
                //if (_ancestors->NumElements()==0) printf("no aestor %d\n", _id)
      ;
                //else printf("yes aestor %d\n",_id);
                for (int i = 0; i < _ancestors->NumElements(); i++) {
                        _ancestors->Nth(i)->genAllPhraseAncestorsList(causeOfPhra
      seinsID, ins);
                }
                _phraseAddFlag = causeOfPhraseinsID;
        }
        Assert(_phraseAddFlag != 0);
}
\end{DoxyCode}
\hypertarget{classinstruction_af5a1d9e1a8a25f768c3dadf66fb83362}{
\index{instruction@{instruction}!genPhraseAncestorsList@{genPhraseAncestorsList}}
\index{genPhraseAncestorsList@{genPhraseAncestorsList}!instruction@{instruction}}
\subsubsection[{genPhraseAncestorsList}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::genPhraseAncestorsList (
\begin{DoxyParamCaption}
\item[{int}]{causeOfPhraseinsID, }
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af5a1d9e1a8a25f768c3dadf66fb83362}

\begin{DoxyCode}
                                                                                 
      {
        //Find the immediate UPLD ops
        for (int i = 0; i < _ancestors->NumElements(); i++) {
                if (_ancestors->Nth(i)->getMemType() == READ && 
                    _ancestors->Nth(i)->getMissrate() > unpredMemOpThreshold) {
                        addAsPhraseAncestor(_ancestors->Nth(i));
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_af6165d6c8ba00c6806eda36e36cb3366}{
\index{instruction@{instruction}!getAncestors@{getAncestors}}
\index{getAncestors@{getAncestors}!instruction@{instruction}}
\subsubsection[{getAncestors}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$ instruction::getAncestors (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af6165d6c8ba00c6806eda36e36cb3366}

\begin{DoxyCode}
                                              {
        return _ancestors;
}
\end{DoxyCode}
\hypertarget{classinstruction_a4cbd72801622336cca5bf1061f3cda6a}{
\index{instruction@{instruction}!getArchRegisterStr@{getArchRegisterStr}}
\index{getArchRegisterStr@{getArchRegisterStr}!instruction@{instruction}}
\subsubsection[{getArchRegisterStr}]{\setlength{\rightskip}{0pt plus 5cm}std::string instruction::getArchRegisterStr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a4cbd72801622336cca5bf1061f3cda6a}

\begin{DoxyCode}
                                          {
        std::stringstream ss;
        std::string s;
        if (getNumReg() == 0) {
                ss << "\n";
        } else {
                for (int i = 0; i < getNumReg(); i++) {
                        ss << getNthArchReg(i) << "#" << getNthRegType(i) << ",";
      
                }
                ss << "\n";
        }
        s = ss.str();
        return s;
}
\end{DoxyCode}
\hypertarget{classinstruction_a023333937041baf6bc2985c94f88c9e5}{
\index{instruction@{instruction}!getBPaccuracy@{getBPaccuracy}}
\index{getBPaccuracy@{getBPaccuracy}!instruction@{instruction}}
\subsubsection[{getBPaccuracy}]{\setlength{\rightskip}{0pt plus 5cm}double instruction::getBPaccuracy (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a023333937041baf6bc2985c94f88c9e5}

\begin{DoxyCode}
                                  {
        Assert((_bpAccuracy >= 0.0 && _bpAccuracy <= 1.0) && "_bpAccuracy value i
      s not recognized.");
        return _bpAccuracy;
}
\end{DoxyCode}
\hypertarget{classinstruction_a4637c7dbd150ddfb700132aba98a8d16}{
\index{instruction@{instruction}!getBrAccuracy@{getBrAccuracy}}
\index{getBrAccuracy@{getBrAccuracy}!instruction@{instruction}}
\subsubsection[{getBrAccuracy}]{\setlength{\rightskip}{0pt plus 5cm}float instruction::getBrAccuracy (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a4637c7dbd150ddfb700132aba98a8d16}

\begin{DoxyCode}
                                  {
        Assert(_brAccuracy >= 0.0 && _brAccuracy <= 1.0);
        return _brAccuracy;
}
\end{DoxyCode}
\hypertarget{classinstruction_ac75c130a63a934b5e7e6ea4317a92a73}{
\index{instruction@{instruction}!getBrBias@{getBrBias}}
\index{getBrBias@{getBrBias}!instruction@{instruction}}
\subsubsection[{getBrBias}]{\setlength{\rightskip}{0pt plus 5cm}float instruction::getBrBias (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ac75c130a63a934b5e7e6ea4317a92a73}

\begin{DoxyCode}
                              {
        Assert(_brBias >= 0.0 && _brBias <= 1.0);
        return _brBias;
}
\end{DoxyCode}
\hypertarget{classinstruction_ad9d2ab40d6cf65d68172316c37438497}{
\index{instruction@{instruction}!getBrDst@{getBrDst}}
\index{getBrDst@{getBrDst}!instruction@{instruction}}
\subsubsection[{getBrDst}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ADDR} instruction::getBrDst (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ad9d2ab40d6cf65d68172316c37438497}

\begin{DoxyCode}
                           {
        //Assert(_brDst >= 0 && "brDst must be larger than zero.");
        return _brDst;
}
\end{DoxyCode}
\hypertarget{classinstruction_a87aa9628956122d77e3b1f6144f7e6e9}{
\index{instruction@{instruction}!getBrHeaderAddr@{getBrHeaderAddr}}
\index{getBrHeaderAddr@{getBrHeaderAddr}!instruction@{instruction}}
\subsubsection[{getBrHeaderAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf INS\_\-ADDR} instruction::getBrHeaderAddr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a87aa9628956122d77e3b1f6144f7e6e9}

\begin{DoxyCode}
                                      {
        //NOTE: this assert does not work because no branch header
        //is constructed when a mid-BB squash is reconstructed
        //(because H is not reconstucted after squash)
        //Assert(_bbHead == true && _brHeaderAddr > 0);
        Assert(_bbHead == true);
        return _brHeaderAddr;
}
\end{DoxyCode}
\hypertarget{classinstruction_a5ec270309f416ce62db5ea8e6478819d}{
\index{instruction@{instruction}!getBrMode@{getBrMode}}
\index{getBrMode@{getBrMode}!instruction@{instruction}}
\subsubsection[{getBrMode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf brMode} instruction::getBrMode (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a5ec270309f416ce62db5ea8e6478819d}

\begin{DoxyCode}
                              {
        Assert(_branchMode != noBrMode);
        return _branchMode;
}
\end{DoxyCode}
\hypertarget{classinstruction_a817d20194ce6f6b0d902f965129b5bc7}{
\index{instruction@{instruction}!getBrSide@{getBrSide}}
\index{getBrSide@{getBrSide}!instruction@{instruction}}
\subsubsection[{getBrSide}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::getBrSide (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a817d20194ce6f6b0d902f965129b5bc7}

\begin{DoxyCode}
                            {
        return _brTaken;
}
\end{DoxyCode}
\hypertarget{classinstruction_ac2be260e8fce5e0615bd68bed97cb591}{
\index{instruction@{instruction}!getBrTakenBias@{getBrTakenBias}}
\index{getBrTakenBias@{getBrTakenBias}!instruction@{instruction}}
\subsubsection[{getBrTakenBias}]{\setlength{\rightskip}{0pt plus 5cm}double instruction::getBrTakenBias (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ac2be260e8fce5e0615bd68bed97cb591}

\begin{DoxyCode}
                                   {
        Assert((_brBias >= 0.0 && _brBias <= 1.0) && "_brBias value is not recogn
      ized.");
        return _brBias;
}
\end{DoxyCode}
\hypertarget{classinstruction_a722d3e54a39d82832a6f9769602ff967}{
\index{instruction@{instruction}!getCacheHitLevel@{getCacheHitLevel}}
\index{getCacheHitLevel@{getCacheHitLevel}!instruction@{instruction}}
\subsubsection[{getCacheHitLevel}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getCacheHitLevel (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a722d3e54a39d82832a6f9769602ff967}

\begin{DoxyCode}
                                  {
        return _hitLevel;
}
\end{DoxyCode}
\hypertarget{classinstruction_a547b08ed7230d48cdc4f2eb5561acac8}{
\index{instruction@{instruction}!getCauseOfFragInsID@{getCauseOfFragInsID}}
\index{getCauseOfFragInsID@{getCauseOfFragInsID}!instruction@{instruction}}
\subsubsection[{getCauseOfFragInsID}]{\setlength{\rightskip}{0pt plus 5cm}{\bf INS\_\-ID} instruction::getCauseOfFragInsID (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a547b08ed7230d48cdc4f2eb5561acac8}

\begin{DoxyCode}
                                        {
        //Assert(_causeOfFragInsID != -1);
        return _causeOfFragInsID;
}
\end{DoxyCode}
\hypertarget{classinstruction_a985a2aa4c8de04b094e19706661db0a3}{
\index{instruction@{instruction}!getCauseOfSBinsID@{getCauseOfSBinsID}}
\index{getCauseOfSBinsID@{getCauseOfSBinsID}!instruction@{instruction}}
\subsubsection[{getCauseOfSBinsID}]{\setlength{\rightskip}{0pt plus 5cm}{\bf INS\_\-ID} instruction::getCauseOfSBinsID (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a985a2aa4c8de04b094e19706661db0a3}

\begin{DoxyCode}
                                      {
        Assert(_currentCauseOfSBinsID != 0);
        return _currentCauseOfSBinsID;
}
\end{DoxyCode}
\hypertarget{classinstruction_a95d2dc965b2b6bb037d31af748b98d30}{
\index{instruction@{instruction}!getCmdStr@{getCmdStr}}
\index{getCmdStr@{getCmdStr}!instruction@{instruction}}
\subsubsection[{getCmdStr}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ instruction::getCmdStr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a95d2dc965b2b6bb037d31af748b98d30}

\begin{DoxyCode}
                             {
        return _command;
}
\end{DoxyCode}
\hypertarget{classinstruction_a509352a63d4ffd931dd5a0a48f4451ba}{
\index{instruction@{instruction}!getCompleteCycle@{getCompleteCycle}}
\index{getCompleteCycle@{getCompleteCycle}!instruction@{instruction}}
\subsubsection[{getCompleteCycle}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getCompleteCycle (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a509352a63d4ffd931dd5a0a48f4451ba}

\begin{DoxyCode}
                                       {
        Assert(_completeCycle > -1);
        return _completeCycle;
}
\end{DoxyCode}
\hypertarget{classinstruction_ad1af63e7f1bfa160b0719027c2a0b8ce}{
\index{instruction@{instruction}!getDependents@{getDependents}}
\index{getDependents@{getDependents}!instruction@{instruction}}
\subsubsection[{getDependents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$ instruction::getDependents (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ad1af63e7f1bfa160b0719027c2a0b8ce}

\begin{DoxyCode}
                                               {
        return _dependents;
}
\end{DoxyCode}
\hypertarget{classinstruction_a93d58b1d8d2969d30dec5184ea22f988}{
\index{instruction@{instruction}!getDependents@{getDependents}}
\index{getDependents@{getDependents}!instruction@{instruction}}
\subsubsection[{getDependents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<${\bf instruction}$\ast$$>$$\ast$ instruction::getDependents (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a93d58b1d8d2969d30dec5184ea22f988}
\hypertarget{classinstruction_aa523eec9522b3dfa68918b24c378fcc2}{
\index{instruction@{instruction}!getDepOnUPLD@{getDepOnUPLD}}
\index{getDepOnUPLD@{getDepOnUPLD}!instruction@{instruction}}
\subsubsection[{getDepOnUPLD}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::getDepOnUPLD (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aa523eec9522b3dfa68918b24c378fcc2}

\begin{DoxyCode}
                               {
        return _hasUPLDancestor;
}
\end{DoxyCode}
\hypertarget{classinstruction_a85915959a0db53205b721c2593941785}{
\index{instruction@{instruction}!getExecuteCycle@{getExecuteCycle}}
\index{getExecuteCycle@{getExecuteCycle}!instruction@{instruction}}
\subsubsection[{getExecuteCycle}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getExecuteCycle (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a85915959a0db53205b721c2593941785}

\begin{DoxyCode}
                                      {
        return _executeCycle;
}
\end{DoxyCode}
\hypertarget{classinstruction_ac1fabe854c85726785052c7a5ebf6d39}{
\index{instruction@{instruction}!getInsAddr@{getInsAddr}}
\index{getInsAddr@{getInsAddr}!instruction@{instruction}}
\subsubsection[{getInsAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ADDR} instruction::getInsAddr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ac1fabe854c85726785052c7a5ebf6d39}
\hypertarget{classinstruction_ac1fabe854c85726785052c7a5ebf6d39}{
\index{instruction@{instruction}!getInsAddr@{getInsAddr}}
\index{getInsAddr@{getInsAddr}!instruction@{instruction}}
\subsubsection[{getInsAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ADDR} instruction::getInsAddr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ac1fabe854c85726785052c7a5ebf6d39}

\begin{DoxyCode}
                              {
        return _insAddr;
}
\end{DoxyCode}
\hypertarget{classinstruction_a9404c158382339e863846837c9b252aa}{
\index{instruction@{instruction}!getInsAsm@{getInsAsm}}
\index{getInsAsm@{getInsAsm}!instruction@{instruction}}
\subsubsection[{getInsAsm}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ instruction::getInsAsm (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9404c158382339e863846837c9b252aa}

\begin{DoxyCode}
{return _command;}
\end{DoxyCode}
\hypertarget{classinstruction_a0856c8a7411c298a51cd8d8d5e2f8b12}{
\index{instruction@{instruction}!getInsID@{getInsID}}
\index{getInsID@{getInsID}!instruction@{instruction}}
\subsubsection[{getInsID}]{\setlength{\rightskip}{0pt plus 5cm}{\bf INS\_\-ID} instruction::getInsID (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a0856c8a7411c298a51cd8d8d5e2f8b12}

\begin{DoxyCode}
                             {
        return _id;
}
\end{DoxyCode}
\hypertarget{classinstruction_a842fd50e52a3e3d31fcf8b7a180a32bd}{
\index{instruction@{instruction}!getLatency@{getLatency}}
\index{getLatency@{getLatency}!instruction@{instruction}}
\subsubsection[{getLatency}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getLatency (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a842fd50e52a3e3d31fcf8b7a180a32bd}
\hypertarget{classinstruction_a842fd50e52a3e3d31fcf8b7a180a32bd}{
\index{instruction@{instruction}!getLatency@{getLatency}}
\index{getLatency@{getLatency}!instruction@{instruction}}
\subsubsection[{getLatency}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getLatency (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a842fd50e52a3e3d31fcf8b7a180a32bd}

\begin{DoxyCode}
                            {
        return _latency;
}
\end{DoxyCode}
\hypertarget{classinstruction_a14d57791b666452fdb91973e35c39c2e}{
\index{instruction@{instruction}!getLdMissRate@{getLdMissRate}}
\index{getLdMissRate@{getLdMissRate}!instruction@{instruction}}
\subsubsection[{getLdMissRate}]{\setlength{\rightskip}{0pt plus 5cm}double instruction::getLdMissRate (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a14d57791b666452fdb91973e35c39c2e}

\begin{DoxyCode}
                                  {
        Assert(_missRate >= 0 && _missRate <= 1 && "Invalid miss rate value\n");
        return _missRate;
}
\end{DoxyCode}
\hypertarget{classinstruction_af4d93f837096be4e0dd2fe8951b1114e}{
\index{instruction@{instruction}!getLongestPath@{getLongestPath}}
\index{getLongestPath@{getLongestPath}!instruction@{instruction}}
\subsubsection[{getLongestPath}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getLongestPath (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af4d93f837096be4e0dd2fe8951b1114e}

\begin{DoxyCode}
                                {
        //if (_critPathLen == -1)
        //      printf ("%d - %s", getInsID(), getCmdStr());
        Assert(_critPathLen != -1);
        return _critPathLen;
}
\end{DoxyCode}
\hypertarget{classinstruction_af4d93f837096be4e0dd2fe8951b1114e}{
\index{instruction@{instruction}!getLongestPath@{getLongestPath}}
\index{getLongestPath@{getLongestPath}!instruction@{instruction}}
\subsubsection[{getLongestPath}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getLongestPath (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af4d93f837096be4e0dd2fe8951b1114e}
\hypertarget{classinstruction_a7811c2dd5418e30c53d2da2460e0d47c}{
\index{instruction@{instruction}!getMemAccessSize@{getMemAccessSize}}
\index{getMemAccessSize@{getMemAccessSize}!instruction@{instruction}}
\subsubsection[{getMemAccessSize}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getMemAccessSize (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a7811c2dd5418e30c53d2da2460e0d47c}
\hypertarget{classinstruction_a7811c2dd5418e30c53d2da2460e0d47c}{
\index{instruction@{instruction}!getMemAccessSize@{getMemAccessSize}}
\index{getMemAccessSize@{getMemAccessSize}!instruction@{instruction}}
\subsubsection[{getMemAccessSize}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getMemAccessSize (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a7811c2dd5418e30c53d2da2460e0d47c}

\begin{DoxyCode}
                                       {
        Assert(_memAccessSize > 0 and getType() == MEM);
        return _memAccessSize;
}
\end{DoxyCode}
\hypertarget{classinstruction_a507811b2f10f679c90ac79ff64929272}{
\index{instruction@{instruction}!getMemAddr@{getMemAddr}}
\index{getMemAddr@{getMemAddr}!instruction@{instruction}}
\subsubsection[{getMemAddr}]{\setlength{\rightskip}{0pt plus 5cm}uint64\_\-t instruction::getMemAddr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a507811b2f10f679c90ac79ff64929272}

\begin{DoxyCode}
                              {
        return _memAddr;
}
\end{DoxyCode}
\hypertarget{classinstruction_af7c6a53cc4270140e47c885d51e55845}{
\index{instruction@{instruction}!getMemAddrCompCompleteCycle@{getMemAddrCompCompleteCycle}}
\index{getMemAddrCompCompleteCycle@{getMemAddrCompCompleteCycle}!instruction@{instruction}}
\subsubsection[{getMemAddrCompCompleteCycle}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getMemAddrCompCompleteCycle (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af7c6a53cc4270140e47c885d51e55845}

\begin{DoxyCode}
                                                  {
        Assert(_memAddrCompCompleteCycle > -1);
        return _memAddrCompCompleteCycle;
}
\end{DoxyCode}
\hypertarget{classinstruction_a8051847b8731d697107d682564a7385f}{
\index{instruction@{instruction}!getMemType@{getMemType}}
\index{getMemType@{getMemType}!instruction@{instruction}}
\subsubsection[{getMemType}]{\setlength{\rightskip}{0pt plus 5cm}{\bf memType} instruction::getMemType (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a8051847b8731d697107d682564a7385f}

\begin{DoxyCode}
                                {
        return _readORwrite;
}
\end{DoxyCode}
\hypertarget{classinstruction_a8968b6df9999fd346e9ad67dbb3c24a6}{
\index{instruction@{instruction}!getMissPrediction@{getMissPrediction}}
\index{getMissPrediction@{getMissPrediction}!instruction@{instruction}}
\subsubsection[{getMissPrediction}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::getMissPrediction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a8968b6df9999fd346e9ad67dbb3c24a6}

\begin{DoxyCode}
                                    {
        return _missPred;
}
\end{DoxyCode}
\hypertarget{classinstruction_a7f04521e22bec22c519fdc44d7c8b83a}{
\index{instruction@{instruction}!getMissrate@{getMissrate}}
\index{getMissrate@{getMissrate}!instruction@{instruction}}
\subsubsection[{getMissrate}]{\setlength{\rightskip}{0pt plus 5cm}double instruction::getMissrate (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a7f04521e22bec22c519fdc44d7c8b83a}

\begin{DoxyCode}
                                {
        return _missRate;
}
\end{DoxyCode}
\hypertarget{classinstruction_aee7e5e20a8bbb42a9efe26289a40eb89}{
\index{instruction@{instruction}!getMy\_\-BB\_\-id@{getMy\_\-BB\_\-id}}
\index{getMy\_\-BB\_\-id@{getMy\_\-BB\_\-id}!instruction@{instruction}}
\subsubsection[{getMy\_\-BB\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ADDR} instruction::getMy\_\-BB\_\-id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aee7e5e20a8bbb42a9efe26289a40eb89}

\begin{DoxyCode}
                               {
        Assert(_myBBs.size() == 1 && "Instruction belongs to too many BB's.");
        set<ADDR>::iterator it = _myBBs.begin();
        return *it;
}
\end{DoxyCode}
\hypertarget{classinstruction_a36e1dd2192e97d1c771be8d0f0779d8c}{
\index{instruction@{instruction}!getMy\_\-first\_\-PB\_\-id@{getMy\_\-first\_\-PB\_\-id}}
\index{getMy\_\-first\_\-PB\_\-id@{getMy\_\-first\_\-PB\_\-id}!instruction@{instruction}}
\subsubsection[{getMy\_\-first\_\-PB\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ADDR} instruction::getMy\_\-first\_\-PB\_\-id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a36e1dd2192e97d1c771be8d0f0779d8c}

\begin{DoxyCode}
                                    {
        set<ADDR>::iterator it = _myBBs.begin();
        return *it;
}
\end{DoxyCode}
\hypertarget{classinstruction_a0e94c2270b46d453299f66a72b7c80de}{
\index{instruction@{instruction}!getMy\_\-PB\_\-id@{getMy\_\-PB\_\-id}}
\index{getMy\_\-PB\_\-id@{getMy\_\-PB\_\-id}!instruction@{instruction}}
\subsubsection[{getMy\_\-PB\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}set$<$ {\bf ADDR} $>$ instruction::getMy\_\-PB\_\-id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a0e94c2270b46d453299f66a72b7c80de}

\begin{DoxyCode}
                                    {
        Assert(_myBBs.size() > 0 && "Instruction must belong to a BB.");
        return _myBBs;
}
\end{DoxyCode}
\hypertarget{classinstruction_a2057b72a13418796e55377b1cee14439}{
\index{instruction@{instruction}!getMyFrag@{getMyFrag}}
\index{getMyFrag@{getMyFrag}!instruction@{instruction}}
\subsubsection[{getMyFrag}]{\setlength{\rightskip}{0pt plus 5cm}{\bf fragment} $\ast$ instruction::getMyFrag (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a2057b72a13418796e55377b1cee14439}

\begin{DoxyCode}
                                 {
        return _myFrag;
}
\end{DoxyCode}
\hypertarget{classinstruction_aab5d4a97c106ad3a04bca6dc2ff8e11c}{
\index{instruction@{instruction}!getMyFragID@{getMyFragID}}
\index{getMyFragID@{getMyFragID}!instruction@{instruction}}
\subsubsection[{getMyFragID}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getMyFragID (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aab5d4a97c106ad3a04bca6dc2ff8e11c}

\begin{DoxyCode}
                             {
        return _myFragID;
}
\end{DoxyCode}
\hypertarget{classinstruction_a48dbb40a5b7bc9bd36b3990fc61f20b2}{
\index{instruction@{instruction}!getMyPathLen@{getMyPathLen}}
\index{getMyPathLen@{getMyPathLen}!instruction@{instruction}}
\subsubsection[{getMyPathLen}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getMyPathLen (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a48dbb40a5b7bc9bd36b3990fc61f20b2}

\begin{DoxyCode}
                              {
        if (_insType == ALU) {
                return ALU_LATENCY;
        } else if (_insType == MEM) {
                return cacheLat[0];
        } else if (_insType == FPU) {
                return FPU_LATENCY;
        } else if (_insType == BR) {
                return ALU_LATENCY; //TODO is this a correct latency?
        } else if (_insType == ASSIGN) {
                return ASSIGN_LATENCY; //TODO is this a correct latency?
        } else {
                printf("ERROR: invalid instruction type.\n");
                exit(1);
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a127fdc66c20261ea6558b0167f19d5ea}{
\index{instruction@{instruction}!getMyPhrase@{getMyPhrase}}
\index{getMyPhrase@{getMyPhrase}!instruction@{instruction}}
\subsubsection[{getMyPhrase}]{\setlength{\rightskip}{0pt plus 5cm}{\bf phrase} $\ast$ instruction::getMyPhrase (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a127fdc66c20261ea6558b0167f19d5ea}

\begin{DoxyCode}
                                 {
        return _myPhrase;
}
\end{DoxyCode}
\hypertarget{classinstruction_a5047f83c94ed37bcae844d295ba0e6e4}{
\index{instruction@{instruction}!getMyPhraseID@{getMyPhraseID}}
\index{getMyPhraseID@{getMyPhraseID}!instruction@{instruction}}
\subsubsection[{getMyPhraseID}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getMyPhraseID (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a5047f83c94ed37bcae844d295ba0e6e4}

\begin{DoxyCode}
                               {
        if (!(_myPhraseID >= 0))printf("%d, %s", getStatus(), getCmdStr());
        Assert(_myPhraseID >= 0);
        return _myPhraseID;
}
\end{DoxyCode}
\hypertarget{classinstruction_a6731a49c3bca293edf8fd1eb57fda995}{
\index{instruction@{instruction}!getMyReg@{getMyReg}}
\index{getMyReg@{getMyReg}!instruction@{instruction}}
\subsubsection[{getMyReg}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getMyReg (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a6731a49c3bca293edf8fd1eb57fda995}

\begin{DoxyCode}
                                     { //TODO this func may return wrong data (re
      gister renaming)
        Assert (i >= 0 && i < _r->NumElements());
        //Assert (_r->Nth(i) >= 1 && _r->Nth(i) <= RF->getNumberOfRegs());
        Assert (_r->Nth(i) >= 1);
        return _r->Nth(i);
}
\end{DoxyCode}
\hypertarget{classinstruction_a0f74a2a6cca80ebc2286daa72e1dfbbd}{
\index{instruction@{instruction}!getMyRegType@{getMyRegType}}
\index{getMyRegType@{getMyRegType}!instruction@{instruction}}
\subsubsection[{getMyRegType}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getMyRegType (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a0f74a2a6cca80ebc2286daa72e1dfbbd}

\begin{DoxyCode}
                                   {
        Assert (i >= 0 && i < _rt->NumElements());
        Assert (_rt->Nth(i) >= READ && _rt->Nth(i) <= WRITE);
        return _rt->Nth(i);
}
\end{DoxyCode}
\hypertarget{classinstruction_aee9c18eaa3dfe56eacc82ac31b8231d5}{
\index{instruction@{instruction}!getNthAncestor@{getNthAncestor}}
\index{getNthAncestor@{getNthAncestor}!instruction@{instruction}}
\subsubsection[{getNthAncestor}]{\setlength{\rightskip}{0pt plus 5cm}{\bf instruction} $\ast$ instruction::getNthAncestor (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aee9c18eaa3dfe56eacc82ac31b8231d5}

\begin{DoxyCode}
                                              {
        return _ancestors->Nth(i);
}
\end{DoxyCode}
\hypertarget{classinstruction_a7d49a66c0f3b426f1cf8fd335a5f3b6a}{
\index{instruction@{instruction}!getNthArchReg@{getNthArchReg}}
\index{getNthArchReg@{getNthArchReg}!instruction@{instruction}}
\subsubsection[{getNthArchReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getNthArchReg (
\begin{DoxyParamCaption}
\item[{int}]{indx}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a7d49a66c0f3b426f1cf8fd335a5f3b6a}

\begin{DoxyCode}
                                            {
        Assert(indx < _r_allocated->NumElements() && indx >= 0 && "Out of range a
      rchitectural register access.");
        return _r_allocated->Nth(indx);
}
\end{DoxyCode}
\hypertarget{classinstruction_a3956b91225afe4381adb46e8630df104}{
\index{instruction@{instruction}!getNthBrAncestor@{getNthBrAncestor}}
\index{getNthBrAncestor@{getNthBrAncestor}!instruction@{instruction}}
\subsubsection[{getNthBrAncestor}]{\setlength{\rightskip}{0pt plus 5cm}{\bf instruction} $\ast$ instruction::getNthBrAncestor (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a3956b91225afe4381adb46e8630df104}

\begin{DoxyCode}
                                                {
        return _brAncestors->Nth(i);
}
\end{DoxyCode}
\hypertarget{classinstruction_ade9345ce46d71d566971798ea924a325}{
\index{instruction@{instruction}!getNthMemRdAncestor@{getNthMemRdAncestor}}
\index{getNthMemRdAncestor@{getNthMemRdAncestor}!instruction@{instruction}}
\subsubsection[{getNthMemRdAncestor}]{\setlength{\rightskip}{0pt plus 5cm}{\bf instruction} $\ast$ instruction::getNthMemRdAncestor (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ade9345ce46d71d566971798ea924a325}

\begin{DoxyCode}
                                                   {
        //NOTE: this function can accessed anytime as opposed to getNthMemRdAnces
      tor
        return _phraseAncestors->Nth(i);
}
\end{DoxyCode}
\hypertarget{classinstruction_aca2f7cc96da470bc99d4c1f0a66646ed}{
\index{instruction@{instruction}!getNthMemRdAncestorID@{getNthMemRdAncestorID}}
\index{getNthMemRdAncestorID@{getNthMemRdAncestorID}!instruction@{instruction}}
\subsubsection[{getNthMemRdAncestorID}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNthMemRdAncestorID (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aca2f7cc96da470bc99d4c1f0a66646ed}

\begin{DoxyCode}
                                            {
        //NOTE: this function can only be accessed only when the instruction is j
      oining a wavefront
        //accessing it later (in time) may cause seg fault as the ancestors may l
      eave ROB
        return _phraseAncestorsID->Nth(i);
}
\end{DoxyCode}
\hypertarget{classinstruction_ad7dce7bff9bfecd11b0e7119738d0994}{
\index{instruction@{instruction}!getNthOldWriteReg@{getNthOldWriteReg}}
\index{getNthOldWriteReg@{getNthOldWriteReg}!instruction@{instruction}}
\subsubsection[{getNthOldWriteReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getNthOldWriteReg (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ad7dce7bff9bfecd11b0e7119738d0994}

\begin{DoxyCode}
                                             {
    Assert(i < _r_write_old->NumElements() && i >= 0);
    return _r_write_old->Nth(i);
}
\end{DoxyCode}
\hypertarget{classinstruction_a0a5ddbb986096245d7742472c49d14b2}{
\index{instruction@{instruction}!getNthReadReg@{getNthReadReg}}
\index{getNthReadReg@{getNthReadReg}!instruction@{instruction}}
\subsubsection[{getNthReadReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getNthReadReg (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a0a5ddbb986096245d7742472c49d14b2}

\begin{DoxyCode}
                                         { 
    Assert(i < _r_read->NumElements() && i >= 0);
    return _r_read->Nth(i);
}
\end{DoxyCode}
\hypertarget{classinstruction_a54412da0ee022e05101d4fb92ee879b9}{
\index{instruction@{instruction}!getNthReg@{getNthReg}}
\index{getNthReg@{getNthReg}!instruction@{instruction}}
\subsubsection[{getNthReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getNthReg (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a54412da0ee022e05101d4fb92ee879b9}

\begin{DoxyCode}
                                     {
        Assert(i < _r->NumElements() && i >= 0);
        return _r->Nth(i);
}
\end{DoxyCode}
\hypertarget{classinstruction_a54412da0ee022e05101d4fb92ee879b9}{
\index{instruction@{instruction}!getNthReg@{getNthReg}}
\index{getNthReg@{getNthReg}!instruction@{instruction}}
\subsubsection[{getNthReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getNthReg (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a54412da0ee022e05101d4fb92ee879b9}
\hypertarget{classinstruction_a9701f53aafaf1b2298378665059cef33}{
\index{instruction@{instruction}!getNthRegType@{getNthRegType}}
\index{getNthRegType@{getNthRegType}!instruction@{instruction}}
\subsubsection[{getNthRegType}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNthRegType (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9701f53aafaf1b2298378665059cef33}
\hypertarget{classinstruction_a9701f53aafaf1b2298378665059cef33}{
\index{instruction@{instruction}!getNthRegType@{getNthRegType}}
\index{getNthRegType@{getNthRegType}!instruction@{instruction}}
\subsubsection[{getNthRegType}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNthRegType (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9701f53aafaf1b2298378665059cef33}

\begin{DoxyCode}
                                    {
        Assert(i < _r->NumElements() && i >= 0);
        return _rt->Nth(i);
}
\end{DoxyCode}
\hypertarget{classinstruction_a29e8de9d3cd22cee464512f9bbc1972c}{
\index{instruction@{instruction}!getNthWriteReg@{getNthWriteReg}}
\index{getNthWriteReg@{getNthWriteReg}!instruction@{instruction}}
\subsubsection[{getNthWriteReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getNthWriteReg (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a29e8de9d3cd22cee464512f9bbc1972c}

\begin{DoxyCode}
                                          { 
    Assert(i < _r_write->NumElements() && i >= 0);
    return _r_write->Nth(i);
}
\end{DoxyCode}
\hypertarget{classinstruction_a2e29e3536ad20c65b6c7b76ba6e37ad8}{
\index{instruction@{instruction}!getNumAncestors@{getNumAncestors}}
\index{getNumAncestors@{getNumAncestors}!instruction@{instruction}}
\subsubsection[{getNumAncestors}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumAncestors (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a2e29e3536ad20c65b6c7b76ba6e37ad8}

\begin{DoxyCode}
                                 {
        return _ancestors->NumElements();
}
\end{DoxyCode}
\hypertarget{classinstruction_a2e29e3536ad20c65b6c7b76ba6e37ad8}{
\index{instruction@{instruction}!getNumAncestors@{getNumAncestors}}
\index{getNumAncestors@{getNumAncestors}!instruction@{instruction}}
\subsubsection[{getNumAncestors}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumAncestors (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a2e29e3536ad20c65b6c7b76ba6e37ad8}
\hypertarget{classinstruction_aea5ab3c5f62740194e3bc9d3335676a2}{
\index{instruction@{instruction}!getNumBrAncestors@{getNumBrAncestors}}
\index{getNumBrAncestors@{getNumBrAncestors}!instruction@{instruction}}
\subsubsection[{getNumBrAncestors}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumBrAncestors (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aea5ab3c5f62740194e3bc9d3335676a2}

\begin{DoxyCode}
                                   {
        return _brAncestors->NumElements();
}
\end{DoxyCode}
\hypertarget{classinstruction_adb8073eb7167fc23a3c846db8129b068}{
\index{instruction@{instruction}!getNumDependents@{getNumDependents}}
\index{getNumDependents@{getNumDependents}!instruction@{instruction}}
\subsubsection[{getNumDependents}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumDependents (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_adb8073eb7167fc23a3c846db8129b068}

\begin{DoxyCode}
                                  {
        return _dependents->NumElements();
}
\end{DoxyCode}
\hypertarget{classinstruction_a71809c767dba335b3bbdad04cb24d43c}{
\index{instruction@{instruction}!getNumLRFreg@{getNumLRFreg}}
\index{getNumLRFreg@{getNumLRFreg}!instruction@{instruction}}
\subsubsection[{getNumLRFreg}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumLRFreg (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a71809c767dba335b3bbdad04cb24d43c}

\begin{DoxyCode}
                              {
        int numReg = 0;
        for (int i = 0; i < _r->NumElements(); i++) {
                if (_r->Nth(i) >= LARF_LO && _r->Nth(i) <= LARF_HI)
                        numReg++;
        }
        return numReg;
}
\end{DoxyCode}
\hypertarget{classinstruction_a2a1e30e887dabbb7b60cc71a1d466105}{
\index{instruction@{instruction}!getNumMemRdAncestors@{getNumMemRdAncestors}}
\index{getNumMemRdAncestors@{getNumMemRdAncestors}!instruction@{instruction}}
\subsubsection[{getNumMemRdAncestors}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumMemRdAncestors (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a2a1e30e887dabbb7b60cc71a1d466105}

\begin{DoxyCode}
                                      {
        //NOTE: read the note for getNthMemRdAncestor()
        Assert(_phraseAncestorsID->NumElements() == _phraseAncestors->
      NumElements());
        return _phraseAncestorsID->NumElements();
}
\end{DoxyCode}
\hypertarget{classinstruction_ae0a1ee97e6ba7920c41dd35f97b1715a}{
\index{instruction@{instruction}!getNumReadReg@{getNumReadReg}}
\index{getNumReadReg@{getNumReadReg}!instruction@{instruction}}
\subsubsection[{getNumReadReg}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumReadReg (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae0a1ee97e6ba7920c41dd35f97b1715a}

\begin{DoxyCode}
                               {
    return _r_read->NumElements();
}
\end{DoxyCode}
\hypertarget{classinstruction_af64e1265e882da7e152bd47cb7794c3b}{
\index{instruction@{instruction}!getNumReg@{getNumReg}}
\index{getNumReg@{getNumReg}!instruction@{instruction}}
\subsubsection[{getNumReg}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumReg (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af64e1265e882da7e152bd47cb7794c3b}
\hypertarget{classinstruction_af64e1265e882da7e152bd47cb7794c3b}{
\index{instruction@{instruction}!getNumReg@{getNumReg}}
\index{getNumReg@{getNumReg}!instruction@{instruction}}
\subsubsection[{getNumReg}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumReg (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af64e1265e882da7e152bd47cb7794c3b}

\begin{DoxyCode}
                           {
        Assert (_r->NumElements() == _rt->NumElements());
        return _r->NumElements();
}
\end{DoxyCode}
\hypertarget{classinstruction_a293a8975be22485ec002ef7cc0466d0a}{
\index{instruction@{instruction}!getNumWriteReg@{getNumWriteReg}}
\index{getNumWriteReg@{getNumWriteReg}!instruction@{instruction}}
\subsubsection[{getNumWriteReg}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumWriteReg (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a293a8975be22485ec002ef7cc0466d0a}

\begin{DoxyCode}
                                {
    return _r_write->NumElements();
}
\end{DoxyCode}
\hypertarget{classinstruction_abe651f9e294dd53e1f515c6856e7e8a3}{
\index{instruction@{instruction}!getNumWrReg@{getNumWrReg}}
\index{getNumWrReg@{getNumWrReg}!instruction@{instruction}}
\subsubsection[{getNumWrReg}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getNumWrReg (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_abe651f9e294dd53e1f515c6856e7e8a3}

\begin{DoxyCode}
                             {
        int numWrReg = 0;
        for (int i = 0; i < _r->NumElements(); i++) {
                if (_rt->Nth(i) == WRITE)
                        numWrReg++;
        }
        return numWrReg;
}
\end{DoxyCode}
\hypertarget{classinstruction_a47d6ca18417d4f185495eb9be2844f07}{
\index{instruction@{instruction}!getOpCode@{getOpCode}}
\index{getOpCode@{getOpCode}!instruction@{instruction}}
\subsubsection[{getOpCode}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ instruction::getOpCode (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a47d6ca18417d4f185495eb9be2844f07}

\begin{DoxyCode}
{return _opCode;}
\end{DoxyCode}
\hypertarget{classinstruction_a081e816b22818a5d9b150678c29d64b3}{
\index{instruction@{instruction}!getOutSideBuff@{getOutSideBuff}}
\index{getOutSideBuff@{getOutSideBuff}!instruction@{instruction}}
\subsubsection[{getOutSideBuff}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::getOutSideBuff (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a081e816b22818a5d9b150678c29d64b3}

\begin{DoxyCode}
                                 {
        _inSideBuff = false;
}
\end{DoxyCode}
\hypertarget{classinstruction_ac773a71d9b69171d092da07080735421}{
\index{instruction@{instruction}!getPathLen@{getPathLen}}
\index{getPathLen@{getPathLen}!instruction@{instruction}}
\subsubsection[{getPathLen}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getPathLen (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ac773a71d9b69171d092da07080735421}

\begin{DoxyCode}
                            {
        Assert(_pathLen > -1);
        return _pathLen;
}
\end{DoxyCode}
\hypertarget{classinstruction_a6691b4bcb64ecd50e0aea3a0558137d0}{
\index{instruction@{instruction}!getPipelineLat@{getPipelineLat}}
\index{getPipelineLat@{getPipelineLat}!instruction@{instruction}}
\subsubsection[{getPipelineLat}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getPipelineLat (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a6691b4bcb64ecd50e0aea3a0558137d0}

\begin{DoxyCode}
                                 {
        Assert (_pipeLineLat != -1);
        return _pipeLineLat;
}
\end{DoxyCode}
\hypertarget{classinstruction_ab78ac4674a2ff497fe482cbbac926ca9}{
\index{instruction@{instruction}!getPredHistObj@{getPredHistObj}}
\index{getPredHistObj@{getPredHistObj}!instruction@{instruction}}
\subsubsection[{getPredHistObj}]{\setlength{\rightskip}{0pt plus 5cm}void $\ast$ instruction::getPredHistObj (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab78ac4674a2ff497fe482cbbac926ca9}

\begin{DoxyCode}
                                  {
        Assert(_bp_hist != NULL && "_bp_hist object must not be null");
        return _bp_hist;
}
\end{DoxyCode}
\hypertarget{classinstruction_a02c4c1da37bc53bbe65fb85ccfd3ee52}{
\index{instruction@{instruction}!getPrediction@{getPrediction}}
\index{getPrediction@{getPrediction}!instruction@{instruction}}
\subsubsection[{getPrediction}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::getPrediction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a02c4c1da37bc53bbe65fb85ccfd3ee52}

\begin{DoxyCode}
                                {
        Assert(_bp_hist != NULL && "_bp_hist object must not be null");
        return _bp_hist;
}
\end{DoxyCode}
\hypertarget{classinstruction_a7824d148fcdeb6a1b7cafd68a7ce99ef}{
\index{instruction@{instruction}!getReadRegSubscript@{getReadRegSubscript}}
\index{getReadRegSubscript@{getReadRegSubscript}!instruction@{instruction}}
\subsubsection[{getReadRegSubscript}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getReadRegSubscript (
\begin{DoxyParamCaption}
\item[{long int}]{var}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a7824d148fcdeb6a1b7cafd68a7ce99ef}

\begin{DoxyCode}
                                                      { 
        // return _readVar.size();
        if (_readVar.find(var) != _readVar.end())
                return _readVar[var];
        else
                return -1;
}
\end{DoxyCode}
\hypertarget{classinstruction_a90450afccd1b4b07bd28b2ee8aabdf6d}{
\index{instruction@{instruction}!getRegAncestors@{getRegAncestors}}
\index{getRegAncestors@{getRegAncestors}!instruction@{instruction}}
\subsubsection[{getRegAncestors}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$ instruction::getRegAncestors (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a90450afccd1b4b07bd28b2ee8aabdf6d}

\begin{DoxyCode}
                                                 {
        return _regAncestors;
}
\end{DoxyCode}
\hypertarget{classinstruction_acd4f756120e0bd6cdb127715c295a5e7}{
\index{instruction@{instruction}!getRegisterStr@{getRegisterStr}}
\index{getRegisterStr@{getRegisterStr}!instruction@{instruction}}
\subsubsection[{getRegisterStr}]{\setlength{\rightskip}{0pt plus 5cm}std::string instruction::getRegisterStr (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_acd4f756120e0bd6cdb127715c295a5e7}

\begin{DoxyCode}
                                      {
        std::stringstream ss;
        std::string s;
        if (getNumReg() == 0) {
                ss << "\n";
        } else {
                for (int i = 0; i < getNumReg(); i++) {
                        if (getNthRegType(i) == WRITE && getRenamedReg(getNthReg(
      i)) != -1)
                                ss << getRenamedReg(getNthReg(i)) << "#" << 
      getNthRegType(i) << ",";
                        else
                                ss << getNthReg(i) << "#" << getNthRegType(i) << 
      ",";
                }
                ss << "\n";
        }
        s = ss.str();
        return s;
}
\end{DoxyCode}
\hypertarget{classinstruction_a35b2a3db2dc9a22bbdcbce797d510c85}{
\index{instruction@{instruction}!getRenamedReg@{getRenamedReg}}
\index{getRenamedReg@{getRenamedReg}!instruction@{instruction}}
\subsubsection[{getRenamedReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getRenamedReg (
\begin{DoxyParamCaption}
\item[{long int}]{reg}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a35b2a3db2dc9a22bbdcbce797d510c85}

\begin{DoxyCode}
                                                {
        if (writeRegRenMap.find(reg) != writeRegRenMap.end())
                return writeRegRenMap.find(reg)->second;
        else
                return -1; //reg is not returned
}
\end{DoxyCode}
\hypertarget{classinstruction_a35b2a3db2dc9a22bbdcbce797d510c85}{
\index{instruction@{instruction}!getRenamedReg@{getRenamedReg}}
\index{getRenamedReg@{getRenamedReg}!instruction@{instruction}}
\subsubsection[{getRenamedReg}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getRenamedReg (
\begin{DoxyParamCaption}
\item[{long int}]{reg}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a35b2a3db2dc9a22bbdcbce797d510c85}
\hypertarget{classinstruction_ae70e85f10d54bf8f323110dd8ecd7d14}{
\index{instruction@{instruction}!getSideBuffNum@{getSideBuffNum}}
\index{getSideBuffNum@{getSideBuffNum}!instruction@{instruction}}
\subsubsection[{getSideBuffNum}]{\setlength{\rightskip}{0pt plus 5cm}int instruction::getSideBuffNum (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae70e85f10d54bf8f323110dd8ecd7d14}

\begin{DoxyCode}
                                {
        Assert (_currentMySBnum != -1);
        return _currentMySBnum;
}
\end{DoxyCode}
\hypertarget{classinstruction_ae93f7b1b0385897bb15fc795ee654c37}{
\index{instruction@{instruction}!getStatus@{getStatus}}
\index{getStatus@{getStatus}!instruction@{instruction}}
\subsubsection[{getStatus}]{\setlength{\rightskip}{0pt plus 5cm}{\bf status} instruction::getStatus (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae93f7b1b0385897bb15fc795ee654c37}

\begin{DoxyCode}
                               {
        return _insStatus;
}
\end{DoxyCode}
\hypertarget{classinstruction_a47623362d505a662b974624f81288389}{
\index{instruction@{instruction}!getType@{getType}}
\index{getType@{getType}!instruction@{instruction}}
\subsubsection[{getType}]{\setlength{\rightskip}{0pt plus 5cm}const char instruction::getType (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a47623362d505a662b974624f81288389}
\hypertarget{classinstruction_a47623362d505a662b974624f81288389}{
\index{instruction@{instruction}!getType@{getType}}
\index{getType@{getType}!instruction@{instruction}}
\subsubsection[{getType}]{\setlength{\rightskip}{0pt plus 5cm}const char instruction::getType (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a47623362d505a662b974624f81288389}

\begin{DoxyCode}
                           {
        return _insType;
}
\end{DoxyCode}
\hypertarget{classinstruction_a1253eafd0173b6daef17fed2311c6bcf}{
\index{instruction@{instruction}!getWriteRegSubscript@{getWriteRegSubscript}}
\index{getWriteRegSubscript@{getWriteRegSubscript}!instruction@{instruction}}
\subsubsection[{getWriteRegSubscript}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::getWriteRegSubscript (
\begin{DoxyParamCaption}
\item[{long int}]{var}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a1253eafd0173b6daef17fed2311c6bcf}

\begin{DoxyCode}
                                                       { 
        // return _writeVar.size();
        if (_writeVar.find(var) != _writeVar.end())
                return _writeVar[var];
        else
                return -1;
}
\end{DoxyCode}
\hypertarget{classinstruction_ae98b3fc0943715a103b91ab8bf272758}{
\index{instruction@{instruction}!goToReadyList@{goToReadyList}}
\index{goToReadyList@{goToReadyList}!instruction@{instruction}}
\subsubsection[{goToReadyList}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::goToReadyList (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae98b3fc0943715a103b91ab8bf272758}

\begin{DoxyCode}
                                {
        _rootList->Append(this);
}
\end{DoxyCode}
\hypertarget{classinstruction_af0d1e76bd95a84ef5629548391264b4e}{
\index{instruction@{instruction}!goToSideBuff@{goToSideBuff}}
\index{goToSideBuff@{goToSideBuff}!instruction@{instruction}}
\subsubsection[{goToSideBuff}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::goToSideBuff (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af0d1e76bd95a84ef5629548391264b4e}

\begin{DoxyCode}
                               {
        _inSideBuff = true;
}
\end{DoxyCode}
\hypertarget{classinstruction_a94d61291db685cc1c3abb2bb72481b3a}{
\index{instruction@{instruction}!importCacheHitLevel@{importCacheHitLevel}}
\index{importCacheHitLevel@{importCacheHitLevel}!instruction@{instruction}}
\subsubsection[{importCacheHitLevel}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::importCacheHitLevel (
\begin{DoxyParamCaption}
\item[{int}]{hitLevel}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a94d61291db685cc1c3abb2bb72481b3a}

\begin{DoxyCode}
                                                  {
        Assert(getType() == MEM);
        _hitLevel = hitLevel;
}
\end{DoxyCode}
\hypertarget{classinstruction_ab04c4389f9057613f1ca69d89509f531}{
\index{instruction@{instruction}!infRegdependencyTable@{infRegdependencyTable}}
\index{infRegdependencyTable@{infRegdependencyTable}!instruction@{instruction}}
\subsubsection[{infRegdependencyTable}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::infRegdependencyTable (
\begin{DoxyParamCaption}
\item[{{\bf dependencyTable} $\ast$}]{depTables, }
\item[{int}]{coreType}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab04c4389f9057613f1ca69d89509f531}

\begin{DoxyCode}
                                                                                 
      {
        //Register true dependency check for all instruction types
        for (int i = 0; i < _r->NumElements(); i++) {
                if (_rt->Nth(i) == READ) { //TODO Does this line make sense? (int
       vs. memType)
                        instruction *temp = depTables->regLookup(_r->Nth(i),
      REG_WRITE);//RAW
                        if (temp != NULL) {
                                if (isRepeated(temp,_ancestors)==false) {
                                        addDep();
                                        temp->setAsDependent(this);
                                        setAsAncestor(temp);
                                }
                        }
                }
        }
        //Update write register table (must be done last to avoid deadlock/wrong 
      dependency)
        for (int i = 0; i < _r->NumElements(); i++) {
                if (_rt->Nth(i) == WRITE) {
                        depTables->addReg(_r->Nth(i), this, REG_WRITE); //overwri
      tes existing table entry for reg
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_afb7103d520a07bdd63d69f5d36d04c38}{
\index{instruction@{instruction}!insertToInsMap@{insertToInsMap}}
\index{insertToInsMap@{insertToInsMap}!instruction@{instruction}}
\subsubsection[{insertToInsMap}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::insertToInsMap (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_afb7103d520a07bdd63d69f5d36d04c38}

\begin{DoxyCode}
                                 {
      _scheduler->insertToInsMap(this);
}
\end{DoxyCode}
\hypertarget{classinstruction_ab5e9dd71fbc48781b528341a9a371a95}{
\index{instruction@{instruction}!isAlreadyAssignedArcRegs@{isAlreadyAssignedArcRegs}}
\index{isAlreadyAssignedArcRegs@{isAlreadyAssignedArcRegs}!instruction@{instruction}}
\subsubsection[{isAlreadyAssignedArcRegs}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isAlreadyAssignedArcRegs (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab5e9dd71fbc48781b528341a9a371a95}

\begin{DoxyCode}
                                           {
        if (_r_allocated->NumElements() == _r->NumElements()) return true;
        else return false;
}
\end{DoxyCode}
\hypertarget{classinstruction_a62b80293d12bff3fca6bb0e052ab710c}{
\index{instruction@{instruction}!isBBhead@{isBBhead}}
\index{isBBhead@{isBBhead}!instruction@{instruction}}
\subsubsection[{isBBhead}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isBBhead (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a62b80293d12bff3fca6bb0e052ab710c}

\begin{DoxyCode}
                           {
        return _bbHead;
}
\end{DoxyCode}
\hypertarget{classinstruction_ab72dc8a4eae39e0ae3f7317fa88d66d7}{
\index{instruction@{instruction}!isBBtail@{isBBtail}}
\index{isBBtail@{isBBtail}!instruction@{instruction}}
\subsubsection[{isBBtail}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isBBtail (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab72dc8a4eae39e0ae3f7317fa88d66d7}

\begin{DoxyCode}
                           {
        return _bbTail;
}
\end{DoxyCode}
\hypertarget{classinstruction_aa6a5b8a0b7f5af780d1593890e87d6a1}{
\index{instruction@{instruction}!isGotoSideBuff@{isGotoSideBuff}}
\index{isGotoSideBuff@{isGotoSideBuff}!instruction@{instruction}}
\subsubsection[{isGotoSideBuff}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isGotoSideBuff (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aa6a5b8a0b7f5af780d1593890e87d6a1}

\begin{DoxyCode}
                                 {
        if (_mySBnum->NumElements() > 0) return true;
        else return false;
}
\end{DoxyCode}
\hypertarget{classinstruction_ab367eab50dc74c47b70de127fc633c9b}{
\index{instruction@{instruction}!isInsRepeated@{isInsRepeated}}
\index{isInsRepeated@{isInsRepeated}!instruction@{instruction}}
\subsubsection[{isInsRepeated}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isInsRepeated (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{ancestors}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab367eab50dc74c47b70de127fc633c9b}

\begin{DoxyCode}
                                                                               {
        Assert (ins != NULL);
        for (int i = 0; i < _ancestors->NumElements(); i++)
                if (_ancestors->Nth(i)->getInsAddr() == ins->getInsAddr()) {
                        return true;
                }
        return false;
}
\end{DoxyCode}
\hypertarget{classinstruction_adc11181683114bd444eff11f1a810c89}{
\index{instruction@{instruction}!isLongestPathSet@{isLongestPathSet}}
\index{isLongestPathSet@{isLongestPathSet}!instruction@{instruction}}
\subsubsection[{isLongestPathSet}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isLongestPathSet (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_adc11181683114bd444eff11f1a810c89}

\begin{DoxyCode}
                                   {
        if (_longestPath == -1) return false;
        else return true;
}
\end{DoxyCode}
\hypertarget{classinstruction_ae047caa60b7297cd7b07fa773003ba71}{
\index{instruction@{instruction}!isOnCritiPath@{isOnCritiPath}}
\index{isOnCritiPath@{isOnCritiPath}!instruction@{instruction}}
\subsubsection[{isOnCritiPath}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isOnCritiPath (
\begin{DoxyParamCaption}
\item[{int}]{candidatePhID}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae047caa60b7297cd7b07fa773003ba71}

\begin{DoxyCode}
                                                 {
        Assert(candidatePhID > -1);
        int maxPathLen=-1;
        for (int i = 0; i < _ancestors->NumElements(); i++) {
                if (candidatePhID == _ancestors->Nth(i)->getMyPhraseID() && maxPa
      thLen < _ancestors->Nth(i)->getPathLen()) {
                        maxPathLen = _ancestors->Nth(i)->getPathLen();
                }
        }
        if (maxPathLen == -1) {maxPathLen = 0;}
        maxPathLen += getMyPathLen();
        int critPathThreshold = phraseSizeBound / NUM_FUNC_UNIT;
        if (maxPathLen > critPathThreshold) return true;
        else return false;
}
\end{DoxyCode}
\hypertarget{classinstruction_abf5f8947b16c91c4e21b82bec378008f}{
\index{instruction@{instruction}!isRdMemType@{isRdMemType}}
\index{isRdMemType@{isRdMemType}!instruction@{instruction}}
\subsubsection[{isRdMemType}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isRdMemType (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_abf5f8947b16c91c4e21b82bec378008f}

\begin{DoxyCode}
                              {
        return _memRead;
}
\end{DoxyCode}
\hypertarget{classinstruction_a3d3c5926b3f74fa012e77011f6d65a57}{
\index{instruction@{instruction}!isReady@{isReady}}
\index{isReady@{isReady}!instruction@{instruction}}
\subsubsection[{isReady}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isReady (
\begin{DoxyParamCaption}
\item[{long int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a3d3c5926b3f74fa012e77011f6d65a57}

\begin{DoxyCode}
                                        {
        Assert(_guardian >= 0); // && 
               //_fetchEndCycle > 0);
        //printf("number of dependents = %d\n", _guardian);
        //if (_guardian > 0)    return false;
        //if (_fetchEndCycle > cycle || //TODO if you uncomment, be sure all func
       calls pass correct cycle val
        if(_ancestors->NumElements() > 0) return false;
        else return true;
}
\end{DoxyCode}
\hypertarget{classinstruction_a8d938a7c74c2bd36d0e5565cf933d9d5}{
\index{instruction@{instruction}!isRepeated@{isRepeated}}
\index{isRepeated@{isRepeated}!instruction@{instruction}}
\subsubsection[{isRepeated}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isRepeated (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{temp, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{ancestors}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a8d938a7c74c2bd36d0e5565cf933d9d5}

\begin{DoxyCode}
                                                                             {
        Assert (temp != NULL);
        for (int i = 0; i < _ancestors->NumElements(); i++)
                if (_ancestors->Nth(i)->getInsID() == temp->getInsID()) {
                        return true;
                }
        return false;
}
\end{DoxyCode}
\hypertarget{classinstruction_a8d938a7c74c2bd36d0e5565cf933d9d5}{
\index{instruction@{instruction}!isRepeated@{isRepeated}}
\index{isRepeated@{isRepeated}!instruction@{instruction}}
\subsubsection[{isRepeated}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isRepeated (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{temp, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{ancestors}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a8d938a7c74c2bd36d0e5565cf933d9d5}
\hypertarget{classinstruction_a0eab1a0a392f17d7ec46e6dbf1ce21fb}{
\index{instruction@{instruction}!isWrMemType@{isWrMemType}}
\index{isWrMemType@{isWrMemType}!instruction@{instruction}}
\subsubsection[{isWrMemType}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::isWrMemType (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a0eab1a0a392f17d7ec46e6dbf1ce21fb}

\begin{DoxyCode}
                              {
        return _memWrite;
}
\end{DoxyCode}
\hypertarget{classinstruction_aad7cdb8a4cb4aa3f6fa92ceba462a106}{
\index{instruction@{instruction}!lookUpANDsetPathLen@{lookUpANDsetPathLen}}
\index{lookUpANDsetPathLen@{lookUpANDsetPathLen}!instruction@{instruction}}
\subsubsection[{lookUpANDsetPathLen}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::lookUpANDsetPathLen (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aad7cdb8a4cb4aa3f6fa92ceba462a106}

\begin{DoxyCode}
                                      {
        Assert(_pathLen == -1);
        //Find the max path-length of the ancestors
        for (int i = 0; i < _ancestors->NumElements(); i++) { //TODO this can be 
      made efficient (see isOnCritiPath())
                if (_ancestors->Nth(i)->getMyPhraseID() == getMyPhraseID() && 
                    _pathLen < _ancestors->Nth(i)->getPathLen()) {
                        _pathLen = _ancestors->Nth(i)->getPathLen();
                }
        }
        //add my own path length
        if (_pathLen == -1) {_pathLen = 0;}
        _pathLen += getMyPathLen();
        Assert(_pathLen > -1);
}
\end{DoxyCode}
\hypertarget{classinstruction_ae406e3e00f408b7b54510867c88b1b5d}{
\index{instruction@{instruction}!makeUniqueRegs@{makeUniqueRegs}}
\index{makeUniqueRegs@{makeUniqueRegs}!instruction@{instruction}}
\subsubsection[{makeUniqueRegs}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::makeUniqueRegs (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae406e3e00f408b7b54510867c88b1b5d}

\begin{DoxyCode}
                                 {
        for (int i = 0; i < _r->NumElements(); i++) {
                long int reg = _r->Nth(i);
                int regT = _rt->Nth(i);
                long int ssa;
                //printf("%d,%d,%d,%llx\n",regT,_readVar.find(reg) != _readVar.en
      d(),_writeVar.find(reg) != _writeVar.end(), getInsAddr());
                if (regT == READ) {
                        Assert(_readVar.find(reg) != _readVar.end());
                        ssa = _readVar[reg]*100+reg;
                } else if (regT == WRITE) {
                        Assert(_writeVar.find(reg) != _writeVar.end());
                        ssa = _writeVar[reg]*100+reg;
                } else {
                        Assert( true == false && "Invalid register type.");
                }
                _r->RemoveAt(i);
                _r->InsertAt(ssa,i);
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a096c7696da9989235116d28996b34143}{
\index{instruction@{instruction}!noRRdependencyTable@{noRRdependencyTable}}
\index{noRRdependencyTable@{noRRdependencyTable}!instruction@{instruction}}
\subsubsection[{noRRdependencyTable}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::noRRdependencyTable (
\begin{DoxyParamCaption}
\item[{{\bf dependencyTable} $\ast$}]{depTables, }
\item[{int}]{coreType}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a096c7696da9989235116d28996b34143}

\begin{DoxyCode}
                                                                               {
        Assert((coreType == IN_ORDER || coreType == PHRASEBLOCK) && "The specifie
      d core type is not supported for register renaming.");
        //Register true dependency check for all instruction types
        for (int i = 0; i < _r->NumElements(); i++) {
                if (coreType == PHRASEBLOCK && !(_r->Nth(i) >= LARF_LO && _r->
      Nth(i) <= LARF_HI)) continue;
                if (coreType == IN_ORDER    && !(_r->Nth(i) >= LARF_LO && _r->
      Nth(i) <= GARF_HI)) Assert(true == false && "Invalid register value.");
                if (_rt->Nth(i) == READ) { //TODO Does this line make sense? (int
       vs. memType)
                        instruction *temp = depTables->regLookup(_r->Nth(i),
      REG_WRITE);//RAW
                        if (temp != NULL) {
                                if (isRepeated(temp,_ancestors)==false) {
                                        addDep();
                                        temp->setAsDependent(this);
                                        setAsAncestor(temp);
                                }
                        }
                } else if (_rt->Nth(i) == WRITE) {
                        //only for non-OOO cores
                        instruction *temp = depTables->regLookup(_r->Nth(i),
      REG_READ);//WAR
                        if (temp != NULL && isRepeated(temp,_ancestors)==false) {
      
                                addDep();
                                temp->setAsDependent(this);
                                setAsAncestor(temp);
                        }
                        temp = depTables->regLookup(_r->Nth(i),REG_WRITE);//WAW
                        if (temp != NULL && isRepeated(temp,_ancestors)==false) {
      
                                addDep();
                                temp->setAsDependent(this);
                                setAsAncestor(temp);
                        }
                }
        }
        //Update write register table (must be done last to avoid deadlock/wrong 
      dependency)
        for (int i = 0; i < _r->NumElements(); i++) {
                if (coreType == PHRASEBLOCK && !(_r->Nth(i) >= LARF_LO && _r->
      Nth(i) <= LARF_HI)) continue;
                if (coreType == IN_ORDER    && !(_r->Nth(i) >= LARF_LO && _r->
      Nth(i) <= GARF_HI)) Assert(true == false && "Invalid register value.");
                if (_rt->Nth(i) == WRITE) {
                        depTables->addReg(_r->Nth(i), this, REG_WRITE); //overwri
      tes existing table entry for reg
                } else if (_rt->Nth(i) == READ) { //TODO register renaming breaks
       this block of code
                        depTables->addReg(_r->Nth(i), this, REG_READ); //overwrit
      es existing table entry for reg
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_abe8f9b353e303a39ab97f1d4bebba101}{
\index{instruction@{instruction}!notifyAllAncISquashed@{notifyAllAncISquashed}}
\index{notifyAllAncISquashed@{notifyAllAncISquashed}!instruction@{instruction}}
\subsubsection[{notifyAllAncISquashed}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::notifyAllAncISquashed (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_abe8f9b353e303a39ab97f1d4bebba101}

\begin{DoxyCode}
                                        {
        for (int i = 0; i < _ancestors->NumElements(); i++) {
                _ancestors->Nth(i)->squashDep(this);
                _guardian--;
        }
        for (int i = 0; i < _brAncestors->NumElements(); i++) {
                _brAncestors->Nth(i)->squashBrDep(this);
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a004b3ed6bdd168e05d4deb6d9dcb6080}{
\index{instruction@{instruction}!notifyAllBrAncestorsICompleted@{notifyAllBrAncestorsICompleted}}
\index{notifyAllBrAncestorsICompleted@{notifyAllBrAncestorsICompleted}!instruction@{instruction}}
\subsubsection[{notifyAllBrAncestorsICompleted}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::notifyAllBrAncestorsICompleted (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a004b3ed6bdd168e05d4deb6d9dcb6080}

\begin{DoxyCode}
                                                 {
        if (getBrMode() == scheduleBr) {
                for (int i = 0; i < _brAncestors->NumElements(); i++) {
                        _brAncestors->Nth(i)->releaseBrAncestors(this);
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_aed884db7d433b78579a964299889823f}{
\index{instruction@{instruction}!notifyAllDepGetOutSideBuff@{notifyAllDepGetOutSideBuff}}
\index{notifyAllDepGetOutSideBuff@{notifyAllDepGetOutSideBuff}!instruction@{instruction}}
\subsubsection[{notifyAllDepGetOutSideBuff}]{\setlength{\rightskip}{0pt plus 5cm}long int instruction::notifyAllDepGetOutSideBuff (
\begin{DoxyParamCaption}
\item[{int}]{sb, }
\item[{{\bf INS\_\-ID}}]{causeOfSBinsID, }
\item[{int}]{numSideBuffs}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aed884db7d433b78579a964299889823f}

\begin{DoxyCode}
                                                                                 
                     {
        Assert (sb >= 0 && sb < numSideBuffs);
        long int _numDepInOtherSBs = 0;
        if (_delFlag != causeOfSBinsID) { //avoid infinite calls
                if (_insStatus == FETCH) {
                        delMySB(sb,causeOfSBinsID,numSideBuffs);
                } else if (_insStatus == sideBuffer && _currentMySBnum != sb) {
                        _numDepInOtherSBs++;
                }
                for (int i = 0; i < _dependents->NumElements(); i++) {
                        _numDepInOtherSBs += _dependents->Nth(i)->
      notifyAllDepGetOutSideBuff(sb, causeOfSBinsID,numSideBuffs);
                }
                _delFlag = causeOfSBinsID;
                return _numDepInOtherSBs;
        }
        return 0;
}
\end{DoxyCode}
\hypertarget{classinstruction_ae57b38a2a8bfab07e1bc6de8add821ae}{
\index{instruction@{instruction}!notifyAllDepGoToSideBuff@{notifyAllDepGoToSideBuff}}
\index{notifyAllDepGoToSideBuff@{notifyAllDepGoToSideBuff}!instruction@{instruction}}
\subsubsection[{notifyAllDepGoToSideBuff}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::notifyAllDepGoToSideBuff (
\begin{DoxyParamCaption}
\item[{int}]{sb, }
\item[{{\bf INS\_\-ID}}]{causeOfSBinsID, }
\item[{int}]{numSideBuffs}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae57b38a2a8bfab07e1bc6de8add821ae}

\begin{DoxyCode}
                                                                                 
               {
        Assert (sb >= 0 && sb < numSideBuffs);

        if (_addFlag != causeOfSBinsID) { //avoid infinite calls
                //This guarantees the youngest long latency op set the SB of an i
      ns in fetch state
                if (_insStatus == FETCH || 
                   (_insStatus == sideBuffer && _currentMySBnum == sb)||
                   //(_insStatus == complete && _currentMySBnum == sb)
                   (_id == causeOfSBinsID))
                {
                        addAsMySB(sb, causeOfSBinsID, numSideBuffs);
                }
                for (int i = 0; i < _dependents->NumElements(); i++) {
                        _dependents->Nth(i)->notifyAllDepGoToSideBuff(sb,causeOfS
      BinsID,numSideBuffs);
                }
                _addFlag = causeOfSBinsID;
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a4d6726de4186f3010dd064582d4637d4}{
\index{instruction@{instruction}!notifyAllDepICompleted@{notifyAllDepICompleted}}
\index{notifyAllDepICompleted@{notifyAllDepICompleted}!instruction@{instruction}}
\subsubsection[{notifyAllDepICompleted}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::notifyAllDepICompleted (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a4d6726de4186f3010dd064582d4637d4}

\begin{DoxyCode}
                                         {
        for (int i = 0; i < _dependents->NumElements(); i++) {
                _dependents->Nth(i)->releaseDep(this);
        }
        for (int i = 0; i < _brDependents->NumElements(); i++) {
                _brDependents->Nth(i)->releaseBrDep(this);
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a6308dc145beb4a8ee6ccace0ed9f8cdd}{
\index{instruction@{instruction}!notifyAllDepICompleted\_\-light@{notifyAllDepICompleted\_\-light}}
\index{notifyAllDepICompleted\_\-light@{notifyAllDepICompleted\_\-light}!instruction@{instruction}}
\subsubsection[{notifyAllDepICompleted\_\-light}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::notifyAllDepICompleted\_\-light (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a6308dc145beb4a8ee6ccace0ed9f8cdd}

\begin{DoxyCode}
                                               {
        for (int i = 0; i < _dependents->NumElements(); i++) {
                _dependents->Nth(i)->releaseDep_light(this);
        }
        for (int i = 0; i < _brDependents->NumElements(); i++) {
                _brDependents->Nth(i)->releaseBrDep(this);
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a229c73b0e852f8b2ab3617b4bc4cb988}{
\index{instruction@{instruction}!notifyDepICommited@{notifyDepICommited}}
\index{notifyDepICommited@{notifyDepICommited}!instruction@{instruction}}
\subsubsection[{notifyDepICommited}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::notifyDepICommited (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a229c73b0e852f8b2ab3617b4bc4cb988}

\begin{DoxyCode}
                                     {
        for (int i = 0; i < _dependents->NumElements(); i++)
                _dependents->Nth(i)->releaseDepFromUPLD(this);
}
\end{DoxyCode}
\hypertarget{classinstruction_a9ece958dee811e62fc0bf63d35bd88d8}{
\index{instruction@{instruction}!notifyMyDepFragsICompleted@{notifyMyDepFragsICompleted}}
\index{notifyMyDepFragsICompleted@{notifyMyDepFragsICompleted}!instruction@{instruction}}
\subsubsection[{notifyMyDepFragsICompleted}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::notifyMyDepFragsICompleted (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9ece958dee811e62fc0bf63d35bd88d8}

\begin{DoxyCode}
                                             {
        for (int i = 0; i < _depFrags->NumElements(); i++) {
                _depFrags->Nth(i)->removeAncestorIns(this);
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_aa8c56a4a880638422bb8d1d1e5d24e8e}{
\index{instruction@{instruction}!notifyMyDepPhrasesICompleted@{notifyMyDepPhrasesICompleted}}
\index{notifyMyDepPhrasesICompleted@{notifyMyDepPhrasesICompleted}!instruction@{instruction}}
\subsubsection[{notifyMyDepPhrasesICompleted}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::notifyMyDepPhrasesICompleted (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aa8c56a4a880638422bb8d1d1e5d24e8e}

\begin{DoxyCode}
                                               {
        for (int i = 0; i < _depPhrases->NumElements(); i++) {
                _depPhrases->Nth(i)->removeAncestorIns(this);
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a213dc8dc75e0df8b8be759462b3cb8b9}{
\index{instruction@{instruction}!perfect\_\-MemDependencyTable@{perfect\_\-MemDependencyTable}}
\index{perfect\_\-MemDependencyTable@{perfect\_\-MemDependencyTable}!instruction@{instruction}}
\subsubsection[{perfect\_\-MemDependencyTable}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::perfect\_\-MemDependencyTable (
\begin{DoxyParamCaption}
\item[{{\bf dependencyTable} $\ast$}]{depTables, }
\item[{int}]{coreType, }
\item[{int}]{numSideBuffs}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a213dc8dc75e0df8b8be759462b3cb8b9}

\begin{DoxyCode}
                                                                                 
                             {
        // Dependency check for mem instructions
        if (_readORwrite == READ) { //Mem Read
                instruction *temp = depTables->addrLookup(_memAddr, MEM_WRITE);//
      RAW
                if (temp != NULL && isRepeated(temp,_ancestors)==false) {
                        addDep();
                        temp->setAsDependent(this);
                        setAsAncestor(temp);
                        if (temp->isGotoSideBuff() == true) {
                                //goToSideBuff();
                                if (coreType != ONE_LEVE_DEEP_STAT) addAsMySB(tem
      p->getSideBuffNum(),temp->getCauseOfSBinsID(),numSideBuffs);
                        }
                }
                depTables->addAddr(_memAddr, this, MEM_READ);
        } else if (_readORwrite == WRITE) { //Mem Write
                instruction *temp = depTables->addrLookup(_memAddr, MEM_READ);//W
      AR
                if (temp != NULL && isRepeated(temp,_ancestors)==false) {
                        addDep();
                        temp->setAsDependent(this);
                        setAsAncestor(temp);
                        if (temp->isGotoSideBuff() == true) {
                                //goToSideBuff();
                                if (coreType != ONE_LEVE_DEEP_STAT) addAsMySB(tem
      p->getSideBuffNum(),temp->getCauseOfSBinsID(),numSideBuffs);
                        }
                }
                temp = depTables->addrLookup(_memAddr, MEM_WRITE);//WAW
                if (temp != NULL && isRepeated(temp,_ancestors)==false) {
                        addDep();
                        temp->setAsDependent(this);
                        setAsAncestor(temp);
                        if (temp->isGotoSideBuff() == true) {
                                //goToSideBuff();
                                if (coreType != ONE_LEVE_DEEP_STAT) addAsMySB(tem
      p->getSideBuffNum(),temp->getCauseOfSBinsID(),numSideBuffs);
                        }
                }
                depTables->addAddr(_memAddr, this, MEM_WRITE);
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a32e2f2aa8991ac0d69ce22e728bdea4d}{
\index{instruction@{instruction}!printToFile@{printToFile}}
\index{printToFile@{printToFile}!instruction@{instruction}}
\subsubsection[{printToFile}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::printToFile (
\begin{DoxyParamCaption}
\item[{FILE $\ast$}]{reScheduleFile, }
\item[{bool}]{recordHitMiss}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a32e2f2aa8991ac0d69ce22e728bdea4d}

\begin{DoxyCode}
                                                                      {
        if (_insType == ALU) {
                fprintf(reScheduleFile, "\nA,%llu,",getInsAddr());
                //printf("\nA,%ld,",getInsAddr());
        } else if (_insType == FPU) {
                fprintf(reScheduleFile, "\nF,%llu,",getInsAddr());
                //printf("\nF,%ld,",getInsAddr());
        } else if (_insType == BR) {
                fprintf(reScheduleFile, "\nB,%llu,%d,%ld,",getInsAddr(),_brTaken,
      _brTarget);
                //printf("\nB,%ld,%d,%ld,",getInsAddr(),_brTaken,_brTarget);
        } else if (_insType == MEM && _readORwrite == READ) {
                fprintf(reScheduleFile, "\nR,%llu,%llu,",getMemAddr(),getInsAddr(
      ));
                //printf("\nR,%ld,%ld,",getMemAddr(),getInsAddr());
        } else if (_insType == MEM && _readORwrite == WRITE) {
                fprintf(reScheduleFile, "\nW,%llu,%llu,",getMemAddr(),getInsAddr(
      ));
                //printf("\nW,%ld,%ld,",getMemAddr(),getInsAddr());
        } else if (_insType == ASSIGN) {
                fprintf(reScheduleFile, "\nT,%llu,",getInsAddr());
                //printf("\nT,%ld,",getInsAddr());
        }

        if (recordHitMiss == true) {
                //COEFF used for conveient parsing later on
                long int temp = COEFF * getMissrate();
                Assert(temp <= COEFF && temp >= 0);
                fprintf(reScheduleFile, "%ld,", temp);
                //printf("%ld,", temp);
                //fprintf(reScheduleFile, "%d,", _hitLevel); //TODO remove - old 
      version
                //printf("%f | %s", getMissrate(), getCmdStr());
                Assert((getMissrate() >= 0.0 && getMissrate() <= 1.0));// &&  _re
      adORwrite == READ) ||
                       //(getMissrate() == 0.0 && (_readORwrite == WRITE || _insT
      ype == ALU || _insType == FPU)));
        }

        Assert(_r->NumElements() == _rt->NumElements());
        for (int i = 0; i < _r->NumElements(); i++) {
                if (_rt->Nth(i) == READ) {
                        fprintf(reScheduleFile, "%ld#%d,",_r->Nth(i),_rt->Nth(i))
      ;
                        //printf("%ld#%d,",_r->Nth(i),_rt->Nth(i));
                } else if (_rt->Nth(i) == WRITE) {
                        long int r = getRenamedReg(_r->Nth(i));
                        if (r != -1) {
                                fprintf(reScheduleFile, "%ld#%d,",r,_rt->Nth(i));
      
                                //printf("%ld#%d,",r,_rt->Nth(i));
                        } else { 
                                fprintf(reScheduleFile, "%ld#%d,",_r->Nth(i),_rt-
      >Nth(i));
                                //printf("%ld#%d,",_r->Nth(i),_rt->Nth(i));
                        }
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a3ad24eb0105af8c9f593642c3961236f}{
\index{instruction@{instruction}!releaseBrAncestors@{releaseBrAncestors}}
\index{releaseBrAncestors@{releaseBrAncestors}!instruction@{instruction}}
\subsubsection[{releaseBrAncestors}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::releaseBrAncestors (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a3ad24eb0105af8c9f593642c3961236f}

\begin{DoxyCode}
                                                     {
        Assert(getType() == BR);
        for (int i = _brDependents->NumElements()-1; i >= 0 ; i--) {
                if (ins->getInsID() == _brDependents->Nth(i)->getInsID()) {
                        _brDependents->RemoveAt(i);
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a8a4fb5b938939b6988c7d76a1808ef0c}{
\index{instruction@{instruction}!releaseBrDep@{releaseBrDep}}
\index{releaseBrDep@{releaseBrDep}!instruction@{instruction}}
\subsubsection[{releaseBrDep}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::releaseBrDep (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a8a4fb5b938939b6988c7d76a1808ef0c}

\begin{DoxyCode}
                                               {
        for (int i = _brAncestors->NumElements()-1; i >= 0 ; i--) {
                if (ins->getInsID() == _brAncestors->Nth(i)->getInsID()) {
                        _brAncestors->RemoveAt(i);
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a9c036772123e1dcf59239cd5fd065f0f}{
\index{instruction@{instruction}!releaseDep@{releaseDep}}
\index{releaseDep@{releaseDep}!instruction@{instruction}}
\subsubsection[{releaseDep}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::releaseDep (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9c036772123e1dcf59239cd5fd065f0f}

\begin{DoxyCode}
                                             {
        for (int i = _ancestors->NumElements()-1; i >= 0 ; i--) {
                if (ins->getInsID() == _ancestors->Nth(i)->getInsID()) {
                        _ancestors->RemoveAt(i);
                }
        }
        _guardian--;
        //Assert(_guardian >=0);
        //if ((getBrMode() == scheduleBr || getBrMode() == allBr || getBrMode() =
      = noBr) && _ancestors->NumElements() == 0) {
        if ((getBrMode() == scheduleBr) && _ancestors->NumElements() == 0) {
                goToReadyList();
                removeFromInsMap();
                //If ther is an older BR op, inject a new ins
                //if (getNumBrAncestors() > 0 && getType() != BR && getMemType() 
      != WRITE && getType() != ASSIGN && getType() != ALU) { //TODO I think this line h
      as the bug!
                //      _scheduler->injectIns(this);
                //}
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a2efa8c5533c25ab4cf5fc812b65a0dc7}{
\index{instruction@{instruction}!releaseDep\_\-light@{releaseDep\_\-light}}
\index{releaseDep\_\-light@{releaseDep\_\-light}!instruction@{instruction}}
\subsubsection[{releaseDep\_\-light}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::releaseDep\_\-light (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a2efa8c5533c25ab4cf5fc812b65a0dc7}

\begin{DoxyCode}
                                                   {
        for (int i = _ancestors->NumElements()-1; i >= 0 ; i--) {
                if (ins->getInsID() == _ancestors->Nth(i)->getInsID()) {
                        _ancestors->RemoveAt(i);
                }
        }
        _guardian--;
}
\end{DoxyCode}
\hypertarget{classinstruction_a6fd66b22a3d589e5f366ec6addc62a3e}{
\index{instruction@{instruction}!releaseDepFromUPLD@{releaseDepFromUPLD}}
\index{releaseDepFromUPLD@{releaseDepFromUPLD}!instruction@{instruction}}
\subsubsection[{releaseDepFromUPLD}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::releaseDepFromUPLD (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a6fd66b22a3d589e5f366ec6addc62a3e}

\begin{DoxyCode}
                                                     {
        for (int i = _phraseAncestors->NumElements()-1; i >= 0 ; i--) {
                if (ins->getInsID() == _phraseAncestors->Nth(i)->getInsID() && in
      s->getMemType() == READ) {
                        _phraseAncestors->RemoveAt(i);
                        _phraseAncestorsID->RemoveAt(i);
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a435d34db2d195bc1a3c451f0132151c1}{
\index{instruction@{instruction}!removeFromInsMap@{removeFromInsMap}}
\index{removeFromInsMap@{removeFromInsMap}!instruction@{instruction}}
\subsubsection[{removeFromInsMap}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::removeFromInsMap (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a435d34db2d195bc1a3c451f0132151c1}

\begin{DoxyCode}
                                   {
      _scheduler->delFromInsMap(this);
}
\end{DoxyCode}
\hypertarget{classinstruction_aabb46003e886f87cd3bc918f05a3682f}{
\index{instruction@{instruction}!removeNthRegister@{removeNthRegister}}
\index{removeNthRegister@{removeNthRegister}!instruction@{instruction}}
\subsubsection[{removeNthRegister}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::removeNthRegister (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aabb46003e886f87cd3bc918f05a3682f}
\hypertarget{classinstruction_aabb46003e886f87cd3bc918f05a3682f}{
\index{instruction@{instruction}!removeNthRegister@{removeNthRegister}}
\index{removeNthRegister@{removeNthRegister}!instruction@{instruction}}
\subsubsection[{removeNthRegister}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::removeNthRegister (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aabb46003e886f87cd3bc918f05a3682f}

\begin{DoxyCode}
                                         {
        Assert(i < _r->NumElements() && i >= 0);
        _r->RemoveAt(i);
        _rt->RemoveAt(i);
}
\end{DoxyCode}
\hypertarget{classinstruction_ae9760e334e7829c4f8504bc8436e2dfb}{
\index{instruction@{instruction}!renameReadReg@{renameReadReg}}
\index{renameReadReg@{renameReadReg}!instruction@{instruction}}
\subsubsection[{renameReadReg}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::renameReadReg (
\begin{DoxyParamCaption}
\item[{int}]{indx, }
\item[{long int}]{renReg}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae9760e334e7829c4f8504bc8436e2dfb}

\begin{DoxyCode}
                                                         {
        Assert(_rt->Nth(indx) == READ);
        int num1 = _r->NumElements();
        if (renReg != -1) {
                _r->RemoveAt(indx);
                _r->InsertAt(renReg,indx);
        }
        int num2 = _r->NumElements();
        Assert (num1 == num2);
}
\end{DoxyCode}
\hypertarget{classinstruction_ae9760e334e7829c4f8504bc8436e2dfb}{
\index{instruction@{instruction}!renameReadReg@{renameReadReg}}
\index{renameReadReg@{renameReadReg}!instruction@{instruction}}
\subsubsection[{renameReadReg}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::renameReadReg (
\begin{DoxyParamCaption}
\item[{int}]{indx, }
\item[{long int}]{renReg}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae9760e334e7829c4f8504bc8436e2dfb}
\hypertarget{classinstruction_a6dfbd578c46bb88f5b7ac61b74b7fba4}{
\index{instruction@{instruction}!renameRegs@{renameRegs}}
\index{renameRegs@{renameRegs}!instruction@{instruction}}
\subsubsection[{renameRegs}]{\setlength{\rightskip}{0pt plus 5cm}bool instruction::renameRegs (
\begin{DoxyParamCaption}
\item[{{\bf registerRename} $\ast$}]{GRF, }
\item[{int}]{coreType}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a6dfbd578c46bb88f5b7ac61b74b7fba4}

\begin{DoxyCode}
                                                              {
        Assert((coreType == OUT_OF_ORDER || coreType == PHRASEBLOCK) && "The spec
      ified core type is not supported for register renaming.");
        //Do we have enough registers to rename?
        if (GRF->getNumAvailablePR() < _numWriteReg)
                return true; //STALL FETCH

        // Process Read Refisters FIRST
        for (int i = 0; i < getNumReg(); i++) {
                if (coreType == PHRASEBLOCK && !(_r->Nth(i) >= GARF_LO && _r->
      Nth(i) <= GARF_HI)) continue;
                if (_rt->Nth(i) == READ) {
                        PR p_reg = GRF->getRenamedReg(_r->Nth(i));
                        switch (GRF->getPRFSM(p_reg)) {
                                case AVAILABLE:
                                        Assert(true == false && "Unexpected regis
      ter state");
                                        //This can happen after some squashed
                                        break;
                                case RENAMED_VALID:
                                        // _r->RemoveAt(i);
                                        // _r->InsertAt(p_reg,i); //don't have to
       do it
                                        break;
                                case RENAMED_INVALID:
                                        //need to impose dependency here
                                        instruction* ancestor;
                                        ancestor = GRF->getWriterIns(p_reg);
                                        if (isRepeated(ancestor,_ancestors)==fals
      e) {
                                                addDep();
                                                ancestor->setAsDependent(this);
                                                setAsAncestor(ancestor);
                                        }
                                        // _r->RemoveAt(i);
                                        // _r->InsertAt(p_reg,i); //don't have to
       do it
                                        break;
                                case ARCH_REG:
                                        // _r->RemoveAt(i);
                                        // _r->InsertAt(p_reg,i); //don't have to
       do it
                                        break;
                                default:
                                        Assert(true == false && "Invalid PR state
      ");
                        };
                }
        }
        // Process Write Refisters SECOND
        for (int i = 0; i < getNumReg(); i++) {
                if (coreType == PHRASEBLOCK && !(_r->Nth(i) >= GARF_LO && _r->
      Nth(i) <= GARF_HI)) continue;
                if (_rt->Nth(i) == WRITE) {
                        AR a_reg = _r->Nth(i);
                        if (GRF->isAnyPRavailable()) {
                                PR old_pr = GRF->getRenamedReg(a_reg);
                                PR new_pr = GRF->getAvailablePR();
                                GRF->update_fRAT(a_reg,new_pr);
                                GRF->setARST(new_pr,old_pr);
                                GRF->updatePRFSM(new_pr,RENAMED_INVALID,this);
                                _pr->Append(new_pr);
                                _pTOaRegMap.insert(pair<PR,AR>(new_pr,a_reg));
                                // _r->RemoveAt(i);
                                // _r->InsertAt(new_pr,i); //don't have to do it
                        } else {
                                Assert(true == false && "An avialable physical re
      gister must have been available!");
                        }
                }
        }
        return false; //DON'T STALL FETCH
}
\end{DoxyCode}
\hypertarget{classinstruction_a696b4ec387bfeb56d4266d08e7bb1627}{
\index{instruction@{instruction}!renameWriteReg@{renameWriteReg}}
\index{renameWriteReg@{renameWriteReg}!instruction@{instruction}}
\subsubsection[{renameWriteReg}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::renameWriteReg (
\begin{DoxyParamCaption}
\item[{long int}]{reg}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a696b4ec387bfeb56d4266d08e7bb1627}

\begin{DoxyCode}
                                             {
        nextRenReg++;
        if (!(reg < NUM_REGISTERS && nextRenReg > INIT_RENAME_REG_NUM)) printf("c
      md = %s --- %lld\n", getCmdStr(),_id);
        Assert(reg < NUM_REGISTERS && nextRenReg > INIT_RENAME_REG_NUM);
        Assert(nextRenReg > INIT_RENAME_REG_NUM);
        writeRegRenMap.insert(pair<long int,long int>(reg,nextRenReg));
}
\end{DoxyCode}
\hypertarget{classinstruction_aabd61e186e80af7dd343e0f142741ed6}{
\index{instruction@{instruction}!renameWriteReg@{renameWriteReg}}
\index{renameWriteReg@{renameWriteReg}!instruction@{instruction}}
\subsubsection[{renameWriteReg}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::renameWriteReg (
\begin{DoxyParamCaption}
\item[{int}]{indx, }
\item[{long int}]{reg}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aabd61e186e80af7dd343e0f142741ed6}

\begin{DoxyCode}
                                                       {
    nextRenReg++;
    Assert(reg <= NUM_REGISTERS && "Invalid Register Number");
    Assert(nextRenReg > INIT_RENAME_REG_NUM && "Invalid Rename Register Number");
      
        if (writeRegRenMap.count(reg) > 0)
                writeRegRenMap.erase(reg);
    _r->RemoveAt(indx);
    _r->InsertAt(nextRenReg,indx);
    writeRegRenMap.insert(pair<long int,long int>(reg,nextRenReg));
}
\end{DoxyCode}
\hypertarget{classinstruction_af6d861b0ad792c3136431c3ef99509ba}{
\index{instruction@{instruction}!resetLongestPath@{resetLongestPath}}
\index{resetLongestPath@{resetLongestPath}!instruction@{instruction}}
\subsubsection[{resetLongestPath}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::resetLongestPath (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af6d861b0ad792c3136431c3ef99509ba}

\begin{DoxyCode}
                                   {
        _longestPath = -1;
}
\end{DoxyCode}
\hypertarget{classinstruction_a8e201444f39b8a779022284e280fdf23}{
\index{instruction@{instruction}!setArchReg@{setArchReg}}
\index{setArchReg@{setArchReg}!instruction@{instruction}}
\subsubsection[{setArchReg}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setArchReg (
\begin{DoxyParamCaption}
\item[{long int}]{r}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a8e201444f39b8a779022284e280fdf23}

\begin{DoxyCode}
                                       {
        if (!((r <= GRF_HI && r >= GRF_LO) || (r <= LRF_HI && r >= LRF_LO))) prin
      tf("invalid arch register value: %d\n",r);
        Assert(((r <= GRF_HI && r >= GRF_LO) || (r <= LRF_HI && r >= LRF_LO)) && 
      "Invalid architectural register assignment.");
        Assert(_r_allocated->NumElements() <= _r->NumElements());
        _r_allocated->Append(r);
}
\end{DoxyCode}
\hypertarget{classinstruction_aee7e55cf32812b46267a22bcb53da670}{
\index{instruction@{instruction}!setAsAncestor@{setAsAncestor}}
\index{setAsAncestor@{setAsAncestor}!instruction@{instruction}}
\subsubsection[{setAsAncestor}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setAsAncestor (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aee7e55cf32812b46267a22bcb53da670}

\begin{DoxyCode}
                                                {
        //if (ins->getInsID() > _id) printf("this ins id %llx < its descendent %l
      lx\n",_id,ins->getInsID());
        Assert(ins->getInsID() <= _id);
        _ancestors->Append(ins);
}
\end{DoxyCode}
\hypertarget{classinstruction_aee7e55cf32812b46267a22bcb53da670}{
\index{instruction@{instruction}!setAsAncestor@{setAsAncestor}}
\index{setAsAncestor@{setAsAncestor}!instruction@{instruction}}
\subsubsection[{setAsAncestor}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setAsAncestor (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aee7e55cf32812b46267a22bcb53da670}
\hypertarget{classinstruction_a508aeb795698276978932acb2d81cfe2}{
\index{instruction@{instruction}!setAsBrAncestor@{setAsBrAncestor}}
\index{setAsBrAncestor@{setAsBrAncestor}!instruction@{instruction}}
\subsubsection[{setAsBrAncestor}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setAsBrAncestor (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a508aeb795698276978932acb2d81cfe2}

\begin{DoxyCode}
                                                  {
        Assert(ins->getInsID() < _id);
        _brAncestors->Append(ins);
}
\end{DoxyCode}
\hypertarget{classinstruction_af3e4f5b3744955fa671e22f75da8b0a5}{
\index{instruction@{instruction}!setAsBrDependent@{setAsBrDependent}}
\index{setAsBrDependent@{setAsBrDependent}!instruction@{instruction}}
\subsubsection[{setAsBrDependent}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setAsBrDependent (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af3e4f5b3744955fa671e22f75da8b0a5}

\begin{DoxyCode}
                                                   {
        Assert(ins->getInsID() > _id);
        _brDependents->Append(ins);
}
\end{DoxyCode}
\hypertarget{classinstruction_ab2ba6828f1256186a787d933a6ca0868}{
\index{instruction@{instruction}!setAsDependent@{setAsDependent}}
\index{setAsDependent@{setAsDependent}!instruction@{instruction}}
\subsubsection[{setAsDependent}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setAsDependent (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab2ba6828f1256186a787d933a6ca0868}

\begin{DoxyCode}
                                                 {
        //if (_insStatus == complete) printf("-ins id: %d, type: %d\n", getInsID(
      ), getType());
        Assert(_insStatus != complete);
        _dependents->Append(ins);
}
\end{DoxyCode}
\hypertarget{classinstruction_ab2ba6828f1256186a787d933a6ca0868}{
\index{instruction@{instruction}!setAsDependent@{setAsDependent}}
\index{setAsDependent@{setAsDependent}!instruction@{instruction}}
\subsubsection[{setAsDependent}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setAsDependent (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab2ba6828f1256186a787d933a6ca0868}
\hypertarget{classinstruction_ab89bab28eb321e32fddfb44354c8245f}{
\index{instruction@{instruction}!setAsRegAncestor@{setAsRegAncestor}}
\index{setAsRegAncestor@{setAsRegAncestor}!instruction@{instruction}}
\subsubsection[{setAsRegAncestor}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setAsRegAncestor (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab89bab28eb321e32fddfb44354c8245f}

\begin{DoxyCode}
                                                   {
        if (ins->getInsAddr() > getInsAddr()) printf("\tAncestor Address %llx > D
      escendent Address %llx (%s, line: %d)\n", ins->getInsAddr(), getInsAddr(), __FILE
      __, __LINE__);
        _regAncestors->Append(ins);
}
\end{DoxyCode}
\hypertarget{classinstruction_a85be485a728d6539088c71dab3cdec0d}{
\index{instruction@{instruction}!setBBhead@{setBBhead}}
\index{setBBhead@{setBBhead}!instruction@{instruction}}
\subsubsection[{setBBhead}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setBBhead (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a85be485a728d6539088c71dab3cdec0d}

\begin{DoxyCode}
                            {
        _bbHead = true;
}
\end{DoxyCode}
\hypertarget{classinstruction_ae47d1153ed4be0ce3ba8e3c5b007e331}{
\index{instruction@{instruction}!setBBtail@{setBBtail}}
\index{setBBtail@{setBBtail}!instruction@{instruction}}
\subsubsection[{setBBtail}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setBBtail (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae47d1153ed4be0ce3ba8e3c5b007e331}

\begin{DoxyCode}
                            {
        _bbTail = true;
}
\end{DoxyCode}
\hypertarget{classinstruction_a613fd5dcaabf9a68596545679b17ffd8}{
\index{instruction@{instruction}!setBPaccuracy@{setBPaccuracy}}
\index{setBPaccuracy@{setBPaccuracy}!instruction@{instruction}}
\subsubsection[{setBPaccuracy}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setBPaccuracy (
\begin{DoxyParamCaption}
\item[{double}]{bpAccuracy}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a613fd5dcaabf9a68596545679b17ffd8}

\begin{DoxyCode}
                                                 {
        Assert((bpAccuracy >= 0.0 && bpAccuracy <= 1.0) && "bpAccuracy value is n
      ot recognized.");
        _bpAccuracy = bpAccuracy;
}
\end{DoxyCode}
\hypertarget{classinstruction_afa5bc75d50f79d6e6af4bf940086357a}{
\index{instruction@{instruction}!setBrAccuracy@{setBrAccuracy}}
\index{setBrAccuracy@{setBrAccuracy}!instruction@{instruction}}
\subsubsection[{setBrAccuracy}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setBrAccuracy (
\begin{DoxyParamCaption}
\item[{float}]{brBias}
\end{DoxyParamCaption}
)}}
\label{classinstruction_afa5bc75d50f79d6e6af4bf940086357a}

\begin{DoxyCode}
                                                 {
        Assert(brAccuracy >= 0.0 && brAccuracy <= 1.0);
        _brAccuracy = brAccuracy;
}
\end{DoxyCode}
\hypertarget{classinstruction_a0ee9ec109536e821189c53b82af33000}{
\index{instruction@{instruction}!setBrBias@{setBrBias}}
\index{setBrBias@{setBrBias}!instruction@{instruction}}
\subsubsection[{setBrBias}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setBrBias (
\begin{DoxyParamCaption}
\item[{float}]{brBias}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a0ee9ec109536e821189c53b82af33000}

\begin{DoxyCode}
                                         {
        Assert(brBias >= 0.0 && brBias <= 1.0);
        _brBias = brBias;
}
\end{DoxyCode}
\hypertarget{classinstruction_aeeee9fa55e89a75f59d160c0aad34a52}{
\index{instruction@{instruction}!setBrDst@{setBrDst}}
\index{setBrDst@{setBrDst}!instruction@{instruction}}
\subsubsection[{setBrDst}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setBrDst (
\begin{DoxyParamCaption}
\item[{{\bf ADDR}}]{brDst}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aeeee9fa55e89a75f59d160c0aad34a52}

\begin{DoxyCode}
                                     {
        Assert(brDst >= 0 && "brDst must be larger than zero.");
        _brDst = brDst;
}
\end{DoxyCode}
\hypertarget{classinstruction_a4e4a5a2f74a5c8420543cd42a0097d64}{
\index{instruction@{instruction}!setBrForward@{setBrForward}}
\index{setBrForward@{setBrForward}!instruction@{instruction}}
\subsubsection[{setBrForward}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setBrForward (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a4e4a5a2f74a5c8420543cd42a0097d64}

\begin{DoxyCode}
                               {
        Assert(_brTarget > 0 || _insAddr > 0);
        //long long int diff = _insAddr - _brTarget;
        //if      (diff < 0 && _insAddr < _brTarget) _brForward = true;
        //else if (diff > 0 && _insAddr > _brTarget) _brForward = false;
        //else Failure ("Compute overflow occured!");
}
\end{DoxyCode}
\hypertarget{classinstruction_a19971c1a97eb166b20b04085842f5fef}{
\index{instruction@{instruction}!setBrHeaderAddr@{setBrHeaderAddr}}
\index{setBrHeaderAddr@{setBrHeaderAddr}!instruction@{instruction}}
\subsubsection[{setBrHeaderAddr}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setBrHeaderAddr (
\begin{DoxyParamCaption}
\item[{{\bf INS\_\-ADDR}}]{brAddr}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a19971c1a97eb166b20b04085842f5fef}

\begin{DoxyCode}
                                                 {
        Assert(_bbHead == true);
        _brHeaderAddr = brAddr;
}
\end{DoxyCode}
\hypertarget{classinstruction_ad7dcd18feb686b41ab57e15e00cf04a6}{
\index{instruction@{instruction}!setBrMode@{setBrMode}}
\index{setBrMode@{setBrMode}!instruction@{instruction}}
\subsubsection[{setBrMode}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setBrMode (
\begin{DoxyParamCaption}
\item[{{\bf brMode}}]{branchMode}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ad7dcd18feb686b41ab57e15e00cf04a6}

\begin{DoxyCode}
                                             {
        _branchMode = branchMode;
}
\end{DoxyCode}
\hypertarget{classinstruction_a0cdb2aa4ff688f48a627a3e03baa6aad}{
\index{instruction@{instruction}!setBrSide@{setBrSide}}
\index{setBrSide@{setBrSide}!instruction@{instruction}}
\subsubsection[{setBrSide}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setBrSide (
\begin{DoxyParamCaption}
\item[{long int}]{brTaken}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a0cdb2aa4ff688f48a627a3e03baa6aad}

\begin{DoxyCode}
                                            {
        Assert(brTaken == 0 || brTaken == 1);
        brTaken == 0 ? _brTaken = false : _brTaken = true;
}
\end{DoxyCode}
\hypertarget{classinstruction_aabc818127836c8403b9c691985ca6d14}{
\index{instruction@{instruction}!setBrTakenBias@{setBrTakenBias}}
\index{setBrTakenBias@{setBrTakenBias}!instruction@{instruction}}
\subsubsection[{setBrTakenBias}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setBrTakenBias (
\begin{DoxyParamCaption}
\item[{double}]{brBias}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aabc818127836c8403b9c691985ca6d14}

\begin{DoxyCode}
                                              {
        Assert((brBias >= 0.0 && brBias <= 1.0) && "brBias value is not recognize
      d.");
        _brBias = brBias;
}
\end{DoxyCode}
\hypertarget{classinstruction_abb70bf9067cbb8427efa16050c1fd34a}{
\index{instruction@{instruction}!setBrTarget@{setBrTarget}}
\index{setBrTarget@{setBrTarget}!instruction@{instruction}}
\subsubsection[{setBrTarget}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setBrTarget (
\begin{DoxyParamCaption}
\item[{long int}]{brTarget}
\end{DoxyParamCaption}
)}}
\label{classinstruction_abb70bf9067cbb8427efa16050c1fd34a}

\begin{DoxyCode}
                                               {
        if (brTarget <= 0) printf("Branch Target Addr: %ld, ins = %s", brTarget, 
      getCmdStr());
        Assert(brTarget > 0);
        _brTarget = brTarget;
}
\end{DoxyCode}
\hypertarget{classinstruction_a060fa401d6b45027f08d827ef2ceb114}{
\index{instruction@{instruction}!setCacheHitLevel@{setCacheHitLevel}}
\index{setCacheHitLevel@{setCacheHitLevel}!instruction@{instruction}}
\subsubsection[{setCacheHitLevel}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setCacheHitLevel (
\begin{DoxyParamCaption}
\item[{int}]{hitLat}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a060fa401d6b45027f08d827ef2ceb114}

\begin{DoxyCode}
                                             {
        Assert(getType() == MEM);

        //Assume a 3-level cache system
        if (hitLat <=  cacheLat[0])
                _hitLevel = 1;
        else if (hitLat <=  cacheLat[1])
                _hitLevel = 2;
        else if (hitLat <=  cacheLat[2])
                _hitLevel = 3;
        else
                _hitLevel = 4;
}
\end{DoxyCode}
\hypertarget{classinstruction_a9006b031450e7290dc089f9edbc213c3}{
\index{instruction@{instruction}!setCauseOfFragInsID@{setCauseOfFragInsID}}
\index{setCauseOfFragInsID@{setCauseOfFragInsID}!instruction@{instruction}}
\subsubsection[{setCauseOfFragInsID}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setCauseOfFragInsID (
\begin{DoxyParamCaption}
\item[{{\bf INS\_\-ID}}]{causeOfFragInsID}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9006b031450e7290dc089f9edbc213c3}

\begin{DoxyCode}
                                                             {
        Assert(causeOfFragInsID != 0);
        _causeOfFragInsID = causeOfFragInsID;

}
\end{DoxyCode}
\hypertarget{classinstruction_adc61c4f03b740668fa8bf4b3e213f8f3}{
\index{instruction@{instruction}!setCmdStr@{setCmdStr}}
\index{setCmdStr@{setCmdStr}!instruction@{instruction}}
\subsubsection[{setCmdStr}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setCmdStr (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{cmd}
\end{DoxyParamCaption}
)}}
\label{classinstruction_adc61c4f03b740668fa8bf4b3e213f8f3}

\begin{DoxyCode}
                                            {
        strcpy(_command, cmd);
}
\end{DoxyCode}
\hypertarget{classinstruction_a99ed8de1173de1012b31333788a3e1a9}{
\index{instruction@{instruction}!setDepOnUPLD@{setDepOnUPLD}}
\index{setDepOnUPLD@{setDepOnUPLD}!instruction@{instruction}}
\subsubsection[{setDepOnUPLD}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setDepOnUPLD (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a99ed8de1173de1012b31333788a3e1a9}

\begin{DoxyCode}
                               {
        //Assert(_hasUPLDancestor == false); //TODO u should remove it i think
        _hasUPLDancestor = true;
}
\end{DoxyCode}
\hypertarget{classinstruction_affb2525016712f3bac93120d4d81961d}{
\index{instruction@{instruction}!setInsAddr@{setInsAddr}}
\index{setInsAddr@{setInsAddr}!instruction@{instruction}}
\subsubsection[{setInsAddr}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setInsAddr (
\begin{DoxyParamCaption}
\item[{{\bf ADDR}}]{insAddr}
\end{DoxyParamCaption}
)}}
\label{classinstruction_affb2525016712f3bac93120d4d81961d}

\begin{DoxyCode}
                                         {
        Assert(insAddr > 0 && "insAddr must be larger than zero.");
        _insAddr = insAddr;
}
\end{DoxyCode}
\hypertarget{classinstruction_ac39145295a94852d0a3efe8c8247473d}{
\index{instruction@{instruction}!setInsAddr@{setInsAddr}}
\index{setInsAddr@{setInsAddr}!instruction@{instruction}}
\subsubsection[{setInsAddr}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setInsAddr (
\begin{DoxyParamCaption}
\item[{{\bf ADDRS}}]{insAddr}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ac39145295a94852d0a3efe8c8247473d}

\begin{DoxyCode}
                                          {
        if (insAddr < 0) printf("%s\n",getCmdStr());
        Assert (insAddr >= 0);
        _insAddr = insAddr;
        //if (debug) printf("ins addr = %lx\n", _insAddr);
}
\end{DoxyCode}
\hypertarget{classinstruction_ae28df36b635c5359fa48a6476eebc425}{
\index{instruction@{instruction}!setInsAsm@{setInsAsm}}
\index{setInsAsm@{setInsAsm}!instruction@{instruction}}
\subsubsection[{setInsAsm}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setInsAsm (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{command}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ae28df36b635c5359fa48a6476eebc425}

\begin{DoxyCode}
{strcpy(_command, command);}
\end{DoxyCode}
\hypertarget{classinstruction_a3ad74e598e69178490590655303466a1}{
\index{instruction@{instruction}!setInsID@{setInsID}}
\index{setInsID@{setInsID}!instruction@{instruction}}
\subsubsection[{setInsID}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setInsID (
\begin{DoxyParamCaption}
\item[{{\bf INS\_\-ID}}]{id}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a3ad74e598e69178490590655303466a1}

\begin{DoxyCode}
                                    {
        _id = id;
}
\end{DoxyCode}
\hypertarget{classinstruction_a5052a04bf5db0d0e1519eb54f343bdc6}{
\index{instruction@{instruction}!setLdMissRate@{setLdMissRate}}
\index{setLdMissRate@{setLdMissRate}!instruction@{instruction}}
\subsubsection[{setLdMissRate}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setLdMissRate (
\begin{DoxyParamCaption}
\item[{double}]{missRate}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a5052a04bf5db0d0e1519eb54f343bdc6}

\begin{DoxyCode}
                                               {
        Assert(missRate >= 0 && missRate <= 1 && "Invalid miss rate fetched\n");
        _missRate = missRate;

        Assert(_latency != -1 && "Invalid latency value detected.");
        if (_missRate > UPLD_THRESHOLD) _latency = L2_LATENCY;
}
\end{DoxyCode}
\hypertarget{classinstruction_a46127cea18a5a4ec73566038a2454ecf}{
\index{instruction@{instruction}!setLongestPath@{setLongestPath}}
\index{setLongestPath@{setLongestPath}!instruction@{instruction}}
\subsubsection[{setLongestPath}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setLongestPath (
\begin{DoxyParamCaption}
\item[{int}]{longestPath}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a46127cea18a5a4ec73566038a2454ecf}

\begin{DoxyCode}
                                                {
        Assert(_longestPath == -1 && longestPath > 0 && "Invalid longest path val
      ue.");
        _longestPath = longestPath;
}
\end{DoxyCode}
\hypertarget{classinstruction_a4e1387f9782160c95597c81694ec0775}{
\index{instruction@{instruction}!setMemAccessSize@{setMemAccessSize}}
\index{setMemAccessSize@{setMemAccessSize}!instruction@{instruction}}
\subsubsection[{setMemAccessSize}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setMemAccessSize (
\begin{DoxyParamCaption}
\item[{long int}]{memAccessSize}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a4e1387f9782160c95597c81694ec0775}

\begin{DoxyCode}
                                                         {
        Assert (memAccessSize > 0);
        _memAccessSize = memAccessSize;
}
\end{DoxyCode}
\hypertarget{classinstruction_ab36280a1a2cd3339e45c8271deaa23d0}{
\index{instruction@{instruction}!setMemAccessSize@{setMemAccessSize}}
\index{setMemAccessSize@{setMemAccessSize}!instruction@{instruction}}
\subsubsection[{setMemAccessSize}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setMemAccessSize (
\begin{DoxyParamCaption}
\item[{int}]{memSize}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab36280a1a2cd3339e45c8271deaa23d0}

\begin{DoxyCode}
                                              { //in bytes
        Assert(memSize > 0 && "invalid memSize value");
        // Assert((memSize == 1 || memSize == 2 || memSize == 4 || memSize == 8 |
      | memSize == 16 || memSize == 32) && "invalid memSize value");
        _memSize = memSize; //TODO this way of assigning memory sizes is wrong. y
      ou should do this based on dynamic execution informaiton
}
\end{DoxyCode}
\hypertarget{classinstruction_a69e75dc34c4197b03e33a0032ae03e8f}{
\index{instruction@{instruction}!setMemAddr@{setMemAddr}}
\index{setMemAddr@{setMemAddr}!instruction@{instruction}}
\subsubsection[{setMemAddr}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setMemAddr (
\begin{DoxyParamCaption}
\item[{{\bf ADDRS}}]{memAddr}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a69e75dc34c4197b03e33a0032ae03e8f}

\begin{DoxyCode}
                                          {
        Assert (memAddr >= 0);
        _memAddr = memAddr;
        //if (debug) printf("addr = %lx\n", _memAddr);
}
\end{DoxyCode}
\hypertarget{classinstruction_a6c57d75878f06764457f4faaabe5de00}{
\index{instruction@{instruction}!setMemType@{setMemType}}
\index{setMemType@{setMemType}!instruction@{instruction}}
\subsubsection[{setMemType}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setMemType (
\begin{DoxyParamCaption}
\item[{{\bf memType}}]{readORwrite}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a6c57d75878f06764457f4faaabe5de00}

\begin{DoxyCode}
                                                 {
        Assert(readORwrite >= none && readORwrite <= WRITE);
        _readORwrite = readORwrite;
}
\end{DoxyCode}
\hypertarget{classinstruction_a0b5a3de8a08da1f9e0c9d8cbff5ba8ce}{
\index{instruction@{instruction}!setMissRate@{setMissRate}}
\index{setMissRate@{setMissRate}!instruction@{instruction}}
\subsubsection[{setMissRate}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setMissRate (
\begin{DoxyParamCaption}
\item[{double}]{missRate}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a0b5a3de8a08da1f9e0c9d8cbff5ba8ce}

\begin{DoxyCode}
                                             {
        //printf("missRate = %f\n",missRate);
        Assert(missRate >= 0.0 && missRate <= 1.0); 
        _missRate = missRate;
        if (getMemType() == READ && 
            _missRate > unpredMemOpThreshold) {
                setDepOnUPLD();
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_af78c579e9c3b74dfc72c5bbfb573deab}{
\index{instruction@{instruction}!setMy\_\-BBorPB\_\-id@{setMy\_\-BBorPB\_\-id}}
\index{setMy\_\-BBorPB\_\-id@{setMy\_\-BBorPB\_\-id}!instruction@{instruction}}
\subsubsection[{setMy\_\-BBorPB\_\-id}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setMy\_\-BBorPB\_\-id (
\begin{DoxyParamCaption}
\item[{{\bf ADDR}}]{id}
\end{DoxyParamCaption}
)}}
\label{classinstruction_af78c579e9c3b74dfc72c5bbfb573deab}

\begin{DoxyCode}
                                          {
        Assert(id > 0 && "BB or PB id is invalid.");
        _myBBs.insert(id);
}
\end{DoxyCode}
\hypertarget{classinstruction_a8fb8324e5524fb201e1377ad3e8e2c3b}{
\index{instruction@{instruction}!setMyFrag@{setMyFrag}}
\index{setMyFrag@{setMyFrag}!instruction@{instruction}}
\subsubsection[{setMyFrag}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setMyFrag (
\begin{DoxyParamCaption}
\item[{{\bf fragment} $\ast$}]{ph}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a8fb8324e5524fb201e1377ad3e8e2c3b}

\begin{DoxyCode}
                                        {
        Assert(_myFragID == -1 && fr->getFragID() >= 0);
        _myFragID = fr->getFragID();
        _myFrag = fr;
}
\end{DoxyCode}
\hypertarget{classinstruction_aa2c3a45485ab0112df0187f08fd8a143}{
\index{instruction@{instruction}!setMyPhrase@{setMyPhrase}}
\index{setMyPhrase@{setMyPhrase}!instruction@{instruction}}
\subsubsection[{setMyPhrase}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setMyPhrase (
\begin{DoxyParamCaption}
\item[{{\bf phrase} $\ast$}]{ph}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aa2c3a45485ab0112df0187f08fd8a143}

\begin{DoxyCode}
                                        {
        Assert(_myPhraseID == -1 && ph->getPhraseID() > -1);
        _myPhraseID = ph->getPhraseID();
        _myPhrase = ph;
}
\end{DoxyCode}
\hypertarget{classinstruction_a9cf32c7fceaedc65fc68fc8711eef824}{
\index{instruction@{instruction}!setMyPhraseID@{setMyPhraseID}}
\index{setMyPhraseID@{setMyPhraseID}!instruction@{instruction}}
\subsubsection[{setMyPhraseID}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setMyPhraseID (
\begin{DoxyParamCaption}
\item[{int}]{id}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9cf32c7fceaedc65fc68fc8711eef824}

\begin{DoxyCode}
                                      {
        if (_myPhraseID != -1) printf("id: %d, type: %d", _myPhraseID, getType())
      ;
        Assert(_myPhraseID == -1);
        _myPhraseID = id;
}
\end{DoxyCode}
\hypertarget{classinstruction_a7a4adbec8d2e9a2cb6090168530e336c}{
\index{instruction@{instruction}!setOpCode@{setOpCode}}
\index{setOpCode@{setOpCode}!instruction@{instruction}}
\subsubsection[{setOpCode}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setOpCode (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{opCode}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a7a4adbec8d2e9a2cb6090168530e336c}

\begin{DoxyCode}
{strcpy(_opCode, opCode);}
\end{DoxyCode}
\hypertarget{classinstruction_a331fb003e92ca7a8b86d95157ecbd122}{
\index{instruction@{instruction}!setPiepelineLat@{setPiepelineLat}}
\index{setPiepelineLat@{setPiepelineLat}!instruction@{instruction}}
\subsubsection[{setPiepelineLat}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setPiepelineLat (
\begin{DoxyParamCaption}
\item[{int}]{pipeLineLat}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a331fb003e92ca7a8b86d95157ecbd122}

\begin{DoxyCode}
                                                  {
        Assert (pipeLineLat > 0);
        _pipeLineLat = pipeLineLat;
}
\end{DoxyCode}
\hypertarget{classinstruction_a71e3f3ce675bfada57fa6ece90336880}{
\index{instruction@{instruction}!setPredHistObj@{setPredHistObj}}
\index{setPredHistObj@{setPredHistObj}!instruction@{instruction}}
\subsubsection[{setPredHistObj}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setPredHistObj (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{bp\_\-hist}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a71e3f3ce675bfada57fa6ece90336880}

\begin{DoxyCode}
                                              {
        Assert(bp_hist != NULL && "bp_hist object must not be null");
        _bp_hist = bp_hist;
}
\end{DoxyCode}
\hypertarget{classinstruction_afc0e97320e3110a0c3870f4537b913fe}{
\index{instruction@{instruction}!setPrediction@{setPrediction}}
\index{setPrediction@{setPrediction}!instruction@{instruction}}
\subsubsection[{setPrediction}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setPrediction (
\begin{DoxyParamCaption}
\item[{bool}]{brPred}
\end{DoxyParamCaption}
)}}
\label{classinstruction_afc0e97320e3110a0c3870f4537b913fe}

\begin{DoxyCode}
                                           {
        Assert(getBrMode() == dynPredBr && "wrong usage of the function");
        Assert(getType() == BR);
        _brPred = brPred;
}
\end{DoxyCode}
\hypertarget{classinstruction_a379cbb0fb6bbe15168c6eac05a37114f}{
\index{instruction@{instruction}!setRdAddrSet@{setRdAddrSet}}
\index{setRdAddrSet@{setRdAddrSet}!instruction@{instruction}}
\subsubsection[{setRdAddrSet}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setRdAddrSet (
\begin{DoxyParamCaption}
\item[{set$<$ {\bf ADDR} $>$ \&}]{addrSet}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a379cbb0fb6bbe15168c6eac05a37114f}

\begin{DoxyCode}
                                                 {
        _memRdAddr = addrSet;
        printf("debug: read set of ins %llx: %d\n", getInsAddr(), _memRdAddr.size
      ());
}
\end{DoxyCode}
\hypertarget{classinstruction_a0d47af8822438b6e838c08dbd31cc02c}{
\index{instruction@{instruction}!setRdMemType@{setRdMemType}}
\index{setRdMemType@{setRdMemType}!instruction@{instruction}}
\subsubsection[{setRdMemType}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setRdMemType (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a0d47af8822438b6e838c08dbd31cc02c}

\begin{DoxyCode}
                               {
        Assert(_memRead == false && "invalid _memWrite value");
        _memRead = true;        
}
\end{DoxyCode}
\hypertarget{classinstruction_a093ff19f17baaf84d4539ea395468265}{
\index{instruction@{instruction}!setReadVar@{setReadVar}}
\index{setReadVar@{setReadVar}!instruction@{instruction}}
\subsubsection[{setReadVar}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setReadVar (
\begin{DoxyParamCaption}
\item[{int}]{var, }
\item[{int}]{subscript}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a093ff19f17baaf84d4539ea395468265}

\begin{DoxyCode}
                                                   {
        Assert((var <= X86_REG_HI && var >= X86_REG_LO) && "Invalid architectural
       register assignment.");
        Assert((subscript >= 0 || subscript == -2) && "Invalid SSA register assig
      nment value");
        // printf("ins (%llx): %d_%d\n", getInsAddr(),var,subscript);
        if (_readVar.find(var) != _readVar.end() && subscript != _readVar[var]) 
                printf("\tWARNING: Rewriting an already assigned READ reg (old:%d
      ,new:%d)\n", subscript,_readVar[var]);
        if (_readVar.find(var) != _readVar.end() && subscript!=-2 && _readVar[var
      ]==-2)
                _readVar.erase(var);
        _readVar.insert(pair<int,int>(var,subscript));
}
\end{DoxyCode}
\hypertarget{classinstruction_a21509e081fdfd3665c30d1bab3e1fd45}{
\index{instruction@{instruction}!setReadyLists@{setReadyLists}}
\index{setReadyLists@{setReadyLists}!instruction@{instruction}}
\subsubsection[{setReadyLists}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setReadyLists (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{rootALUins, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{rootMEMins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a21509e081fdfd3665c30d1bab3e1fd45}

\begin{DoxyCode}
                                                                                 
                   {
        if (getType() == MEM) {
                _rootList = rootMEMins;
        } else {
                _rootList = rootALUins;
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a456de8aa26ff79d2b7cd203f7c59f2cb}{
\index{instruction@{instruction}!setRegister@{setRegister}}
\index{setRegister@{setRegister}!instruction@{instruction}}
\subsubsection[{setRegister}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setRegister (
\begin{DoxyParamCaption}
\item[{long int $\ast$}]{r, }
\item[{int $\ast$}]{rt}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a456de8aa26ff79d2b7cd203f7c59f2cb}
\hypertarget{classinstruction_a456de8aa26ff79d2b7cd203f7c59f2cb}{
\index{instruction@{instruction}!setRegister@{setRegister}}
\index{setRegister@{setRegister}!instruction@{instruction}}
\subsubsection[{setRegister}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setRegister (
\begin{DoxyParamCaption}
\item[{long int $\ast$}]{r, }
\item[{int $\ast$}]{rt}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a456de8aa26ff79d2b7cd203f7c59f2cb}

\begin{DoxyCode}
                                                   {
        long int tempR = *r;
        int tempRT = *rt;
        //Assert(tempR >= 1); //TODO this is remved to enable instruction injecti
      on
        Assert(tempRT >= READ && tempRT <= WRITE);
        (_r)->Append(tempR);
        (_rt)->Append(tempRT);
        if (tempRT == WRITE) _numWriteReg++;
        //if (debug) printf("reg = %d, type = %d\n", tempR, tempRT);
}
\end{DoxyCode}
\hypertarget{classinstruction_ab4b1bbe98c775d3a1fab0ed281a4ad4f}{
\index{instruction@{instruction}!setStatus@{setStatus}}
\index{setStatus@{setStatus}!instruction@{instruction}}
\subsubsection[{setStatus}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setStatus (
\begin{DoxyParamCaption}
\item[{{\bf status}}]{insStatus, }
\item[{long int}]{cycle, }
\item[{int}]{latency}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab4b1bbe98c775d3a1fab0ed281a4ad4f}

\begin{DoxyCode}
                                         {
        Assert(insStatus != NO_STAGE);
        _insStatus = insStatus;
        if (_insStatus == execute) {
                _executeCycle  = cycle;
                _latency     = latency;
                _completeCycle = cycle + (long int)latency;
                if (getType() == MEM) { //This block is used for LSQ (Naive, Stor
      e Set, etc)
                        Assert(latency >= ADDR_COMPUTE_LATENCY);
                        _memAddrCompCompleteCycle = cycle + ADDR_COMPUTE_LATENCY;
      
                }
        } else if (_insStatus == FETCH) {
                _fetchEndCycle = cycle + FETCH_STATE_LATENCY;
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_ad9c7d979b5f4b00189973e47caa3411f}{
\index{instruction@{instruction}!setType@{setType}}
\index{setType@{setType}!instruction@{instruction}}
\subsubsection[{setType}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setType (
\begin{DoxyParamCaption}
\item[{{\bf type}}]{insType}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ad9c7d979b5f4b00189973e47caa3411f}

\begin{DoxyCode}
                                       {
        Assert(insType != noType);
        _insType = insType;
}
\end{DoxyCode}
\hypertarget{classinstruction_aa6ff7d5323483cf18c10687ed8c1dc73}{
\index{instruction@{instruction}!setType@{setType}}
\index{setType@{setType}!instruction@{instruction}}
\subsubsection[{setType}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setType (
\begin{DoxyParamCaption}
\item[{const char}]{insType}
\end{DoxyParamCaption}
)}}
\label{classinstruction_aa6ff7d5323483cf18c10687ed8c1dc73}

\begin{DoxyCode}
                                            {
        Assert((insType == 'j' || insType == 'o' || insType == 'c' || 
                insType == 'r' || insType == 'b' || insType == 'M') && "insType v
      alue is not recognized.");
        if (_insType != 'x') return; //Do not set type more than once
        Assert(_latency == -1 && "Invalid latency value detected.");
        _insType = insType;
        if (getType() == 'b') {
                _brBias = 0.5;
                _bpAccuracy = 0.5;
                _latency = BR_LATENCY;
        } else if (getType()  == 'c' || getType()  == 'j') {
                _brBias = 1.0;
                _bpAccuracy = 1.0;
                _latency = ALU_LATENCY;
        } else if (getType() == 'M') {
                _brBias = 0.0;
                _bpAccuracy = 1.0;
                _latency = L1_LATENCY;
        } else { //NOTE: in this not wrong to do? covers fall through paths that 
      are not all branch ops
                _brBias = 0.0;
                _bpAccuracy = 1.0;
                _latency = ALU_LATENCY;
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_ab2079e0fa9269a24ae4597eaaad67918}{
\index{instruction@{instruction}!setVliwScheduler@{setVliwScheduler}}
\index{setVliwScheduler@{setVliwScheduler}!instruction@{instruction}}
\subsubsection[{setVliwScheduler}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setVliwScheduler (
\begin{DoxyParamCaption}
\item[{{\bf vliwScheduler} $\ast$}]{scheduler}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab2079e0fa9269a24ae4597eaaad67918}

\begin{DoxyCode}
                                                           {
      _scheduler = scheduler;
}
\end{DoxyCode}
\hypertarget{classinstruction_a8928d9fe638fd7307606fac71a31b681}{
\index{instruction@{instruction}!setWrAddrSet@{setWrAddrSet}}
\index{setWrAddrSet@{setWrAddrSet}!instruction@{instruction}}
\subsubsection[{setWrAddrSet}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setWrAddrSet (
\begin{DoxyParamCaption}
\item[{set$<$ {\bf ADDR} $>$ \&}]{addrSet}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a8928d9fe638fd7307606fac71a31b681}

\begin{DoxyCode}
                                                 {
        _memWrAddr = addrSet;
        printf("debug: write set of ins %llx: %d\n", getInsAddr(), _memWrAddr.siz
      e());
}
\end{DoxyCode}
\hypertarget{classinstruction_a67c584522eaa68d46a495170ce8a3bbd}{
\index{instruction@{instruction}!setWriteVar@{setWriteVar}}
\index{setWriteVar@{setWriteVar}!instruction@{instruction}}
\subsubsection[{setWriteVar}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setWriteVar (
\begin{DoxyParamCaption}
\item[{int}]{var, }
\item[{int}]{subscript}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a67c584522eaa68d46a495170ce8a3bbd}

\begin{DoxyCode}
                                                    {
        Assert((var <= X86_REG_HI && var >= X86_REG_LO) && "Invalid architectural
       register assignment.");
        Assert(subscript >= 0 && "Invalid SSA register assignment value");
        if (_writeVar.find(var) != _writeVar.end()) printf("trying to rewrite an 
      already assigned write register(old:%d,new:%d)\n", subscript,_writeVar[var]);
        if (_writeVar.find(var) != _writeVar.end() && subscript>0 && _writeVar[va
      r]==0)
                _writeVar.erase(var);
        _writeVar.insert(pair<int,int>(var,subscript));
}
\end{DoxyCode}
\hypertarget{classinstruction_a1a85e010b731e20bcd25310a26eabd98}{
\index{instruction@{instruction}!setWrMemType@{setWrMemType}}
\index{setWrMemType@{setWrMemType}!instruction@{instruction}}
\subsubsection[{setWrMemType}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::setWrMemType (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a1a85e010b731e20bcd25310a26eabd98}

\begin{DoxyCode}
                               {
        Assert(_memWrite == false && "invalid _memWrite value");
        _memWrite = true;
}
\end{DoxyCode}
\hypertarget{classinstruction_ad515289a10c6e269fda95c07dd7112bb}{
\index{instruction@{instruction}!squashBrDep@{squashBrDep}}
\index{squashBrDep@{squashBrDep}!instruction@{instruction}}
\subsubsection[{squashBrDep}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::squashBrDep (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ad515289a10c6e269fda95c07dd7112bb}

\begin{DoxyCode}
                                              {
        Assert(getType() == BR);
        for (int i = _brDependents->NumElements()-1; i >= 0 ; i--) {
                if (ins->getInsID() == _brDependents->Nth(i)->getInsID()) {
                        _brDependents->RemoveAt(i);
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a9643852ed74b72636a5327a6278fe12f}{
\index{instruction@{instruction}!squashDep@{squashDep}}
\index{squashDep@{squashDep}!instruction@{instruction}}
\subsubsection[{squashDep}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::squashDep (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9643852ed74b72636a5327a6278fe12f}

\begin{DoxyCode}
                                            {
        for (int i = _dependents->NumElements()-1; i >= 0 ; i--) {
                if (ins->getInsID() == _dependents->Nth(i)->getInsID()) {
                        _dependents->RemoveAt(i);
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a9860d38bd4eed33f9047b7829173d183}{
\index{instruction@{instruction}!squashRenameReg@{squashRenameReg}}
\index{squashRenameReg@{squashRenameReg}!instruction@{instruction}}
\subsubsection[{squashRenameReg}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::squashRenameReg (
\begin{DoxyParamCaption}
\item[{{\bf registerRename} $\ast$}]{GRF}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a9860d38bd4eed33f9047b7829173d183}

\begin{DoxyCode}
                                                     {
        for (int i = 0; i < _pr->NumElements(); i++) {
                PR p_reg = _pr->Nth(i);
                Assert(_pTOaRegMap.find(p_reg) != _pTOaRegMap.end());
                GRF->squashRAT(_pTOaRegMap[p_reg]);
                GRF->squashARST(p_reg);
                GRF->squashPRFSM(p_reg);
                GRF->setAsAvailablePR(p_reg);
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_ab817675ba27852b024c813bb5387b058}{
\index{instruction@{instruction}!storeOrder\_\-MemDependencyTable@{storeOrder\_\-MemDependencyTable}}
\index{storeOrder\_\-MemDependencyTable@{storeOrder\_\-MemDependencyTable}!instruction@{instruction}}
\subsubsection[{storeOrder\_\-MemDependencyTable}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::storeOrder\_\-MemDependencyTable (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ancestor}
\end{DoxyParamCaption}
)}}
\label{classinstruction_ab817675ba27852b024c813bb5387b058}

\begin{DoxyCode}
                                                                      {
        //Enforce INO execution of ST operations
        if (ancestor == NULL) printf("empty\n");
        if (getMemType() == WRITE) {
                if (ancestor->getStatus() != complete) { //WAW
                        addDep();
                        ancestor->setAsDependent(this);
                        setAsAncestor(ancestor);
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a939213a50cdd3a5e31f6d543d5408b15}{
\index{instruction@{instruction}!totalOrder\_\-MemDependencyTable@{totalOrder\_\-MemDependencyTable}}
\index{totalOrder\_\-MemDependencyTable@{totalOrder\_\-MemDependencyTable}!instruction@{instruction}}
\subsubsection[{totalOrder\_\-MemDependencyTable}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::totalOrder\_\-MemDependencyTable (
\begin{DoxyParamCaption}
\item[{{\bf lsq} $\ast$}]{totalOrderLSQ}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a939213a50cdd3a5e31f6d543d5408b15}

\begin{DoxyCode}
                                                                   {
        if (getMemType() == READ && !totalOrderLSQ->isSQempty()) {
                instruction* ancestor = totalOrderLSQ->getSQtail();
                if (ancestor->getStatus() != complete) { //WAR and RAW
                        addDep();
                        ancestor->setAsDependent(this);
                        setAsAncestor(ancestor);
                }
        } else if (getMemType() == WRITE) {
                if (totalOrderLSQ->isSQfull()) {
                        //STALL (add code here)
                } else {
                        if (!totalOrderLSQ->isSQempty()) {
                                instruction* ancestor = totalOrderLSQ->getSQtail(
      );
                                if (ancestor->getStatus() != complete) { //WAW
                                        addDep();
                                        ancestor->setAsDependent(this);
                                        setAsAncestor(ancestor);
                                }
                        }
                        totalOrderLSQ->pushBackSQ(this);
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a8ef95c2bb6b131c4ce3f33cfc124c748}{
\index{instruction@{instruction}!updateDepTableEntris@{updateDepTableEntris}}
\index{updateDepTableEntris@{updateDepTableEntris}!instruction@{instruction}}
\subsubsection[{updateDepTableEntris}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::updateDepTableEntris (
\begin{DoxyParamCaption}
\item[{{\bf dependencyTable} $\ast$}]{depTables, }
\item[{int}]{coreType, }
\item[{{\bf instruction} $\ast$}]{replaceIns}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a8ef95c2bb6b131c4ce3f33cfc124c748}

\begin{DoxyCode}
                                                                                 
                             {
        //printf("command = %s\n", _command);
        Assert(getMemType() == READ && getMissrate() > unpredMemOpThreshold);
        //Assert(getMemType() != WRITE && getType() != BR && getType() != ASSIGN)
      ; // && getType() != ALU);
        for (int i = 0; i < _r->NumElements(); i++) {
                if (_rt->Nth(i) == WRITE) {
                        depTables->addReg(_r->Nth(i), replaceIns, REG_WRITE);
                }
        }
}
\end{DoxyCode}
\hypertarget{classinstruction_a818803cc54cb0b34c373ad6537976014}{
\index{instruction@{instruction}!updateLatency@{updateLatency}}
\index{updateLatency@{updateLatency}!instruction@{instruction}}
\subsubsection[{updateLatency}]{\setlength{\rightskip}{0pt plus 5cm}void instruction::updateLatency (
\begin{DoxyParamCaption}
\item[{long int}]{cycle, }
\item[{int}]{latency}
\end{DoxyParamCaption}
)}}
\label{classinstruction_a818803cc54cb0b34c373ad6537976014}

\begin{DoxyCode}
                                                           {
        Assert(_executeCycle > -1 && _executeCycle < cycle);
        _latency       = (latency-(ADDR_COMPUTE_LATENCY+CAM_ACCESS_LATENCY))+(
      cycle-_executeCycle+1);
        _completeCycle = _executeCycle + _latency;
}
\end{DoxyCode}


\subsection{Member Data Documentation}
\hypertarget{classinstruction_ac1dd06cf09542ab004237f1dddd1da02}{
\index{instruction@{instruction}!\_\-ancestors@{\_\-ancestors}}
\index{\_\-ancestors@{\_\-ancestors}!instruction@{instruction}}
\subsubsection[{\_\-ancestors}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$ {\bf instruction::\_\-ancestors}}}
\label{classinstruction_ac1dd06cf09542ab004237f1dddd1da02}
\hypertarget{classinstruction_a50304cae9052c65b138274a96edfbca0}{
\index{instruction@{instruction}!\_\-dependents@{\_\-dependents}}
\index{\_\-dependents@{\_\-dependents}!instruction@{instruction}}
\subsubsection[{\_\-dependents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$ {\bf instruction::\_\-dependents}}}
\label{classinstruction_a50304cae9052c65b138274a96edfbca0}
\hypertarget{classinstruction_a060702a038491fdd3e98661fec166fa4}{
\index{instruction@{instruction}!\_\-guardian@{\_\-guardian}}
\index{\_\-guardian@{\_\-guardian}!instruction@{instruction}}
\subsubsection[{\_\-guardian}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf instruction::\_\-guardian}}}
\label{classinstruction_a060702a038491fdd3e98661fec166fa4}
\hypertarget{classinstruction_a728468d228311067d26e390b263dc140}{
\index{instruction@{instruction}!\_\-phraseAncestors@{\_\-phraseAncestors}}
\index{\_\-phraseAncestors@{\_\-phraseAncestors}!instruction@{instruction}}
\subsubsection[{\_\-phraseAncestors}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<${\bf instruction}$\ast$$>$$\ast$ {\bf instruction::\_\-phraseAncestors}}}
\label{classinstruction_a728468d228311067d26e390b263dc140}
\hypertarget{classinstruction_a2631d0b5947d06f6ff13170e6dc88f78}{
\index{instruction@{instruction}!\_\-phraseAncestorsID@{\_\-phraseAncestorsID}}
\index{\_\-phraseAncestorsID@{\_\-phraseAncestorsID}!instruction@{instruction}}
\subsubsection[{\_\-phraseAncestorsID}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$int$>$$\ast$ {\bf instruction::\_\-phraseAncestorsID}}}
\label{classinstruction_a2631d0b5947d06f6ff13170e6dc88f78}


The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
/home/milad/esc\_\-project/svn/PARS/src/backend/\hyperlink{backend_2instruction_8h}{instruction.h}\item 
/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/\hyperlink{binaryTranslator_2instruction_8h}{instruction.h}\item 
/home/milad/esc\_\-project/svn/PARS/src/backend/\hyperlink{backend_2instruction_8cpp}{instruction.cpp}\item 
/home/milad/esc\_\-project/svn/PARS/src/backend/\hyperlink{backend_2stat_8cpp}{stat.cpp}\item 
/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/\hyperlink{binaryTranslator_2instruction_8cpp}{instruction.cpp}\end{DoxyCompactItemize}
