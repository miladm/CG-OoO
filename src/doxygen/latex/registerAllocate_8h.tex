\hypertarget{registerAllocate_8h}{
\section{/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/registerAllocate.h File Reference}
\label{registerAllocate_8h}\index{/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/registerAllocate.h@{/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/registerAllocate.h}}
}
{\ttfamily \#include $<$list$>$}\par
{\ttfamily \#include $<$set$>$}\par
{\ttfamily \#include $<$map$>$}\par
{\ttfamily \#include $<$vector$>$}\par
{\ttfamily \#include \char`\"{}global.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}interfNode.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}basicblock.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}instruction.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}listSchedule.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}dependencySetup.h\char`\"{}}\par
Include dependency graph for registerAllocate.h:
This graph shows which files directly or indirectly include this file:
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{registerAllocate_8h_a89206e9b97c233cca9ffa40229a32a77}{allocate\_\-register} (\hyperlink{classList}{List}$<$ \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$bbList, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$insList, map$<$ \hyperlink{binaryTranslator_2global_8h_a8bb6b77b3aab51e3a8d1866dd5861225}{ADDR}, \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$insAddrMap, \hyperlink{binaryTranslator_2global_8h_a78dd04e0a4364ff551d83095f9bc0264}{REG\_\-ALLOC\_\-MODE} reg\_\-alloc\_\-mode, \hyperlink{binaryTranslator_2global_8h_a81dba944bc61f5b25a3513766ef6651b}{SCH\_\-MODE} sch\_\-mode)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{registerAllocate_8h_a89206e9b97c233cca9ffa40229a32a77}{
\index{registerAllocate.h@{registerAllocate.h}!allocate\_\-register@{allocate\_\-register}}
\index{allocate\_\-register@{allocate\_\-register}!registerAllocate.h@{registerAllocate.h}}
\subsubsection[{allocate\_\-register}]{\setlength{\rightskip}{0pt plus 5cm}void allocate\_\-register (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf basicblock} $\ast$ $>$ $\ast$}]{bbList, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{insList, }
\item[{map$<$ {\bf ADDR}, {\bf instruction} $\ast$ $>$ $\ast$}]{insAddrMap, }
\item[{{\bf REG\_\-ALLOC\_\-MODE}}]{reg\_\-alloc\_\-mode, }
\item[{{\bf SCH\_\-MODE}}]{sch\_\-mode}
\end{DoxyParamCaption}
)}}
\label{registerAllocate_8h_a89206e9b97c233cca9ffa40229a32a77}

\begin{DoxyCode}
                                           {
        List<basicblock*> *interiorBB = new List<basicblock*>;
        map<long int,interfNode*> localIntfNodeMap, globalIntfNodeMap, allIntfNod
      eMap;

    setupValidBBs (bbList);

        printf ("\tPhi-Function Elimination\n");
        int numInsInsertion = eliminatePhiFuncs (bbList, insAddrMap);

        printf ("\tSSA Rename & Build Def/Use Set\n");
        renameAndbuildDefUseSets (bbList); //TODO: make sure this step does not i
      mpact next step

        printf ("\tLiveness Analysis\n");
        livenessAnalysis (bbList, reg_alloc_mode, insAddrMap);

    setupValidBBs (bbList);

        printf ("\tFind Graph Entry Points\n");
        findEntryPoints (bbList, interiorBB);


        /* PERFORM LIST SCHEDULING ON BB */
    printf ("\tSetup Dependency Table\n");
    dependencySetup (bbList, insList);
    if (sch_mode == LIST_SCH) {
        printf ("\tRun List Scheduling\n");
        for  (int i = 0; i < bbList->NumElements (); i++) {
            basicblock* bb = bbList->Nth (i);
            listSchedule (bb); //why does this affect BB structure?
        }
    }

        //TODO is the block below okay? needed?
        for (int i = 0; i < bbList->NumElements (); i++)
                bbList->Nth (i)->setAsUnvisited ();

        printf ("\tBuild Interference Graph & Run Register Assignment\n");
        for (int i = 0; i < interiorBB->NumElements (); i++) {
                basicblock* bbHead = interiorBB->Nth (i);
                localIntfNodeMap.clear ();
                globalIntfNodeMap.clear ();
                allIntfNodeMap.clear ();
                make_interference_nodes_network (bbHead, globalIntfNodeMap, local
      IntfNodeMap,allIntfNodeMap, reg_alloc_mode);
                assign_global_registers (localIntfNodeMap, globalIntfNodeMap, all
      IntfNodeMap);
                set_arch_reg_for_all_ins (bbHead, allIntfNodeMap);
        }
    printf ("\tNumber of BB NOT register allocated: %d\n", 
      num_bb_not_reg_allocated);

        for (int i = 0; i < bbList->NumElements (); i++) {      
                basicblock* bb = bbList->Nth (i);
                // Assert (bb->isVisited ()); //all BB must be visited by now //T
      ODO put this back ASAP
                bb->setAsUnvisited ();
        }

        printf ("\tNumber of Phi MOV instructions: %d added to the %d static prog
      ram instructions\n", numInsInsertion, insList->NumElements ());
        printf ("\tMAX number of global/local live variables: %d / %d\n", liveGlb
      MaxSize, liveLclMaxSize);
        printf ("\tLocal Registers Allocated: %d | Global Registers Allocated: %d
      \n", localRegCnt, globalRegCnt);

        delete interiorBB;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


