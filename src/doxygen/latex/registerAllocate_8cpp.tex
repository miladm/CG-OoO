\hypertarget{registerAllocate_8cpp}{
\section{/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/registerAllocate.cpp File Reference}
\label{registerAllocate_8cpp}\index{/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/registerAllocate.cpp@{/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/registerAllocate.cpp}}
}
{\ttfamily \#include \char`\"{}registerAllocate.h\char`\"{}}\par
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{registerAllocate_8cpp_aa1b9aef4bd270d92ee493acef4c5cffa}{eliminatePhiFuncs} (\hyperlink{classList}{List}$<$ \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$bbList)
\item 
void \hyperlink{registerAllocate_8cpp_a398558d22a764dcc2fdc74639b3f56c6}{renameAndbuildDefUseSets} (\hyperlink{classList}{List}$<$ \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$bbList)
\item 
void \hyperlink{registerAllocate_8cpp_a3511145027350bf1c4fab3a22f79be40}{findEntryPoints} (\hyperlink{classList}{List}$<$ \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$bbList, \hyperlink{classList}{List}$<$ \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$interiorBB)
\item 
void \hyperlink{registerAllocate_8cpp_a890d083ac7d418402e1acbcda4930e1b}{livenessAnalysis} (\hyperlink{classList}{List}$<$ \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$bbList)
\item 
void \hyperlink{registerAllocate_8cpp_a66bb4ccca1dacd495fef9d58f1ed6620}{assign\_\-local\_\-registers} (map$<$ long int, \hyperlink{classinterfNode}{interfNode} $\ast$ $>$ \&locallIntfNodeMap, map$<$ long int, \hyperlink{classinterfNode}{interfNode} $\ast$ $>$ \&allIntfNodeMap)
\item 
void \hyperlink{registerAllocate_8cpp_ad793e858badbde1ceff1536fc3145c65}{assign\_\-global\_\-registers} (map$<$ long int, \hyperlink{classinterfNode}{interfNode} $\ast$ $>$ \&locallIntfNodeMap, map$<$ long int, \hyperlink{classinterfNode}{interfNode} $\ast$ $>$ \&globalIntfNodeMap, map$<$ long int, \hyperlink{classinterfNode}{interfNode} $\ast$ $>$ \&allIntfNodeMap)
\item 
void \hyperlink{registerAllocate_8cpp_a44ba610b0d634eb37dc4a1228f9fe6d7}{make\_\-interference\_\-nodes\_\-network} (\hyperlink{classbasicblock}{basicblock} $\ast$bb, map$<$ long int, \hyperlink{classinterfNode}{interfNode} $\ast$ $>$ \&globalIntfNodeMap, map$<$ long int, \hyperlink{classinterfNode}{interfNode} $\ast$ $>$ \&locallIntfNodeMap, map$<$ long int, \hyperlink{classinterfNode}{interfNode} $\ast$ $>$ \&allIntfNodeMap)
\item 
void \hyperlink{registerAllocate_8cpp_aaf92c40633364d00817ec3f029a77f3c}{set\_\-arch\_\-reg\_\-for\_\-all\_\-ins} (\hyperlink{classbasicblock}{basicblock} $\ast$bb, map$<$ long int, \hyperlink{classinterfNode}{interfNode} $\ast$ $>$ \&globalIntfNodeMap)
\item 
void \hyperlink{registerAllocate_8cpp_adaeef7e1cff31b45dd8d7d8adbcd1662}{allocate\_\-register} (\hyperlink{classList}{List}$<$ \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$bbList, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$insList)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{registerAllocate_8cpp_adaeef7e1cff31b45dd8d7d8adbcd1662}{
\index{registerAllocate.cpp@{registerAllocate.cpp}!allocate\_\-register@{allocate\_\-register}}
\index{allocate\_\-register@{allocate\_\-register}!registerAllocate.cpp@{registerAllocate.cpp}}
\subsubsection[{allocate\_\-register}]{\setlength{\rightskip}{0pt plus 5cm}void allocate\_\-register (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf basicblock} $\ast$ $>$ $\ast$}]{bbList, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{insList}
\end{DoxyParamCaption}
)}}
\label{registerAllocate_8cpp_adaeef7e1cff31b45dd8d7d8adbcd1662}

\begin{DoxyCode}
                                                                               {
        List<basicblock*> *interiorBB = new List<basicblock*>;
        map<long int,interfNode*> locallIntfNodeMap, globalIntfNodeMap, allIntfNo
      deMap;
        printf("\tPhi-Function Elimination\n");
        int numInsInsertion = eliminatePhiFuncs(bbList);
        printf("\tSSA Rename & Build Def/Use Set\n");
        renameAndbuildDefUseSets(bbList); //TODO: make sure this step does not im
      pact next step
        printf("\tLiveness Analysis\n");
        livenessAnalysis(bbList);
        printf("\tFind Graph Entry Points\n");
        findEntryPoints(bbList, interiorBB);
        //TODO is the block below okay? needed?
        for (int i = 0; i < bbList->NumElements(); i++)
                bbList->Nth(i)->setAsUnvisited();
        printf("\tBuild Interference Graph & Run Register Assignment\n");
        for (int i = 0; i < interiorBB->NumElements(); i++) {
                basicblock* bbHead = interiorBB->Nth(i);
                locallIntfNodeMap.clear();
                globalIntfNodeMap.clear();
                allIntfNodeMap.clear();
                make_interference_nodes_network(bbHead, globalIntfNodeMap, locall
      IntfNodeMap,allIntfNodeMap);
                for (map<long int,interfNode*>::iterator it = locallIntfNodeMap.b
      egin(); it != locallIntfNodeMap.end(); it++) {
                        if (globalIntfNodeMap.find(it->first) != globalIntfNodeMa
      p.end()) printf("*SHIIIIIIIIT+++++++\n");
                }
                for (map<long int,interfNode*>::iterator it = globalIntfNodeMap.b
      egin(); it != globalIntfNodeMap.end(); it++) {
                        if (locallIntfNodeMap.find(it->first) != locallIntfNodeMa
      p.end()) printf("SHIIIIIIIIT+++++++\n");
                }
                // printf("sizes: %d,%d,%d\n",allIntfNodeMap.size(),globalIntfNod
      eMap.size(),locallIntfNodeMap.size());
                assign_global_registers(locallIntfNodeMap, globalIntfNodeMap, all
      IntfNodeMap);
                // printf("sizes: %d,%d,%d\n",allIntfNodeMap.size(),globalIntfNod
      eMap.size(),locallIntfNodeMap.size());
                set_arch_reg_for_all_ins(bbHead, allIntfNodeMap);
        }
        for (int i = 0; i < bbList->NumElements(); i++) {       
                basicblock* bb = bbList->Nth(i);
                // Assert(bb->isVisited()); //all BB must be visited by now //TOD
      O put this back ASAP
                bb->setAsUnvisited();
                // printf("%llx, %d\n", bb->getID(),    bb->getLiveVarSize());
                // bb->getLiveVarSize();
        }
        printf("\tNumber of Phi MOV instructions: %d added to the %d static progr
      am instructions\n",numInsInsertion,insList->NumElements());
        delete interiorBB;
}
\end{DoxyCode}
\hypertarget{registerAllocate_8cpp_ad793e858badbde1ceff1536fc3145c65}{
\index{registerAllocate.cpp@{registerAllocate.cpp}!assign\_\-global\_\-registers@{assign\_\-global\_\-registers}}
\index{assign\_\-global\_\-registers@{assign\_\-global\_\-registers}!registerAllocate.cpp@{registerAllocate.cpp}}
\subsubsection[{assign\_\-global\_\-registers}]{\setlength{\rightskip}{0pt plus 5cm}void assign\_\-global\_\-registers (
\begin{DoxyParamCaption}
\item[{map$<$ long int, {\bf interfNode} $\ast$ $>$ \&}]{locallIntfNodeMap, }
\item[{map$<$ long int, {\bf interfNode} $\ast$ $>$ \&}]{globalIntfNodeMap, }
\item[{map$<$ long int, {\bf interfNode} $\ast$ $>$ \&}]{allIntfNodeMap}
\end{DoxyParamCaption}
)}}
\label{registerAllocate_8cpp_ad793e858badbde1ceff1536fc3145c65}

\begin{DoxyCode}
                                                                                 
                                                                                       
        {
        if (globalIntfNodeMap.size() == 0 && locallIntfNodeMap.size() == 0) retur
      n;
        // printf("2 map size: %d\n", globalIntfNodeMap.size());
        if (globalIntfNodeMap.size() > 0) {
                vector<interfNode*> removedIntfNodeVector;
                // Step 1: Eliminate Resgisters from Interference Graph
                while (globalIntfNodeMap.size() > 0) {
                        int neighborCount = -1;
                        map<long int,interfNode*>::iterator candidateNodeIt;
                        for (map<long int,interfNode*>::iterator it = globalIntfN
      odeMap.begin(); it != globalIntfNodeMap.end(); it++) {
                                // Remove redundant map elements
                                // if ((it->second)->getNeighborSize() == 0) {
                                //      allIntfNodeMap.insert(pair<long int,inter
      fNode*> (it->first,it->second));
                                //      globalIntfNodeMap.erase(it);
                                //      continue;
                                // }
                                if ((it->second)->getNeighborSize() > neighborCou
      nt &&
                                    (it->second)->getNeighborSize() < GRF_SIZE) {
      
                                                neighborCount =  (it->second)->ge
      tNeighborSize();
                                                candidateNodeIt = it;
                                }
                        }
                        if (globalIntfNodeMap.size() == 0) {
                                break;
                        } else if (neighborCount > -1) {
                                interfNode* node = candidateNodeIt->second;
                                node->removeFromGraph();
                                removedIntfNodeVector.push_back(node);
                                #ifdef DEBUG_RA printf("adding to ALL: %d\n",cand
      idateNodeIt->first); 
                                #endif
                                allIntfNodeMap.insert(pair<long int,interfNode*> 
      (candidateNodeIt->first,candidateNodeIt->second));
                                globalIntfNodeMap.erase(candidateNodeIt);
                        } else {
                                for (map<long int,interfNode*>::iterator it = glo
      balIntfNodeMap.begin(); it != globalIntfNodeMap.end(); it++) {
                                        printf("remaining nodes size: %d\n", (it-
      >second)->getNeighborSize());
                                }
                                Assert(true == false && "no candidate neighbors f
      ound.");
                        }
                }
                // Step 2: Color Registers (reg assignment)
                set<long int> GRFset;
                for (int i = GRF_LO; i <= GRF_HI; i++) GRFset.insert(i);
                for (int i = removedIntfNodeVector.size()-1; i >= 0; i--) {
                        interfNode *node = removedIntfNodeVector.at(i);
                        node->assignReg(GRFset);
                        // printf("%d\n", node->getReg());
                }
        }
}
\end{DoxyCode}
\hypertarget{registerAllocate_8cpp_a66bb4ccca1dacd495fef9d58f1ed6620}{
\index{registerAllocate.cpp@{registerAllocate.cpp}!assign\_\-local\_\-registers@{assign\_\-local\_\-registers}}
\index{assign\_\-local\_\-registers@{assign\_\-local\_\-registers}!registerAllocate.cpp@{registerAllocate.cpp}}
\subsubsection[{assign\_\-local\_\-registers}]{\setlength{\rightskip}{0pt plus 5cm}void assign\_\-local\_\-registers (
\begin{DoxyParamCaption}
\item[{map$<$ long int, {\bf interfNode} $\ast$ $>$ \&}]{locallIntfNodeMap, }
\item[{map$<$ long int, {\bf interfNode} $\ast$ $>$ \&}]{allIntfNodeMap}
\end{DoxyParamCaption}
)}}
\label{registerAllocate_8cpp_a66bb4ccca1dacd495fef9d58f1ed6620}

\begin{DoxyCode}
                                                                                 
                                          {
        if (locallIntfNodeMap.size() == 0) return;
        if (locallIntfNodeMap.size() > 0) {
                vector<interfNode*> removedIntfNodeVector;
                // Step 1: Eliminate Resgisters from Interference Graph
                while (locallIntfNodeMap.size() > 0) {
                        int neighborCount = -1;
                        map<long int,interfNode*>::iterator candidateNodeIt;
                        for (map<long int,interfNode*>::iterator it = locallIntfN
      odeMap.begin(); it != locallIntfNodeMap.end(); it++) {
                                // Remove redundant map elements
                                        // if ((it->second)->getNeighborSize() ==
       0) {
                                        //      allIntfNodeMap.insert(pair<long i
      nt,interfNode*> (it->first,it->second));
                                        //      globalIntfNodeMap.erase(it);
                                        //      continue;
                                        // }
                                if ((it->second)->getNeighborSize() > neighborCou
      nt &&
                                    (it->second)->getNeighborSize() < LRF_SIZE) {
      
                                                neighborCount =  (it->second)->ge
      tNeighborSize();
                                                candidateNodeIt = it;
                                }
                        }
                        if (locallIntfNodeMap.size() == 0) {
                                break;
                        } else if (neighborCount > -1) {
                                interfNode* node = candidateNodeIt->second;
                                node->removeFromGraph();
                                removedIntfNodeVector.push_back(node);
                                // if (allIntfNodeMap.find(candidateNodeIt->first
      ) != allIntfNodeMap.end()) printf("\n============================================
      \n");
                                #ifdef DEBUG_RA printf("adding to ALL: %d\n",cand
      idateNodeIt->first);
                                #endif
                                allIntfNodeMap.insert(pair<long int,interfNode*> 
      (candidateNodeIt->first,candidateNodeIt->second));
                                locallIntfNodeMap.erase(candidateNodeIt);
                        } else {
                                for (map<long int,interfNode*>::iterator it = loc
      allIntfNodeMap.begin(); it != locallIntfNodeMap.end(); it++) {
                                        printf("remaining nodes size: %d\n", (it-
      >second)->getNeighborSize());
                                }
                                Assert(true == false && "no candidate neighbors f
      ound.");
                        }
                }
                // Step 2: Color Registers (reg assignment)
                set<long int> LRFset;
                for (int i = LRF_LO; i <= LRF_HI; i++) LRFset.insert(i);
                for (int i = removedIntfNodeVector.size()-1; i >= 0; i--) {
                        interfNode *node = removedIntfNodeVector.at(i);
                        node->assignReg(LRFset);
                        // printf("%d\n", node->getReg());
                }
        }
        // printf("\tDEBUG: Completed register assignment for one network.\n");
}
\end{DoxyCode}
\hypertarget{registerAllocate_8cpp_aa1b9aef4bd270d92ee493acef4c5cffa}{
\index{registerAllocate.cpp@{registerAllocate.cpp}!eliminatePhiFuncs@{eliminatePhiFuncs}}
\index{eliminatePhiFuncs@{eliminatePhiFuncs}!registerAllocate.cpp@{registerAllocate.cpp}}
\subsubsection[{eliminatePhiFuncs}]{\setlength{\rightskip}{0pt plus 5cm}int eliminatePhiFuncs (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf basicblock} $\ast$ $>$ $\ast$}]{bbList}
\end{DoxyParamCaption}
)}}
\label{registerAllocate_8cpp_aa1b9aef4bd270d92ee493acef4c5cffa}

\begin{DoxyCode}
                                                 {
        /* CAUTION:
                After phi-function elimination you must never poke into 
        the end of a BB to search for a branch of some sort.
        */
        int numInsInsertion = 0;
        for (int i =0 ; i < bbList->NumElements(); i++) {
                numInsInsertion += bbList->Nth(i)->elimPhiFuncs();
        }
        return numInsInsertion;
}
\end{DoxyCode}
\hypertarget{registerAllocate_8cpp_a3511145027350bf1c4fab3a22f79be40}{
\index{registerAllocate.cpp@{registerAllocate.cpp}!findEntryPoints@{findEntryPoints}}
\index{findEntryPoints@{findEntryPoints}!registerAllocate.cpp@{registerAllocate.cpp}}
\subsubsection[{findEntryPoints}]{\setlength{\rightskip}{0pt plus 5cm}void findEntryPoints (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf basicblock} $\ast$ $>$ $\ast$}]{bbList, }
\item[{{\bf List}$<$ {\bf basicblock} $\ast$ $>$ $\ast$}]{interiorBB}
\end{DoxyParamCaption}
)}}
\label{registerAllocate_8cpp_a3511145027350bf1c4fab3a22f79be40}

\begin{DoxyCode}
                                                                               {
        for (int i = 0; i < bbList->NumElements(); i++) {       
                basicblock* bb = bbList->Nth(i);
                if (bb->getNumAncestors() == 0 || bb->numNonBackEdgeAncestors() =
      = 0) {
                        interiorBB->Append(bb);
                }
        }
}
\end{DoxyCode}
\hypertarget{registerAllocate_8cpp_a890d083ac7d418402e1acbcda4930e1b}{
\index{registerAllocate.cpp@{registerAllocate.cpp}!livenessAnalysis@{livenessAnalysis}}
\index{livenessAnalysis@{livenessAnalysis}!registerAllocate.cpp@{registerAllocate.cpp}}
\subsubsection[{livenessAnalysis}]{\setlength{\rightskip}{0pt plus 5cm}void livenessAnalysis (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf basicblock} $\ast$ $>$ $\ast$}]{bbList}
\end{DoxyParamCaption}
)}}
\label{registerAllocate_8cpp_a890d083ac7d418402e1acbcda4930e1b}

\begin{DoxyCode}
                                                 {
        bool change = true;
        while (change == true) {
                change = false;
                for (int i = 0; i < bbList->NumElements(); i++) {       
                        basicblock* bb = bbList->Nth(i);
                        if (bb->update_InOutSet() == true)
                                change = true;
                }
        }
        //Create local sets for implementing LRF reg. allcoation
        for (int i = 0; i < bbList->NumElements(); i++)
                bbList->Nth(i)->updateLocalRegSet();
}
\end{DoxyCode}
\hypertarget{registerAllocate_8cpp_a44ba610b0d634eb37dc4a1228f9fe6d7}{
\index{registerAllocate.cpp@{registerAllocate.cpp}!make\_\-interference\_\-nodes\_\-network@{make\_\-interference\_\-nodes\_\-network}}
\index{make\_\-interference\_\-nodes\_\-network@{make\_\-interference\_\-nodes\_\-network}!registerAllocate.cpp@{registerAllocate.cpp}}
\subsubsection[{make\_\-interference\_\-nodes\_\-network}]{\setlength{\rightskip}{0pt plus 5cm}void make\_\-interference\_\-nodes\_\-network (
\begin{DoxyParamCaption}
\item[{{\bf basicblock} $\ast$}]{bb, }
\item[{map$<$ long int, {\bf interfNode} $\ast$ $>$ \&}]{globalIntfNodeMap, }
\item[{map$<$ long int, {\bf interfNode} $\ast$ $>$ \&}]{locallIntfNodeMap, }
\item[{map$<$ long int, {\bf interfNode} $\ast$ $>$ \&}]{allIntfNodeMap}
\end{DoxyParamCaption}
)}}
\label{registerAllocate_8cpp_a44ba610b0d634eb37dc4a1228f9fe6d7}

\begin{DoxyCode}
                                                                                 
                                                                                       
                                {
        if (!bb->isVisited()) {
                bb->setAsVisited();
                set<long int> defSet = bb->getDefSet();
                set<long int> inSet = bb->getInSet();
                set<long int> localSet = bb->getLocalRegSet();
                set<long int> liveSet, defSet_noLocal;
                // printf("%llx - inSet size: %d\n", bb->getID(), inSet.size());
                set_difference(defSet.begin(), defSet.end(), localSet.begin(), lo
      calSet.end(), std::inserter(defSet_noLocal, defSet_noLocal.begin()));
                set_union(defSet.begin(), defSet.end(), inSet.begin(), inSet.end(
      ), std::inserter(liveSet, liveSet.begin()));
                //TODO - debug - to remove
                // set<long int> test;
                // set_intersection(liveSet.begin(), liveSet.end(), localSet.begi
      n(), localSet.end(), std::inserter(test, test.begin()));
                // printf("test set: %d, %d, %d\n", liveSet.size(), localSet.size
      (), test.size());
                // For each live value, connect the node to all other live nodes 
      at that BB
                for (set<long int>::iterator it = liveSet.begin(); it != liveSet.
      end(); it++) {
                        if (globalIntfNodeMap.find(*it) == globalIntfNodeMap.end(
      )) {
                                interfNode *IntfNd = new interfNode(*it);
                                globalIntfNodeMap.insert(pair<long int,interfNode
      *> (*it,IntfNd));
                        }
                        interfNode *defNode = globalIntfNodeMap[*it];
                        for (set<long int>::iterator it_live = liveSet.begin(); i
      t_live != liveSet.end(); it_live++) {
                                if (*it != *it_live) { //avoid edges to self
                                        if (globalIntfNodeMap.find(*it_live) == g
      lobalIntfNodeMap.end()) {
                                                interfNode *IntfNd = new 
      interfNode(*it_live);
                                                globalIntfNodeMap.insert(pair<lon
      g int,interfNode*> (*it_live,IntfNd));
                                        }
                                        interfNode *node = globalIntfNodeMap[*it_
      live];
                                        defNode->addEdge(node);
                                }
                        }
                }
    //  // For each local value, connect the node to all other local nodes at tha
      t BB
    //  for (set<long int>::iterator it = localSet.begin(); it != localSet.end();
       it++) {
    //          if (locallIntfNodeMap.find(*it) != locallIntfNodeMap.end()) 
    //                  printf("OMG. This value already exists: %llx\n", *it);
    //  }
    //  for (set<long int>::iterator it = localSet.begin(); it != localSet.end();
       it++) {
    //          if (locallIntfNodeMap.find(*it) == locallIntfNodeMap.end()) {
    //                  interfNode *IntfNd = new interfNode(*it);
    //                  locallIntfNodeMap.insert(pair<long int,interfNode*> (*it,
      IntfNd));
    //          }
    //          interfNode *defNode = locallIntfNodeMap[*it];
    //          for (set<long int>::iterator it_live = localSet.begin(); it_live 
      != localSet.end(); it_live++) {
    //                  if (*it != *it_live) { //avoid edges to self
    //                          if (locallIntfNodeMap.find(*it_live) == locallInt
      fNodeMap.end()) {
    //                                  interfNode *IntfNd = new interfNode(*it_l
      ive);
    //                                  locallIntfNodeMap.insert(pair<long int,in
      terfNode*> (*it_live,IntfNd));
    //                          }
    //                          interfNode *node = locallIntfNodeMap[*it_live];
    //                          defNode->addEdge(node);
    //                  }
    //          }
    //  }
    //  //=======
    //  //Do register allocation for local registerrs
    //  //Problem to solve: it looks like for some strange reason
    //  //local registers do conflict across BB's this solution, avoids that.
    //  //(I don't yet know what the cause of the conflict is)
    //  assign_local_registers(locallIntfNodeMap,allIntfNodeMap);
    //  locallIntfNodeMap.clear();
    //  //=======
    //  for (map<long int,interfNode*>::iterator it = globalIntfNodeMap.begin(); 
      it != globalIntfNodeMap.end(); it++) {
    //          if (locallIntfNodeMap.find(it->first) != locallIntfNodeMap.end())
       printf("-SHIIIIIIIIT+++++++ %d\n", it->first);
    //  }
                // printf("CALLING DESCENDENTS\n");
                for (int i = 0; i < bb->getNumDescendents(); i++)
                        make_interference_nodes_network(bb->getNthDescendent(i), 
      globalIntfNodeMap, locallIntfNodeMap, allIntfNodeMap);//TODO should it not be a B
      FS instead of DFS? 
                for (int i = 0; i < bb->getNumAncestors(); i++)
                        make_interference_nodes_network(bb->getNthAncestor(i), gl
      obalIntfNodeMap, locallIntfNodeMap, allIntfNodeMap);//TODO should it not be a BFS
       instead of DFS? 
        }
        // printf("1 map size: %d\n", globalIntfNodeMap.size());
}
\end{DoxyCode}
\hypertarget{registerAllocate_8cpp_a398558d22a764dcc2fdc74639b3f56c6}{
\index{registerAllocate.cpp@{registerAllocate.cpp}!renameAndbuildDefUseSets@{renameAndbuildDefUseSets}}
\index{renameAndbuildDefUseSets@{renameAndbuildDefUseSets}!registerAllocate.cpp@{registerAllocate.cpp}}
\subsubsection[{renameAndbuildDefUseSets}]{\setlength{\rightskip}{0pt plus 5cm}void renameAndbuildDefUseSets (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf basicblock} $\ast$ $>$ $\ast$}]{bbList}
\end{DoxyParamCaption}
)}}
\label{registerAllocate_8cpp_a398558d22a764dcc2fdc74639b3f56c6}

\begin{DoxyCode}
                                                         {
        for (int i =0 ; i < bbList->NumElements(); i++)
                bbList->Nth(i)->renameAllInsRegs();
}
\end{DoxyCode}
\hypertarget{registerAllocate_8cpp_aaf92c40633364d00817ec3f029a77f3c}{
\index{registerAllocate.cpp@{registerAllocate.cpp}!set\_\-arch\_\-reg\_\-for\_\-all\_\-ins@{set\_\-arch\_\-reg\_\-for\_\-all\_\-ins}}
\index{set\_\-arch\_\-reg\_\-for\_\-all\_\-ins@{set\_\-arch\_\-reg\_\-for\_\-all\_\-ins}!registerAllocate.cpp@{registerAllocate.cpp}}
\subsubsection[{set\_\-arch\_\-reg\_\-for\_\-all\_\-ins}]{\setlength{\rightskip}{0pt plus 5cm}void set\_\-arch\_\-reg\_\-for\_\-all\_\-ins (
\begin{DoxyParamCaption}
\item[{{\bf basicblock} $\ast$}]{bb, }
\item[{map$<$ long int, {\bf interfNode} $\ast$ $>$ \&}]{globalIntfNodeMap}
\end{DoxyParamCaption}
)}}
\label{registerAllocate_8cpp_aaf92c40633364d00817ec3f029a77f3c}

\begin{DoxyCode}
                                                                                 
                 {
        // printf("3 map size: %d\n", globalIntfNodeMap.size());
        List<instruction*>* insList = bb->getInsList();
        for (int i = 0; i <  insList->NumElements(); i++) {
                instruction* ins = insList->Nth(i);
                bool isAlreadyAssigned = false;
                for (int j = 0; j < ins->getNumReg(); j++) {
                        // printf("(%llx) reg type: %d, %d, ", bb->getID(), ins->
      getNthRegType(j), ins->getNthReg(j));
                        isAlreadyAssigned = ins->isAlreadyAssignedArcRegs();
                        if (isAlreadyAssigned) break;
                        if (globalIntfNodeMap.find(ins->getNthReg(j)) == globalIn
      tfNodeMap.end()) break; //TODO replace this with next line
                        // Assert(globalIntfNodeMap.find(ins->getNthReg(j)) != gl
      obalIntfNodeMap.end());
                        long int reg = ((globalIntfNodeMap.find(ins->getNthReg(j)
      ))->second)->getReg();
                        // printf("arch reg: %d\n", reg);
                        ins->setArchReg(reg);
                        //assign reg to proper instruction obj. if already assign
      ed, break out of bb
                        //at dump time make sure no reg is left unassigned
                }
                if (isAlreadyAssigned) return; //skip bb
        }
        for (int i = 0; i < bb->getNumDescendents(); i++)
                set_arch_reg_for_all_ins(bb->getNthDescendent(i), globalIntfNodeM
      ap);//TODO should it not be a BFS instead of DFS? 
        for (int i = 0; i < bb->getNumAncestors(); i++)
                set_arch_reg_for_all_ins(bb->getNthAncestor(i), globalIntfNodeMap
      );//TODO should it not be a BFS instead of DFS? 
}
\end{DoxyCode}
