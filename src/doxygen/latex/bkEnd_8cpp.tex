\hypertarget{bkEnd_8cpp}{
\section{/home/milad/esc\_\-project/svn/PARS/src/backend/bkEnd.cpp File Reference}
\label{bkEnd_8cpp}\index{/home/milad/esc\_\-project/svn/PARS/src/backend/bkEnd.cpp@{/home/milad/esc\_\-project/svn/PARS/src/backend/bkEnd.cpp}}
}
{\ttfamily \#include $<$unistd.h$>$}\par
{\ttfamily \#include $<$signal.h$>$}\par
{\ttfamily \#include $<$iostream$>$}\par
{\ttfamily \#include $<$algorithm$>$}\par
{\ttfamily \#include $<$string.h$>$}\par
{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$time.h$>$}\par
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include $<$string$>$}\par
{\ttfamily \#include $<$list$>$}\par
{\ttfamily \#include $<$set$>$}\par
{\ttfamily \#include $<$sstream$>$}\par
{\ttfamily \#include \char`\"{}dependencyTable.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}oooLD\_\-lsq\_\-ctrl.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}registerRename.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}vliwScheduler.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}instruction.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}../frontend/tournament.hh\char`\"{}}\par
{\ttfamily \#include \char`\"{}cacheLine.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}cacheCtrl.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}quickSort.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}phraseGen.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}basicblock.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}sideBuff.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}fragment.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}latency.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}regFile.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}utility.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}parser.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}../global/global.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}cache.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}../lib/list.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}hist.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}dot.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}lsq.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}bkEnd.h\char`\"{}}\par
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
string \hyperlink{bkEnd_8cpp_a4bdab479a34b2695251fda1824813fbc}{inFileName} (\char`\"{}../trace\_\-regOnly\_\-bzipSTM\_\-default.out\char`\"{})
\item 
string \hyperlink{bkEnd_8cpp_a8a7960f44b590e5ca0e8cc8273f64dd4}{reScheduleFileName} (\char`\"{}../trace\_\-regOnly\_\-bzipSTM\_\-rescheduled\_\-default.out\char`\"{})
\item 
string \hyperlink{bkEnd_8cpp_a263d48d5587cc05b4b3c9fe77bf86fe8}{phrasingFileName} (\char`\"{}../trace\_\-regOnly\_\-bzipSTM\_\-phrased\_\-default.out\char`\"{})
\item 
string \hyperlink{bkEnd_8cpp_a4cf2d67fd505b560c46cfc3386bdab9a}{outFileName1} (\char`\"{}timingTrace\_\-default\_\-outFile\_\-default.out\char`\"{})
\item 
string \hyperlink{bkEnd_8cpp_a9302c3259f5dfab8bec5c1b4f4e8f52f}{branchProfileFileName} (\char`\"{}/home/milad/esc\_\-project/svn/memTraceMilad/TraceSim/results/hmmer/branch\_\-exe\_\-count\_\-map.csv\char`\"{})
\item 
string \hyperlink{bkEnd_8cpp_a0734fb039a0e7c39dbb26942683ee2e6}{branchAccuracyFileName} (\char`\"{}/home/milad/esc\_\-project/svn/memTraceMilad/TraceSim/results/bzip2/predhistory.csv\char`\"{})
\item 
string \hyperlink{bkEnd_8cpp_afff51beec397710490f251f8e36fc167}{upldProfileFileName} (\char`\"{}/home/milad/esc\_\-project/svn/memTraceMilad/TraceSim/results/hmmer/unpredictableLDs.csv\char`\"{})
\item 
string \hyperlink{bkEnd_8cpp_a26c1e64683b2450f033b67ba14be8a97}{wbb\_\-skip\_\-count} (\char`\"{}wbb\_\-skip\_\-count.csv\char`\"{})
\item 
string \hyperlink{bkEnd_8cpp_a284d05841cccaebd1aa53c032d756d5a}{br\_\-skip\_\-accuracy} (\char`\"{}br\_\-skip\_\-accuracy.csv\char`\"{})
\item 
void \hyperlink{bkEnd_8cpp_a2610cc7850729dad55450e26627d78ae}{bkEnd\_\-init} (int argc, char const $\ast$argv\mbox{[}$\,$\mbox{]}, \hyperlink{structg__variable}{g\_\-variable} \&\hyperlink{g__variable_8h_adfd3dddc03cc8a61d5ba0f266d7caeaa}{g\_\-var})
\item 
void \hyperlink{bkEnd_8cpp_a870d541d0ad8aae66f1b83a348dec2e2}{Update} (uint64\_\-t \_\-\_\-pc, bool \_\-\_\-taken, \hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
bool \hyperlink{bkEnd_8cpp_a34cf3d53dd637753d853c59ec050c13a}{PrePredict} (uint64\_\-t \_\-\_\-pc, void $\ast$\&bp\_\-hist)
\item 
bool \hyperlink{bkEnd_8cpp_a956efe210acb292cfb8e75396ef62677}{isMisPrePredicted} (bool \hyperlink{bkEnd_8cpp_a155d4466ed8ddecb8cbb21f3b798904c}{bbPrediction}, bool taken)
\item 
bool \hyperlink{bkEnd_8cpp_a5184890a4947515e205215feed25fdd9}{Predict} (uint64\_\-t \_\-\_\-pc, void $\ast$\&bp\_\-hist)
\item 
bool \hyperlink{bkEnd_8cpp_a5627ce0f84690d974b96ebb091e67d6e}{PredictAndUpdate} (uint64\_\-t \_\-\_\-pc, int \_\-\_\-taken)
\item 
void \hyperlink{bkEnd_8cpp_add7c033a8f7a85ceede7a13701545aa4}{freeALUs} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{bkEnd_8cpp_a9a25aed4f2747b7f642111fd4ee5b9cf}{completeIns} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$\hyperlink{backend_2parser_8cpp_ad73ae25f81e6e99482f3fbd5ba9664ce}{iROB})
\item 
void \hyperlink{bkEnd_8cpp_a968c90c4d8d2a7f34dcb172bfef57feb}{completePB} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{bkEnd_8cpp_ad1dec997d8c5cff0b27c7b88ca4ab6e0}{removePhrase} (\hyperlink{classList}{List}$<$ \hyperlink{classphrase}{phrase} $\ast$ $>$ $\ast$iPh, int phIndx)
\item 
void \hyperlink{bkEnd_8cpp_a81faf93556d4154fc76abed8d0f06cd5}{removeFrag} (\hyperlink{classList}{List}$<$ \hyperlink{classfragment}{fragment} $\ast$ $>$ $\ast$iFr, int frIndx)
\item 
void \hyperlink{bkEnd_8cpp_ae9343acaa4bb2c5419f4f893d228d061}{findReadyFrag} (\hyperlink{classList}{List}$<$ \hyperlink{classfragment}{fragment} $\ast$ $>$ $\ast$iFr\_\-ready, \hyperlink{classList}{List}$<$ \hyperlink{classfragment}{fragment} $\ast$ $>$ $\ast$iFr\_\-wait)
\item 
void \hyperlink{bkEnd_8cpp_a28571fa314c00095dc96822adb0dd144}{reportInsTiming} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{bkEnd_8cpp_aae29b315f876b102642b3eb99838a9fd}{printSTALL} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{bkEnd_8cpp_a0bff6def00178cb9d06eff35aeebcb65}{createTraceAndHitMiss} (int i)
\item 
void \hyperlink{bkEnd_8cpp_a4668f9d4a280acba3afd26e75675918d}{addToPBCache} ()
\item 
void \hyperlink{bkEnd_8cpp_adf93e43bd3a6a80076405e72701ecc93}{addToInsCache} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{bkEnd_8cpp_a3d96f03b51c73d69d52d695fc3b67751}{updateBBboundaries} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{bkEnd_8cpp_a9401b69204b88b4ecc302d76c27ad810}{addLastBracket} ()
\item 
void \hyperlink{bkEnd_8cpp_a30b10d56e06d16f688d896f71bb5ea58}{removeFromROB} (\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$\hyperlink{backend_2parser_8cpp_ad73ae25f81e6e99482f3fbd5ba9664ce}{iROB}, \hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} insId)
\item 
void \hyperlink{bkEnd_8cpp_a2cc88dd3e5bb835d2853b0692e286158}{removeFromiWindow} (\hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} \hyperlink{backend_2parser_8cpp_a1c9e72bbfe446ae69bd2ec84c6220841}{insID})
\item 
void \hyperlink{bkEnd_8cpp_a865779257efd579c612bee7d113a4692}{removeFromiResStn} (\hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} \hyperlink{backend_2parser_8cpp_a1c9e72bbfe446ae69bd2ec84c6220841}{insID})
\item 
bool \hyperlink{bkEnd_8cpp_ae394aec2b634fd76cd5c65bcd6ef019e}{popFromInsCache} ()
\item 
void \hyperlink{bkEnd_8cpp_a832dd92de97859679d2c78b8f8dc99e7}{getSquashRFstatForStatus} (\hyperlink{classinstruction}{instruction} $\ast$ins, \hyperlink{global_2global_8h_a015eb90e0de9f16e87bd149d4b9ce959}{status} st)
\item 
void \hyperlink{bkEnd_8cpp_a3e5129a7cabbb869a82de1f82e856d57}{getSquashRFstat} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{bkEnd_8cpp_ab66b103fb7f2942ca9fd5379cf47893f}{squash} (\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$\hyperlink{backend_2parser_8cpp_ad73ae25f81e6e99482f3fbd5ba9664ce}{iROB}, \hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} \hyperlink{backend_2parser_8cpp_a1c9e72bbfe446ae69bd2ec84c6220841}{insID}, \hyperlink{classlsq}{lsq} $\ast$oooLd\_\-inoSt\_\-LSQ)
\item 
void \hyperlink{bkEnd_8cpp_a43ea6d39a044acd2c1dd61f1fe00b3f0}{getRFstat} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{bkEnd_8cpp_a5d6a55cf1d8b31005873f03a098bc5ed}{insTypeCountStat} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
int \hyperlink{bkEnd_8cpp_a55d405fd16809cc233376112b4527f0b}{commitIns} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$\hyperlink{backend_2parser_8cpp_ad73ae25f81e6e99482f3fbd5ba9664ce}{iROB})
\item 
int \hyperlink{bkEnd_8cpp_a2fbac5556ee437e9fab920fdc6eecce2}{commitPB} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{bkEnd_8cpp_abec3fc00feaa7527678f9768c30c3fe1}{resetInput} (char $\ast$\hyperlink{_8AppleDouble_2sat__counter_8cpp_aa41808e37ba1ecae7ee6bde4a5c62f82}{c}, int i)
\item 
long int \hyperlink{bkEnd_8cpp_a50572d24f56e517753d0b24cc3f560c5}{getReg} (char $\ast$\hyperlink{_8AppleDouble_2sat__counter_8cpp_aa41808e37ba1ecae7ee6bde4a5c62f82}{c})
\item 
int \hyperlink{bkEnd_8cpp_a8894d121130f17e7b86a4808184d7686}{getRegType} (char $\ast$\hyperlink{_8AppleDouble_2sat__counter_8cpp_aa41808e37ba1ecae7ee6bde4a5c62f82}{c})
\item 
long int \hyperlink{bkEnd_8cpp_a9589f904c9dbc95069671b28d883a4f7}{getANumber} (char $\ast$\hyperlink{_8AppleDouble_2sat__counter_8cpp_aa41808e37ba1ecae7ee6bde4a5c62f82}{c})
\item 
\hyperlink{global_2global_8h_a7ea74bb9ffd2e4d41550ae2383dd25bc}{ADDRS} \hyperlink{bkEnd_8cpp_a2fce9656bfaf3c3b7160cf9a396c7297}{getAddr} (char $\ast$\hyperlink{_8AppleDouble_2sat__counter_8cpp_aa41808e37ba1ecae7ee6bde4a5c62f82}{c})
\item 
int \hyperlink{bkEnd_8cpp_ae65f5a08a89109ce2afb34faaf30edac}{setupNewIns} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
int \hyperlink{bkEnd_8cpp_a699e911f02cc068558e37f3496d086ce}{addIns} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
int \hyperlink{bkEnd_8cpp_ab5a65ee867edd1ec1db1265dd7ca57d2}{setupNewInsV2} (\hyperlink{classinstruction}{instruction} $\ast$ins, char $\ast$\hyperlink{_8AppleDouble_2sat__counter_8cpp_aa41808e37ba1ecae7ee6bde4a5c62f82}{c})
\item 
void \hyperlink{bkEnd_8cpp_a73b0a124e04ab7ad583a8ad063d501c5}{addPhrase} (\hyperlink{classList}{List}$<$ \hyperlink{classphrase}{phrase} $\ast$ $>$ $\ast$iPh, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, \hyperlink{classdot}{dot} $\ast$d)
\item 
void \hyperlink{bkEnd_8cpp_ae7c9964c26331fddb647175a6d70a00a}{addPhraseblock} (\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$$\ast$pbLists, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{bkEnd_8cpp_ac404f1539d9a3d1ef63387444a621721}{addFrag} (\hyperlink{classList}{List}$<$ \hyperlink{classfragment}{fragment} $\ast$ $>$ $\ast$iFr, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
bool \hyperlink{bkEnd_8cpp_a614e7cde759a7fb104ba2b7c53ac31d3}{checkAncestor} (\hyperlink{classinstruction}{instruction} $\ast$ins, int bottom, int top, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$\hyperlink{backend_2parser_8cpp_a901b5b3874c558101a1c250f2f2d0662}{iWindow})
\item 
void \hyperlink{bkEnd_8cpp_a62811b6c8089a0b9969bcfa219fe4326}{scheduleInsInFlight} (\hyperlink{classList}{List}$<$ int $>$ $\ast$\hyperlink{bkEnd_8cpp_a441b50ca30ab742e02e0d1aca889307b}{SBlist}, \hyperlink{classList}{List}$<$ int $>$ $\ast$\hyperlink{bkEnd_8cpp_a5d56c51d0584a2183c83a3dfe157e724}{delList}, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$\hyperlink{backend_2parser_8cpp_a901b5b3874c558101a1c250f2f2d0662}{iWindow}, int top, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
bool \hyperlink{bkEnd_8cpp_adccf4da88f361a0940e757c32241240e}{isALUfree} ()
\item 
bool \hyperlink{bkEnd_8cpp_a8787d06d2c8d571bee81ae5887237534}{isWinNotEmpty} ()
\item 
bool \hyperlink{bkEnd_8cpp_ad5f095c0a96cd9bf9981cb1851e09e56}{checkRegDependency} (int indx)
\item 
bool \hyperlink{bkEnd_8cpp_ae0c892b61c0b3a005382554567c7eb51}{checkMemDependency} (int indx)
\item 
void \hyperlink{bkEnd_8cpp_a9bec7fac736a429a859566bf1701fd5f}{recordMemAccess} (\hyperlink{classinstruction}{instruction} $\ast$\_\-ins, int lat)
\item 
void \hyperlink{bkEnd_8cpp_ab08c8d5c859ade3a154bc445acc72565}{printMissRatetoFile} ()
\item 
void \hyperlink{bkEnd_8cpp_a5ed10a88f4f69dd854e85cdedcb6bb32}{computeMissRates} ()
\item 
int \hyperlink{bkEnd_8cpp_a425e040d7cdd063c48e543f19d61d29e}{findLatency} (\hyperlink{classinstruction}{instruction} $\ast$\_\-ins)
\item 
void \hyperlink{bkEnd_8cpp_a71f0f1c12b63efb040d2ab4a920e02d5}{executeIns} (\hyperlink{classinstruction}{instruction} $\ast$\_\-ins, int \_\-cycle, int \_\-latency)
\item 
void \hyperlink{bkEnd_8cpp_a40f88a65aa975103ceb5a3ca6cbab13f}{updateInsLatency} (\hyperlink{classinstruction}{instruction} $\ast$\_\-ins, int \_\-cycle, int \_\-latency)
\item 
void \hyperlink{bkEnd_8cpp_a184a478d12000544a380c7aa50a9894d}{exeMemPipeStage} (\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$\hyperlink{backend_2parser_8cpp_ad73ae25f81e6e99482f3fbd5ba9664ce}{iROB}, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, \hyperlink{classlsq}{lsq} $\ast$\hyperlink{bkEnd_8cpp_ad6065125a6a2298f4e8d8fc1cbe70927}{loadStoreQue})
\item 
void \hyperlink{bkEnd_8cpp_aeb3bb6faa3048d5856d06e6205cc3248}{runStoreQueue} (\hyperlink{classlsq}{lsq} $\ast$\hyperlink{bkEnd_8cpp_ad6065125a6a2298f4e8d8fc1cbe70927}{loadStoreQue}, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{bkEnd_8cpp_ae6039b0814e906c7bd5d3c85dde971ac}{getLSQsize} (\hyperlink{classlsq}{lsq} $\ast$\hyperlink{bkEnd_8cpp_ad6065125a6a2298f4e8d8fc1cbe70927}{loadStoreQue})
\item 
void \hyperlink{bkEnd_8cpp_a6e0579d00974898848aa5cc8f63a325e}{getRRsize} (\hyperlink{classregisterRename}{registerRename} $\ast$GRF)
\item 
void \hyperlink{bkEnd_8cpp_a10447d26aeb9ab403590f64c71683174}{runOOOcoreSingleIssue} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{bkEnd_8cpp_a0048e706dd30cad67418041c870d1850}{runOOOcore} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
int \hyperlink{bkEnd_8cpp_abcce050b02a52df68094f9fd386dc8e9}{findBestResStation} ()
\item 
void \hyperlink{bkEnd_8cpp_a1e86a57f718ccc5c785cb2f69e4eb150}{runOOOcore2} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{bkEnd_8cpp_a1900d3c581025a2ef05801ce26dd51b3}{createStrand} (\hyperlink{classinstruction}{instruction} $\ast$ins, int indx, int iWinIndx, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$\hyperlink{backend_2parser_8cpp_a901b5b3874c558101a1c250f2f2d0662}{iWindow})
\item 
void \hyperlink{bkEnd_8cpp_a72051851d4c12247aaab4ed481b9c2d1}{runStrandcore} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{bkEnd_8cpp_a6ce7251cbd93290a7c6774649b96b166}{runPhraseblockCore} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$$\ast$pbLists)
\item 
void \hyperlink{bkEnd_8cpp_a00dd14f5dbcba28599ade0a3d5c47091}{runxLDcore\_\-DYN} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{bkEnd_8cpp_a63d6bd6a56d403ccb003d08d98681a3b}{runxLD\_\-STAT} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{bkEnd_8cpp_a97c39e40275c8b88452f484247c641e6}{run1LD\_\-STAT} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{bkEnd_8cpp_a95df5d21c6f8468a37ead48e9bf899c7}{updateResStn} (\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$\hyperlink{bkEnd_8cpp_a1fe2792cb7bb7af1e331c6d059b53925}{iResStation}, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$\hyperlink{backend_2parser_8cpp_a901b5b3874c558101a1c250f2f2d0662}{iWindow})
\item 
void \hyperlink{bkEnd_8cpp_ace2244168da67b24c25de5eeb8e324e7}{runDueLaneInOcore} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$iWindow1, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$iWindow2, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$iWindow3, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$iWindow4, int arbitrate)
\item 
void \hyperlink{bkEnd_8cpp_a08f23b53db9ac916db6ee3b82c8a80a9}{runInOcore} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$\hyperlink{backend_2parser_8cpp_a901b5b3874c558101a1c250f2f2d0662}{iWindow})
\item 
void \hyperlink{bkEnd_8cpp_ac12de6e25fc3f32a278fbc174b77bcf8}{runInOcore2} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{bkEnd_8cpp_a0de885ce07273f37e162ecb0e63ec95d}{bkEnd\_\-run} ()
\item 
void \hyperlink{bkEnd_8cpp_af34e8aea898d89ab4f271696b1c9ab8b}{bkEnd\_\-finish} ()
\item 
void \hyperlink{bkEnd_8cpp_aa41656fd1e95e4bdc43191b18dfd8102}{bkEnd\_\-heading} (int argc, char const $\ast$argv\mbox{[}$\,$\mbox{]})
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
time\_\-t \hyperlink{bkEnd_8cpp_ada310e7f72b38fadd4b24d80ed3438ee}{start}
\item 
int64\_\-t \hyperlink{bkEnd_8cpp_a42869d36a7a91edc4e9dd046cc56dab8}{idleCount} = 0
\item 
int64\_\-t \hyperlink{bkEnd_8cpp_a10a5299fe321f662b02fa5dd316c5216}{crCount} = 0
\item 
\hyperlink{global_2global_8h_ab65a1cfe05166d06195718a9587d7b86}{core} \hyperlink{bkEnd_8cpp_a617ce1763c0446f48a6d3a158d507f46}{coreType}
\item 
FILE $\ast$ \hyperlink{bkEnd_8cpp_ac4589ec3ae9811cdbbcaa0388bd1a557}{pinFile}
\item 
FILE $\ast$ \hyperlink{bkEnd_8cpp_a58b968b0b4c5babf4eafd809481c7a9f}{outFile}
\item 
FILE $\ast$ \hyperlink{bkEnd_8cpp_a61d6eeffda4f719d0f542ee6a9e407db}{outFile1}
\item 
FILE $\ast$ \hyperlink{bkEnd_8cpp_a168197596d43af3ce1d178cc4c9f578f}{outFile2}
\item 
FILE $\ast$ \hyperlink{bkEnd_8cpp_a0e5f51d6a6b1d82437b223b600c984c2}{reScheduleFile}
\item 
FILE $\ast$ \hyperlink{bkEnd_8cpp_a77fc2d35c5f7077be762435e06e16bd2}{phraseFile}
\item 
FILE $\ast$ \hyperlink{bkEnd_8cpp_a51689c6d1f78b1fbc43733c1c4fd445a}{branchProfile}
\item 
FILE $\ast$ \hyperlink{bkEnd_8cpp_a828d20f0028160082fefe7d78033f5ee}{branchAccuracy}
\item 
FILE $\ast$ \hyperlink{bkEnd_8cpp_aff570ff1dcf13ad70c23459a2ebb4c8e}{upldProfile}
\item 
FILE $\ast$ \hyperlink{bkEnd_8cpp_af363413293438e60d03cba536e49a584}{wbbSkipCountFile}
\item 
FILE $\ast$ \hyperlink{bkEnd_8cpp_a7d813c308490d9e10a54861418d277aa}{brSkipAccuracyFile}
\item 
char \hyperlink{bkEnd_8cpp_a777274a5678acb2b7b90ccc870ccf090}{outFileName2} \mbox{[}400\mbox{]}
\item 
long int \hyperlink{bkEnd_8cpp_aea9ee59506f5a334d39148183b7e41fa}{oneLevDeepLatLevel}
\item 
int \hyperlink{bkEnd_8cpp_adddd54573e6076312789ea401c93718b}{xLevDeepLatLevel}
\item 
int \hyperlink{bkEnd_8cpp_aa5174ce0e698d30e1a35dcc9a95aa9f4}{invalidInsCount}
\item 
bool \hyperlink{bkEnd_8cpp_a5bc2e7d32b5d98c548bd9c05ea0336e5}{eoc}
\item 
bool \hyperlink{bkEnd_8cpp_a6c052602d1d43227768ad3807f7b7268}{eof}
\item 
long int \hyperlink{bkEnd_8cpp_a4c2112621e10ca7f39e060af81ccaab1}{corruptInsCount}
\item 
bool \hyperlink{bkEnd_8cpp_a36c2cd06ade9d3098dde0c50717fa838}{reportTrace} = false
\item 
bool \hyperlink{bkEnd_8cpp_abff560f06193e35b78e72071d5653eb0}{reportTraceAndHitMiss} = false
\item 
\hyperlink{structg__variable}{g\_\-variable} $\ast$ \hyperlink{bkEnd_8cpp_a594bdd547bbe5b3f5f4ca0429647a941}{\_\-\_\-g\_\-var}
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{bkEnd_8cpp_a1fe2792cb7bb7af1e331c6d059b53925}{iResStation}
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{bkEnd_8cpp_ab0e03ef58c817c2f8faa2ee8cb4db257}{iResStations} \mbox{[}NUM\_\-FUNC\_\-UNIT\mbox{]}
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{bkEnd_8cpp_abb15b2b37e31156813a393e46cb18ba1}{iMemBuf}
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{bkEnd_8cpp_a901b5b3874c558101a1c250f2f2d0662}{iWindow}
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$ \hyperlink{bkEnd_8cpp_ad73ae25f81e6e99482f3fbd5ba9664ce}{iROB}
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$ \hyperlink{bkEnd_8cpp_a992518257eb58a8e76b23747fbd88f9e}{pbROB}
\item 
\hyperlink{classList}{List}$<$ char $\ast$ $>$ $\ast$ \hyperlink{bkEnd_8cpp_a8fab7d3c15974f28a194e46d5041a7a6}{ICQ}
\item 
\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$$\ast$ \hyperlink{bkEnd_8cpp_a8c85ae26ca2aa6181da521dfdb7626b7}{\_\-pbLists}
\item 
\hyperlink{classList}{List}$<$ int $>$ $\ast$ \hyperlink{bkEnd_8cpp_acb9a5d4416a8eae707a46571f8e54bff}{SBpriorityList}
\item 
\hyperlink{classsideBuff}{sideBuff} $\ast$$\ast$ \hyperlink{bkEnd_8cpp_a940bb8467f99fe8b410375e47613acc9}{iSideBuff}
\item 
map$<$ long int, int $>$ \hyperlink{bkEnd_8cpp_a06e3b7f24bea52d1e3f4b9729aacd514}{inFlightLDops}
\item 
map$<$ long int, int $>$ \hyperlink{bkEnd_8cpp_a38d70a0557186ae085098575fbab0cb3}{memRdTotCountTable}
\item 
map$<$ long int, int $>$ \hyperlink{bkEnd_8cpp_a4a9366847a52b92f577935eed2f002df}{memRdMissCountTable}
\item 
map$<$ long int, float $>$ \hyperlink{bkEnd_8cpp_ab14bebb6d6e05c80319f2d8f4d01ca3a}{memRdMissRateTable}
\item 
map$<$ long int, float $>$ \hyperlink{bkEnd_8cpp_a933fdb35e831942cf441b78ecbc3d3a7}{correlationMap}
\item 
map$<$ long int, float $>$ \hyperlink{bkEnd_8cpp_a6f1336f38aabf029a0d9b4e4428e9a5e}{branchBiasProfileMap}
\item 
map$<$ long int, float $>$ \hyperlink{bkEnd_8cpp_adf10622e01bd8d6fdf36e5c73cc7fdac}{branchAccuracyMap}
\item 
map$<$ long int, float $>$ \hyperlink{bkEnd_8cpp_ad10d3c35c7ebe4161160c67b1f711335}{upldMissRateProfileMap}
\item 
map$<$ \hyperlink{global_2global_8h_a7ea74bb9ffd2e4d41550ae2383dd25bc}{ADDRS}, int $>$ \hyperlink{bkEnd_8cpp_aa5a81a60745b2467840283669f49ce28}{br\_\-pred\_\-update\_\-distance}
\item 
set$<$ long int $>$ \hyperlink{bkEnd_8cpp_aa8f7dd26d3ed214b8a93eca6f30cd6ea}{missingAccuracyBranches}
\item 
\hyperlink{classdependencyTable}{dependencyTable} $\ast$ \hyperlink{bkEnd_8cpp_ab1dae06b10269a1b683512c8ecb25def}{depTables}
\item 
\hyperlink{classdependencyTable}{dependencyTable} $\ast$ \hyperlink{bkEnd_8cpp_a96c2987acbb47290afce74588a45ea49}{LRFTables} \mbox{[}NUM\_\-PHRASEBLKS\mbox{]}
\item 
\hyperlink{global_2global_8h_a1883c47d0023d0f200e1d86eced6a070}{INS\_\-ID} \hyperlink{bkEnd_8cpp_a9a3892377020df8367aca5dcaede5232}{insID}
\item 
int \hyperlink{bkEnd_8cpp_a06a6e046fd7b9a66b03d334b1df5e3ad}{ROBsize}
\item 
int \hyperlink{bkEnd_8cpp_aeb8271044b5f2f0cc0d6b3ef8d3f288d}{pbROBsize}
\item 
\hyperlink{classparser}{parser} $\ast$ \hyperlink{bkEnd_8cpp_a9b8e7669bda57879d8abc5234b2f0b19}{parse}
\item 
long int \hyperlink{bkEnd_8cpp_ac00b6eff67b68a541747526ab37ce1f3}{insParseCap} = -\/1
\item 
\hyperlink{classTournamentBP}{TournamentBP} $\ast$ \hyperlink{bkEnd_8cpp_a00d2c11cba3a3f23cf4967a1e481ff7c}{predictor} = NULL
\item 
int \hyperlink{bkEnd_8cpp_ae0b3cf4db09e8c26c2ab03dbe18bfb19}{numFU} = NUM\_\-FUNC\_\-UNIT
\item 
bool \hyperlink{bkEnd_8cpp_ac894a295997e8bd0440d43cafc9a630d}{aluAvail} \mbox{[}NUM\_\-FUNC\_\-UNIT\mbox{]}
\item 
int \hyperlink{bkEnd_8cpp_a09ed74baaab433989cac4334dd14838f}{aluFreeTime} \mbox{[}NUM\_\-FUNC\_\-UNIT\mbox{]}
\item 
long int \hyperlink{bkEnd_8cpp_a71ca470c14cd7c280dc06f84dcb1ebd5}{aluStat} \mbox{[}NUM\_\-FUNC\_\-UNIT\mbox{]}
\item 
\hyperlink{binaryTranslator_2global_8h_a7aead736a07eaf25623ad7bfa1f0ee2d}{type} \hyperlink{bkEnd_8cpp_a229b024d8df7a4e3507e2746da8bf972}{aluKind} \mbox{[}NUM\_\-FUNC\_\-UNIT\mbox{]}
\item 
\hyperlink{classcache}{cache} $\ast$ \hyperlink{bkEnd_8cpp_aff6a511d0f79b17fa32081abfd2b5bc6}{\_\-L1}
\item 
\hyperlink{classcache}{cache} $\ast$ \hyperlink{bkEnd_8cpp_a36621f4e017586bf3fd070b443755da2}{\_\-L2}
\item 
\hyperlink{classcache}{cache} $\ast$ \hyperlink{bkEnd_8cpp_ad3c630a534ba16b1ffdc565033ad36ee}{\_\-L3}
\item 
\hyperlink{classregFile}{regFile} $\ast$ \hyperlink{bkEnd_8cpp_a2d3dfa31b077f1d81553e749601f1c58}{RF}
\item 
int \hyperlink{bkEnd_8cpp_abca2f358bc2b145a7d9fbb9395ad9c89}{cacheLat} \mbox{[}MEM\_\-HIGHERARCHY\mbox{]}
\item 
\hyperlink{classregisterRename}{registerRename} $\ast$ \hyperlink{bkEnd_8cpp_af5a59016fe141b79dfa006fac24d657e}{GRF}
\item 
\hyperlink{classlsq}{lsq} $\ast$ \hyperlink{bkEnd_8cpp_ad6065125a6a2298f4e8d8fc1cbe70927}{loadStoreQue}
\item 
bool \hyperlink{bkEnd_8cpp_aca6f12e6524e5175a4ea527b5eb137e6}{isCacheBusFree} = true
\item 
bool \hyperlink{bkEnd_8cpp_a398527b3e9e358c345c5047b16871957}{debug}
\item 
long int \hyperlink{bkEnd_8cpp_a24ddb63d7b594cb1489ae68dfa66e584}{cycle}
\item 
int \hyperlink{bkEnd_8cpp_a1985e535946ec8df48f67faaa3f0e2bf}{phCycle} = 0
\item 
int \hyperlink{bkEnd_8cpp_a40d804e4f2ea76bca108eb373fa6ae65}{frCycle} = 0
\item 
long int \hyperlink{bkEnd_8cpp_ae6c3a951ad171705af12e339de84894f}{numSideBuffs} = NUM\_\-SIDE\_\-BUFFERS
\item 
long int \hyperlink{bkEnd_8cpp_ac80333f7873dfd04b73922669d3df554}{SBlength} = SB\_\-SIZE\_\-LIMIT
\item 
bool \hyperlink{bkEnd_8cpp_a880392d0383fea210f5ae5b88cc5eeba}{reschedule} = false
\item 
bool \hyperlink{bkEnd_8cpp_a11a86001d145184dffcc82c55772537c}{makePhrase} = false
\item 
float \hyperlink{bkEnd_8cpp_a88cfebd9f1e296c291bf05c5a78a6177}{unpredMemOpThreshold} = UNPRED\_\-MEM\_\-THRESHOLD
\item 
int \hyperlink{bkEnd_8cpp_a2e417281295ec1ce0e132e2a37ad227d}{phraseSizeBound} = MAX\_\-NUM\_\-INS\_\-VISITORS
\item 
int \hyperlink{bkEnd_8cpp_ab89bce3b6c39af4337cdc6d48e717238}{parseHitMiss} = 0
\item 
int \hyperlink{bkEnd_8cpp_a1d888710b2006447c5080e525cdccd4d}{isSquashed} = false
\item 
char $\ast$ \hyperlink{bkEnd_8cpp_a25dae25c3bf9b28d54eb4df7afb2a491}{comment}
\item 
float \hyperlink{bkEnd_8cpp_a26c3037ee5ff6d9c3abfd650323b039c}{ipc}
\item 
long int \hyperlink{bkEnd_8cpp_a22c7fe5fbee20c3db9579adc7a36335f}{insCount}
\item 
long int \hyperlink{bkEnd_8cpp_a2aa917380abc6bd6e4a5af04ad15fa20}{executeInsCount}
\item 
long int \hyperlink{bkEnd_8cpp_aec0b962de2a1d8dc9d6c4de39385886a}{completeInsCount}
\item 
long int \hyperlink{bkEnd_8cpp_a6773b2c2bce2cabc7252077c70015122}{iROBSize} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a296533024000eaee9a17e3b8e5249869}{iWinSize} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a5458bd6aadaa6a425617e8fffc205295}{iResStnSize} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a87be851ed79d85fbdd80b6832c080aea}{iResStnsSize} \mbox{[}NUM\_\-FUNC\_\-UNIT\mbox{]}
\item 
long int \hyperlink{bkEnd_8cpp_a2a44290329192be0c7810087d3c92cb4}{pbListsSize} \mbox{[}NUM\_\-PHRASEBLKS\mbox{]}
\item 
long int \hyperlink{bkEnd_8cpp_a27b503b3b0cd16ca59209476a997c0ba}{iSideBufSize} = 0
\item 
long int \hyperlink{bkEnd_8cpp_ab381424ceda4b88473c155e7eb6e70cb}{iMemBuffSize} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a6e3caa21589fa52000a11353bb59e34c}{inFlightLDopsSize} = 0
\item 
long int \hyperlink{bkEnd_8cpp_ac753d4e26142b8751fabcf2793ffd2b3}{totNumSBactivations} = 0
\item 
long int $\ast$ \hyperlink{bkEnd_8cpp_a280978aed4c98c12ac739598e05e85e0}{numSBactivations} = new long int \mbox{[}\hyperlink{backend_2parser_8cpp_a33b052a847ffe72153acdfeaa15c48da}{numSideBuffs}\mbox{]}
\item 
long int \hyperlink{bkEnd_8cpp_ac4f66ee745d0d0159ccf3630448f1bca}{totNumSBreactivations} = 0
\item 
long int $\ast$ \hyperlink{bkEnd_8cpp_a00a3fa92a491104663c3650d4bccc137}{numSBreactivations} = new long int \mbox{[}\hyperlink{backend_2parser_8cpp_a33b052a847ffe72153acdfeaa15c48da}{numSideBuffs}\mbox{]}
\item 
long int \hyperlink{bkEnd_8cpp_a4bfc1483b6aefe8b6422fc04f4cfb7e0}{totInsVisitingSBcount} = 0
\item 
long int $\ast$ \hyperlink{bkEnd_8cpp_a413be8a490fd3df8f42aae278091b987}{insVisitingSBcount} = new long int \mbox{[}\hyperlink{backend_2parser_8cpp_a33b052a847ffe72153acdfeaa15c48da}{numSideBuffs}\mbox{]}
\item 
long unsigned \hyperlink{bkEnd_8cpp_a373fbba4cafdbfeb353503c4dc35d1e4}{totalSBsize} = 0
\item 
long unsigned $\ast$ \hyperlink{bkEnd_8cpp_aaae1ecdf840d99afd76706706450524b}{SBsize} = new long unsigned \mbox{[}\hyperlink{backend_2parser_8cpp_a33b052a847ffe72153acdfeaa15c48da}{numSideBuffs}\mbox{]}
\item 
long int \hyperlink{bkEnd_8cpp_aff18f359b22d2e65871b803be6edc8c1}{totSBactiveCycles} = 0
\item 
long int $\ast$ \hyperlink{bkEnd_8cpp_a782a546d55a0f531f577aab7342c5ae8}{SBactiveCycles} = new long int \mbox{[}\hyperlink{backend_2parser_8cpp_a33b052a847ffe72153acdfeaa15c48da}{numSideBuffs}\mbox{]}
\item 
long int \hyperlink{bkEnd_8cpp_a1f95e2dbf2d6bbd0969150ab292206ec}{totInsCountWhenSBon} = 0
\item 
long int $\ast$ \hyperlink{bkEnd_8cpp_a0e2d51cb13db227f9dc3a8c90f4b24e4}{InsCountWhenSBon} = new long int \mbox{[}\hyperlink{backend_2parser_8cpp_a33b052a847ffe72153acdfeaa15c48da}{numSideBuffs}\mbox{]}
\item 
long int \hyperlink{bkEnd_8cpp_ace3198fb3de7e5dc13d0995f38b530fb}{totSBoffCycles} = 0
\item 
long int \hyperlink{bkEnd_8cpp_ae78c4cfb3041a36224ee6a1246904a74}{numOnSideBuffs} = 0
\item 
long int $\ast$ \hyperlink{bkEnd_8cpp_a8e6f89aabd81d260a14e7c203d6e08a7}{SBoffCycles} = new long int \mbox{[}\hyperlink{backend_2parser_8cpp_a33b052a847ffe72153acdfeaa15c48da}{numSideBuffs}\mbox{]}
\item 
long int \hyperlink{bkEnd_8cpp_ac8d2ba075f1720da64e00e03081ce681}{numMemOps} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a99e158204dabc119d57a8ddf66d413c9}{numALUOps} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a00f80363001f9affede7c0feb25eac16}{numFPUOps} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a60d14c1c616033f85bff10082d441222}{numBROps} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a749b154cd6624c9481b25d12c7f267f1}{numAssignOps} = 0
\item 
long int \hyperlink{bkEnd_8cpp_ac01b32c964c6071fd4f45869b33b9284}{missPredBROps} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a82767088fb8520248dff1da53476f47d}{missPredBROps\_\-fetch} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a7b30f72f4f83f3f8f1841216e7091739}{missPredBROps\_\-NT} = 0
\item 
long int \hyperlink{bkEnd_8cpp_afc0974196154292eb093fa44f778d54d}{missPredBROps\_\-NT\_\-fetch} = 0
\item 
long int \hyperlink{bkEnd_8cpp_aaead9f67122e91f57171b797c893b832}{numBrOps\_\-predT} = 0
\item 
long int \hyperlink{bkEnd_8cpp_aed1c14b28f4f14e669c73847aa18524f}{numBrOps\_\-predT\_\-fetch} = 0
\item 
long int \hyperlink{bkEnd_8cpp_ac95e4e39b07dbbbd1026abd949169dba}{numReadOps} = 0
\item 
long int \hyperlink{bkEnd_8cpp_afb39d8142b31567500131a68f648a699}{numWriteOps} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a0a0796a6caa647405fec70ca633e777f}{numDepInOtherSBs} = 0
\item 
long int \hyperlink{bkEnd_8cpp_ac6a2252e34991ece96daab9fac67d3ed}{emptyResStation} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a11e3878a580a088bd3ce667a54e8a62d}{stFwdMemOp} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a7b72b8299099888d04bef51d3bdd490c}{nonBlockingMemOp} = 0
\item 
long int \hyperlink{bkEnd_8cpp_abf2fc095166550665fe650cc1b5f6a74}{cacheAccessMemOp} = 0
\item 
long int \hyperlink{bkEnd_8cpp_ac3e602b1cb0c363bc4dcb6e133d35200}{maxSBsize} = -\/1
\item 
long int \hyperlink{bkEnd_8cpp_abd4b229feea4f321d63060675b7348bd}{minSBsize} = 100000000000
\item 
long int \hyperlink{bkEnd_8cpp_a60db58d54ff9814390e82ed746c7e484}{totFrameSize} = 0
\item 
long int \hyperlink{bkEnd_8cpp_af259df35d99544e6c1940312d65e3658}{totMainStreamBound} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a683df1ef3f168d6cbca3bfb0d5f97bc6}{windowSatration} = 0
\item 
\hyperlink{classList}{List}$<$ int $>$ $\ast$ \hyperlink{bkEnd_8cpp_a11210922214a240fb374152864c598ca}{SBsizeList} = new \hyperlink{classList}{List}$<$int$>$
\item 
\hyperlink{classList}{List}$<$ void $\ast$ $>$ $\ast$ \hyperlink{bkEnd_8cpp_a5726e3725395e6cca4a0f649f0d9b9dd}{bp\_\-hist\_\-list} = new \hyperlink{classList}{List}$<$void$\ast$$>$
\item 
long int \hyperlink{bkEnd_8cpp_a4525b6c832e1577aa761e33b2f7f8828}{longLatOpWhenSPisON} = 0
\item 
long int \hyperlink{bkEnd_8cpp_ac7c424dd8e041d935c7660903f51e3aa}{longLatOpWhenSPisDraining} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a6b51da567e6b8a11bba9ec1f241f1c97}{longLatOpWhenSPisWaiting} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a63c4fc64877e8bbc0f9a2b03e75747b8}{unpredMemOpCnt} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a04ebe6ac3125163359d4a78297881816}{unpredMemInsCnt} = 0
\item 
long int \hyperlink{bkEnd_8cpp_aa0401948da1730abb47403f5abfb0177}{totNumPhrase} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a7014445eaece6bc443d6b47b3076d4db}{totNumFrag} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a97ad0b6082503d6f33a93ac5c590e480}{totNumSoftBound} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a17080a3e155de1ec688dbf44eac39838}{totNumPhUnpredMemOp} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a74ec424cfa117db797896d4ba741ef85}{totNumRootIns} = 0
\item 
long int \hyperlink{bkEnd_8cpp_af11920776ab445587c1ce2f48679e512}{totNumPhraseAncestors} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a4e77e421d1fab38cc99f0b8d6fe32381}{totNumPhGenResets} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a5ee417237aef174d8cd2bb79d099f4e2}{totPhStall} = 0
\item 
long int \hyperlink{bkEnd_8cpp_adff839258d7ad49e2b0fc21c1eafad40}{totFrStall} = 0
\item 
long int \hyperlink{bkEnd_8cpp_ade40078060c9ea45a4a30adbcad861bf}{totNumRootPh} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a148b0106fd99040a9fd6aba42a7f5a51}{totNumCritPathViol} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a839b51bce9a6c8b6c9d9080c1e86c2cc}{unexpectedMiss} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a04887990fda36c4ec9170f07fc7de069}{unexpecteedLat} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a68b1015c6457559a53773263cbf73dfa}{totNumRealFrag} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a048055f984c4d0c31fc8a133c206f73e}{totSizRealFrag} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a7067d74f5505d4c1e8d8ac5ec020a1b8}{totNumOfSigleFragPhrases} = 0
\item 
long int \hyperlink{bkEnd_8cpp_aaf53c801386a341acc33d0ff2d6e4f05}{numReadyFrags} = 0
\item 
long int \hyperlink{bkEnd_8cpp_aa6649eec80584c1612637ea9e63fbd9c}{interFragStallCycle} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a0a3ac309d2b8e9c712629d4bc1f6ac9d}{evaltMissRtCorrel} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a0cbaf833a38f9d2dc7a056c175c1b6bd}{activeBuffCnt} = 0
\item 
long int \hyperlink{bkEnd_8cpp_add0bef1c5cb38bedd4e253cc424d48ca}{bbCount} = 0
\item 
long int \hyperlink{bkEnd_8cpp_add9c322dd68dbffceca88b569baf8842}{brInsCount} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a36872c8ab2563fdb198259c76b40c4b3}{fetchStallCycle} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a48c38e208d1bbc2c7fca2ecd344652b1}{br\_\-pred\_\-update\_\-dist} = 0
\item 
bool \hyperlink{bkEnd_8cpp_a7277fb65c975b154a18137469afeb3f2}{UPLDhoist} = false
\item 
bool \hyperlink{bkEnd_8cpp_a8486b3a365530862ecd746e9277391c2}{branchProfileFlag} = false
\item 
bool \hyperlink{bkEnd_8cpp_a3e399a2c5b99f032319799880f78cf0b}{upldProfileFlag} = true
\item 
bool \hyperlink{bkEnd_8cpp_a24de26574dd41fb459f4e9c7eef97d2d}{perfectRegRen} = false
\item 
\hyperlink{global_2global_8h_a01e05efee3068c759b10b6181a6065e1}{brMode} \hyperlink{bkEnd_8cpp_ac7bd9648b0cf77fbafdeb4490e46e7de}{branchMode} = noBrMode
\item 
\hyperlink{global_2global_8h_a0685c5d42062f018dda85c9d62f3ac1f}{memModel} \hyperlink{bkEnd_8cpp_a4b11b7c87b23b4b281fdcf9c67725e39}{memoryModel} = PERFECT
\item 
int \hyperlink{bkEnd_8cpp_a4b4b7dee6e38ef31b4c9cca4d54523a1}{inCompleteBBbuffIndx} = -\/1
\item 
long long int \hyperlink{bkEnd_8cpp_ad5a50c792dddaaaec411854653939d8d}{lqSize} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a906e52723622864ac6f5d1942021545c}{sqSize} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a960c872c7813979fde70109b980a40d6}{rrSize} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a6952280a935d46003680da298022dd98}{lrfCount} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_aba6b75941fb6bb5d268f339b9cd68312}{grfCount} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a8ce9db15f8587f6c52ec4475a875d399}{lrfWrCountPerIns} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a7bf86f930cb5df55e96c5b80ccd9e9b3}{grfWrCountPerIns} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a049a2414981f3c3a351ce982f8ab0982}{lrfRdCountPerIns} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a9559f8e45d45ac943aca5b966aacda55}{grfRdCountPerIns} = 0
\item 
\hyperlink{classhist}{hist} $\ast$ \hyperlink{bkEnd_8cpp_a37d85a3b8a3536e66166c451d5e2e713}{frSizeHist}
\item 
\hyperlink{classhist}{hist} $\ast$ \hyperlink{bkEnd_8cpp_afa2bf6bba12df3c2a5a49fd5ef7646c6}{frLatHist}
\item 
\hyperlink{classhist}{hist} $\ast$ \hyperlink{bkEnd_8cpp_aa9f966543a1fad5f317290d2529dee5b}{phCritPathHist}
\item 
\hyperlink{classhist}{hist} $\ast$ \hyperlink{bkEnd_8cpp_a6bf02640e739260e991ef79f520ec0a4}{phSizeHist}
\item 
\hyperlink{classhist}{hist} $\ast$ \hyperlink{bkEnd_8cpp_a9e3229bf4d007be6b9e5e4cc9473e304}{correlationHist}
\item 
\hyperlink{classhist}{hist} $\ast$ \hyperlink{bkEnd_8cpp_a9c0332d1a8ff0a6bd8af16de918bf90a}{numChildrenHist}
\item 
\hyperlink{classhist}{hist} $\ast$ \hyperlink{bkEnd_8cpp_a3ef201c944505a0c7cc1d3367a773586}{numParentsHist}
\item 
FILE $\ast$ \hyperlink{bkEnd_8cpp_a657f56ad87b88b8b18377a96c1e606f8}{junk}
\item 
long long int \hyperlink{bkEnd_8cpp_a514b3db4380a7c56e04f22b24fd94fc2}{squashInsCount} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a1ee4089bacf27c9f9cb690babeb57b55}{squashWinInsCount} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a0a4857c3deadd79ab3ea72b120ba0fe8}{squashPhrInsCount} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a18e20b819b11dbfb38a06e026142f8e0}{squashRSinsCount} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a4f7c62b80c5be8c541a7a924ac1f7a60}{num\_\-squashed\_\-lrf\_\-wr\_\-fetch\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_aad90d32e2ca559f064b10531d78fb8f9}{num\_\-squashed\_\-lrf\_\-rd\_\-fetch\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a25e3c694cc23a732aabf5f2b2a023519}{num\_\-squashed\_\-lrf\_\-wr\_\-ready\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a755444f10a85ea8212fd5beff948521e}{num\_\-squashed\_\-lrf\_\-rd\_\-ready\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a6fecb1d1e47a460f2d215df7146c9804}{num\_\-squashed\_\-lrf\_\-wr\_\-execute\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a40bffc89ce6f958b3318f572dafcdcb1}{num\_\-squashed\_\-lrf\_\-rd\_\-execute\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a2ce0e6721860e7f0e00f1e786363265f}{num\_\-squashed\_\-lrf\_\-wr\_\-complete\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_af336deada0618ea56c44ba90f1e16421}{num\_\-squashed\_\-lrf\_\-rd\_\-complete\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a294e848610ffe17cdab79ed24123bd01}{num\_\-squashed\_\-grf\_\-wr\_\-fetch\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_aca08ffd71d4708a90ff27b13e60c1171}{num\_\-squashed\_\-grf\_\-rd\_\-fetch\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a03b0149a23ebc201907949388fe562ec}{num\_\-squashed\_\-grf\_\-wr\_\-ready\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_afcfce379af6def85e339f519477e23fe}{num\_\-squashed\_\-grf\_\-rd\_\-ready\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_adcbe2621722be0f220d104181e11a7d0}{num\_\-squashed\_\-grf\_\-wr\_\-execute\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a1bc3804191941684f302988c1a2b5a97}{num\_\-squashed\_\-grf\_\-rd\_\-execute\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a409c0ede2016a5a944ea82c1225f80d4}{num\_\-squashed\_\-grf\_\-wr\_\-complete\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a38fd9dc636261f7b48415dff41b44e0d}{num\_\-squashed\_\-grf\_\-rd\_\-complete\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_abc0f16ebe353acf6b6fdb8a253af477d}{squashRegRenCount} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_ab8599a08e3c482c99e25b917e8342c2e}{squashLRFcount} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a86a76ec07deef440147ede7b0664358c}{num\_\-squashed\_\-grf\_\-rd\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a844295d5a281e437cceae9db2865a4ce}{num\_\-squashed\_\-grf\_\-wr\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a1fa21c200e5d00578252d37246b857ad}{num\_\-squashed\_\-lrf\_\-rd\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a231286cf17c5cfc1e4c48193eaf61836}{num\_\-squashed\_\-lrf\_\-wr\_\-reg} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a2cd5012e008846c3d0473aea56dc0421}{squashSQinsCount} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a389709682848b6b5fb2dd86394287e27}{squashLQinsCount} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_a0e845623020a577aea1623384ed5d9eb}{squashBRinsCount} = 0
\item 
int \hyperlink{bkEnd_8cpp_a8b2251d5f55aba867043997b1f794fa7}{squashCount} = 0
\item 
bool \hyperlink{bkEnd_8cpp_a155d4466ed8ddecb8cbb21f3b798904c}{bbPrediction}
\item 
int \hyperlink{bkEnd_8cpp_ad56ae4aa91c8a06d94f2b137fa93258d}{PhListSize} = 100
\item 
int \hyperlink{bkEnd_8cpp_a3709ef01c299a1b84a1b023b9a44d4bc}{phraseID} = 0
\item 
map$<$ long int, int $>$ \hyperlink{bkEnd_8cpp_acf42f0f2445bdd6c9d588d0e642e3f0b}{num\_\-bypassed\_\-wbb}
\item 
map$<$ long int, int $>$ \hyperlink{bkEnd_8cpp_afe56689ffc9fa80e64c2b5cbd7c975cb}{num\_\-ins\_\-exe\_\-cnt}
\item 
map$<$ long int, float $>$ \hyperlink{bkEnd_8cpp_a6b39a22d9e7e986ea0df5ebfb42e9f24}{ins\_\-exe\_\-hoist\_\-accuracy}
\item 
bool \hyperlink{bkEnd_8cpp_acc1a97d6ee9b32a86dc0697b17860f31}{collect\_\-stat} = false
\item 
int \hyperlink{bkEnd_8cpp_a3940161b607133ebd851ec48a8eb6e51}{print\_\-count} = 0
\item 
int \hyperlink{bkEnd_8cpp_aa40c785bbba5c399bea190f191d3ebcd}{laten} = -\/1
\item 
bool \hyperlink{bkEnd_8cpp_a73bd470252d42e355346dfd2575c776d}{start\_\-print} = false
\item 
long long int \hyperlink{bkEnd_8cpp_a295eb046e3bc33d7d17cf3e21c71910e}{total\_\-num\_\-strand\_\-ins} = 0
\item 
long long int \hyperlink{bkEnd_8cpp_adbdb9667280430c4647823ce818645db}{dyn\_\-num\_\-strands} = 0
\item 
bool \hyperlink{bkEnd_8cpp_a6c1acac6218b4ae58652b78892eaf778}{xLevelDeepEnable} = false
\item 
int \hyperlink{bkEnd_8cpp_a9d371f0f4b31309fd4613ce93821c162}{mainStreamInsCount} = 0
\item 
int \hyperlink{bkEnd_8cpp_a118e471f7e27b0e5a45d2e0b2d7d8a1a}{mainStreamBound} = -\/1
\item 
\hyperlink{classList}{List}$<$ int $>$ $\ast$ \hyperlink{bkEnd_8cpp_a5d56c51d0584a2183c83a3dfe157e724}{delList} = new \hyperlink{classList}{List}$<$int$>$
\item 
\hyperlink{classList}{List}$<$ int $>$ $\ast$ \hyperlink{bkEnd_8cpp_a441b50ca30ab742e02e0d1aca889307b}{SBlist} = new \hyperlink{classList}{List}$<$int$>$
\item 
int \hyperlink{bkEnd_8cpp_aa1ce2c4c6b8b37f120c7d5f8672a61a1}{numActiveSideBuffs} = 1
\item 
int \hyperlink{bkEnd_8cpp_a18ef05402bcffc4388618f03462778da}{drainedSBcount} = 0
\item 
long int \hyperlink{bkEnd_8cpp_a1dd7dc7ec5b0445afcc24d3fc4bd4164}{runningFragNumber}
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{bkEnd_8cpp_ac404f1539d9a3d1ef63387444a621721}{
\index{bkEnd.cpp@{bkEnd.cpp}!addFrag@{addFrag}}
\index{addFrag@{addFrag}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{addFrag}]{\setlength{\rightskip}{0pt plus 5cm}void addFrag (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf fragment} $\ast$ $>$ $\ast$}]{iFr, }
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_ac404f1539d9a3d1ef63387444a621721}

\begin{DoxyCode}
{}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a699e911f02cc068558e37f3496d086ce}{
\index{bkEnd.cpp@{bkEnd.cpp}!addIns@{addIns}}
\index{addIns@{addIns}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{addIns}]{\setlength{\rightskip}{0pt plus 5cm}int addIns (
\begin{DoxyParamCaption}
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a699e911f02cc068558e37f3496d086ce}

\begin{DoxyCode}
                       {
        //At SQUASH, wait for ROB to drain
        if (isSquashed && iROB->NumElements() > 0) {return 0;}
        else if (isSquashed && iROB->NumElements() == 0) {
                Assert(memoryModel == NAIVE_SPECUL);
                isSquashed = false;
                //printf("SQUASH END\n");
                if (!perfectRegRen && coreType != IN_ORDER) GRF->flush_fRAT();
                depTables->flush_depTables();
        }
        //Fill ICQ
        if (!eof) addToInsCache(cycle);
        //int activeWinRange = iROB->NumElements() - iWinPointer;
        if (iROB->NumElements() < ROBsize) {
                int diff = ROBsize - iROB->NumElements();
                for (int i = 0; i < diff; i++) {
                        instruction *newIns = new instruction;
                        newIns->setStatus(FETCH, cycle, -1);
                        int result = setupNewIns(newIns);
                        if (debug) printf ("result = %d\n", result);
                        if (result == -1) {
                                //eoc = true; //End of program
                                delete newIns;
                                break;
                        } else if (result == -2) {
                                popFromInsCache();
                                delete newIns;
                                i--;
                                continue; //Skip the line and read next line
                        } else {
                                insID++;
                                newIns->setInsID(insID);
                                bool isRRstall = false, isLSQstall = false;
                                if (perfectRegRen) {
                                        /* Manage LSQ */ 
                                        if (memoryModel == PERFECT) {
                                                newIns->
      perfect_MemDependencyTable(depTables, coreType, numSideBuffs);
                                        } else if (memoryModel == TOTAL_ORDER) {
                                                newIns->
      totalOrder_MemDependencyTable(loadStoreQue);
                                        } else if (memoryModel == NAIVE_SPECUL) {
      
                                                instruction* ancestor = NULL;
                                                bool sqHasIncomplIns = 
      loadStoreQue->SQhasIncompleteIns();
                                                if (sqHasIncomplIns) ancestor = 
      loadStoreQue->getSQtail();
                                                isLSQstall = oooLD_lsqHazard (
      loadStoreQue, newIns);
                                                if (!isLSQstall) oooLD_lsqEnque (
      loadStoreQue, newIns);
                                                if (sqHasIncomplIns && !isLSQstal
      l) newIns->storeOrder_MemDependencyTable(ancestor);
                                        }
                                        if (isLSQstall) {
                                                /*-----STAT-----*/
                                                fetchStallCycle++;
                                                /*-----STAT-----*/
                                                delete newIns;
                                                insID--;
                                                break;
                                        } else {
                                                popFromInsCache();
                                        }
                                        newIns->infRegdependencyTable(depTables, 
      coreType);
                                        newIns->br_dependencyTable(depTables);
                                } else if (coreType == IN_ORDER) {
                                        /* Manage LSQ */ 
                                        if (memoryModel == PERFECT) {
                                                newIns->
      perfect_MemDependencyTable(depTables, coreType, numSideBuffs);
                                        } else if (memoryModel == TOTAL_ORDER) {
                                                newIns->
      totalOrder_MemDependencyTable(loadStoreQue);
                                        } else if (memoryModel == NAIVE_SPECUL) {
      
                                                instruction* ancestor = NULL;
                                                bool sqHasIncomplIns = 
      loadStoreQue->SQhasIncompleteIns();
                                                if (sqHasIncomplIns) ancestor = 
      loadStoreQue->getSQtail();
                                                isLSQstall = oooLD_lsqHazard (
      loadStoreQue, newIns);
                                                if (!isLSQstall) oooLD_lsqEnque (
      loadStoreQue, newIns);
                                                if (sqHasIncomplIns && !isLSQstal
      l) newIns->storeOrder_MemDependencyTable(ancestor);
                                        }
                                        if (isLSQstall) {
                                                /*-----STAT-----*/
                                                fetchStallCycle++;
                                                /*-----STAT-----*/
                                                delete newIns;
                                                insID--;
                                                break;
                                        } else {
                                                popFromInsCache();
                                        }
                                        newIns->noRRdependencyTable(depTables, 
      coreType);
                                        newIns->br_dependencyTable(depTables);
                                } else if (coreType == OUT_OF_ORDER) {
                                        /* Manage LSQ */ 
                                        if (memoryModel == PERFECT) {
                                                isRRstall = newIns->renameRegs(
      GRF, coreType);
                                                if (isRRstall) { //if regrename n
      ot available, stall
                                                        /*-----STAT-----*/
                                                        fetchStallCycle++;
                                                        /*-----STAT-----*/
                                                        delete newIns;
                                                        insID--;
                                                        break;
                                                }
                                                newIns->
      perfect_MemDependencyTable(depTables, coreType, numSideBuffs);
                                        } else if (memoryModel == TOTAL_ORDER) {
                                                isRRstall = newIns->renameRegs(
      GRF, coreType);
                                                if (isRRstall) { //if regrename n
      ot available, stall
                                                        /*-----STAT-----*/
                                                        fetchStallCycle++;
                                                        /*-----STAT-----*/
                                                        delete newIns;
                                                        insID--;
                                                        break;
                                                }
                                                newIns->
      totalOrder_MemDependencyTable(loadStoreQue);
                                        } else if (memoryModel == NAIVE_SPECUL) {
      
                                                instruction* ancestor = NULL;
                                                bool sqHasIncomplIns = 
      loadStoreQue->SQhasIncompleteIns();
                                                if (sqHasIncomplIns) ancestor = 
      loadStoreQue->getSQtail();
                                                isLSQstall = oooLD_lsqHazard (
      loadStoreQue, newIns);
                                                if (isLSQstall) {
                                                        /*-----STAT-----*/
                                                        fetchStallCycle++;
                                                        /*-----STAT-----*/
                                                        delete newIns;
                                                        insID--;
                                                        break;
                                                }
                                                isRRstall = newIns->renameRegs(
      GRF, coreType);
                                                if (isRRstall) { //if regrename n
      ot available, stall
                                                        /*-----STAT-----*/
                                                        fetchStallCycle++;
                                                        /*-----STAT-----*/
                                                        delete newIns;
                                                        insID--;
                                                        break;
                                                }
                                                oooLD_lsqEnque (loadStoreQue, new
      Ins);
                                                if (sqHasIncomplIns) newIns->
      storeOrder_MemDependencyTable(ancestor);
                                        }
                                        popFromInsCache();
                                        newIns->br_dependencyTable(depTables);
                                } else {
                                        Assert(true == false && "Depeency provisi
      ons for this core type is not supported.");
                                }
                                /*-----STAT-----*/
                                numParentsHist->addElem(newIns->getNumAncestors()
      );
                                /*-----STAT-----*/
                                if (reschedule == false && makePhrase == false)
                                        iWindow->Append(newIns);
                                iROB->Append(newIns);
                                newIns->setBrMode(branchMode);
                                newIns->findPhraseAncestors(); //TODO this should
       go somewhere else
                                newIns = NULL;
                                //printf("TEST: newIndx = %d, ROB size = %d\n", *
      iWindow->Nth(iWindow->NumElements()-1), iROB->NumElements());
                        }
                }
                if (debug) printf ("Added %d instruction(s)\n", diff);
        } else {
                if (debug) printf ("WARNING: The iROB is FULL\n");
        }
        return 0;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a9401b69204b88b4ecc302d76c27ad810}{
\index{bkEnd.cpp@{bkEnd.cpp}!addLastBracket@{addLastBracket}}
\index{addLastBracket@{addLastBracket}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{addLastBracket}]{\setlength{\rightskip}{0pt plus 5cm}void addLastBracket (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a9401b69204b88b4ecc302d76c27ad810}

\begin{DoxyCode}
                      {
        if (strcmp(ICQ->Nth(0), "{") == 0 || strcmp(ICQ->Nth(0),"{\n") == 0) retu
      rn;
        char *c = new char[INS_STRING_SIZE];
        strcpy(c, "{");
        //printf("-%s\n",c);
        ICQ->InsertAt(c,0);
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a73b0a124e04ab7ad583a8ad063d501c5}{
\index{bkEnd.cpp@{bkEnd.cpp}!addPhrase@{addPhrase}}
\index{addPhrase@{addPhrase}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{addPhrase}]{\setlength{\rightskip}{0pt plus 5cm}void addPhrase (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf phrase} $\ast$ $>$ $\ast$}]{iPh, }
\item[{int}]{cycle, }
\item[{{\bf dot} $\ast$}]{d}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a73b0a124e04ab7ad583a8ad063d501c5}

\begin{DoxyCode}
                                                       {
        //int activeWinRange = iROB->NumElements() - iWinPointer;
        if (iPh->NumElements() < PhListSize) {
                int diff = PhListSize - iPh->NumElements();
                char c[INS_STRING_SIZE];
                for (int i = 0; i < diff; i++) {
                        while(true) {
                                if (fgets (c, INS_STRING_SIZE, pinFile) == NULL) 
      {
                                        eoc = true;
                                        delete d;
                                        return;} //EOC
                                //printf("%c\n",c[0]);
                                if (c[0] == '{') {
                                        phrase* ph = new phrase(phraseID);
                                        phraseID++;
                                        while(true) {
                                                if (fgets (c, INS_STRING_SIZE, 
      pinFile) == NULL) {
                                                        eoc = true;
                                                        printf("An incomplete phr
      ase has been detected!\n");
                                                        for (int j = 0; j < iPh->
      NumElements(); j++) {
                                                                printf ("%d, ", i
      Ph->Nth(j)->getPhraseSize());
                                                        }
                                                        exit(-1);} //EOC
                                                //printf("%c\n",c[0]);
                                                if (c[0] != '}') {
                                                        instruction *newIns = new
       instruction;
                                                        newIns->setStatus(FETCH, 
      cycle, -1);
                                                        int result = 
      setupNewInsV2(newIns, c);
                                                        if (result == -1) {
                                                                eoc = true;
                                                                delete newIns;
                                                                break;
                                                        } //EOC
                                                        else if (result == -2) {
                                                                delete newIns;
                                                                i--;
                                                                continue; //Skip 
      the line and read next line
                                                        } else {
                                                                insID++;
                                                                newIns->setInsID(
      insID);
                                                                newIns->
      br_dependencyTable(depTables);
                                                                /* Manage LSQ */ 
      
                                                                if (memoryModel =
      = PERFECT) {
                                                                        newIns->
      perfect_MemDependencyTable(depTables, coreType, numSideBuffs);
                                                                } else if (
      memoryModel == TOTAL_ORDER) {
                                                                        newIns->
      totalOrder_MemDependencyTable(loadStoreQue);
                                                                } else if (
      memoryModel == NAIVE_SPECUL) {
                                                                        
      oooLD_lsqEnque (loadStoreQue, newIns);
                                                                }
                                                                newIns->
      setMyPhrase(ph);
                                                                //if (reschedule 
      == false)
                                                                //      iWindow->
      Append(newIns);
                                                                iROB->Append(newI
      ns);
                                                                ph->addToPhrase(n
      ewIns);
                                                                newIns = NULL;
                                                        }
                                                } else {break;}
                                        }
                                        Assert(ph->getPhraseSize() > 0);
                                        //phSizeHist->addElem(ph->getPhraseSize_u
      nsort());
                                        printf("%d\n", phraseID);
                                        //if (phraseID > 500 && phraseID < 520) {
      
                                                printf("phraseID: %d\n",phraseID)
      ;
                                                d->runDot(ph->getInsList_unsort()
      ,ph->getPhraseID());
                                        //}
                                        iPh->Append(ph);
                                        //printf("number of phrases = %d\n", iPh-
      >Nth(iPh->NumElements()-1)->getPhraseID());
                                        break;
                                }
                        }
                }
                if (debug) printf ("Added %d instruction(s)\n", diff);
        } else {
                if (debug) printf ("WARNING: The iROB is FULL\n");
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_ae7c9964c26331fddb647175a6d70a00a}{
\index{bkEnd.cpp@{bkEnd.cpp}!addPhraseblock@{addPhraseblock}}
\index{addPhraseblock@{addPhraseblock}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{addPhraseblock}]{\setlength{\rightskip}{0pt plus 5cm}void addPhraseblock (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$$\ast$}]{pbLists, }
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_ae7c9964c26331fddb647175a6d70a00a}

\begin{DoxyCode}
                                                              {
        //static bool firstBBins = true;
        //At Squash, wait for ROB to drain
        //if (isSquashed && pbROB->NumElements() > 0) {return;}
        //else if (isSquashed && iROB->NumElements() == 0) {
        //      Assert(memoryModel == NAIVE_SPECUL);
        //      isSquashed = false;
        //      //printf("SQUASH END\n");
        //      if (!perfectRegRen) GRF->flush_fRAT();
        //      depTables->flush_depTables();
        //      if (!perfectRegRen) {
        //              for (int i = 0; i < NUM_PHRASEBLKS; i++) {
        //                      LRFTables[i]->flush_depTables();
        //              }
        //      }
        //      if (coreType == PHRASEBLOCK) {
        //              addLastBracket();
        //              inCompleteBBbuffIndx = -1;
        //      }
        //}
        if (pbROB->NumElements() < pbROBsize) {
                for (int k = 0; k < NUM_PHRASEBLKS; k++) {
                        List<instruction*>* pbList = pbLists[k];
                        if (pbList->NumElements() == 0) {
                                addToPBCache();
                                if (eof) return;
                                char c[INS_STRING_SIZE];
                                for (int j = 0; j < pbROB->Last()->getNumBBIns_s(
      ); j++) {
                                        strcpy(c, (pbROB->Last()->getNthBBIns_s(
      j))->c_str());
                                        instruction *newIns = new instruction;
                                        newIns->setStatus(FETCH, cycle, -1);
                                        //bool isRRstall = false, isLSQstall = fa
      lse;
                                        int result = setupNewInsV2(newIns, c);
                                        if (result == -1) { //TODO redundant bloc
      k I think - eliminate
                                                delete newIns;
                                                break;
                                        } //EOC
                                        else if (result == -2) {
                                                delete newIns;
                                                continue; //Skip the line and rea
      d next line
                                        } else {
                                                insID++;
                                                newIns->setInsID(insID);
                                                if (perfectRegRen) {
                                                        /* Manage LSQ */ 
                                                        if (memoryModel == 
      PERFECT) {
                                                                newIns->perfect_M
      emDependencyTable(depTables, coreType, numSideBuffs);
                                                        //} else if (memoryModel 
      == TOTAL_ORDER) {
                                                        //      newIns->totalOrde
      r_MemDependencyTable(loadStoreQue);
                                                        //} else if (memoryModel 
      == NAIVE_SPECUL) {
                                                        //      instruction* ance
      stor = NULL;
                                                        //      bool sqHasIncompl
      Ins = loadStoreQue->SQhasIncompleteIns();
                                                        //      if (sqHasIncomplI
      ns) ancestor = loadStoreQue->getSQtail();
                                                        //      isLSQstall = oooL
      D_lsqHazard (loadStoreQue, newIns);
                                                        //      if (!isLSQstall) 
      oooLD_lsqEnque (loadStoreQue, newIns);
                                                        //      if (sqHasIncomplI
      ns && !isLSQstall) newIns->storeOrder_MemDependencyTable(ancestor);
                                                        //}
                                                        //if (isLSQstall) {
                                                        //      /*-----STAT-----*
      /
                                                        //      fetchStallCycle++
      ;
                                                        //      /*-----STAT-----*
      /
                                                        //      delete newIns;
                                                        //      insID--;
                                                        //      inCompleteBBbuffI
      ndx = k;
                                                        //      return;
                                                        //} else {
                                                        //      popFromInsCache()
      ;
                                                        }
                                                        newIns->infRegdependencyT
      able(depTables, coreType);
                                                        newIns->br_dependencyTabl
      e(depTables);
                                                //} else {
                                                //      /* Manage LSQ */ 
                                                //      if (memoryModel == PERFEC
      T) {
                                                //              isRRstall = newIn
      s->renameRegs(GRF, coreType);
                                                //              if (isRRstall) { 
      //if regrename not available, stall
                                                //                      /*-----ST
      AT-----*/
                                                //                      fetchStal
      lCycle++;
                                                //                      /*-----ST
      AT-----*/
                                                //                      delete ne
      wIns;
                                                //                      insID--;
                                                //                      inComplet
      eBBbuffIndx = k;
                                                //                      return;
                                                //              }
                                                //              newIns->perfect_M
      emDependencyTable(depTables, coreType, numSideBuffs);
                                                //      } else if (memoryModel ==
       TOTAL_ORDER) {
                                                //              isRRstall = newIn
      s->renameRegs(GRF, coreType);
                                                //              if (isRRstall) { 
      //if regrename not available, stall
                                                //                      /*-----ST
      AT-----*/
                                                //                      fetchStal
      lCycle++;
                                                //                      /*-----ST
      AT-----*/
                                                //                      delete ne
      wIns;
                                                //                      insID--;
                                                //                      inComplet
      eBBbuffIndx = k;
                                                //                      return;
                                                //              }
                                                //              newIns->totalOrde
      r_MemDependencyTable(loadStoreQue);
                                                //      } else if (memoryModel ==
       NAIVE_SPECUL) {
                                                //              instruction* ance
      stor = NULL;
                                                //              bool sqHasIncompl
      Ins = loadStoreQue->SQhasIncompleteIns();
                                                //              if (sqHasIncomplI
      ns) ancestor = loadStoreQue->getSQtail();
                                                //              isLSQstall = oooL
      D_lsqHazard (loadStoreQue, newIns);
                                                //              if (isLSQstall) {
      
                                                //                      /*-----ST
      AT-----*/
                                                //                      fetchStal
      lCycle++;
                                                //                      /*-----ST
      AT-----*/
                                                //                      delete ne
      wIns;
                                                //                      insID--;
                                                //                      inComplet
      eBBbuffIndx = k;
                                                //                      return;
                                                //              }
                                                //              isRRstall = newIn
      s->renameRegs(GRF, coreType);
                                                //              if (isRRstall) { 
      //if regrename not available, stall
                                                //                      /*-----ST
      AT-----*/
                                                //                      fetchStal
      lCycle++;
                                                //                      /*-----ST
      AT-----*/
                                                //                      delete ne
      wIns;
                                                //                      insID--;
                                                //                      inComplet
      eBBbuffIndx = k;
                                                //                      return;
                                                //              }
                                                //              oooLD_lsqEnque (l
      oadStoreQue, newIns);
                                                //              if (sqHasIncomplI
      ns) newIns->storeOrder_MemDependencyTable(ancestor);
                                                //      }
                                                //      popFromInsCache();
                                                //      newIns->noRRdependencyTab
      le(LRFTables[k], coreType); //LRF depdency handling
                                                //      newIns->br_dependencyTabl
      e(depTables);
                                                //}
                                                //iROB->Append(newIns);
                                                //if (firstBBins) {
                                                //      newIns->setBBhead();
                                                //      newIns->setBrHeaderAddr(h
      eader);
                                                //      firstBBins = false;
                                                }
                                                pbROB->Last()->addToBB(newIns);
                                                pbList->Append(newIns);
                                                newIns = NULL;
                                        }
                                        //inCompleteBBbuffIndx = -1;
                                        //} else if (c[0] == 'H') {
                                        //      c[0] = 'z';
                                        //      header = getAddr(c);
                                        //      void *bp_hist = NULL;
                                        //      bbPrediction = PrePredict(header,
       bp_hist);
                                        //      Assert(bp_hist != NULL);
                                        //      popFromInsCache();
                                        //      bp_hist_list->Append(bp_hist);
                                        //      br_pred_update_distance.insert(pa
      ir<ADDRS,int> (header,cycle));
                                        //      inCompleteBBbuffIndx = -1;
                                        //} else {
                                        //      if (iROB->NumElements() > 0) iROB
      ->Nth(iROB->NumElements()-1)->setBBtail();
                                        //      popFromInsCache();
                                        //      inCompleteBBbuffIndx = -1;
                                        //      break;
                                        //}
                                }
                        }
                }
        } else {
                if (debug) printf ("WARNING: The iROB is FULL\n");
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_adf93e43bd3a6a80076405e72701ecc93}{
\index{bkEnd.cpp@{bkEnd.cpp}!addToInsCache@{addToInsCache}}
\index{addToInsCache@{addToInsCache}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{addToInsCache}]{\setlength{\rightskip}{0pt plus 5cm}void addToInsCache (
\begin{DoxyParamCaption}
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_adf93e43bd3a6a80076405e72701ecc93}

\begin{DoxyCode}
                              {
        //Read a number of lines from trace file
        int insCacheSiz = ROBsize*3;
        static int insList_indx = 0;
        Assert(__g_var->g_insList->NumElements() > insCacheSiz);
        while(ICQ->NumElements() < insCacheSiz) {
                if (insList_indx == __g_var->g_insList->NumElements() - 10) {
                        eof = true; //EOF
                        //if (debug) printf("breaking from addToInsCache ((%d,%d)
      ,%d)\n", insList_indx, insCacheSiz, __g_var->g_insList->NumElements());
                        __g_var->g_insList_indx = insList_indx;
                        insList_indx = 0;
                        break;
                } else {
                        char *c = new char[INS_STRING_SIZE];
                        Assert(__g_var->g_insList->NumElements() > insList_indx);
      
                        strcpy(c, (__g_var->g_insList->Nth(insList_indx))->c_str(
      ));
                        insList_indx++;
                        ICQ->Append(c);
                        //if (debug) printf("\tadding instruction (%d, %d) (%s)\n
      ", ICQ->NumElements(), iROB->NumElements(), (__g_var->g_insList->Nth(insList_indx
      ))->c_str());
                }
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a4668f9d4a280acba3afd26e75675918d}{
\index{bkEnd.cpp@{bkEnd.cpp}!addToPBCache@{addToPBCache}}
\index{addToPBCache@{addToPBCache}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{addToPBCache}]{\setlength{\rightskip}{0pt plus 5cm}void addToPBCache (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a4668f9d4a280acba3afd26e75675918d}

\begin{DoxyCode}
                    {
        if (__g_var->g_BBlist_indx >= 19) {eof = true; return;}
        __g_var->g_BBlist_indx++;
        pbROB->Append(__g_var->g_BBlist->Nth(__g_var->g_BBlist_indx));
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_af34e8aea898d89ab4f271696b1c9ab8b}{
\index{bkEnd.cpp@{bkEnd.cpp}!bkEnd\_\-finish@{bkEnd\_\-finish}}
\index{bkEnd\_\-finish@{bkEnd\_\-finish}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{bkEnd\_\-finish}]{\setlength{\rightskip}{0pt plus 5cm}void bkEnd\_\-finish (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_af34e8aea898d89ab4f271696b1c9ab8b}

\begin{DoxyCode}
                     {
        //Print Stats on screen
        //printf("line Number = %ld\n", lineNum);
        printf("------------------------------------------\n");
        printf("COMMENT           = %s\n", comment);
        printf("CORE TYPE         = %d\n", coreType);
        printf("Perf Reg Renaming = %d (Size: %d)\n", perfectRegRen, GRRF_SIZE);
        printf("LSQ Model         = %d (LQ: %d, SQ %d)\n", memoryModel, LQ_SIZE, 
      SQ_SIZE);
        if (coreType == PHRASEBLOCK) printf("Num Ins Buff = %d\n", 
      NUM_PHRASEBLKS);
        printf("ROB Size                  = %d\n", ROBsize);
        printf("1 LD Lat Lvl      = %ld\n", oneLevDeepLatLevel);
        printf("Frame Buffer Size         = %ld\n", SBlength);
        printf("Num Side Buffs            = %ld\n", numSideBuffs);
        printf("IN FILE                   = %s\n", inFileName.c_str());
        printf("OUT FILE                  = %s\n", outFileName1.c_str());
        if (reschedule == true) printf("VLIW TRACE FILE = %s\n", 
      reScheduleFileName.c_str());
        if (makePhrase == true) printf("PHRASE TRACE FILE = %s\n", 
      phrasingFileName.c_str());
        if (reportTraceAndHitMiss == true) 
                printf("UNPRED MEM TRACE FILE = %s\n", reScheduleFileName.c_str()
      );
        printf("IPC                       = %f\n", ipc);
        printf("Corrupt Instruction Conut = %ld\n", corruptInsCount);
        printf("Miss  Count            = %ld\n", missCount(cacheLat[0]));
        printf("Hit   Count            = %ld\n", hitCount(0));
        printf("Miss  Latency          = %ld\n", missLatency(cacheLat[0]));
        printf("Hit   Latency          = %ld\n", hitLatency(0));
        printf("TOTAL Latency          = %ld\n", cycle);
        printf("TOTAL MEM Latency      = %ld\n", totalLatency(0));
        printf("FU  Utilization Count  = %ld, %ld, %ld, %ld\n\n",aluStat[0],
      aluStat[1],aluStat[2],aluStat[3]);
        printf("STALL Event Rate = %ld (%f)\n",fetchStallCycle,(float)
      fetchStallCycle/(float)cycle);

        printf("Miss  Rate             = %f\n", (float)missCount(cacheLat[0])/(fl
      oat)(hitCount(0)+missCount(cacheLat[0])));
        printf("Hit   Rate             = %f\n", (float)hitCount(0)/(float)(
      hitCount(0)+missCount(cacheLat[0])));
        printf("Miss  Avg Latency      = %f\n", (float)missLatency(cacheLat[0])/(
      float)totalLatency(0));
        printf("Hit   Avg Latency      = %f\n", (float)hitLatency(0)/(float)
      totalLatency(0));
        printf("FU  Utilization Rate   = %f, %f, %f, %f\n\n",(float)aluStat[0]/(f
      loat)cycle,
                                                             (float)aluStat[1]/(f
      loat)cycle,
                                                             (float)aluStat[2]/(f
      loat)cycle,
                                                             (float)aluStat[3]/(f
      loat)cycle);

        printf("L1  Hit Rate           = %f\n", (float)L1hitCount()/(float)(
      hitCount(0)+missCount(cacheLat[0])));
        printf("L2  Hit Rate           = %f\n", (float)L2hitCount()/(float)(
      hitCount(0)+missCount(cacheLat[0])));
        printf("L3  Hit Rate           = %f\n", (float)L3hitCount()/(float)(
      hitCount(0)+missCount(cacheLat[0])));
        printf("MEM Hit Rate           = %f\n\n", (float)MEMhitCount()/(float)(
      hitCount(0)+missCount(cacheLat[0])));

        printf("Ins ROB   Utilization  = %f\n", (float)iROBSize/(float)cycle);
        printf("Ins Win   Utilization  = %f\n", (float)iWinSize/(float)cycle);
        printf("Res Stn   Utilization  = %f\n", (float)iResStnSize/(float)cycle);
      
        printf("Ins LQ    Utilization  = %f\n", (float)lqSize/(float)cycle);
        printf("Ins SQ    Utilization  = %f\n", (float)sqSize/(float)cycle);
        printf("Ins RR    Utilization  = %f\n", (float)rrSize/(float)cycle);
        printf("Ins LRF   Utilization  = %lld (%f)\n",lrfCount,(double)lrfCount/(
      double)insCount);
        printf("Ins GRF   Utilization  = %lld (%f)\n",grfCount,(double)grfCount/(
      double)insCount);
        printf("LRF WR    Utilization  = %lld (%f)\n",lrfWrCountPerIns,(double)
      lrfWrCountPerIns/(double)insCount);
        printf("LRF RD    Utilization  = %lld (%f)\n",lrfRdCountPerIns,(double)
      lrfRdCountPerIns/(double)insCount);
        printf("GRF WR    Utilization  = %lld (%f)\n",grfWrCountPerIns,(double)
      grfWrCountPerIns/(double)insCount);
        printf("GRF RD    Utilization  = %lld (%f)\n",grfRdCountPerIns,(double)
      grfRdCountPerIns/(double)insCount);
        printf("Mem Buf   Utilization  = %f\n", (float)iMemBuffSize/(float)cycle)
      ;
        printf("Side Buf  Utilization  = %f\n", (float)iSideBufSize/(float)cycle)
      ;
        printf("In Flight Utilization  = %f\n\n",(float)inFlightLDopsSize/(float)
      cycle);

        printf("Tot Num Squash Events   = %d,   Ratio: (%f)\n",squashCount, (floa
      t)squashCount/(float)cycle);
        printf("Tot Num Squash Ins      = %lld, Ratio: (%f)\n",squashInsCount, (f
      loat)squashInsCount/(float)insCount);
        printf("Tot Num Squash BR Ins   = %lld, Ratio: (%f)\n",squashBRinsCount, 
      (float)squashBRinsCount/(float)insCount);
        printf("Tot Num Squash LD Ins   = %lld, Ratio: (%f)\n",squashLQinsCount, 
      (float)squashLQinsCount/(float)insCount);
        printf("Tot Num Squash ST Ins   = %lld, Ratio: (%f)\n",squashSQinsCount, 
      (float)squashSQinsCount/(float)insCount);
        printf("Tot Num Squash RS Ins   = %lld, Ratio: (%f)\n",squashRSinsCount, 
      (float)squashRSinsCount/(float)insCount);
        printf("Tot Num Squash iWin Ins = %lld, Ratio: (%f)\n",squashWinInsCount,
       (float)squashWinInsCount/(float)insCount);
        printf("Tot Num Squash iPhr Ins = %lld, Ratio: (%f)\n",squashPhrInsCount,
       (float)squashPhrInsCount/(float)insCount);
        printf("Tot Num Squash GRF Reg = %lld, Ratio: (%f)\n",squashRegRenCount, 
      (float)squashRegRenCount/(float)insCount);
        printf("Tot Num Squash LRF Reg = %lld, Ratio: (%f)\n",squashLRFcount, (fl
      oat)squashLRFcount/(float)insCount);
        printf("Tot Num Squash GRF WR Reg (ALL)   = %lld\n",
      num_squashed_grf_wr_reg);
        printf("Tot Num Squash GRF RD Reg (ALL)   = %lld\n",
      num_squashed_grf_rd_reg);
        printf("Tot Num Squash LRF WR Reg (ALL)   = %lld\n",
      num_squashed_lrf_wr_reg);
        printf("Tot Num Squash LRF RD Reg (ALL)   = %lld\n",
      num_squashed_lrf_rd_reg);
        printf("Tot Num Squash LRF WR Reg (FETCH) = %lld\n",
      num_squashed_lrf_wr_fetch_reg);
        printf("Tot Num Squash LRF RD Reg (FETCH) = %lld\n",
      num_squashed_lrf_rd_fetch_reg);
        printf("Tot Num Squash LRF WR Reg (READY) = %lld\n",
      num_squashed_lrf_wr_ready_reg);
        printf("Tot Num Squash LRF RD Reg (READY) = %lld\n",
      num_squashed_lrf_rd_ready_reg);
        printf("Tot Num Squash LRF WR Reg (EXECT) = %lld\n",
      num_squashed_lrf_wr_execute_reg);
        printf("Tot Num Squash LRF RD Reg (EXECT) = %lld\n",
      num_squashed_lrf_rd_execute_reg);
        printf("Tot Num Squash LRF WR Reg (COMPL) = %lld\n",
      num_squashed_lrf_wr_complete_reg);
        printf("Tot Num Squash LRF RD Reg (COMPL) = %lld\n",
      num_squashed_lrf_rd_complete_reg);
        printf("Tot Num Squash GRF WR Reg (FETCH) = %lld\n",
      num_squashed_grf_wr_fetch_reg);
        printf("Tot Num Squash GRF RD Reg (FETCH) = %lld\n",
      num_squashed_grf_rd_fetch_reg);
        printf("Tot Num Squash GRF WR Reg (READY) = %lld\n",
      num_squashed_grf_wr_ready_reg);
        printf("Tot Num Squash GRF RD Reg (READY) = %lld\n",
      num_squashed_grf_rd_ready_reg);
        printf("Tot Num Squash GRF WR Reg (EXECT) = %lld\n",
      num_squashed_grf_wr_execute_reg);
        printf("Tot Num Squash GRF RD Reg (EXECT) = %lld\n",
      num_squashed_grf_rd_execute_reg);
        printf("Tot Num Squash GRF WR Reg (COMPL) = %lld\n",
      num_squashed_grf_wr_complete_reg);
        printf("Tot Num Squash GRF RD Reg (COMPL) = %lld\n",
      num_squashed_grf_rd_complete_reg);
        printf("Tot Num SB Activations            = %ld\n",totNumSBactivations);
        printf("Tot Num SB ReActivations          = %ld\n",totNumSBreactivations)
      ;
        printf("Tot SB Reactivation Rate          = %f\n",(float)
      totNumSBreactivations/(float)totNumSBactivations);
        printf("Total SB Size                     = %lu\n",totalSBsize);
        printf("Tot Avg SB Size                   = %f\n",(float)totalSBsize/(flo
      at)totNumSBactivations);
        printf("Max SB Size                           = %ld\n",maxSBsize);
        printf("Min SB Size                           = %ld\n",minSBsize);
        printf("Total Number of Execute  Ins      = %ld\n",executeInsCount);
        printf("Total Number of Complete Ins      = %ld\n",completeInsCount);
        printf("Total Number of Commit Ins        = %ld\n",insCount);
        printf("Total Num Ins Visit SB            = %ld\n",totInsVisitingSBcount)
      ;
        printf("Total Rate of Ins Visiting SB     = %f\n",(float)
      totInsVisitingSBcount/(float)insCount);
        printf("Tot Ins Exe When SB ON            = %ld\n",totInsCountWhenSBon);
        printf("Tot Ins Exe When SB ON IPC        = %f\n",(float)
      totInsCountWhenSBon/(float)totSBactiveCycles);
        printf("Tot SB ON Avg. Time               = %f\n\n",(float)(cycle-
      totSBoffCycles)/(float)cycle);
        printf("Tot Num of Off SB Dep. Ins/Active Win = %f\n",(float)
      numDepInOtherSBs/(float)totNumSBactivations);
        printf("Num Empty Res Stn Cycles          = %ld\n", emptyResStation);
        printf("Num Empty Res Stn Cycles/All Cycl = %f\n\n", (float)
      emptyResStation/(float)cycle);

        if (reportTraceAndHitMiss) {
                printf("Unpredictability Threshold        = %f\n", (double)
      unpredMemOpThreshold/(double)COEFF);
                printf("Num Unpred. Ins:                  = %ld\n", 
      unpredMemInsCnt);
                printf("Num Unpred. Ops:                  = %ld\n", 
      unpredMemOpCnt);
                printf("Unpred. Ins Rate:                 = %f\n\n", (float)
      unpredMemOpCnt/(float)insCount);
        }
        if (makePhrase) {
                printf("Max Phrases Size                  = %d\n", 
      phraseSizeBound);
                printf("Unpredictable Ins Threshold       = %f\n", (double)
      unpredMemOpThreshold/(double)COEFF);
                printf("Num Phrases                       = %ld\n", totNumPhrase)
      ;
                printf("Avg. Num Ins/Phrase               = %f\n", (float)
      insCount/(float)totNumPhrase);
                printf("Tot Num SoftBound Partitions      = %ld\n", 
      totNumSoftBound);
                printf("Avg. Num SoftBound/Phrase         = %f\n", (float)
      totNumSoftBound/(float)totNumPhrase);
                printf("Tot Num Unpred. Ins               = %ld\n", 
      totNumPhUnpredMemOp);
                printf("Num Unpred. Ins/Phrase            = %f\n", (float)
      totNumPhUnpredMemOp/(float)totNumPhrase);
                printf("Num Unpred. Ins/Total Ins         = %f\n", (float)
      totNumPhUnpredMemOp/(float)insCount);
                printf("Tot Num Root Ins                  = %ld\n", 
      totNumRootIns);
                printf("Num Root Ins/Phrase               = %f\n", (float)
      totNumRootIns/(float)totNumPhrase);
                printf("Tot Num Phrase Ancestors          = %ld\n", 
      totNumPhraseAncestors);
                printf("NumPhrase Ancestors/Phrase        = %f\n", (float)
      totNumPhraseAncestors/(float)totNumPhrase);
                printf("Num of Resetting Times            = %ld\n\n", 
      totNumPhGenResets);
                printf("Num Fragment                      = %ld\n", totNumFrag);
                printf("Num Root Phrases                  = %ld\n", totNumRootPh)
      ;
                printf("Root Phrases Rate                 = %f\n", (double)
      totNumRootPh/(double)totNumPhrase);
                printf("Num Critical Path Violations      = %ld\n", 
      totNumCritPathViol);
                printf("Critical Path Violations Rate     = %f\n", (double)
      totNumCritPathViol/(double)totNumPhrase);
                printf("Avg. Num Ins/Fragment             = %f\n", (float)
      insCount/(float)totNumFrag);
                printf("Avg. Num Fragment/Phrase          = %f\n", (float)
      totNumFrag/(float)totNumPhrase);
        }
        if (coreType == PHRASE || coreType == FRAGMENT) {
                printf("Num Phrases                       = %ld\n", totNumPhrase)
      ;
                printf("Avg. Num Ins/Fragment             = %f\n", (float)
      insCount/(float)totNumFrag);
                printf("Avg. Num Fragment/Phrase          = %f\n", (float)
      totNumFrag/(float)totNumPhrase);
                printf("Avg. Num Ins/Phrase               = %f\n", (float)
      insCount/(float)totNumPhrase);
                printf("Latency/Phrase                    = %f\n", (float)
      totalLatency(0)/(float)totNumPhrase);
                printf("Tot Phrase Stall Time             = %ld\n", totPhStall);
                printf("Avg. Phrase Stall Time            = %f\n", (float)
      totPhStall/(float)totNumPhrase);
                printf("Unexpected Miss Count             = %ld\n", 
      unexpectedMiss);
                printf("Unexpected Miss Rate              = %f\n", (float)
      unexpectedMiss/(float)missCount(cacheLat[0]));
                printf("Unexpected Miss Latency           = %ld\n", 
      unexpecteedLat);
                printf("Unexpected Avg. Miss Lat          = %f\n", (float)
      unexpecteedLat/(float)unexpectedMiss);
                printf("Unexpected Miss Lat Rate          = %f\n", (float)
      unexpecteedLat/(float)missLatency(0));
        }
        if (coreType == FRAGMENT) {
                printf("Num Fragment                      = %ld\n", totNumFrag);
                printf("Tot Fragment Stall Time           = %ld\n", totFrStall);
                printf("Avg. Fragment  Stall Time         = %f\n", (float)
      totFrStall/(float)totNumFrag);
                printf("Num Real Fragment                 = %ld\n", 
      totNumRealFrag);
                printf("Real Frag/Tot Frag                = %f\n", (float)
      totNumRealFrag/(float)totNumFrag);
                printf("Avg. Num Ins/Real Frag            = %f\n", (float)
      totSizRealFrag/(float)totNumRealFrag);
                printf("Num of Single Frag Wavefront      = %ld\n", 
      totNumOfSigleFragPhrases);
                printf("Avg. Num Real Frag/Phrase         = %f\n", (double)
      totNumRealFrag/(double)(totNumPhrase-totNumOfSigleFragPhrases));
                printf("Avg. Num Ready Frags              = %f\n", (double)
      numReadyFrags/(double)totNumFrag);
                printf("Inter-Fragment Stall Time         = %ld\n", 
      interFragStallCycle);
                printf("Inter-Fragment Stall Rate         = %f\n\n", (double)
      interFragStallCycle/(double)cycle);
        }



        printf("---    ---    ---    ---    ---    ----   \n");
        for (int  i = 0; i < numSideBuffs; i++) {
                printf("SB INDEX                = %d\n",i);
                printf("Num SB Activations      = %ld\n",numSBactivations[i]);
                printf("Num SB ReActivations    = %ld\n",numSBreactivations[i]);
                printf("SB Reactivation Rate    = %f\n",(float)
      numSBreactivations[i]/(float)numSBactivations[i]);
                printf("SB Size                 = %lu\n",SBsize[i]);
                printf("Avg SB Size             = %f\n",(float)SBsize[i]/(float)
      numSBactivations[i]);
                printf("Num Ins Visit SB        = %ld\n",insVisitingSBcount[i]);
                printf("Rate of Ins Visiting SB = %f\n",(float)
      insVisitingSBcount[i]/(float)insCount);
                printf("Ins Exe When SB ON      = %ld\n",InsCountWhenSBon[i]);
                printf("Ins Exe When SB ON IPC  = %f\n",(float)InsCountWhenSBon[i
      ]/(float)SBactiveCycles[i]);
                printf("SB ON Avg. Time         = %f\n\n",(float)(cycle-
      SBoffCycles[i])/(float)cycle);
                printf("Frame Win Avg. Size    = %f\n",(float)(totFrameSize)/(flo
      at)numSBactivations[i]);
                printf("Frame NonSB Ins Avg Cnt= %f\n",(float)(
      totMainStreamBound)/(float)numSBactivations[i]);
                printf("Frame Window Sat Rate  = %f\n",(float)(windowSatration)/(
      float)numSBactivations[i]);  //TODO THIS IS NOT A VECTOR ELEMENT, fix
                printf("Frame ON longLat op Rate  = %f\n",(float)(
      longLatOpWhenSPisON)/(float)numSBactivations[i]);  //TODO THIS IS NOT A VECTOR EL
      EMENT, fix
                printf("Frame ON-Drain longLat Rat= %f\n",(float)(
      longLatOpWhenSPisDraining)/(float)numSBactivations[i]);  //TODO THIS IS NOT A VEC
      TOR ELEMENT, fix
                printf("Frame ON-Wait longLat Rate= %f\n",(float)(
      longLatOpWhenSPisWaiting)/(float)numSBactivations[i]);  //TODO THIS IS NOT A VECT
      OR ELEMENT, fix
                printf("---    ---    ---    ---    ---    ----   \n");
        }

        printf("\nNumber of MEM Ops       = %ld\n",numMemOps);
        printf("Number of ALU Ops         = %ld\n",numALUOps);
        printf("Number of FPU Ops         = %ld\n",numFPUOps);
        printf("Number of BR  Ops         = %ld\n",numBROps);
        printf("Number of ASSIGN  Ops     = %ld\n",numAssignOps);
        printf("Number of READ Ops        = %ld\n",numReadOps);
        printf("Number of WRITE Op        = %ld\n",numWriteOps);
        printf("Number Mis-Pred BR Ops (Fetch)     = %ld, Rate: %f\n",
      missPredBROps_fetch, (float)missPredBROps_fetch/(float)numBROps);
        printf("Number Mis-Pred BR Ops (Commit)    = %ld, Rate: %f\n",
      missPredBROps, (float)missPredBROps/(float)numBROps);
        printf("Number Mis-Pred_NT BR Ops (Fetch)  = %ld, Rate: %f\n",
      missPredBROps_NT_fetch, (float)missPredBROps_NT_fetch/(float)numBROps);
        printf("Number Mis-Pred_NT BR Ops (Commit) = %ld, Rate: %f\n",
      missPredBROps_NT, (float)missPredBROps_NT/(float)numBROps);
        printf("Number Pred_NT R Ops (Fetch)       = %ld, Rate: %f\n",
      numBrOps_predT_fetch, (float)numBrOps_predT_fetch/(float)numBROps);
        printf("Number Pred_T BR Ops (Commit)      = %ld, Rate: %f\n",
      numBrOps_predT, (float)numBrOps_predT/(float)numBROps);
        printf("Store FWD READ Ops        = %ld\n",stFwdMemOp);
        printf("Store FWD READ/All READ   = %f\n",(float)stFwdMemOp/(float)
      numReadOps);
        printf("Non-blocking READ Ops     = %ld\n",nonBlockingMemOp);
        printf("Non-blck READ/All READ    = %f\n",(float)nonBlockingMemOp/(float)
      numReadOps);
        printf("Cache Axes READ Ops       = %ld\n",maxSBsize);
        printf("Cache Axes READ/All READ  = %f\n",(float)maxSBsize/(float)
      numReadOps);
        printf("MEM Ops Rate            = %f\n",(float)numMemOps/(float)insCount)
      ;
        printf("ALU Ops Rate            = %f\n",(float)numALUOps/(float)insCount)
      ;
        printf("FPU Ops Rate            = %f\n",(float)numFPUOps/(float)insCount)
      ;
        printf("BR  Ops Rate            = %f\n",(float)numBROps/(float)insCount);
      
        printf("ASSIGN  Ops     Rate    = %f\n",(float)numAssignOps/(float)
      insCount);
        printf("READ Ops Rate           = %f\n",(float)numReadOps/(float)
      insCount);
        printf("WRITE Ops Rate          = %f\n",(float)numWriteOps/(float)
      insCount);
        printf("READ/MEM  Ops Rate      = %f\n",(float)numReadOps/(float)
      numMemOps);
        printf("WRITE/MEM Ops Rate      = %f\n\n",(float)numWriteOps/(float)
      numMemOps);
        printf("------------------------------------------\n");

        /* STRAND EXE STAT */
        if (coreType == STRAND || coreType == PHRASEBLOCK) {
                printf("STRAND COUNT: %lld\n", dyn_num_strands);
                printf("TOT NUM INS IN STRAND: %lld\n", total_num_strand_ins);
                printf("AVG. STRAND SIZE: %f\n", (double)total_num_strand_ins/(do
      uble)dyn_num_strands);
                printf("Percent of Ins in Strands: %f\n", (double)
      total_num_strand_ins/(double)insCount*100.0);
        } 
        /* PHRASEBLOCK EXE STAT */
        else if (coreType == PHRASEBLOCK) {
                printf("Total Num PB/BB Ran: %ld\n", bbCount);
                printf("AVG. Active BB/PB Ratio: %f\n", (double)activeBuffCnt/(do
      uble)cycle);
                printf("Average # of Cycles b/w BP Lookup & Update: %f\n", (doubl
      e)br_pred_update_dist/(double)brInsCount);
        }
        for (int i = 0; i < NUM_FUNC_UNIT; i++)
                printf("Res Stn %d Utilization  = %f\n", i, (float)iResStnsSize[i
      ]/(float)cycle);
        for (int i = 0; i < NUM_PHRASEBLKS; i++)
                printf("Phraseblock %d Utilization  = %f\n", i, (float)
      pbListsSize[i]/(float)cycle);

        /* Report the branches whose accuracy was not recorded: */
        if (branchProfileFlag) {
                set<long int>::iterator it;
                printf("Report the branches whose accuracy was not recorded:\n");
      
                for (it = missingAccuracyBranches.begin(); it != 
      missingAccuracyBranches.end(); it++) {
                        printf("%ld, ", *it);
                }
                printf("\n");
        }

        //Print Stats into file
        //for (int i = 0; i < 1; i++) {
        //      if (i == 0) outFile = outFile1;
        //      else        outFile = outFile2;
        outFile = outFile1;

                fprintf(outFile, "------------------------------------------\n");
      
                fprintf(outFile,"COMMENT                    = %s\n", comment);
                fprintf(outFile, "CORE TYPE         = %d\n", coreType);
                fprintf(outFile, "Perf Reg Renaming = %d (Size: %d)\n", 
      perfectRegRen, GRRF_SIZE);
                fprintf(outFile, "LSQ Model         = %d (LQ: %d, SQ %d)\n", 
      memoryModel, LQ_SIZE, SQ_SIZE);
                if (coreType == PHRASEBLOCK) fprintf(outFile, "Num Ins Buff = %d\
      n", NUM_PHRASEBLKS);
                fprintf(outFile, "ROB Size                  = %d\n", ROBsize);
                fprintf(outFile, "1 LD Lat Lvl              = %ld\n", 
      oneLevDeepLatLevel);
                fprintf(outFile, "Frame Buffer Size       = %ld\n", SBlength);
                fprintf(outFile, "Num Side Buffs            = %ld\n", numSideBuff
      s);
                fprintf(outFile, "IN FILE                   = %s\n", inFileName.c
      _str());
                fprintf(outFile, "OUT FILE                  = %s\n", 
      outFileName1.c_str());
                if (reschedule == true) fprintf(outFile,"VLIW TRACE FILE = %s\n",
       reScheduleFileName.c_str());
                if (makePhrase == true) fprintf(outFile,"PHRASE TRACE FILE = %s\n
      ", phrasingFileName.c_str());
                if (reportTraceAndHitMiss == true) 
                                        fprintf(outFile,"UNPRED MEM TRACE FILE = 
      %s\n", reScheduleFileName.c_str());
                fprintf(outFile, "IPC                       = %f\n", ipc);
                fprintf(outFile, "Corrupt Instruction Conut = %ld\n", 
      corruptInsCount);
                fprintf(outFile, "Miss  Count               = %ld\n", missCount(
      cacheLat[0]));
                fprintf(outFile, "Hit   Count               = %ld\n", hitCount(0)
      );
                fprintf(outFile, "Miss  Latency             = %ld\n", 
      missLatency(0));
                fprintf(outFile, "Hit   Latency             = %ld\n", hitLatency(
      0));
                fprintf(outFile, "TOTAL Latency             = %ld\n", cycle);
                fprintf(outFile, "TOTAL MEM Latency         = %ld\n", 
      totalLatency(0));
                fprintf(outFile, "FU  Utilization Count = %ld, %ld, %ld, %ld\n\n"
      ,aluStat[0],aluStat[1],aluStat[2],aluStat[3]);
                fprintf(outFile, "STALL Event Rate = %ld (%f)\n",fetchStallCycle,
      (float)fetchStallCycle/(float)cycle);
                
                fprintf(outFile, "Miss  Rate             = %f\n", (float)
      missCount(cacheLat[0])/(float)(hitCount(0)+missCount(cacheLat[0])));
                fprintf(outFile, "Hit   Rate             = %f\n", (float)
      hitCount(0)/(float)(hitCount(0)+missCount(cacheLat[0])));
                fprintf(outFile, "Miss  Avg Latency      = %f\n", (float)
      missLatency(cacheLat[0])/(float)totalLatency(0));
                fprintf(outFile, "Hit   Avg Latency      = %f\n", (float)
      hitLatency(0)/(float)totalLatency(0));
                fprintf(outFile, "FU  Utilization Rate   = %f, %f, %f, %f\n\n", (
      float)aluStat[0]/(float)cycle,
                                                                                (
      float)aluStat[1]/(float)cycle,
                                                                                (
      float)aluStat[2]/(float)cycle,
                                                                                (
      float)aluStat[3]/(float)cycle);
                
                fprintf(outFile, "L1  Hit Rate           = %f\n",   (float)
      L1hitCount()/(float)(hitCount(0)+missCount(cacheLat[0])));
                fprintf(outFile, "L2  Hit Rate           = %f\n",   (float)
      L2hitCount()/(float)(hitCount(0)+missCount(cacheLat[0])));
                fprintf(outFile, "L3  Hit Rate           = %f\n",   (float)
      L3hitCount()/(float)(hitCount(0)+missCount(cacheLat[0])));
                fprintf(outFile, "MEM Hit Rate           = %f\n\n", (float)
      MEMhitCount()/(float)(hitCount(0)+missCount(cacheLat[0])));
                
                fprintf(outFile, "Ins ROB   Utilization  = %f\n", (float)
      iROBSize/(float)cycle);
                fprintf(outFile, "Ins Win   Utilization  = %f\n", (float)
      iWinSize/(float)cycle);
                fprintf(outFile, "Res Stn   Utilization  = %f\n", (float)
      iResStnSize/(float)cycle);
                fprintf(outFile, "Ins LQ    Utilization  = %f\n", (float)lqSize/(
      float)cycle);
                fprintf(outFile, "Ins SQ    Utilization  = %f\n", (float)sqSize/(
      float)cycle);
                fprintf(outFile, "Ins RR    Utilization  = %f\n", (float)rrSize/(
      float)cycle);
                fprintf(outFile, "Ins LRF   Utilization  = %lld (%f)\n",lrfCount,
      (double)lrfCount/(double)insCount);
                fprintf(outFile, "Ins GRF   Utilization  = %lld (%f)\n",grfCount,
      (double)grfCount/(double)insCount);
                fprintf(outFile, "LRF WR    Utilization  = %lld (%f)\n",
      lrfWrCountPerIns,(double)lrfWrCountPerIns/(double)insCount);
                fprintf(outFile, "LRF RD    Utilization  = %lld (%f)\n",
      lrfRdCountPerIns,(double)lrfRdCountPerIns/(double)insCount);
                fprintf(outFile, "GRF WR    Utilization  = %lld (%f)\n",
      grfWrCountPerIns,(double)grfWrCountPerIns/(double)insCount);
                fprintf(outFile, "GRF RD    Utilization  = %lld (%f)\n",
      grfRdCountPerIns,(double)grfRdCountPerIns/(double)insCount);
                fprintf(outFile, "Mem Buf   Utilization  = %f\n", (float)
      iMemBuffSize/(float)cycle);
                fprintf(outFile, "Side Buf  Utilization  = %f\n", (float)
      iSideBufSize/(float)cycle);
                fprintf(outFile, "In Flight Utilization  = %f\n", (float)
      inFlightLDopsSize/(float)cycle);

                fprintf(outFile, "Tot Num Squash Events = %d, Ratio: (%f)\n",
      squashCount, (float)squashCount/(float)cycle);
                fprintf(outFile, "Tot Num Squash Ins    = %lld, Ratio: (%f)\n",
      squashInsCount, (float)squashInsCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash BR Ins   = %lld, Ratio: (%f)\n",
      squashBRinsCount, (float)squashBRinsCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash LD Ins = %lld, Ratio: (%f)\n",
      squashLQinsCount, (float)squashLQinsCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash ST Ins = %lld, Ratio: (%f)\n",
      squashSQinsCount, (float)squashSQinsCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash RS Ins = %lld, Ratio: (%f)\n",
      squashRSinsCount, (float)squashRSinsCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash iWin Ins = %lld, Ratio: (%f)\n",
      squashWinInsCount, (float)squashWinInsCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash iPhr Ins = %lld, Ratio: (%f)\n",
      squashPhrInsCount, (float)squashPhrInsCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash GRF Reg = %lld, Ratio: (%f)\n",
      squashRegRenCount, (float)squashRegRenCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash LRF Reg = %lld, Ratio: (%f)\n",
      squashLRFcount, (float)squashLRFcount/(float)insCount);
                fprintf(outFile, "Tot Num Squash GRF WR Reg (ALL)   = %lld\n",
      num_squashed_grf_wr_reg);
                fprintf(outFile, "Tot Num Squash GRF RD Reg (ALL)   = %lld\n",
      num_squashed_grf_rd_reg);
                fprintf(outFile, "Tot Num Squash LRF WR Reg (ALL)   = %lld\n",
      num_squashed_lrf_wr_reg);
                fprintf(outFile, "Tot Num Squash LRF RD Reg (ALL)   = %lld\n",
      num_squashed_lrf_rd_reg);
                fprintf(outFile, "Tot Num Squash LRF WR Reg (FETCH) = %lld\n",
      num_squashed_lrf_wr_fetch_reg);
                fprintf(outFile, "Tot Num Squash LRF RD Reg (FETCH) = %lld\n",
      num_squashed_lrf_rd_fetch_reg);
                fprintf(outFile, "Tot Num Squash LRF WR Reg (READY) = %lld\n",
      num_squashed_lrf_wr_ready_reg);
                fprintf(outFile, "Tot Num Squash LRF RD Reg (READY) = %lld\n",
      num_squashed_lrf_rd_ready_reg);
                fprintf(outFile, "Tot Num Squash LRF WR Reg (EXECT) = %lld\n",
      num_squashed_lrf_wr_execute_reg);
                fprintf(outFile, "Tot Num Squash LRF RD Reg (EXECT) = %lld\n",
      num_squashed_lrf_rd_execute_reg);
                fprintf(outFile, "Tot Num Squash LRF WR Reg (COMPL) = %lld\n",
      num_squashed_lrf_wr_complete_reg);
                fprintf(outFile, "Tot Num Squash LRF RD Reg (COMPL) = %lld\n",
      num_squashed_lrf_rd_complete_reg);
                fprintf(outFile, "Tot Num Squash GRF WR Reg (FETCH) = %lld\n",
      num_squashed_grf_wr_fetch_reg);
                fprintf(outFile, "Tot Num Squash GRF RD Reg (FETCH) = %lld\n",
      num_squashed_grf_rd_fetch_reg);
                fprintf(outFile, "Tot Num Squash GRF WR Reg (READY) = %lld\n",
      num_squashed_grf_wr_ready_reg);
                fprintf(outFile, "Tot Num Squash GRF RD Reg (READY) = %lld\n",
      num_squashed_grf_rd_ready_reg);
                fprintf(outFile, "Tot Num Squash GRF WR Reg (EXECT) = %lld\n",
      num_squashed_grf_wr_execute_reg);
                fprintf(outFile, "Tot Num Squash GRF RD Reg (EXECT) = %lld\n",
      num_squashed_grf_rd_execute_reg);
                fprintf(outFile, "Tot Num Squash GRF WR Reg (COMPL) = %lld\n",
      num_squashed_grf_wr_complete_reg);
                fprintf(outFile, "Tot Num Squash GRF RD Reg (COMPL) = %lld\n",
      num_squashed_grf_rd_complete_reg);
                fprintf(outFile, "Tot Num SB Activations            = %ld\n",
      totNumSBactivations);
                fprintf(outFile, "Tot Num SB ReActivations          = %ld\n",
      totNumSBreactivations);
                fprintf(outFile, "Tot SB Reactivation Rate          = %f\n",(floa
      t)totNumSBreactivations/(float)totNumSBactivations);
                fprintf(outFile, "Total SB Size                     = %lu\n",
      totalSBsize);
                fprintf(outFile, "Tot Avg SB Size                   = %f\n",(floa
      t)totalSBsize/(float)totNumSBactivations);
                fprintf(outFile, "Max SB Size                       = %ld\n",
      maxSBsize);
                fprintf(outFile, "Min SB Size                       = %ld\n",
      minSBsize);
                fprintf(outFile, "Total Number of Execute  Ins      = %ld\n",
      executeInsCount);
                fprintf(outFile, "Total Number of Complete Ins      = %ld\n",
      completeInsCount);
                fprintf(outFile, "Total Number of Commit Ins        = %ld\n",
      insCount);
                fprintf(outFile, "Total Num Ins Visit SB            = %ld\n",
      totInsVisitingSBcount);
                fprintf(outFile, "Total Rate of Ins Visiting SB     = %f\n",(floa
      t)totInsVisitingSBcount/(float)insCount);
                fprintf(outFile, "Tot Ins Exe When SB ON            = %ld\n",
      totInsCountWhenSBon);
                fprintf(outFile, "Tot Ins Exe When SB ON IPC        = %f\n",(floa
      t)totInsCountWhenSBon/(float)totSBactiveCycles);
                fprintf(outFile, "SB ON Avg. Time                   = %f\n\n",(fl
      oat)(cycle-totSBoffCycles)/(float)cycle);
                fprintf(outFile, "Tot Num of Off SB Dep. Ins/Active Win = %f\n",(
      float)numDepInOtherSBs/(float)totNumSBactivations);
                fprintf(outFile, "Num Empty Res Stn Cycles          = %ld\n", 
      emptyResStation);
                fprintf(outFile, "Num Empty Res Stn Cycles/All Cycl = %f\n\n", (f
      loat)emptyResStation/(float)cycle);

                if (reportTraceAndHitMiss) {
                        fprintf(outFile, "Unpredictability Threshold= %f\n", (dou
      ble)unpredMemOpThreshold/(double)COEFF);
                        fprintf(outFile, "Num Unpred. Ins:          = %ld\n", 
      unpredMemInsCnt);
                        fprintf(outFile, "Num Unpred. Ops:          = %ld\n", 
      unpredMemOpCnt);
                        fprintf(outFile, "Unpred. Ins Rate:         = %f\n", (flo
      at)unpredMemOpCnt/(float)insCount);
                }
                if (makePhrase) {
                        fprintf(outFile, "Max Phrases Size                = %d\n"
      , phraseSizeBound);
                        fprintf(outFile, "Unpredictable Ins Threshold     = %f\n"
      , (double)unpredMemOpThreshold/(double)COEFF);
                        fprintf(outFile, "Num Phrases                     = %ld\n
      ", totNumPhrase);
                        fprintf(outFile, "Avg. Num Ins/Phrase             = %f\n"
      , (float)insCount/(float)totNumPhrase);
                        fprintf(outFile, "Tot Num SoftBound Partitions    = %ld\n
      ", totNumSoftBound);
                        fprintf(outFile, "Avg. Num SoftBound/Phrase       = %f\n"
      , (float)totNumSoftBound/(float)totNumPhrase);
                        fprintf(outFile, "Tot Num Unpred. Ins             = %ld\n
      ", totNumPhUnpredMemOp);
                        fprintf(outFile, "Num Unpred. Ins/Phrase          = %f\n"
      , (float)totNumPhUnpredMemOp/(float)totNumPhrase);
                        fprintf(outFile, "Num Unpred. Ins/Total Ins       = %f\n"
      , (float)totNumPhUnpredMemOp/(float)insCount);
                        fprintf(outFile, "Tot Num Root Ins                = %ld\n
      ", totNumRootIns);
                        fprintf(outFile, "Num Root Ins/Phrase             = %f\n"
      , (float)totNumRootIns/(float)totNumPhrase);
                        fprintf(outFile, "Tot Num Phrase Ancestors        = %ld\n
      ", totNumPhraseAncestors);
                        fprintf(outFile, "NumPhrase Ancestors/Phrase      = %f\n"
      , (float)totNumPhraseAncestors/(float)totNumPhrase);
                        fprintf(outFile, "Num of Resetting Times          = %ld\n
      \n", totNumPhGenResets);
                        fprintf(outFile, "Num Fragment                    = %ld\n
      ", totNumFrag);
                        fprintf(outFile, "Num Root Phrases                = %ld\n
      ", totNumRootPh);
                        fprintf(outFile, "Root Phrases Rate               = %f\n"
      , (double)totNumRootPh/(double)totNumPhrase);
                        fprintf(outFile, "Num Critical Path Violations    = %ld\n
      ", totNumCritPathViol);
                        fprintf(outFile, "Critical Path Violations Rate   = %f\n"
      , (double)totNumCritPathViol/(double)totNumPhrase);
                        fprintf(outFile, "Avg. Num Ins/Fragment           = %f\n"
      , (float)insCount/(float)totNumFrag);
                        fprintf(outFile, "Avg. Num Fragment/Phrase        = %f\n"
      , (float)totNumFrag/(float)totNumPhrase);
                }
                if (coreType == PHRASE || coreType == FRAGMENT) {
                        fprintf(outFile, "Num Phrases                     = %ld\n
      ", totNumPhrase);
                        fprintf(outFile, "Avg. Num Ins/Fragment           = %f\n"
      , (float)insCount/(float)totNumFrag);
                        fprintf(outFile, "Avg. Num Fragment/Phrase        = %f\n"
      , (float)totNumFrag/(float)totNumPhrase);
                        fprintf(outFile, "Avg. Num Ins/Phrase             = %f\n"
      , (float)insCount/(float)totNumPhrase);
                        fprintf(outFile, "Latency/Phrase                  = %f\n"
      , (float)totalLatency(0)/(float)totNumPhrase);
                        fprintf(outFile, "Tot Phrase Stall Time           = %ld\n
      ", totPhStall);
                        fprintf(outFile, "Avg. Phrase Stall Time          = %f\n"
      , (float)totPhStall/(float)totNumPhrase);
                        fprintf(outFile, "Unexpected Miss Count           = %ld\n
      ", unexpectedMiss);
                        fprintf(outFile, "Unexpected Miss Rate            = %f\n"
      , (float)unexpectedMiss/(float)missCount(cacheLat[0]));
                        fprintf(outFile, "Unexpected Miss Latency         = %ld\n
      ", unexpecteedLat);
                        fprintf(outFile, "Unexpected Avg. Miss Lat        = %f\n"
      , (float)unexpecteedLat/(float)unexpectedMiss);
                        fprintf(outFile, "Unexpected Miss Lat Rate        = %f\n"
      , (float)unexpecteedLat/(float)missLatency(0));
                }
                if (coreType == FRAGMENT) {
                        fprintf(outFile, "Num Fragment                    = %ld\n
      ", totNumFrag);
                        fprintf(outFile, "Tot Fragment Stall Time         = %ld\n
      ", totFrStall);
                        fprintf(outFile, "Avg. Fragment  Stall Time       = %f\n"
      , (float)totFrStall/(float)totNumFrag);
                        fprintf(outFile, "Num Real Fragment               = %ld\n
      ", totNumRealFrag);
                        fprintf(outFile, "Real Frag/Tot Frag              = %f\n"
      , (float)totNumRealFrag/(float)totNumFrag);
                        fprintf(outFile, "Avg. Num Ins/Real Frag          = %f\n"
      , (float)totSizRealFrag/(float)totNumRealFrag);
                        fprintf(outFile, "Num of Single Frag Wavefront    = %ld\n
      ", totNumOfSigleFragPhrases);
                        fprintf(outFile, "Avg. Num Real Frag/Phrase       = %f\n"
      , (double)totNumRealFrag/(double)(totNumPhrase-totNumOfSigleFragPhrases));
                        fprintf(outFile, "Avg. Num Ready Frags            = %f\n"
      , (double)numReadyFrags/(double)totNumFrag);
                        fprintf(outFile, "Inter-Fragment Stall Time       = %ld\n
      ", interFragStallCycle);
                        fprintf(outFile, "Inter-Fragment Stall Rate       = %f\n\
      n", (double)interFragStallCycle/(double)cycle);

                }


                fprintf(outFile, "---    ---    ---    ---    ---    ----   \n");
      
                for (int  i = 0; i < numSideBuffs; i++) {
                        fprintf(outFile, "SB INDEX                = %d\n",i);
                        fprintf(outFile, "Num SB Activations      = %ld\n",
      numSBactivations[i]);
                        fprintf(outFile, "Num SB ReActivations    = %ld\n",
      numSBreactivations[i]);
                        fprintf(outFile, "SB Reactivation Rate    = %f\n",(float)
      numSBreactivations[i]/(float)numSBactivations[i]);
                        fprintf(outFile, "SB Size                 = %lu\n",
      SBsize[i]);
                        fprintf(outFile, "Avg SB Size             = %f\n",(float)
      SBsize[i]/(float)numSBactivations[i]);
                        fprintf(outFile, "Num Ins Visit SB        = %ld\n",
      insVisitingSBcount[i]);
                        fprintf(outFile, "Rate of Ins Visiting SB = %f\n",(float)
      insVisitingSBcount[i]/(float)insCount);
                        fprintf(outFile, "Ins Exe When SB ON      = %ld\n",
      InsCountWhenSBon[i]);
                        fprintf(outFile, "Ins Exe When SB ON IPC  = %f\n",(float)
      InsCountWhenSBon[i]/(float)SBactiveCycles[i]);
                        fprintf(outFile, "SB ON Avg. Time         = %f\n\n",(floa
      t)(cycle-SBoffCycles[i])/(float)cycle);
                        fprintf(outFile, "Frame Win Avg. Size    = %f\n",(float)(
      totFrameSize)/(float)numSBactivations[i]);
                        fprintf(outFile, "Frame NonSB Ins Avg Cnt= %f\n",(float)(
      totMainStreamBound)/(float)numSBactivations[i]);
                        fprintf(outFile, "Frame Window Sat Rate  = %f\n",(float)(
      windowSatration)/(float)numSBactivations[i]);  //TODO THIS IS NOT A VECTOR ELEMEN
      T, fix
                        fprintf(outFile, "Frame ON longLat op Rate  = %f\n",(floa
      t)(longLatOpWhenSPisON)/(float)numSBactivations[i]);  //TODO THIS IS NOT A VECTOR
       ELEMENT, fix
                        fprintf(outFile, "Frame ON-Drain longLat Rat= %f\n",(floa
      t)(longLatOpWhenSPisDraining)/(float)numSBactivations[i]);  //TODO THIS IS NOT A 
      VECTOR ELEMENT, fix
                        fprintf(outFile, "Frame ON-Wait longLat Rate= %f\n",(floa
      t)(longLatOpWhenSPisWaiting)/(float)numSBactivations[i]);  //TODO THIS IS NOT A V
      ECTOR ELEMENT, fix
                        fprintf(outFile, "---    ---    ---    ---    ---    ----
         \n");
                }


                fprintf(outFile, "\nNumber of MEM Ops       = %ld\n",numMemOps);
                fprintf(outFile, "Number of ALU Ops         = %ld\n",numALUOps);
                fprintf(outFile, "Number of FPU Ops         = %ld\n",numFPUOps);
                fprintf(outFile, "Number of BR  Ops         = %ld\n",numBROps);
                fprintf(outFile, "Number of ASSIGN  Ops     = %ld\n",
      numAssignOps);
                fprintf(outFile, "Number of READ Ops        = %ld\n",numReadOps);
      
                fprintf(outFile, "Number of WRITE Ops       = %ld\n",numWriteOps)
      ;
                fprintf(outFile, "Number Mis-Pred BR Ops (Fetch)     = %ld, Rate:
       %f\n",missPredBROps_fetch, (float)missPredBROps_fetch/(float)numBROps);
                fprintf(outFile, "Number Mis-Pred BR Ops (Commit)    = %ld, Rate:
       %f\n",missPredBROps, (float)missPredBROps/(float)numBROps);
                fprintf(outFile, "Number Mis-Pred_NT BR Ops (Fetch)  = %ld, Rate:
       %f\n",missPredBROps_NT_fetch, (float)missPredBROps_NT_fetch/(float)numBROps);
                fprintf(outFile, "Number Mis-Pred_NT BR Ops (Commit) = %ld, Rate:
       %f\n",missPredBROps_NT, (float)missPredBROps_NT/(float)numBROps);
                fprintf(outFile, "Number Pred_NT R Ops (Fetch)       = %ld, Rate:
       %f\n",numBrOps_predT_fetch, (float)numBrOps_predT_fetch/(float)numBROps);
                fprintf(outFile, "Number Pred_T BR Ops (Commit)      = %ld, Rate:
       %f\n",numBrOps_predT, (float)numBrOps_predT/(float)numBROps);
                fprintf(outFile, "Store FWD READ Ops        = %ld\n",stFwdMemOp);
      
                fprintf(outFile, "Store FWD READ/All READ   = %f\n",(float)
      stFwdMemOp/(float)numReadOps);
                fprintf(outFile, "Non-blocking READ Ops     = %ld\n",
      nonBlockingMemOp);
                fprintf(outFile, "Non-blck READ/All READ    = %f\n",(float)
      nonBlockingMemOp/(float)numReadOps);
                fprintf(outFile, "Cache Axes READ Ops       = %ld\n",maxSBsize);
                fprintf(outFile, "Cache Axes READ/All READ  = %f\n",(float)
      maxSBsize/(float)numReadOps);
                fprintf(outFile, "MEM Ops Rate          = %f\n",(float)numMemOps/
      (float)insCount);
                fprintf(outFile, "ALU Ops Rate          = %f\n",(float)numALUOps/
      (float)insCount);
                fprintf(outFile, "FPU Ops Rate          = %f\n",(float)numFPUOps/
      (float)insCount);
                fprintf(outFile, "BR  Ops Rate          = %f\n",(float)numBROps/(
      float)insCount);
                fprintf(outFile, "ASSIGN  Ops Rate      = %f\n",(float)
      numAssignOps/(float)insCount);
                fprintf(outFile, "READ Ops Rate         = %f\n",(float)
      numReadOps/(float)insCount);
                fprintf(outFile, "WRITE Ops Rate        = %f\n",(float)
      numWriteOps/(float)insCount);
                fprintf(outFile, "READ/MEM  Ops Rate    = %f\n",(float)
      numReadOps/(float)numMemOps);
                fprintf(outFile, "WRITE/MEM Ops Rate    = %f\n\n",(float)
      numWriteOps/(float)numMemOps);
                fprintf(outFile, "------------------------------------------\n");
      
        //}
        //fprintf(outFile, "SB Sizes:\n");
        //for (int x = 0; x < SBsizeList->NumElements(); x++)
        //      fprintf(outFile, "%d\n", SBsizeList->Nth(x));
        //fprintf(outFile, "------------------------------------------\n");
        //fprintf(outFile, "SB Sizes (SORTED):\n");
        //quicksort(SBsizeList,0,SBsizeList->NumElements()-1,cycle);
        //for (int x = 0; x < SBsizeList->NumElements(); x++)
        //      fprintf(outFile, "%d\n", SBsizeList->Nth(x));

        if (coreType == FRAGMENT || coreType == FRAGMENT2) {
                frSizeHist->report(outFile, "Frag Size Hist");
                frLatHist->report(outFile, "Frag Latency Hist");
        } 
        else if (coreType == PHRASE) {
                //phCritPathHist->report(outFile, "Phrase Critical Path Hist");
                //phSizeHist->report(outFile, "Phrase Size Hist");
        }
        if (coreType == STRAND || coreType == PHRASEBLOCK) {
                fprintf(outFile, "STRAND COUNT: %lld\n", dyn_num_strands);
                fprintf(outFile, "TOT NUM INS IN STRAND: %lld\n", 
      total_num_strand_ins);
                fprintf(outFile, "AVG. STRAND SIZE: %f\n", (double)
      total_num_strand_ins/(double)dyn_num_strands);
                fprintf(outFile, "Percent of Ins in Strands: %f\n", (double)
      total_num_strand_ins/(double)insCount*100.0);
        } 
        /* PHRASEBLOCK EXE STAT */
        else if (coreType == PHRASEBLOCK) {
                fprintf(outFile, "Total Num PB/BB Ran: %ld\n", bbCount);
                fprintf(outFile, "AVG. Active BB/PB Ratio: %f\n", (double)
      activeBuffCnt/(double)cycle);
                fprintf(outFile, "Average # of Cycles b/w BP Lookup & Update: %f\
      n", (double)br_pred_update_dist/(double)brInsCount);
        }
        for (int i = 0; i < NUM_FUNC_UNIT; i++)
                fprintf(outFile, "Res Stn %d Utilization  = %f\n", i, (float)
      iResStnsSize[i]/(float)cycle);
        for (int i = 0; i < NUM_PHRASEBLKS; i++)
                fprintf(outFile, "Phraseblock %d Utilization  = %f\n", i, (float)
      pbListsSize[i]/(float)cycle);
        if (reportTraceAndHitMiss == true) {
                correlationHist->report(outFile, "Miss Rate Correlation between I
      NO Schedule and the 'new' schedule");
        }
        numParentsHist->report(outFile, "Num of Ancestors Hist");
        numChildrenHist->report(outFile, "Num of Dependents Hist");
        numParentsHist->report();
        numChildrenHist->report();

        map<long int, int>::iterator wbb_it;
        for (wbb_it = num_ins_exe_cnt.end(); wbb_it != num_ins_exe_cnt.begin(); w
      bb_it--) {
                long int insAddr = wbb_it->first;
                fprintf(wbbSkipCountFile, "%ld, %d, %d, %f\n",  insAddr,
                                                                                                                
      num_ins_exe_cnt[insAddr],
                                                                                                                
      num_bypassed_wbb[insAddr],
                                                                                                                f
      loat(num_bypassed_wbb[insAddr])/float(num_ins_exe_cnt[insAddr]));
        }
        map<long int, int>::iterator br_it;
        for (br_it = num_ins_exe_cnt.end(); br_it != num_ins_exe_cnt.begin(); br_
      it--) {
                long int insAddr = br_it->first;
                fprintf(brSkipAccuracyFile, "%ld, %d, %f, %f\n",insAddr,
                                                                                                                
      num_ins_exe_cnt[insAddr],
                                                                                                                
      ins_exe_hoist_accuracy[insAddr],
                                                                                                                f
      loat(ins_exe_hoist_accuracy[insAddr])/float(num_ins_exe_cnt[insAddr]));
        }
        fclose(wbbSkipCountFile);
        fclose(brSkipAccuracyFile);
        fclose (pinFile);
        fclose (outFile);
        if (reschedule == true) fclose (reScheduleFile);
        if (makePhrase == true) fclose (phraseFile);
        printf("DONE TRACING!\n");

        delete iResStation;
        delete iMemBuf;
        delete iWindow;
        delete iROB;
        //delete iSideBuff[0];
        delete _L1;
        delete _L2;
        delete _L3;
        delete [] iSideBuff;

        delete [] numSBreactivations;
        delete [] insVisitingSBcount;
        delete [] numSBactivations;
        delete [] InsCountWhenSBon;
        delete [] SBactiveCycles;
        delete [] SBoffCycles;
        delete [] SBsize;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_aa41656fd1e95e4bdc43191b18dfd8102}{
\index{bkEnd.cpp@{bkEnd.cpp}!bkEnd\_\-heading@{bkEnd\_\-heading}}
\index{bkEnd\_\-heading@{bkEnd\_\-heading}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{bkEnd\_\-heading}]{\setlength{\rightskip}{0pt plus 5cm}void bkEnd\_\-heading (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char const $\ast$}]{argv\mbox{[}$\,$\mbox{]}}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_aa41656fd1e95e4bdc43191b18dfd8102}

\begin{DoxyCode}
                                                  {
        printf("-----------------------------------------\n");
        printf("COMMAND:          ");
        for (int i = 0; i < argc; i++) {
                printf("%s ", argv[i]);
        }
        printf("\n");
        printf("CACHE LAT:       = ");
        for (int i = 0; i < MEM_HIGHERARCHY; i++) {
                printf("%d, ", cacheLat[i]);
        }
        printf("\n");
        printf("CORE TYPE         = %d\n", coreType);
        printf("Perf Reg Renaming = %d (Size: %d)\n", perfectRegRen, GRRF_SIZE);
        printf("LSQ Model         = %d (LQ: %d, SQ %d)\n", memoryModel, LQ_SIZE, 
      SQ_SIZE);
        printf("ROB Size              = %d\n", ROBsize);
        printf("1 LD Lat Lvl      = %ld\n", oneLevDeepLatLevel);
        printf("Frame Buffer Size = %ld\n", SBlength);
        printf("Num Side Buffs    = %ld\n", numSideBuffs);
        printf("IN FILE               = %s\n", inFileName.c_str());
        printf("OUT FILE          = %s\n", outFileName1.c_str());
        if (reschedule == true) printf("VLIW TRACE FILE = %s\n", 
      reScheduleFileName.c_str());
        if (makePhrase == true) printf("PHRASE TRACE FILE = %s\n", 
      phrasingFileName.c_str());
        if (reportTraceAndHitMiss == true) 
                                printf("UNPRED MEM TRACE FILE = %s\n", 
      reScheduleFileName.c_str());
        printf("COMMENT          = %s\n", comment);
        printf("-----------------------------------------\n");

        outFile = outFile1;
        fprintf(outFile, "-----------------------------------------\n");
        fprintf(outFile, "COMMAND:          ");
        for (int i = 0; i < argc; i++) {
                fprintf(outFile, "%s ", argv[i]);
        }
        fprintf(outFile, "\n");
        fprintf(outFile, "CACHE LAT:       = ");
        for (int i = 0; i < MEM_HIGHERARCHY; i++) {
                fprintf(outFile, "%d, ", cacheLat[i]);
        }
        fprintf(outFile, "\n");
        fprintf(outFile, "CORE TYPE        = %d\n", coreType);
        fprintf(outFile, "ROB Size                 = %d\n", ROBsize);
        fprintf(outFile, "1 LD Lat Lvl     = %ld\n", oneLevDeepLatLevel);
        fprintf(outFile, "Frame Buffer Size= %ld\n", SBlength);
        fprintf(outFile, "Num Side Buffs   = %ld\n", numSideBuffs);
        fprintf(outFile, "IN FILE          = %s\n", inFileName.c_str());
        fprintf(outFile, "OUT FILE         = %s\n", outFileName1.c_str());
        if (reschedule == true) fprintf(outFile,"VLIW TRACE FILE = %s\n", 
      reScheduleFileName.c_str());
        if (makePhrase == true) fprintf(outFile,"PHRASE TRACE FILE = %s\n", 
      phrasingFileName.c_str());
        if (reportTraceAndHitMiss == true) 
                                fprintf(outFile,"UNPRED MEM TRACE FILE = %s\n", 
      reScheduleFileName.c_str());
        fprintf(outFile,"COMMENT                 = %s\n", comment);
        fprintf(outFile, "-----------------------------------------\n");
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a2610cc7850729dad55450e26627d78ae}{
\index{bkEnd.cpp@{bkEnd.cpp}!bkEnd\_\-init@{bkEnd\_\-init}}
\index{bkEnd\_\-init@{bkEnd\_\-init}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{bkEnd\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void bkEnd\_\-init (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char const $\ast$}]{argv\mbox{[}$\,$\mbox{]}, }
\item[{{\bf g\_\-variable} \&}]{g\_\-var}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a2610cc7850729dad55450e26627d78ae}

\begin{DoxyCode}
                                                                   {
        junk=fopen("junk_bzip.txt", "w");
        for (int i = 0; i < numSideBuffs; i++) {
                numSBreactivations[i] = 0;
                insVisitingSBcount[i] = 0;
                numSBactivations[i] = 0;
                InsCountWhenSBon[i] = 0;
                SBactiveCycles[i] = 0;
                SBoffCycles[i] = 0;
                SBsize[i] = 0;
        }
        //Initialize Branch Predictor
    predictor = new TournamentBP(2048, 2, 2048, 11, 8192, 13, 2, 8192, 2, 0);

        //Set cache level latencies
        cacheLat[0] = L1_LATENCY;
        cacheLat[1] = L2_LATENCY;
        cacheLat[2] = L3_LATENCY;
        cacheLat[3] = MEM_LATENCY;

        oneLevDeepLatLevel = cacheLat[0];
        xLevDeepLatLevel   = cacheLat[0];

        //Set core type
        coreType =IN_ORDER ; //;OUT_OF_ORDER;ONE_LEVEL_DEEP_DYN 
        ROBsize = ROB_SIZE;
        pbROBsize = PB_ROB_SIZE;
        
        //Comment
        comment = new char[500];

        //Parse inputs
        int c;
        int temp = -1;
        while ((c = getopt (argc, (char **)argv, "l:o:i:u:f:c:w:s:b:t:m:p:r:h:a:1
      :2:3:4:n:d:e:v:g:j:k:x:y:z:")) != -1) 
        {   
                switch(c)
                {   
                case 'l':
                        xLevDeepLatLevel = atoi(optarg);
                        break;
                case 'o':
                        outFileName1.assign(optarg);
                        break;
                case 'i':
                        inFileName.assign(optarg);
                        break;
                case 'u':
                        reScheduleFileName.assign(optarg);
                        break;
                case 'f':
                        phrasingFileName.assign(optarg);
                        break;
                case 'c':
                        coreType = (core) atoi(optarg);
                        break;
                case 'w':
                        ROBsize = atoi(optarg);
                        break;
                case 's':
                        numSideBuffs = atoi(optarg);
                        break;
                case 'b':
                        SBlength = atoi(optarg);
                        break;
                case 't':
                        temp = atoi(optarg);
                        if (temp == 0)  reportTrace = false;
                        else            reportTrace = true;
                        Assert(temp == 1 || temp == 0);
                        break;
                case 'm':
                        temp = atoi(optarg);
                        if (temp == 0)  reportTraceAndHitMiss = false;
                        else            reportTraceAndHitMiss = true;
                        Assert(temp == 1 || temp == 0);
                        break;
                case 'p':
                        temp = atoi(optarg);
                        if (temp == 0)  makePhrase = false;
                        else            makePhrase = true;
                        Assert(temp == 1 || temp == 0);
                        break;
                case 'r':
                        temp = atoi(optarg);
                        if (temp == 0)  reschedule = false;
                        else            reschedule = true;
                        Assert(temp == 1 || temp == 0);
                        break;
                case 'h':
                        unpredMemOpThreshold = atof(optarg);
                        break;
                case 'a':
                        phraseSizeBound = atoi(optarg);
                        break;
                case '1':
                        cacheLat[0] = atoi(optarg);
                        break;
                case '2':
                        cacheLat[1] = atoi(optarg);
                        break;
                case '3':
                        cacheLat[2] = atoi(optarg);
                        break;
                case '4':
                        cacheLat[3] = atoi(optarg);
                        break;
                case 'n': //NOTE: incomplete - only implemented for single issue 
      INO and OOO
                        numFU = atoi(optarg);
                        break;
                case 'd':
                        parseHitMiss = atoi(optarg);
                        break;
                case 'e':
                        comment = optarg;
                        break;
                case 'v':
                        evaltMissRtCorrel = atoi(optarg);
                        break;
                case 'g':
                        temp = atoi(optarg);
                        if (temp == 0)  UPLDhoist = false;
                        else            UPLDhoist = true;
                        break;
                case 'j':
                        branchMode = (brMode) atoi(optarg);
                        break;
                case 'k':
                        insParseCap = atoi(optarg);
                        Assert(insParseCap > 0);
                        break;
                case 'x':
                        wbb_skip_count.assign(optarg);
                        break;
                case 'y':
                        temp = atoi(optarg);
                        if (temp == 0)  branchProfileFlag = false;
                        else                    branchProfileFlag = true;
                        break;
                case 'z':
                        branchProfileFileName.assign(optarg);
                        break;
                default:
                        //Unrecognized input. Terminate the run
                        exit(-1);
                };
        }
        //Assert(branchMode >= noBr && branchMode <= scheduleBr);

        //Build the cache
        _L1 = new cache(1, 64, 32768  ); //32KB
        _L2 = new cache(1, 64, 2097152); //2MB
        _L3 = new cache(1, 64, 8388608); //8MB

        //Build functional units status
        for (int i = 0; i < NUM_FUNC_UNIT; i++) {
                aluAvail   [i] = true;
                aluFreeTime[i] = 0;
                aluStat    [i] = 0;
                if (i == 0) {
                        aluKind[i] = MEM;
                } else {
                        aluKind[i] = ALU;
                }
        }
        
        //Build instruction window (empty right now)
        iROB           = new List<instruction*>;
        pbROB          = new List<basicblock*>;
        ICQ            = new List<char*>;
        iWindow        = new List<instruction*>;
        iMemBuf        = new List<instruction*>;
        iResStation    = new List<instruction*>;
        SBpriorityList = new List<int>;
        iSideBuff   = new sideBuff* [NUM_SIDE_BUFFERS];
        for (int i = 0; i < NUM_FUNC_UNIT; i++)
                iResStations[i] = new List<instruction*>;
        for (int i = 0; i < NUM_SIDE_BUFFERS; i++)
                iSideBuff[i] = new sideBuff;
        for (int i = 0; i < NUM_FUNC_UNIT; i++)
                iResStnsSize[i] = 0;
        for (int i = 0; i < NUM_PHRASEBLKS; i++)
                pbListsSize[i] = 0;

        //Open files
        sprintf(outFileName2,"%sSum",outFileName1.c_str());
        if((pinFile=fopen(inFileName.c_str(), "r")) == NULL || 
           (outFile1=fopen(outFileName1.c_str(), "w+")) == NULL) {// ||
           //(outFile2=fopen(outFileName2, "w+")) == NULL) {
            printf("1-ERROR: Cannot open file(s).\n");
            exit(1);
        }
        if(//reschedule == true &&
           (reScheduleFile=fopen(reScheduleFileName.c_str(), "w")) == NULL) {
            printf("2-ERROR: Cannot open file(s).\n");
            exit(1);
        }
        if (makePhrase == true &&
           (phraseFile=fopen(phrasingFileName.c_str(), "w")) == NULL) {
            printf("3-ERROR: Cannot open file(s).\n");
            exit(1);
        }

        if (branchProfileFlag == true &&
            ((branchProfile=fopen(branchProfileFileName.c_str(), "r")) == NULL ||
      
             (branchAccuracy=fopen(branchAccuracyFileName.c_str(), "r")) == NULL)
      ) {
            printf("4-ERROR: Cannot open file(s).\n");
            exit(1);
        } else if (branchProfileFlag == true) {
                int total_count, taken_count, bbl_size;
                long int ins_addr, dst_addr;
                float taken_rate;
                while(fscanf(branchProfile, "%ld, %d, %d, %d, %f, %ld\n", &ins_ad
      dr, &bbl_size, &total_count, &taken_count, &taken_rate, &dst_addr) != EOF) {
                //while(fscanf(branchProfile, "%ld, %d, %d, %f\n", &ins_addr, &to
      tal_count, &taken_count, &taken_rate) != EOF) {
                        branchBiasProfileMap[ins_addr] = taken_rate;
                }
                while(fscanf(branchAccuracy, "%ld, %f\n", &ins_addr, &taken_rate)
       != EOF) {
                        branchAccuracyMap[ins_addr] = taken_rate;
                }
        }


        if (upldProfileFlag == true &&
           (upldProfile=fopen(upldProfileFileName.c_str(), "r")) == NULL) {
            printf("4-ERROR: Cannot open file(s).\n");
            exit(1);
        } else if (upldProfileFlag == true) {
                long int ins_addr;
                float miss_rate;
                while(fscanf(upldProfile, "(%ld, %f)\n", &ins_addr, &miss_rate) !
      = EOF) {
                        upldMissRateProfileMap[ins_addr] = miss_rate;
                }
        }
        
        if ((wbbSkipCountFile=fopen(wbb_skip_count.c_str(), "w")) == NULL) {
            printf("3-ERROR: Cannot open file(s).\n");
            exit(1);
        }
        if ((brSkipAccuracyFile=fopen(br_skip_accuracy.c_str(), "w")) == NULL) {
            printf("3-ERROR: Cannot open file(s).\n");
            exit(1);
        }

        //Debug
        debug = false;

        //Invalid instruction counter
        invalidInsCount = 0;

        //EOC/EOF flags
        eoc = false;
        eof = false;

        corruptInsCount = 0;

        //generates the instruction Id
        insID = 0;
        cycle = 0;
        insCount = 0;
        completeInsCount = 0;
        executeInsCount = 0;

        //Histogram
        if (coreType == FRAGMENT || coreType == FRAGMENT2) {
                frSizeHist = new hist(phraseSizeBound+1, 0, phraseSizeBound+1);
                frLatHist = new hist(750, 0, 750);
        } else if (coreType == PHRASE) {
                //phCritPathHist = new hist(cacheLat[0]*phraseSizeBound, 0, cache
      Lat[0]*phraseSizeBound);
                //phSizeHist = new hist(phraseSizeBound+1, 0, phraseSizeBound+1);
      
        }
        numChildrenHist = new hist(ROBsize, 0, ROBsize);
        numParentsHist  = new hist(ROBsize, 0, ROBsize);

        //Parser
        parse = new parser;

        //Register Configuration
        if (perfectRegRen == true) {
                //Build x86 register file
                RF = new regFile;
                //Setup Dependency Table Obj for REG, MRM & BR
                depTables = new dependencyTable;
        } else { //Build an actual RF system
                switch (coreType) {
                        case IN_ORDER:
                                //Setup Dependency Table Obj for REG, MRM & BR
                                depTables = new dependencyTable;
                                break;
                        case OUT_OF_ORDER:
                                //Setup RR Obj for all reg
                                GRF = new registerRename(LARF_LO,GARF_HI);
                                //Setup Dependency Table Obj for MRM & BR
                                depTables = new dependencyTable;
                                break;
                        case PHRASEBLOCK:
                                //Setup RR Obj for global reg
                                GRF = new registerRename;
                                //GRF = new registerRename(LARF_LO,GARF_HI); /* f
      or no LRF */
                                //Setup Dependency Table Obj for local reg
                                for (int i = 0; i < NUM_PHRASEBLKS; i++) {
                                        LRFTables[i] = new dependencyTable;
                                }
                                //Setup Dependency Table Obj for MRM & BR
                                depTables = new dependencyTable;
                                break;
                        default: 
                                Assert(true == false && "Register allocation regu
      laion is not defined for this core.");
                };
        }
        
        //LSQ Configuration
        if (memoryModel == PERFECT) {
                ;//nothing to be done
        } else if (memoryModel == TOTAL_ORDER || memoryModel == NAIVE_SPECUL) {
                loadStoreQue = new lsq;
        }

        //INO is only valid when perfectRegRen is disabled
        if (coreType == IN_ORDER)
                Assert(perfectRegRen == false && "INO and perfectRegRen produce m
      eaningless results");
        
        //Initialize the frontend variables
        __g_var = &g_var;

        //phraseblock initialization
        if (coreType == PHRASEBLOCK) {
                _pbLists = new List<instruction*>* [NUM_PHRASEBLKS];
                for (int i = 0; i < NUM_PHRASEBLKS; i++) {
                        _pbLists[i] = new List<instruction*>;
                }
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a0de885ce07273f37e162ecb0e63ec95d}{
\index{bkEnd.cpp@{bkEnd.cpp}!bkEnd\_\-run@{bkEnd\_\-run}}
\index{bkEnd\_\-run@{bkEnd\_\-run}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{bkEnd\_\-run}]{\setlength{\rightskip}{0pt plus 5cm}void bkEnd\_\-run (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a0de885ce07273f37e162ecb0e63ec95d}

\begin{DoxyCode}
                  {
        //VLIW Scheduler
        if (reschedule == true) {
                bool addMoreIns = true;
                vliwScheduler* schedule = new vliwScheduler;
                while (true) {
                        cycle++;
                        if (eoc == false && addMoreIns == true) addIns(cycle);
                        else if (eoc == true && iROB->NumElements() == 0) break; 
      //TODO double check this line
                        if (numFU == 1) { //VLIW scheduling (normal) for 1FU
                                addMoreIns = schedule->scheduleInsStream_1FU(
      iROB,cycle,false,reScheduleFile);
                        } else { //VLIW scheduling (normal) for multiple FU's
                                addMoreIns = schedule->scheduleInsStream(iROB,
      cycle,UPLDhoist,reScheduleFile,unpredMemOpThreshold);
                        }
                        //Runtime Stat
                        if (cycle%100000==0) {
                                printf ("Cycle %ld\n", cycle);
                                //printf("Ins Count = %d\n", insCount); //TODO ad
      d this line later
                        }
                }
                delete schedule;
        }

        // Phrase Maker
        else if (makePhrase == true) {
                bool addMoreIns = true;
                vliwScheduler* schedule = new vliwScheduler;
                List<phrase*>* phList = new List<phrase*>;
                while (true) {
                        cycle++;
                        if (eoc == false && addMoreIns == true) schedule->
      parseIns(ROBsize, parse, cycle);
                        else if (eoc == true) break; //TODO double check this lin
      e
                        //while (iWindow->NumElements() > 0) {iWindow->RemoveAt(0
      );}//Drain it to avoid core dump (TODO optimize it out later)
                        addMoreIns = schedule->schedulePhraseinsStream(iROB,
      cycle,UPLDhoist,reScheduleFile,unpredMemOpThreshold,phList);
                        //Runtime Stat
                        if (cycle%10000==0) {
                                printf ("Cycle %ld\n", cycle);
                                printf("Ins Count = %ld\n", insCount);
                        }
                }
                delete schedule;
        }
        //----
        //else if (makePhrase == true) {
        //      printf("\n---WARNING: SET THE CORRECT unpredMemOpThreshold VALUE!
      !!---\n\n");
        //      int numPhrases = -1;
        //      phraseGen* phGen = new phraseGen;
        //      while (true) {
        //              cycle++;
        //              if (iROB->NumElements() == 0) printf("***********ROB DONE
      \n");
        //              if (iWindow->NumElements() == 0) printf("***********iWIN 
      DONE\n");
        //              if (eoc == true) printf("END OF FILE\n");
        //              //if (numPhrases == 0) printf("PHRASES DONE\n");
        //              //else printf("num phrases = %d\n", numPhrases);
        //
        //              if (eoc == false) addIns(cycle);
        //              else if (eoc == true &&
        //                       numPhrases == 0 &&
        //                       iROB->NumElements() == 0) break;
        //              numPhrases = phGen->runPhraseGen(iROB, iWindow, phraseFil
      e, depTables, eoc, ROBsize);
        //              if (cycle%300000==0) {
        //                      printf ("Instruction: %d\n", iWindow->Nth(0)->get
      InsID());
        //              }
        //      }
        //      /*-----STAT-----*/
        //      totNumPhrase = phGen->getTotNumPhrases();
        //      totNumSoftBound = phGen->getTotNumSoftBound();
        //      totNumPhUnpredMemOp = phGen->getTotNumPhraseUPLD();
        //      totNumRootIns = phGen->getTotNumRootIns();
        //      totNumPhraseAncestors = phGen->getTotNumPhraseAncestors();
        //      totNumPhGenResets = phGen->getNumPhGenReset();
        //      insCount = phGen->getTotNumIns();
        //      totNumFrag = phGen->getTotNumFrags();
        //      totNumRootPh = phGen->getTotNumRootPh();
        //      totNumCritPathViol = phGen->getTotNumCritPathViolations();
        //      /*-----STAT-----*/
        //      //delete phGen;
        //}

        // Phrase Core
        else if (coreType == PHRASE) {
                List<phrase*> *iPh = new List<phrase*>;
                dot *d = new dot(0);
                long int phIndx = 0;
                long int phIdealLat;
                bool phStart = true;
                int phSize;
                int numInFlightPh = 0;
                if (eoc == false) addPhrase(iPh, cycle, d); //TODO temperary loca
      tion
                phSize = iPh->Nth(0)->getPhraseSize_unsort();
                //long int critPath = iPh->Nth(0)->findCriticalPath();
                //phCritPathHist->addElem(critPath);
                for (int i = 0; i < phSize; i++) {
                        iWindow->Append(iPh->Nth(0)->getNthIns_unsort(i));
                }
                numInFlightPh++;
                /*-----STAT-----*/
                phIdealLat = iPh->Nth(0)->getPhIdealLat();
                /*-----STAT-----*/
                while (true) {
                        cycle++;
                        if (phStart == true) phCycle++;
                        //Free the busy ALU's
                        freeALUs(cycle);
                        //Complete executed phrases
                        for (int i = 0; i < numInFlightPh; i++) {
                                completeIns(cycle,iPh->Nth(i)->getInsList_unsort(
      ));
                                commitIns(cycle,iPh->Nth(i)->getInsList_unsort())
      ;
                                //Complete executed phrases
                                completeIns(cycle,iPh->Nth(i)->getInsList_unsort(
      ));
                        }
                        //Add instructions to phrase
                        if (eoc == false) addPhrase (iPh, cycle, d);
                        //Check resources status - goto nxt iter if all busy
                        if (!isALUfree()) continue;
                        int temp = numInFlightPh;
                        for (int i = temp-1; i >= 0; i--) {
                                if (iPh->Nth(i)->getPhraseSize_unsort() == 0) {
                                        removePhrase(iPh, i);
                                        numInFlightPh--;
                                        Assert(numInFlightPh >= 0);
                                        //printf("removed:%d\n", numInFlightPh);
                                }
                        }
                        //Go to Next Phrase
                        if (iWindow->NumElements() == 0 && iPh->NumElements() > n
      umInFlightPh) {
                                phStart = false;
                                //removePhrase(iPh, 0);
                                //if (iPh->NumElements() == 0) break;
                                phIndx++;
                                /*-----STAT-----*/
                                //printf("%d, %d\n", phIdealLat/4, phCycle);
                                //Assert((phIdealLat/NUM_FUNC_UNIT-1) <= phCycle)
      ; //TODO this check is broken. fix it
                                totPhStall += phCycle - phIdealLat;
                                phIdealLat = iPh->Nth(0)->getPhIdealLat();
                                /*-----STAT-----*/
                                phCycle = 1;
                                //Assert(iWindow->NumElements() == 0);
                                phSize = iPh->Nth(numInFlightPh)->
      getPhraseSize_unsort();
                                //critPath = iPh->Nth(numInFlightPh)->findCritica
      lPath();
                                //phCritPathHist->addElem(iPh->Nth(numInFlightPh)
      ->findCriticalPath());
                                for (int i = 0; i < phSize; i++) {
                                        iWindow->Append(iPh->Nth(numInFlightPh)->
      getNthIns_unsort(i));
                                }
                                Assert(iWindow->NumElements() == iPh->Nth(numInFl
      ightPh)->getPhraseSize_unsort());
                                numInFlightPh++;
                        }
                        if (iPh->NumElements() == 0 && iWindow->NumElements() == 
      0) break;
                        //Run the core
                        runInOcore(cycle,iWindow);
                        if (iWindow->NumElements() < phSize) phStart = true;
                        //Runtime Stat
                        if (cycle%200000==0) {
                                ipc = (float)(insCount)/(float)(cycle);
                                printf ("Cycle %ld\n", cycle);
                                printf("IPC = %f\n", ipc);
                                //phCritPathHist->report();
                                //phSizeHist->report();
                                //printf("------\n");
                        }
                }
                d->finish();
                delete d;
                /*-----STAT-----*/
                totNumPhrase = phIndx+1;
                /*-----STAT-----*/
        }

        // Fragment Core
        else if (coreType == FRAGMENT) {
                List<fragment*> *iFr_wait  = new List<fragment*>;
                List<fragment*> *iFr_ready = new List<fragment*>;
                long int frIndx = 0;
                long int frIdealLat;
                bool frStart = true;
                int frSize;
                int numInFlightFrags = 0;
                if (eoc == false) addFrag (iFr_wait, cycle); //TODO temperary loc
      ation
                findReadyFrag(iFr_ready, iFr_wait);
                numReadyFrags += iFr_ready->NumElements();
                frSize = iFr_ready->Nth(0)->getFragSize();
                for (int i = 0; i < frSize; i++) {
                        iWindow->Append(iFr_ready->Nth(0)->getNthIns(i));
                }
                numInFlightFrags++;
                /*-----STAT-----*/
                frIdealLat = iFr_ready->Nth(0)->getFrIdealLat();
                /*-----STAT-----*/
                while (true) {
                        cycle++;
                        if (frStart == true) frCycle++;
                        //Free the busy ALU's
                        freeALUs(cycle);
                        for (int i = 0; i < numInFlightFrags; i++) {
                                //Complete executed fragments
                                completeIns(cycle,iFr_ready->Nth(i)->getInsList()
      );
                                commitIns(cycle,iFr_ready->Nth(i)->getInsList());
      
                                //Complete executed fragments
                                completeIns(cycle,iFr_ready->Nth(i)->getInsList()
      );
                        }
                        //Move Fragments from Wait List to Ready List
                        findReadyFrag(iFr_ready, iFr_wait);
                        //Add instructions to fragment
                        if (eoc == false) addFrag (iFr_wait, cycle);
                        //Check resources status - goto nxt iter if all busy
                        if (!isALUfree()) continue;
                        int temp = numInFlightFrags;
                        for (int i = temp-1; i >= 0; i--) {
                                if (iFr_ready->Nth(i)->getFragSize() == 0) {
                                        iFr_ready->Nth(i)->setEnd(cycle);
                                        frLatHist->addElem(iFr_ready->Nth(i)->
      getLat());
                                        removeFrag(iFr_ready, i);
                                        numInFlightFrags--;
                                        Assert(numInFlightFrags >= 0);
                                        //printf("removed:%d\n", numInFlightFrags
      );
                                }
                        }
                        //printf("num: %d,%d,%d,%d\n", iFr_ready->NumElements(), 
      iFr_ready->Nth(0)->getFragSize(), iWindow->NumElements(),numInFlightFrags);
                        //Go to Next Frag
                        if (iWindow->NumElements() == 0 && iFr_ready->
      NumElements() > numInFlightFrags) {
                                //printf("num ready frags=%d\n",iFr_ready->NumEle
      ments());
                                frStart = false;
                                //removeFrag(iFr_ready, 0);
                                frIndx++;
                                /*-----STAT-----*/
                                //printf("%d, %d\n", frIdealLat/4, frCycle);
                                //Assert((frIdealLat/NUM_FUNC_UNIT-1) <= frCycle)
      ; //TODO this check is broken. fix it
                                totFrStall += frCycle - frIdealLat/NUM_FUNC_UNIT;
      
                                //printf("%d\n",frCycle - frIdealLat/4);
                                frIdealLat = iFr_ready->Nth(0)->getFrIdealLat();
                                /*-----STAT-----*/
                                frCycle = 1;
                                //Assert(iWindow->NumElements() == 0);
                                //quicksortFragScore(iFr_ready, numInFlightFrags,
       iFr_ready->NumElements()-1, -1);
                                frSize = iFr_ready->Nth(numInFlightFrags)->
      getFragSize();
                                runningFragNumber = iFr_ready->Nth(numInFlightFra
      gs)->getFragNum();
                                //printf("%d\n", numInFlightFrags);
                                iFr_ready->Nth(numInFlightFrags)->setStart(cycle)
      ;
                                for (int i = 0; i < frSize; i++) {
                                        iWindow->Append(iFr_ready->Nth(numInFligh
      tFrags)->getNthIns(i));
                                }
                                Assert(iWindow->NumElements() == iFr_ready->Nth(n
      umInFlightFrags)->getFragSize());
                                numInFlightFrags++;
                                //printf("added:%d\n", numInFlightFrags);
                                /*-----STAT-----*/
                                if (frSize < phraseSizeBound) {
                                        totNumRealFrag++;
                                        totSizRealFrag += frSize;
                                } else {
                                        totNumOfSigleFragPhrases++;
                                }
                                numReadyFrags += iFr_ready->NumElements();
                                //printf("num ready frags = %d, %d\n", iFr_ready-
      >NumElements(), cycle);
                                /*-----STAT-----*/
                        }
                        if (iFr_wait->NumElements() == 0 && iFr_ready->
      NumElements() == 0 && iWindow->NumElements() == 0) break;
                        /*-----STAT-----*/
                        if (iFr_ready->NumElements()==0) {interFragStallCycle++; 
      printf("empty\n");}
                        /*-----STAT-----*/
                        //Run the core
                        runInOcore(cycle,iWindow);
                        if (iWindow->NumElements() < frSize) frStart = true;
                        //Runtime Stat
                        if (cycle%200000==0) {
                                ipc = (float)(insCount)/(float)(cycle);
                                printf ("Cycle %ld\n", cycle);
                                printf("IPC = %f\n", ipc);
                                //frSizeHist->report();
                                //printf("------\n");
                                //frLatHist->report();
                        }
                }
                delete iFr_wait;
                delete iFr_ready;
                /*-----STAT-----*/
                totNumFrag = frIndx+1;
                /*-----STAT-----*/
        }
        else if (coreType == FRAGMENT2) {
                List<fragment*> *iFr_wait  = new List<fragment*>;
                List<fragment*> *iFr_ready = new List<fragment*>;
                List<instruction*> *iWindow1  = new List<instruction*>;
                List<instruction*> *iWindow2  = new List<instruction*>;
                List<instruction*> *iWindow3  = new List<instruction*>;
                List<instruction*> *iWindow4  = new List<instruction*>;
                long int frIndx = 0;
                //long int frIdealLat;
                bool frStart = true;
                int frSize;
                int numInFlightFrags = 0;
                int arbitrate = -1;
                if (eoc == false) addFrag (iFr_wait, cycle); //TODO temperary loc
      ation
                findReadyFrag(iFr_ready, iFr_wait);
                numReadyFrags += iFr_ready->NumElements();
                frSize = iFr_ready->Nth(0)->getFragSize();
                for (int i = 0; i < frSize; i++) {
                        iWindow1->Append(iFr_ready->Nth(0)->getNthIns(i));
                        arbitrate = 1;
                }
                numInFlightFrags++;
                if (iFr_ready->NumElements() > 1) {
                        frSize = iFr_ready->Nth(1)->getFragSize();
                        for (int i = 0; i < frSize; i++) {
                                iWindow2->Append(iFr_ready->Nth(1)->getNthIns(i))
      ;
                                arbitrate = 1; //TODO is this correect?
                        }
                        numInFlightFrags++;
                }
                /*-----STAT-----*/
                //frIdealLat = iFr_ready->Nth(0)->getFrIdealLat();
                /*-----STAT-----*/
                while (true) {
                        cycle++;
                        if (frStart == true) frCycle++;
                        //Free the busy ALU's
                        freeALUs(cycle);
                        for (int i = 0; i < numInFlightFrags; i++) {
                                //Complete executed fragments
                                completeIns(cycle,iFr_ready->Nth(i)->getInsList()
      );
                                commitIns(cycle,iFr_ready->Nth(i)->getInsList());
      
                                //Complete executed fragments
                                completeIns(cycle,iFr_ready->Nth(i)->getInsList()
      );
                        }
                        //Move Fragments from Wait List to Ready List
                        findReadyFrag(iFr_ready, iFr_wait);
                        //Add instructions to fragment
                        if (eoc == false) addFrag (iFr_wait, cycle);
                        //Check resources status - goto nxt iter if all busy
                        if (!isALUfree()) continue;
                        //if (iFr_ready->NumElements()) {
                        //      printf("num: %d,%d,%d,%d\n", iFr_ready->NumElemen
      ts(), 
                        //                                   iFr_ready->Nth(0)->g
      etFragSize(), 
                        //                                   iWindow1->NumElement
      s(),
                        //                                   numInFlightFrags);
                        //}
                        int temp = numInFlightFrags;
                        for (int i = temp-1; i >= 0; i--) {
                                if (iFr_ready->Nth(i)->getFragSize() == 0) {
                                        removeFrag(iFr_ready, i);
                                        numInFlightFrags--;
                                        Assert(numInFlightFrags >= 0);
                                }
                        }
                        //Go to Next Frag
                        if (iWindow1->NumElements() == 0 && iFr_ready->
      NumElements() > numInFlightFrags) {
                                //printf("******* 1 \n");
                                //int whichWin = -1;
                                //if (iFr_ready->Nth(0)->getFragSize() == 0)
                                //      whichWin = 0;
                                //else if (iFr_ready->Nth(1)->getFragSize() == 0)
      
                                //      whichWin = 1;
                                //else
                                //      Assert(whichWin == 0 || whichWin == 1);
                                //frSize = iFr_ready->Nth(numInFlightFrags)->getF
      ragSize();
                                //removeFrag(iFr_ready, whichWin);
                                //quicksortFragScore(iFr_ready, 0, iFr_ready->Num
      Elements()-1, -1);
                                frSize = iFr_ready->Nth(numInFlightFrags)->
      getFragSize();
                                for (int i = 0; i < frSize; i++) {
                                        iWindow1->Append(iFr_ready->Nth(numInFlig
      htFrags)->getNthIns(i));
                                }
                                Assert(iWindow1->NumElements() == iFr_ready->Nth(
      numInFlightFrags)->getFragSize());
                                numInFlightFrags++;
                                arbitrate = 2;
                        } if (iWindow2->NumElements() == 0 && iFr_ready->
      NumElements() > numInFlightFrags) {
                                //printf("******* 2 \n");
                                //int whichWin = -1;
                                //if (iFr_ready->Nth(0)->getFragSize() == 0)
                                //      whichWin = 0;
                                //else if (iFr_ready->Nth(1)->getFragSize() == 0)
      
                                //      whichWin = 1;
                                //else
                                //      Assert(whichWin == 0 || whichWin == 1);
                                //removeFrag(iFr_ready, whichWin);
                                //quicksortFragScore(iFr_ready, 0, iFr_ready->Num
      Elements()-1, -1);
                                frSize = iFr_ready->Nth(numInFlightFrags)->
      getFragSize();
                                for (int i = 0; i < frSize; i++) {
                                        iWindow2->Append(iFr_ready->Nth(numInFlig
      htFrags)->getNthIns(i));
                                }
                                Assert(iWindow2->NumElements() == iFr_ready->Nth(
      numInFlightFrags)->getFragSize());
                                numInFlightFrags++;
                                arbitrate = 3;
                        } if (iWindow3->NumElements() == 0 && iFr_ready->
      NumElements() > numInFlightFrags) {
                                //printf("******* 2 \n");
                                //int whichWin = -1;
                                //if (iFr_ready->Nth(0)->getFragSize() == 0)
                                //      whichWin = 0;
                                //else if (iFr_ready->Nth(1)->getFragSize() == 0)
      
                                //      whichWin = 1;
                                //else
                                //      Assert(whichWin == 0 || whichWin == 1);
                                //removeFrag(iFr_ready, whichWin);
                                //quicksortFragScore(iFr_ready, 0, iFr_ready->Num
      Elements()-1, -1);
                                frSize = iFr_ready->Nth(numInFlightFrags)->
      getFragSize();
                                for (int i = 0; i < frSize; i++) {
                                        iWindow3->Append(iFr_ready->Nth(numInFlig
      htFrags)->getNthIns(i));
                                }
                                Assert(iWindow3->NumElements() == iFr_ready->Nth(
      numInFlightFrags)->getFragSize());
                                numInFlightFrags++;
                                arbitrate = 4;
                        } if (iWindow4->NumElements() == 0 && iFr_ready->
      NumElements() > numInFlightFrags) {
                                //printf("******* 2 \n");
                                //int whichWin = -1;
                                //if (iFr_ready->Nth(0)->getFragSize() == 0)
                                //      whichWin = 0;
                                //else if (iFr_ready->Nth(1)->getFragSize() == 0)
      
                                //      whichWin = 1;
                                //else
                                //      Assert(whichWin == 0 || whichWin == 1);
                                //removeFrag(iFr_ready, whichWin);
                                //quicksortFragScore(iFr_ready, 0, iFr_ready->Num
      Elements()-1, -1);
                                frSize = iFr_ready->Nth(numInFlightFrags)->
      getFragSize();
                                for (int i = 0; i < frSize; i++) {
                                        iWindow4->Append(iFr_ready->Nth(numInFlig
      htFrags)->getNthIns(i));
                                }
                                Assert(iWindow4->NumElements() == iFr_ready->Nth(
      numInFlightFrags)->getFragSize());
                                numInFlightFrags++;
                                arbitrate = 1;
                        }
                        /*-----STAT-----*/
                        if (iFr_ready->NumElements()== 0 && iFr_wait->
      NumElements()>0) interFragStallCycle++;
                        if (iFr_wait->NumElements() == 0 && 
                            iFr_ready->NumElements()== 0 && 
                            iWindow1->NumElements() == 0 && 
                            iWindow2->NumElements() == 0 &&
                            iWindow3->NumElements() == 0 &&
                            iWindow4->NumElements() == 0) break;
                        /*-----STAT-----*/
                        //Run the core
                        runDueLaneInOcore(cycle,iWindow1,iWindow2,iWindow3,iWindo
      w4,arbitrate); //TODO fix arbitration
                        if (iWindow1->NumElements() < frSize) frStart = true;
                        //Runtime Stat
                        if (cycle%200000==0) {
                                ipc = (float)(insCount)/(float)(cycle);
                                printf ("Cycle %ld\n", cycle);
                                printf("IPC = %f\n", ipc);
                        }
                }
                delete iFr_wait;
                delete iFr_ready;
                delete iWindow1;
                delete iWindow2;
                delete iWindow3;
                delete iWindow4;
                /*-----STAT-----*/
                totNumFrag = frIndx+1;
                /*-----STAT-----*/
        } else if (coreType == PHRASEBLOCK) {
                //long int phIndx = 0;
                //long int phIdealLat;
                //bool phStart = true;
                //int phSize;
                //cout << "addPhraseblock\n";
                addPhraseblock(_pbLists, cycle);
                while (true) {
                        cycle++;
                        //Free the busy ALU's
                        //cout << "freeALUs\n";
                        freeALUs(cycle);
                        //Complete executed phrases
                        //cout << "completePB\n";
                        completePB(cycle);
                        //Commit executed instructions
                        //cout << "commitPB\n";
                        if (commitPB(cycle) == -1 && cycle != 1 && eoc == true) {
      break;}
                        //Complete executed phrases
                        //cout << "completePB\n";
                        completePB(cycle);
                        //LSQ
                        //if (memoryModel == NAIVE_SPECUL) {
                        //      //Run LSQ
                        //      exeMemPipeStage(pbROB, cycle, loadStoreQue);
                        //      //SQ Access Cache for Write
                        //      runStoreQueue(loadStoreQue, cycle);
                        //      getLSQsize(loadStoreQue); /*STAT*/
                        //}
                        if (!perfectRegRen) getRRsize(GRF); /*STAT*/
                        //Add instructions to phrase
                        //cout << "addPhraseblock\n";
                        addPhraseblock (_pbLists, cycle);
                        if (eof) {eof=false; break;}
                        //Check resources status - goto nxt iter if all busy
                        //cout << "isALUfree\n";
                        if (!isALUfree()) continue;
                        //Run the core
                        //cout << "runPhraseblockCore\n";
                        runPhraseblockCore(cycle,_pbLists);
                        //Runtime Stat
                        if (cycle%300000==0) {
                                ipc = (float)(insCount)/(float)(cycle);
                                printf ("Cycle %ld\n", cycle);
                                printf("IPC = %f\n", ipc);
                                printf("Squash Cnt = %d\n", squashCount);
                                printf("EOF: %d EOC: %d\n", eof, eoc);
                        }
                }
                /*-----STAT-----*/
                //totNumPhrase = phIndx+1;
                /*-----STAT-----*/
        } else if (coreType == DOT) {
                printf("hey\n");
                dot *d = new dot(0);
                if (eoc == false) addIns(cycle);
                d->runDot(iWindow,0);
        }
        //core implementations
        else {
                if (debug) {
                        printf("CYCLE IN = %ld\n", cycle);
                        //long int cycle_in = cycle; //TODO cycle_in must be defi
      ned outside this scope
                }
                while (true) {
                        cycle++;
                        //Free the busy ALU's
                        freeALUs(cycle);
                        //Complete executed instructions
                        completeIns(cycle,iROB);
                        //Commit executed instructions
                        if (commitIns(cycle,iROB) == -1 && cycle != 1 && eoc == t
      rue) break;
                        //Complete executed instructions
                        completeIns(cycle,iROB);
                        //LSQ
                        if (memoryModel == NAIVE_SPECUL) {
                                //Run LSQ
                                exeMemPipeStage(iROB, cycle, loadStoreQue);
                                //SQ Access Cache for Write
                                runStoreQueue(loadStoreQue, cycle);
                                getLSQsize(loadStoreQue); /*STAT*/
                        }
                        if (!perfectRegRen && coreType != IN_ORDER) getRRsize(
      GRF); /*STAT*/
                        //Add instructions to iROB
                        if (eoc == false) addIns(cycle);
                        if (eof) {eof=false;break;}
                        //Check resources status - goto nxt iter if all busy
                        if (!isALUfree()) continue;
                        //Run the core
                        if (coreType == OUT_OF_ORDER) {
                                if (numFU == 1) {
                                        runOOOcoreSingleIssue(cycle);
                                } else if (numFU == 4) {
                                        runOOOcore2(cycle);
                                } else {
                                        runOOOcore(cycle);}
                        } else if (coreType == STRAND) {
                                runStrandcore(cycle);
                        } else if (coreType == IN_ORDER) {
                                if (numFU == 4)
                                        runInOcore2(cycle);
                                else
                                        runInOcore(cycle,iWindow);
                        } else if (coreType == X_LEVEL_DEEP_DYN) {
                                runxLDcore_DYN(cycle);
                        } else if (coreType == ONE_LEVE_DEEP_STAT) {
                                run1LD_STAT(cycle);
                        } else if (coreType == X_LEVE_DEEP_STAT) {
                                runxLD_STAT(cycle);
                        }else {
                                printf("ERROR: core name is not set correctly!\n"
      );
                                Assert(coreType >= IN_ORDER && coreType <= 
      X_LEVEL_DEEP_DYN);
                        }
                        //Runtime Stat
                        if (cycle%300000==0) {
                                ipc = (float)(insCount)/(float)(cycle);
                                printf ("Cycle %ld\n", cycle);
                                printf("IPC = %f\n", ipc);
                                printf("Squash Cnt = %d\n", squashCount);
                        }
                }
                //if (debug) printf("CYCLE OUT = %ld (diff = %ld)\n", cycle, cycl
      e-cycle_in);
                if (reportTraceAndHitMiss == true) {
                        printf("STORE Unpredictable Memory Accesses\n");
                        computeMissRates();
                        printMissRatetoFile();
                        fclose (pinFile);
                        //if((pinFile=fopen(inFileName.c_str(), "r")) == NULL) {
                        //      printf("ERROR: Cannot open file(s).\n");
                        //      exit(1);
                        //}
                        //eoc = false;
                        //if (evaltMissRtCorrel == 1) {
                        //      correlationHist = new hist(1001, 0, 1001);
                        //}
                        //while (true) {
                        //      if (eoc == false) addIns(cycle);
                        //      else break;
                        //      while (iWindow->NumElements() > 0) {iWindow->Remo
      veAt(0);}//Drain it to avoid core dump
                        //      while (iROB->NumElements() > 0) {
                        //              instruction *ins = iROB->Nth(0);
                        //              long int insAddr = ins->getInsAddr();
                        //              if (ins->getMemType() == READ &&
                        //                  memRdMissRateTable.count(insAddr) > 0
      ) {
                        //                      float missRate = memRdMissRateTab
      le.find(insAddr)->second;
                        //                      /*-----STAT-----*/
                        //                      if (missRate > unpredMemOpThresho
      ld) {unpredMemOpCnt++;}
                        //                      /*-----STAT-----*/
                        //                      //For measuring UPLD measurement 
      accuracy
                        //                      //if (missRate > unpredMemOpThres
      hold && ins->getMissrate() <= unpredMemOpThreshold)
                        //                      //      printf("1: %f - %f = %f\n
      ",ins->getMissrate(), missRate, ins->getMissrate()-missRate);
                        //                      //else if (missRate <= unpredMemO
      pThreshold && ins->getMissrate() > unpredMemOpThreshold)
                        //                      //      printf("2: %f - %f = %f\n
      ",ins->getMissrate(), missRate, ins->getMissrate()-missRate);

                        //                      if (evaltMissRtCorrel == 0) {
                        //                              ins->setMissRate(missRate
      );
                        //                      } else {
                        //                              float missRateDiff = miss
      Rate - ins->getMissrate();
                        //                              long int temp = (long int
      ) (missRate * 1000.0);
                        //                              if (temp < 0) temp *= -1;
       //take abs
                        //                              correlationHist->addElem(
      temp);
                        //                      }
                        //              } //miss rate is zero by default
                        //              if (evaltMissRtCorrel == 0) {
                        //                      createTraceAndHitMiss(0);
                        //              }
                        //              iROB->Nth(0)->notifyAllDepICompleted();
                        //              iROB->Nth(0)->delDepTableEntris(depTables
      , coreType);
                        //              delete iROB->Nth(0);
                        //              iROB->RemoveAt(0);
                        //      }
                        //}
                        //if (evaltMissRtCorrel == 1) {
                        //      correlationHist->report();
                        //}
                }
        }
        //Final IPC computation
        ipc = (float)(insCount)/(float)(cycle);
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a284d05841cccaebd1aa53c032d756d5a}{
\index{bkEnd.cpp@{bkEnd.cpp}!br\_\-skip\_\-accuracy@{br\_\-skip\_\-accuracy}}
\index{br\_\-skip\_\-accuracy@{br\_\-skip\_\-accuracy}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{br\_\-skip\_\-accuracy}]{\setlength{\rightskip}{0pt plus 5cm}string br\_\-skip\_\-accuracy (
\begin{DoxyParamCaption}
\item[{\char`\"{}br\_\-skip\_\-accuracy.csv\char`\"{}}]{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a284d05841cccaebd1aa53c032d756d5a}
\hypertarget{bkEnd_8cpp_a0734fb039a0e7c39dbb26942683ee2e6}{
\index{bkEnd.cpp@{bkEnd.cpp}!branchAccuracyFileName@{branchAccuracyFileName}}
\index{branchAccuracyFileName@{branchAccuracyFileName}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{branchAccuracyFileName}]{\setlength{\rightskip}{0pt plus 5cm}string branchAccuracyFileName (
\begin{DoxyParamCaption}
\item[{\char`\"{}/home/milad/esc\_\-project/svn/memTraceMilad/TraceSim/results/bzip2/predhistory.csv\char`\"{}}]{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a0734fb039a0e7c39dbb26942683ee2e6}
\hypertarget{bkEnd_8cpp_a9302c3259f5dfab8bec5c1b4f4e8f52f}{
\index{bkEnd.cpp@{bkEnd.cpp}!branchProfileFileName@{branchProfileFileName}}
\index{branchProfileFileName@{branchProfileFileName}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{branchProfileFileName}]{\setlength{\rightskip}{0pt plus 5cm}string branchProfileFileName (
\begin{DoxyParamCaption}
\item[{\char`\"{}/home/milad/esc\_\-project/svn/memTraceMilad/TraceSim/results/hmmer/branch\_\-exe\_\-count\_\-map.csv\char`\"{}}]{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a9302c3259f5dfab8bec5c1b4f4e8f52f}
\hypertarget{bkEnd_8cpp_a614e7cde759a7fb104ba2b7c53ac31d3}{
\index{bkEnd.cpp@{bkEnd.cpp}!checkAncestor@{checkAncestor}}
\index{checkAncestor@{checkAncestor}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{checkAncestor}]{\setlength{\rightskip}{0pt plus 5cm}bool checkAncestor (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins, }
\item[{int}]{bottom, }
\item[{int}]{top, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iWindow}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a614e7cde759a7fb104ba2b7c53ac31d3}

\begin{DoxyCode}
                                                                                 
            {
        if (ins->isGotoSideBuff() == true) return false;
        for (int i = 0; i < ins->getNumAncestors(); i++) {
                instruction* ancestor = ins->getNthAncestor(i);
                for (int j = bottom; j < top; j++) {
                        if (iWindow->Nth(j)->getType() == ins->getType() &&
                            iWindow->Nth(j)->isGotoSideBuff() == false &&
                            iWindow->Nth(j)->getInsID() == ancestor->getInsID()) 
      {
                                return false; //ins cannot be moved due to depend
      ency
                        }
                }
        }
        return true;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_ae0c892b61c0b3a005382554567c7eb51}{
\index{bkEnd.cpp@{bkEnd.cpp}!checkMemDependency@{checkMemDependency}}
\index{checkMemDependency@{checkMemDependency}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{checkMemDependency}]{\setlength{\rightskip}{0pt plus 5cm}bool checkMemDependency (
\begin{DoxyParamCaption}
\item[{int}]{indx}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_ae0c892b61c0b3a005382554567c7eb51}

\begin{DoxyCode}
                                   {
        if (iROB->Nth(indx)->getMemType() == READ) { //RAW Hazard Check (word lev
      el address check)
                for (int i = indx-1; i >= 0; i--) {
                        if (iROB->Nth(i)->getMemType() == WRITE && iROB->Nth(i)->
      getStatus() != complete) {
                                long int temp1 = iROB->Nth(i)->getMemAddr() >> 
      WORD_OFFSET;
                                long int temp2 = iROB->Nth(indx)->getMemAddr() >>
       WORD_OFFSET;
                                if (temp1 == temp2) {
                                        return true; //found true dependency (RAW
      )
                                }
                        }
                }
        } else if (iROB->Nth(indx)->getMemType() == WRITE) { //WAR Hazard Check (
      cache line level addr check)
                for (int i = indx-1; i >= 0; i--) {
                        if ((iROB->Nth(i))->getMemType() == WRITE && (iROB->Nth(i
      ))->getStatus() != complete) {
                                return true; //Memory store total ordering (WAW)
                        } else if (iROB->Nth(i)->getMemType() == READ && iROB->
      Nth(i)->getStatus() != complete) {
                                //WAR hazard check
                                long int temp1 = iROB->Nth(i)->getMemAddr()    >>
       (WORD_OFFSET+BLOCK_OFFSET);
                                long int temp2 = iROB->Nth(indx)->getMemAddr() >>
       (WORD_OFFSET+BLOCK_OFFSET);
                                if (temp1 == temp2) {
                                        return true; //found false dependency (WA
      R)
                                }
                        }
                }
        }
        return false;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_ad5f095c0a96cd9bf9981cb1851e09e56}{
\index{bkEnd.cpp@{bkEnd.cpp}!checkRegDependency@{checkRegDependency}}
\index{checkRegDependency@{checkRegDependency}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{checkRegDependency}]{\setlength{\rightskip}{0pt plus 5cm}bool checkRegDependency (
\begin{DoxyParamCaption}
\item[{int}]{indx}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_ad5f095c0a96cd9bf9981cb1851e09e56}

\begin{DoxyCode}
                                   {
        //for (int j = 0; j < iROB->Nth(indx)->getNumReg(); j++) {
        //      if (iROB->Nth(indx)->getMyRegType(j) == READ) {
        //              //TODO I am not sure about this condition below
        //              //if (RF->getRegStatus(iROB->Nth(indx)->getMyReg(j)) < iR
      OB->Nth(indx)->getInsID()) {
        //              int regStat = RF->getRegStat(iROB->Nth(indx)->getMyReg(j)
      );
        //              if (regStat != -1 && regStat < iROB->Nth(indx)->getInsID(
      )) {
        //                      //register is reserved for write
        //                      return true;
        //              }
        //      }
        //}
        for (int i = indx-1; i >= 0; i--) {
                if ((iROB->Nth(i))->getStatus() != complete) {
                        for (int j = 0; j < iROB->Nth(indx)->getNumReg(); j++) {
                                if (iROB->Nth(indx)->getMyRegType(j) == READ) {
                                        for (int ii = 0; ii < iROB->Nth(i)->
      getNumReg(); ii++) {
                                                if (iROB->Nth(i)->getMyReg(ii) ==
       iROB->Nth(indx)->getMyReg(j)) {
                                                        if (iROB->Nth(i)->
      getMyRegType(ii) == WRITE) {
                                                                return true; //fo
      und true dependency
                                                        }
                                                }
                                        }
                                } else if (coreType == IN_ORDER && iROB->Nth(indx
      )->getMyRegType(j) == WRITE) {
                                        for (int ii = 0; ii < iROB->Nth(i)->
      getNumReg(); ii++) {
                                                if (iROB->Nth(i)->getMyReg(ii) ==
       iROB->Nth(indx)->getMyReg(j)) {
                                                        return true; //found fals
      e dependency (in order superscalar only)
                                                }
                                        }
                                }
                        }
                }
        }
        return false;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a55d405fd16809cc233376112b4527f0b}{
\index{bkEnd.cpp@{bkEnd.cpp}!commitIns@{commitIns}}
\index{commitIns@{commitIns}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{commitIns}]{\setlength{\rightskip}{0pt plus 5cm}int commitIns (
\begin{DoxyParamCaption}
\item[{int}]{cycle, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iROB}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a55d405fd16809cc233376112b4527f0b}

\begin{DoxyCode}
                                                    {
        if (iROB->NumElements() > 0) {
                //printf("in commit %s, %d, %d\n",iROB->Nth(0)->getCmdStr(), iROB
      ->Nth(0)->getStatus(), iROB->Nth(0)->getCompleteCycle());
                while(iROB->NumElements() > 0) {
                        if ((iROB->Nth(0))->getStatus() == complete) {
                                //Report execution timing
                                //if (reportTrace == true) reportInsTiming(iROB->
      Nth(0));
                                //if (reportTraceAndHitMiss == true) createTraceA
      ndHitMiss(0); //TODO remove it... moved somewhere else in main.cpp
                                
                                /* Update BP */
                                if (branchMode == dynPredBr && iROB->Nth(0)->getT
      ype() == BR) {
                                        Update((uint64_t)iROB->Nth(0)->getInsAddr
      (), iROB->Nth(0)->getBrSide(), iROB->Nth(0));
                                }
                                if (perfectRegRen == false) {
                                        //Update register rename states
                                        iROB->Nth(0)->commitRegs(GRF);
                                }

                                /* Manage LSQ */ 
                                if (memoryModel == PERFECT) {
                                        ;//nothing to be done
                                } else if (memoryModel == TOTAL_ORDER) {
                                        if (iROB->Nth(0)->getMemType() == WRITE &
      & !loadStoreQue->isSQempty()) {
                                                instruction *sqHead = 
      loadStoreQue->getSQhead();
                                                if (sqHead->getInsID() == iROB->
      Nth(0)->getInsID()) {
                                                        loadStoreQue->popFrontSQ(
      );
                                                        //TODO this is NOT the pl
      ace to pop from SQ (fix it)
                                                }
                                        }
                                } else if (memoryModel == NAIVE_SPECUL) {
                                        if (iROB->Nth(0)->getMemType() == WRITE) 
      {
                                                oooLD_updateSQcommitSet(
      loadStoreQue, iROB->Nth(0));
                                                INS_ID LDinsID = 
      oooLD_findLQviolation(loadStoreQue, iROB->Nth(0));
                                                if (LDinsID != 0) {
                                                        //printf("SQUASH\n");
                                                        squashCount++;
                                                        //squash(iROB,LDinsID,loa
      dStoreQue);
                                                        isSquashed = true;
                                                        if (iROB->NumElements() =
      = 0) return 0;
                                                }
                                        } else if (iROB->Nth(0)->getMemType() == 
      READ) {
                                                oooLD_lqDequ (loadStoreQue, iROB-
      >Nth(0));
                                        }
                                }
                                /*-----STAT-----*/
                                if (!perfectRegRen) getRFstat(iROB->Nth(0));
                                insCount++; /*non-speculative ins conut */
                                insTypeCountStat(iROB->Nth(0));
                                /*-----STAT-----*/
                                /* Remove item */
                                delete iROB->Nth(0);
                                iROB->RemoveAt(0); //Commit
                                //if (debug) printf("completed something - Window
       Size = %d\n", iROB->NumElements());
                        } else {
                                break;
                        }
                }
                return 0;
        } else {
                //printf("The iROB is empty\n");
                return -1;
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a2fbac5556ee437e9fab920fdc6eecce2}{
\index{bkEnd.cpp@{bkEnd.cpp}!commitPB@{commitPB}}
\index{commitPB@{commitPB}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{commitPB}]{\setlength{\rightskip}{0pt plus 5cm}int commitPB (
\begin{DoxyParamCaption}
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a2fbac5556ee437e9fab920fdc6eecce2}

\begin{DoxyCode}
                        {
        if (pbROB->NumElements() > 0) {
                //printf("in commit %s, %d, %d\n",iROB->Nth(0)->getCmdStr(), iROB
      ->Nth(0)->getStatus(), iROB->Nth(0)->getCompleteCycle());
                int numPB = pbROB->NumElements();
                for (int j = 0; j < numPB; j++) {
                        basicblock* bb = pbROB->Nth(0);
                        if (bb->isBBcomplete()) {
                                int numIns = bb->getNumBBIns_o();
                                for (int k = 0; k < numIns; k++) {
                                        instruction* ins = bb->getNthBBIns_o(0);
                                        //Report execution timing
                                        //if (reportTrace == true) reportInsTimin
      g(iROB->Nth(0));
                                        //if (reportTraceAndHitMiss == true) crea
      teTraceAndHitMiss(0); //TODO remove it... moved somewhere else in main.cpp
                                        /* Update BP */
                                        if (branchMode == dynPredBr && ins->
      getType() == BR) {
                                                Update((uint64_t)ins->getInsAddr(
      ), ins->getBrSide(), ins);
                                        }
                                        if (perfectRegRen == false) {
                                                //Update register rename states
                                                ins->commitRegs(GRF);
                                        }

                                        /* Manage LSQ */ 
                                        if (memoryModel == PERFECT) {
                                                ;//nothing to be done
                                        //} else if (memoryModel == TOTAL_ORDER) 
      {
                                        //      if (ins->getMemType() == WRITE &&
       !loadStoreQue->isSQempty()) {
                                        //              instruction *sqHead = loa
      dStoreQue->getSQhead();
                                        //              if (sqHead->getInsID() ==
       ins->getInsID()) {
                                        //                      loadStoreQue->pop
      FrontSQ();
                                        //                      //TODO this is NO
      T the place to pop from SQ (fix it)
                                        //              }
                                        //      }
                                        //} else if (memoryModel == NAIVE_SPECUL)
       {
                                        //      if (ins->getMemType() == WRITE) {
      
                                        //              oooLD_updateSQcommitSet(l
      oadStoreQue, ins);
                                        //              INS_ID LDinsID = oooLD_fi
      ndLQviolation(loadStoreQue, ins);
                                        //              if (LDinsID != 0) {
                                        //                      //printf("SQUASH\
      n");
                                        //                      squashCount++;
                                        //                      //squash(iROB,LDi
      nsID,loadStoreQue);
                                        //                      isSquashed = true
      ;
                                        //                      if (pbROB->NumEle
      ments() == 0) return 0;
                                        //              }
                                        //      } else if (ins->getMemType() == R
      EAD) {
                                        //              oooLD_lqDequ (loadStoreQu
      e, ins);
                                        //      }
                                        }
                                        /*-----STAT-----*/
                                        if (!perfectRegRen) getRFstat(ins);
                                        insCount++; /*non-speculative ins conut *
      /
                                        //insTypeCountStat(ins); TODO put it back
       after fixing braanches - milad
                                        /*-----STAT-----*/
                                        //if (debug) printf("completed something 
      - Window Size = %d\n", pbROB->NumElements());
                                }
                                delete pbROB->Nth(0);
                                pbROB->RemoveAt(0);
                        } else {
                                break;
                        }
                }
                return 0;
        } else {
                printf("The pbROB is empty\n");
                return -1;
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a9a25aed4f2747b7f642111fd4ee5b9cf}{
\index{bkEnd.cpp@{bkEnd.cpp}!completeIns@{completeIns}}
\index{completeIns@{completeIns}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{completeIns}]{\setlength{\rightskip}{0pt plus 5cm}void completeIns (
\begin{DoxyParamCaption}
\item[{int}]{cycle, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iROB}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a9a25aed4f2747b7f642111fd4ee5b9cf}

\begin{DoxyCode}
                                                      {
        //printf("\n");
        for (int i = 0; i < iROB->NumElements(); i++) {
                //long int x = ((iROB->Nth(i))->getStatus() == execute ? iROB->Nt
      h(i)->getCompleteCycle() : -1);
                //printf("%llu, %llu, %d, %ld, %d (%s)\n", iROB->Nth(i)->getInsAd
      dr(), iROB->Nth(i)->getInsID(), iROB->Nth(i)->getStatus(), x, cycle, iROB->Nth(i)
      ->getCmdStr());
                if ((iROB->Nth(i))->getStatus() == execute && 
                    (iROB->Nth(i))->getCompleteCycle() <= cycle) {
                        //if (debug) printf("just commited something\n");
                        (iROB->Nth(i))->setStatus(complete, -1, -1);
                        //Update the load buffer
                        if (iROB->Nth(i)->getMemType() == READ) {
                                long int insAddr = iROB->Nth(i)->getMemAddr() >> 
      (BLOCK_OFFSET+WORD_OFFSET);
                                if (inFlightLDops.count(insAddr) > 0) {//Non-bloc
      king Load Op
                                        inFlightLDops.erase(insAddr);
                                }
                        }
                        //Release dependencies
                        /*-----STAT-----*/
                        //TODO put this back
                        //numChildrenHist->addElem(iROB->Nth(i)->_dependents->Num
      Elements());
                        completeInsCount++;
                        /*-----STAT-----*/
                        iROB->Nth(i)->notifyAllBrAncestorsICompleted();
                        iROB->Nth(i)->notifyAllDepICompleted();
                        iROB->Nth(i)->delDepTableEntris(depTables, coreType, 
      perfectRegRen);
                        if (coreType == PHRASEBLOCK && perfectRegRen == false) {
                                iROB->Nth(i)->completeRegs(GRF);
                                for (int k = 0; k < NUM_PHRASEBLKS; k++) {
                                        iROB->Nth(i)->delDepTableEntris_LRF(
      LRFTables[k], coreType, perfectRegRen);
                                }
                        } else if (coreType == OUT_OF_ORDER && perfectRegRen == f
      alse) {
                                iROB->Nth(i)->completeRegs(GRF);
                        } else if (coreType == FRAGMENT || coreType == FRAGMENT2)
       {
                                iROB->Nth(i)->notifyMyDepFragsICompleted();
                        }
                        //1LD support
                        //if (iROB->Nth(i)->isGotoSideBuff() == true && 
                        //    iROB->Nth(i)->getCauseOfSBinsID() == iROB->Nth(i)->
      getInsID()) { //TODO && oneLevelDeepEnable == true
                        //      numDepInOtherSBs += iROB->Nth(i)->notifyAllDepGet
      OutSideBuff(iROB->Nth(i)->getSideBuffNum(), iROB->Nth(i)->getInsID(),numSideBuffs
      );
                        //      /*-----STAT-----*/
                        //      int currentSBsize = iSideBuff[iROB->Nth(i)->getSi
      deBuffNum()]->NumElements();
                        //      SBsizeList->Append(currentSBsize);
                        //      Assert(currentSBsize >= 0);
                        //      if (maxSBsize < currentSBsize) maxSBsize = curren
      tSBsize;
                        //      if (minSBsize > currentSBsize) minSBsize = curren
      tSBsize;
                        //      totalSBsize += currentSBsize;
                        //      SBsize[iROB->Nth(i)->getSideBuffNum()] += iSideBu
      ff[iROB->Nth(i)->getSideBuffNum()]->NumElements();
                        //      /*-----STAT-----*/
                        //}
                }
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a968c90c4d8d2a7f34dcb172bfef57feb}{
\index{bkEnd.cpp@{bkEnd.cpp}!completePB@{completePB}}
\index{completePB@{completePB}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{completePB}]{\setlength{\rightskip}{0pt plus 5cm}void completePB (
\begin{DoxyParamCaption}
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a968c90c4d8d2a7f34dcb172bfef57feb}

\begin{DoxyCode}
                            {
        for (int j = 0; j < pbROB->NumElements(); j++) {
                basicblock* bb = pbROB->Nth(j);
                for (int i = 0; i < bb->getNumBBIns_o(); i++) {
                        instruction * ins = bb->getNthBBIns_o(i);
                        if (ins->getStatus() == execute && 
                            ins->getCompleteCycle() <= cycle) {
                                ins->setStatus(complete, -1, -1);
                                //Update the load buffer
                                if (ins->getMemType() == READ) {
                                        long int insAddr = ins->getMemAddr() >> (
      BLOCK_OFFSET+WORD_OFFSET);
                                        if (inFlightLDops.count(insAddr) > 0) {//
      Non-blocking Load Op
                                                inFlightLDops.erase(insAddr);
                                        }
                                }
                                //Release dependencies
                                /*-----STAT-----*/
                                completeInsCount++;
                                /*-----STAT-----*/
                                ins->notifyAllBrAncestorsICompleted();
                                ins->notifyAllDepICompleted();
                                ins->delDepTableEntris(depTables, coreType, 
      perfectRegRen);
                                if (coreType == PHRASEBLOCK && perfectRegRen == f
      alse) {
                                        ins->completeRegs(GRF);
                                        for (int k = 0; k < NUM_PHRASEBLKS; k++) 
      {
                                                ins->delDepTableEntris_LRF(
      LRFTables[k], coreType, perfectRegRen);
                                        }
                                } else if (coreType == OUT_OF_ORDER && 
      perfectRegRen == false) {
                                        ins->completeRegs(GRF);
                                } else if (coreType == FRAGMENT || coreType == 
      FRAGMENT2) {
                                        ins->notifyMyDepFragsICompleted();
                                }
                        }
                }
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a5ed10a88f4f69dd854e85cdedcb6bb32}{
\index{bkEnd.cpp@{bkEnd.cpp}!computeMissRates@{computeMissRates}}
\index{computeMissRates@{computeMissRates}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{computeMissRates}]{\setlength{\rightskip}{0pt plus 5cm}void computeMissRates (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a5ed10a88f4f69dd854e85cdedcb6bb32}

\begin{DoxyCode}
                        {
        int missCount, totalCount;
        float missRate;
        long int insAddr;
        map<long int,int>::iterator it;
        for (it=memRdTotCountTable.begin(); it != memRdTotCountTable.end(); it++)
       {
                insAddr    = (*it).first;
                totalCount = (*it).second;
                if (memRdMissCountTable.count(insAddr) > 0) {
                        missCount = memRdMissCountTable.find(insAddr)->second; 
                        missRate = (float)missCount/(float)totalCount;
                        memRdMissRateTable.insert(pair<long int, float>(insAddr,m
      issRate));
                        memRdMissCountTable.erase(insAddr);
                        /*-----STAT-----*/
                        if (missRate > unpredMemOpThreshold) 
                                unpredMemInsCnt++;
                        /*-----STAT-----*/
                }
        }
        //Assert(memRdTotCountTable.empty() == true);
        Assert(memRdMissCountTable.empty() == true);
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a1900d3c581025a2ef05801ce26dd51b3}{
\index{bkEnd.cpp@{bkEnd.cpp}!createStrand@{createStrand}}
\index{createStrand@{createStrand}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{createStrand}]{\setlength{\rightskip}{0pt plus 5cm}void createStrand (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins, }
\item[{int}]{indx, }
\item[{int}]{iWinIndx, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iWindow}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a1900d3c581025a2ef05801ce26dd51b3}

\begin{DoxyCode}
                                                                                 
              {
        bool foundIns = false;
        bool strand_formed = false;
        instruction *prevIns = ins;
        if (ins->getDependents()->NumElements() != 1)
                return;
        do {
                foundIns = false;
                prevIns = ins;
                ins = ins->getDependents()->Nth(0);
                if (!(ins->getDependents()->NumElements() == 1 && 
                      ins->getNumAncestors() == 1 && 
                          ins->getNthAncestor(0)->getInsID() == prevIns->
      getInsID()))// &&
                          //upldMissRateProfileMap.find(ins->getInsAddr()) ==  up
      ldMissRateProfileMap.end()))
                          //ins->getType() != MEM))
                        break;
                for (int i = iWinIndx; i < iWindow->NumElements(); i++) {
                        if (ins->getInsID() == iWindow->Nth(i)->getInsID()) {
                                foundIns = true;
                                break;
                        }
                }
                if (foundIns) {
                        //printf("YAAY %d, ", ins->getInsID());
                        ins->setStatus(chain,-1,-1);
                        iResStations[indx]->Append(ins);
                        strand_formed = true;
                        total_num_strand_ins++;
                } else {
                        break;
                }
        } while (1);
        if (strand_formed) /* strand has a min length of 2 */
                dyn_num_strands++;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a0bff6def00178cb9d06eff35aeebcb65}{
\index{bkEnd.cpp@{bkEnd.cpp}!createTraceAndHitMiss@{createTraceAndHitMiss}}
\index{createTraceAndHitMiss@{createTraceAndHitMiss}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{createTraceAndHitMiss}]{\setlength{\rightskip}{0pt plus 5cm}void createTraceAndHitMiss (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a0bff6def00178cb9d06eff35aeebcb65}

\begin{DoxyCode}
                                   {
        iROB->Nth(i)->printToFile(reScheduleFile, true);
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a71f0f1c12b63efb040d2ab4a920e02d5}{
\index{bkEnd.cpp@{bkEnd.cpp}!executeIns@{executeIns}}
\index{executeIns@{executeIns}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{executeIns}]{\setlength{\rightskip}{0pt plus 5cm}void executeIns (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{\_\-ins, }
\item[{int}]{\_\-cycle, }
\item[{int}]{\_\-latency}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a71f0f1c12b63efb040d2ab4a920e02d5}

\begin{DoxyCode}
                                                              {
        executeInsCount++; /* STAT */
        _ins->setStatus(execute, _cycle, _latency);
        if (reportTrace == true) reportInsTiming(_ins);
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a184a478d12000544a380c7aa50a9894d}{
\index{bkEnd.cpp@{bkEnd.cpp}!exeMemPipeStage@{exeMemPipeStage}}
\index{exeMemPipeStage@{exeMemPipeStage}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{exeMemPipeStage}]{\setlength{\rightskip}{0pt plus 5cm}void exeMemPipeStage (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iROB, }
\item[{int}]{cycle, }
\item[{{\bf lsq} $\ast$}]{loadStoreQue}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a184a478d12000544a380c7aa50a9894d}

\begin{DoxyCode}
                                                                             {
        isCacheBusFree = true;
        for (int i = 0; i < iROB->NumElements(); i++) {
                instruction* ins = iROB->Nth(i);
                if (ins->getMemType() == READ && 
                    ins->getStatus() == execute) {
                        if (ins->getMemAddrCompCompleteCycle() == cycle) {
                                //Assuming MSHR && SQ are looked up in parallel
                                long int insAddr = ins->getMemAddr() >> (
      BLOCK_OFFSET+WORD_OFFSET);
                                if (oooLD_insertLQ_addr(loadStoreQue,ins)) { //St
      ore FWD
                                        /*-----STAT-----*/
                                        stFwdMemOp++;
                                        /*-----STAT-----*/
                                        updateInsLatency(ins, cycle, 
      ADDR_COMPUTE_LATENCY+CAM_ACCESS_LATENCY); //Complete next cycle
                                } else if (inFlightLDops.find(insAddr)->second >=
       cycle) {//Non-blocking Load Op (MSHR)
                                        /*-----STAT-----*/
                                        nonBlockingMemOp++;
                                        /*-----STAT-----*/
                                        int tempLat = inFlightLDops.find(insAddr)
      ->second - cycle;
                                        updateInsLatency(ins, cycle, tempLat);
                                        getLatency(0,tempLat); //Generate hit lat
      ency stat
                                } else { //Cache Access (TODO can access cache mo
      re than once in a cycle (fix it)
                                        /*-----STAT-----*/
                                        cacheAccessMemOp++;
                                        /*-----STAT-----*/
                                        isCacheBusFree = false;
                                        int latency = findLatency(ins);
                                        updateInsLatency(ins, cycle, latency);
                                        int completeCycle = cycle+latency;
                                        insAddr = ins->getMemAddr() >> (
      BLOCK_OFFSET+WORD_OFFSET);
                                        inFlightLDops.insert(pair<long int,int>(i
      nsAddr,completeCycle));
                                }
                        }
                } else if (ins->getMemType() == WRITE &&
                                   ins->getStatus() == execute &&
                                   ins->getMemAddrCompCompleteCycle() == cycle) {
      
                        oooLD_insertSQ_addrNdata(loadStoreQue,ins);
                        updateInsLatency(ins, cycle, ADDR_COMPUTE_LATENCY+
      CAM_ACCESS_LATENCY); //Complete next cycle (this should be unnecessary)
                        //NOTE: do not access cache for WRITE here
                }
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_abcce050b02a52df68094f9fd386dc8e9}{
\index{bkEnd.cpp@{bkEnd.cpp}!findBestResStation@{findBestResStation}}
\index{findBestResStation@{findBestResStation}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{findBestResStation}]{\setlength{\rightskip}{0pt plus 5cm}int findBestResStation (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_abcce050b02a52df68094f9fd386dc8e9}

\begin{DoxyCode}
                         {
        int indx = 0, shortest_res_station = 10000;
        for (int i = 0; i < NUM_FUNC_UNIT; i++) {
                if (shortest_res_station > iResStations[i]->NumElements()) {
                        shortest_res_station = iResStations[i]->NumElements();
                        indx = i;
                }
        }
        return indx;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a425e040d7cdd063c48e543f19d61d29e}{
\index{bkEnd.cpp@{bkEnd.cpp}!findLatency@{findLatency}}
\index{findLatency@{findLatency}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{findLatency}]{\setlength{\rightskip}{0pt plus 5cm}int findLatency (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{\_\-ins}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a425e040d7cdd063c48e543f19d61d29e}

\begin{DoxyCode}
                                    {
        if (_ins->getType() == MEM) {
                int *lat = new int; //TODO stupid setup... get rid of lat
                int lat2;
                lat2 = cacheCtrl(_ins->getMemType(), _ins->getMemAddr(), 4, _L1, 
      _L2, _L3);
                if (reportTraceAndHitMiss == true &&
                    _ins->getMemType() == READ) {recordMemAccess(_ins,lat2);}
                //Cache Miss Transient Measurement (disabled by default)
                //if (lat2 > cacheLat[0]) fprintf(outFile, "%d,", _ins->getInsID(
      ));
                /*-----STAT-----*/
                if ((coreType == PHRASE || coreType == FRAGMENT || coreType == 
      FRAGMENT2) 
                    && lat2 > cacheLat[0]
                    && _ins->getMissrate() <= unpredMemOpThreshold) {
                        unexpectedMiss++;
                        unexpecteedLat+=lat2;
                        //printf("%d, %f\n", lat2,_ins->getMissrate());
                        //lat2 = cacheLat[0]; //TODO remove this - for single exp
      eriment purposes
                        //printf("WF: %d, FR: %d, lat: %d\n", _ins->getMyPhraseID
      (), _ins->getMyFragID(), lat2);
                }
                /*-----STAT-----*/
                delete lat;
                if (_ins->getMemType() == READ) {
                        _ins->setCacheHitLevel(lat2);
                        return lat2;
                } else {
                        _ins->setCacheHitLevel(ST_LATENCY);
                        return ST_LATENCY;
                }
        } else if (_ins->getType() == ALU) {
                return ALU_LATENCY;
        } else if (_ins->getType() == FPU) {
                return FPU_LATENCY;
        } else if (_ins->getType() == ASSIGN) {
                return ASSIGN_LATENCY;
        } else if (_ins->getType() == BR && branchMode == statPredBr) {
                if (_ins->getMissPrediction() == true) //Static branch prediction
      
                        return BR_LATENCY;
                else
                        return ALU_LATENCY;
        } else if (_ins->getType() == BR && branchMode == noBr) {//No branches
                        return ALU_LATENCY;
        } else if (_ins->getType() == BR && branchMode == dynPredBr) {
                        /* Set Br Latency */
                        if (_ins->getMissPrediction())
                                return ALU_LATENCY;
                        else
                                return BR_LATENCY; //From Zsim
        } else if (_ins->getType() == BR) {
                        return BR_LATENCY;
        } else {
                printf("Invalid Functional Unit Type!\nTerminating the program...
      \n");
                exit(-1);
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_ae9343acaa4bb2c5419f4f893d228d061}{
\index{bkEnd.cpp@{bkEnd.cpp}!findReadyFrag@{findReadyFrag}}
\index{findReadyFrag@{findReadyFrag}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{findReadyFrag}]{\setlength{\rightskip}{0pt plus 5cm}void findReadyFrag (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf fragment} $\ast$ $>$ $\ast$}]{iFr\_\-ready, }
\item[{{\bf List}$<$ {\bf fragment} $\ast$ $>$ $\ast$}]{iFr\_\-wait}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_ae9343acaa4bb2c5419f4f893d228d061}

\begin{DoxyCode}
                                                                          {
        List<int>* delInsList = new List<int>;
        for (int i = 0; i < iFr_wait->NumElements(); i++) {
                if (iFr_wait->Nth(i)->isReady() == true) {
                        iFr_ready->Append(iFr_wait->Nth(i));
                        delInsList->Append(i);
                }
        }
        for (int i = delInsList->NumElements()-1; i >= 0; i--) {
                //TODO confirm that delInsList is sorted
                iFr_wait->RemoveAt(delInsList->Nth(i));
        }
        delete delInsList;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_add7c033a8f7a85ceede7a13701545aa4}{
\index{bkEnd.cpp@{bkEnd.cpp}!freeALUs@{freeALUs}}
\index{freeALUs@{freeALUs}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{freeALUs}]{\setlength{\rightskip}{0pt plus 5cm}void freeALUs (
\begin{DoxyParamCaption}
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_add7c033a8f7a85ceede7a13701545aa4}

\begin{DoxyCode}
                          {
        for (int i = 0; i < NUM_FUNC_UNIT; i++) {
                if (aluAvail[i] == false) {
                        aluStat[i]++;
                }
                if (aluAvail[i] == false && aluFreeTime[i] <= cycle) {
                        aluAvail[i] = true; 
                        //aluFreeTime[i] = 0;
                }
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a2fce9656bfaf3c3b7160cf9a396c7297}{
\index{bkEnd.cpp@{bkEnd.cpp}!getAddr@{getAddr}}
\index{getAddr@{getAddr}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{getAddr}]{\setlength{\rightskip}{0pt plus 5cm}{\bf ADDRS} getAddr (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{c}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a2fce9656bfaf3c3b7160cf9a396c7297}

\begin{DoxyCode}
                       {
        int i = 0, start = 0, end = 0;
        char temp[INS_STRING_SIZE];

        //Parse a x86 resgiter name
        while (c[i]=='z') {i++;}
        if (c[i] == ',') {
                resetInput(c,i);
                i++;
                start = i;
                while (c[i] != ',' && c[i] != '\0' && c[i] != '\n') {
                        temp[i] = c[i];
                        resetInput(c,i);
                        if (debug) printf("temp[i] = %c\n", temp[i]);
                        i++;
                }
                //if (c[i] == '\n' || c[i] == '\0') return -3; //End of line (uns
      igned return)
                end = i;
        }
        int size = end - start;
        char * addr = new char[size+1];
        for (i=0; i < (end-start); i++) {
                addr[i] = temp[i+start];
                if (debug) printf("addr [i] = %c, size = %d\n", addr[i], size);
        }
        addr[size] = '\0';
        ADDRS result = 0;
        result = strtoull(addr, NULL, 10);
        if (debug) printf("addr = %s, result = %llu\n", addr, result);
        if (result == 0) {
                delete [] addr;
                return 0; //corrupt number
        }
        delete [] addr;
        return result;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a9589f904c9dbc95069671b28d883a4f7}{
\index{bkEnd.cpp@{bkEnd.cpp}!getANumber@{getANumber}}
\index{getANumber@{getANumber}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{getANumber}]{\setlength{\rightskip}{0pt plus 5cm}long int getANumber (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{c}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a9589f904c9dbc95069671b28d883a4f7}

\begin{DoxyCode}
                             {
        int i = 0, start = 0, end = 0;
        char temp[INS_STRING_SIZE];

        //Parse a x86 resgiter name
        while (c[i]=='z') {i++;}
        if (c[i] == ',' || c[i] == ' ') {
                resetInput(c,i);
                i++;
                start = i;
                while (c[i] != ',' && c[i] != '\0' && c[i] != '\n' && c[i] != ')'
      ) {
                        temp[i] = c[i];
                        resetInput(c,i);
                        if (debug) printf("temp[i] = %c\n", temp[i]);
                        i++;
                }
                //if (c[i] == '\n' || c[i] == '\0') return -3; //End of line (uns
      igned return)
                end = i;
        }
        int size = end - start;
        char * addr = new char[size+1];
        for (i=0; i < (end-start); i++) {
                addr[i] = temp[i+start];
                if (addr[i] < 48 || addr[i] > 57) {
                        delete [] addr;
                        return 0; //corrupt number
                }
                if (debug) printf("addr [i] = %c, size = %d\n", addr[i], size);
        }
        addr[size] = '\0';
        long int result = 0;
        for (i = size-1; i >= 0; i--) {
                long int tenPow = 1;
                for (int j = 0; j < size-1-i; j++) {
                        tenPow *= 10;}
                result += ((long int)addr[i]-48)*tenPow;
        }
        if (debug) printf("ins addr = %s, result = %ld\n", addr, result);
        //No negative or zero values allowed
        if (result <= 0) {
                delete [] addr;
                return 0; //corrupt number
        }
        delete [] addr;
        return result;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_ae6039b0814e906c7bd5d3c85dde971ac}{
\index{bkEnd.cpp@{bkEnd.cpp}!getLSQsize@{getLSQsize}}
\index{getLSQsize@{getLSQsize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{getLSQsize}]{\setlength{\rightskip}{0pt plus 5cm}void getLSQsize (
\begin{DoxyParamCaption}
\item[{{\bf lsq} $\ast$}]{loadStoreQue}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_ae6039b0814e906c7bd5d3c85dde971ac}

\begin{DoxyCode}
                                   {
        lqSize += loadStoreQue->getLQsize();
        sqSize += loadStoreQue->getSQsize();
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a50572d24f56e517753d0b24cc3f560c5}{
\index{bkEnd.cpp@{bkEnd.cpp}!getReg@{getReg}}
\index{getReg@{getReg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{getReg}]{\setlength{\rightskip}{0pt plus 5cm}long int getReg (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{c}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a50572d24f56e517753d0b24cc3f560c5}

\begin{DoxyCode}
                         {
        int i = 0, start = 0, end = 0;
        char temp[INS_STRING_SIZE];

        //Parse a x86 resgiter name
        while (c[i]=='z') {i++;}
        if (c[i] == ',') {
                resetInput(c,i);
                i++;
                start = i;
                while (c[i] != '#' && c[i] != '\0' && c[i] != '\n') {
                        temp[i] = c[i];
                        resetInput(c,i);
                        if (debug) printf("temp[i] = %c\n", temp[i]);
                        if (c[i] == ',') return -1; //corrupt ins
                        i++;
                }
                end = i;
                if (c[i] == '\n' || c[i] == '\0') return -3; //End of line
        }
        int size = end - start;
        char * reg = new char[size+1];
        for (i=0; i < size; i++) {
                reg[i] = temp[i+start];
                if (debug) printf("reg [i] = %c, size = %d", reg[i], size);
        }
        reg[size] = '\0';
        //for (i=0; i < (end-start); i++) {
        //      if (debug) printf("%c", reg[i], size);
        //}
        long int result = atoi(reg); //RF->getRegNum(reg); 
        delete [] reg;
        return result;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a8894d121130f17e7b86a4808184d7686}{
\index{bkEnd.cpp@{bkEnd.cpp}!getRegType@{getRegType}}
\index{getRegType@{getRegType}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{getRegType}]{\setlength{\rightskip}{0pt plus 5cm}int getRegType (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{c}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a8894d121130f17e7b86a4808184d7686}

\begin{DoxyCode}
                        {
        int i = 0, start = 0, end = 0;
        char temp[INS_STRING_SIZE];

        //Parse a x86 resgiter name
        while (c[i]=='z') {i++;}
        if (c[i] == '#') {
                resetInput(c,i);
                i++;
                start = i;
                while (c[i] != ',' && c[i] != '\0' && c[i] != '\n') {
                        temp[i] = c[i];
                        resetInput(c,i);
                        //if (debug) printf("temp[i] = %c\n", temp[i]);
                        i++;
                }
                if (c[i] == '\n' || c[i] == '\0') return -3; //End of line
                end = i;
        }
        int size = end - start;
        char * reg = new char[size+1];
        for (i=0; i < size; i++) {
                reg[i] = temp[i+start];
                if (debug) printf("reg [i] = %c, size = %d\n", reg[i], size);
        }
        reg[size] = '\0';
        int result = (int) strtol(reg, NULL, 10);
        //if (debug) printf("priority: %c,%c,%c\n", reg[0],reg[1],reg[2]);
        delete [] reg;
        return result;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a43ea6d39a044acd2c1dd61f1fe00b3f0}{
\index{bkEnd.cpp@{bkEnd.cpp}!getRFstat@{getRFstat}}
\index{getRFstat@{getRFstat}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{getRFstat}]{\setlength{\rightskip}{0pt plus 5cm}void getRFstat (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a43ea6d39a044acd2c1dd61f1fe00b3f0}

\begin{DoxyCode}
                                 {
        for (int i = 0; i < ins->getNumReg(); i++) {
                if (coreType == PHRASEBLOCK) {
                        if (ins->getNthReg(i) >= LARF_LO && ins->getNthReg(i) <= 
      LARF_HI) {
                                lrfCount++;
                                if (ins->getNthRegType(i) == WRITE) 
      lrfWrCountPerIns++;
                                else lrfRdCountPerIns++;
                        } else if (ins->getNthReg(i) >= GARF_LO && ins->
      getNthReg(i) <= GARF_HI) {
                                grfCount++;
                                if (ins->getNthRegType(i) == WRITE) 
      grfWrCountPerIns++;
                                else grfRdCountPerIns++;
                        } else {
                                Assert(true == false && "invalid register value")
      ;
                        }
                } else if (coreType == OUT_OF_ORDER) {
                        Assert (ins->getNthReg(i) >= LARF_LO && ins->getNthReg(i)
       <= GARF_HI);
                        grfCount++;
                        if (ins->getNthRegType(i) == WRITE) grfWrCountPerIns++;
                        else grfRdCountPerIns++;
                } else if (coreType == IN_ORDER) {
                        Assert (ins->getNthReg(i) >= LARF_LO && ins->getNthReg(i)
       <= GARF_HI);
                        lrfCount++;
                        if (ins->getNthRegType(i) == WRITE) lrfWrCountPerIns++;
                        else lrfRdCountPerIns++;
                } else {
                        Assert(true == false && "unsupported core type");
                }
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a6e0579d00974898848aa5cc8f63a325e}{
\index{bkEnd.cpp@{bkEnd.cpp}!getRRsize@{getRRsize}}
\index{getRRsize@{getRRsize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{getRRsize}]{\setlength{\rightskip}{0pt plus 5cm}void getRRsize (
\begin{DoxyParamCaption}
\item[{{\bf registerRename} $\ast$}]{GRF}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a6e0579d00974898848aa5cc8f63a325e}

\begin{DoxyCode}
                                    {
        //Assert(GRRF_SIZE <= GRF->getNumAvailablePR()); //TODO put this back?
        rrSize += (GRRF_SIZE - GRF->getNumAvailablePR());
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a3e5129a7cabbb869a82de1f82e856d57}{
\index{bkEnd.cpp@{bkEnd.cpp}!getSquashRFstat@{getSquashRFstat}}
\index{getSquashRFstat@{getSquashRFstat}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{getSquashRFstat}]{\setlength{\rightskip}{0pt plus 5cm}void getSquashRFstat (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a3e5129a7cabbb869a82de1f82e856d57}

\begin{DoxyCode}
                                       {
        //int lrfCountPerIns=0, grfCountPerIns=0;
        for (int i = 0; i < ins->getNumReg(); i++) {
                if (coreType == PHRASEBLOCK) {
                        if (ins->getNthReg(i) >= LARF_LO && ins->getNthReg(i) <= 
      LARF_HI) {
                                lrfCount++;
                                if (ins->getNthRegType(i) == WRITE) {
                                        num_squashed_lrf_wr_reg++;
                                        squashLRFcount++;
                                } else num_squashed_lrf_rd_reg++;
                        } else if (ins->getNthReg(i) >= GARF_LO && ins->
      getNthReg(i) <= GARF_HI) {
                                grfCount++;
                                if (ins->getNthRegType(i) == WRITE) {
                                        num_squashed_grf_wr_reg++;
                                        squashRegRenCount++;
                                } else num_squashed_grf_rd_reg++;
                        } else {
                                Assert(true == false && "invalid register value")
      ;
                        }
                } else if (coreType == OUT_OF_ORDER) {
                        Assert (ins->getNthReg(i) >= LARF_LO && ins->getNthReg(i)
       <= GARF_HI);
                        if (ins->getNthRegType(i) == WRITE) {
                                num_squashed_grf_wr_reg++;
                                squashRegRenCount++;
                        } else num_squashed_grf_rd_reg++;
                } else if (coreType == IN_ORDER) {
                        Assert (ins->getNthReg(i) >= LARF_LO && ins->getNthReg(i)
       <= GARF_HI);
                        if (ins->getNthRegType(i) == WRITE) {
                                num_squashed_lrf_wr_reg++;
                                squashLRFcount++;
                        } else num_squashed_lrf_rd_reg++;
                } else {
                        Assert(true == false && "unsupported core type");
                }
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a832dd92de97859679d2c78b8f8dc99e7}{
\index{bkEnd.cpp@{bkEnd.cpp}!getSquashRFstatForStatus@{getSquashRFstatForStatus}}
\index{getSquashRFstatForStatus@{getSquashRFstatForStatus}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{getSquashRFstatForStatus}]{\setlength{\rightskip}{0pt plus 5cm}void getSquashRFstatForStatus (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins, }
\item[{{\bf status}}]{st}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a832dd92de97859679d2c78b8f8dc99e7}

\begin{DoxyCode}
                                                           {
        if (coreType == PHRASEBLOCK) {
                for (int i = 0; i < ins->getNumReg(); i++) {
                        if (ins->getNthReg(i) >= LARF_LO && ins->getNthReg(i) <= 
      LARF_HI) {
                                switch(st) {
                                        case FETCH:
                                                if (ins->getNthRegType(i) == 
      WRITE) num_squashed_lrf_wr_fetch_reg++;
                                                else 
      num_squashed_lrf_rd_fetch_reg++;
                                                break;
                                        case ready:
                                                if (ins->getNthRegType(i) == 
      WRITE) num_squashed_lrf_wr_ready_reg++;
                                                else 
      num_squashed_lrf_rd_ready_reg++;
                                                break;
                                        case execute:
                                                if (ins->getNthRegType(i) == 
      WRITE) num_squashed_lrf_wr_execute_reg++;
                                                else 
      num_squashed_lrf_rd_execute_reg++;
                                                break;
                                        case complete:
                                                if (ins->getNthRegType(i) == 
      WRITE) num_squashed_lrf_wr_complete_reg++;
                                                else 
      num_squashed_lrf_rd_complete_reg++;
                                                break;
                                        default:
                                                Assert(true == false && "Ins Stat
      us Not Recognized");
                                }
                        } else if (ins->getNthReg(i) >= GARF_LO && ins->
      getNthReg(i) <= GARF_HI) {
                                switch(st) {
                                        case FETCH:
                                                if (ins->getNthRegType(i) == 
      WRITE) num_squashed_grf_wr_fetch_reg++;
                                                else 
      num_squashed_grf_rd_fetch_reg++;
                                                break;
                                        case ready:
                                                if (ins->getNthRegType(i) == 
      WRITE) num_squashed_grf_wr_ready_reg++;
                                                else 
      num_squashed_grf_rd_ready_reg++;
                                                break;
                                        case execute:
                                                if (ins->getNthRegType(i) == 
      WRITE) num_squashed_grf_wr_execute_reg++;
                                                else 
      num_squashed_grf_rd_execute_reg++;
                                                break;
                                        case complete:
                                                if (ins->getNthRegType(i) == 
      WRITE) num_squashed_grf_wr_complete_reg++;
                                                else 
      num_squashed_grf_rd_complete_reg++;
                                                break;
                                        default:
                                                Assert(true == false && "Ins Stat
      us Not Recognized");
                                }
                        } else {
                                Assert(true == false && "invalid register value")
      ;
                        }
                }
        } else if (coreType == OUT_OF_ORDER) {
                for (int i = 0; i < ins->getNumReg(); i++) {
                        switch(st) {
                                case FETCH:
                                        if (ins->getNthRegType(i) == WRITE) 
      num_squashed_grf_wr_fetch_reg++;
                                        else num_squashed_grf_rd_fetch_reg++;
                                        break;
                                case ready:
                                        if (ins->getNthRegType(i) == WRITE) 
      num_squashed_grf_wr_ready_reg++;
                                        else num_squashed_grf_rd_ready_reg++;
                                        break;
                                case execute:
                                        if (ins->getNthRegType(i) == WRITE) 
      num_squashed_grf_wr_execute_reg++;
                                        else num_squashed_grf_rd_execute_reg++;
                                        break;
                                case complete:
                                        if (ins->getNthRegType(i) == WRITE) 
      num_squashed_grf_wr_complete_reg++;
                                        else num_squashed_grf_rd_complete_reg++;
                                        break;
                                default:
                                        Assert(true == false && "Ins Status Not R
      ecognized");
                        }
                }
        } else if (coreType == IN_ORDER) {
                for (int i = 0; i < ins->getNumReg(); i++) {
                        switch(st) {
                                case FETCH:
                                        if (ins->getNthRegType(i) == WRITE) 
      num_squashed_lrf_wr_fetch_reg++;
                                        else num_squashed_lrf_rd_fetch_reg++;
                                        break;
                                case ready:
                                        if (ins->getNthRegType(i) == WRITE) 
      num_squashed_lrf_wr_ready_reg++;
                                        else num_squashed_lrf_rd_ready_reg++;
                                        break;
                                case execute:
                                        if (ins->getNthRegType(i) == WRITE) 
      num_squashed_lrf_wr_execute_reg++;
                                        else num_squashed_lrf_rd_execute_reg++;
                                        break;
                                case complete:
                                        if (ins->getNthRegType(i) == WRITE) 
      num_squashed_lrf_wr_complete_reg++;
                                        else num_squashed_lrf_rd_complete_reg++;
                                        break;
                                default:
                                        Assert(true == false && "Ins Status Not R
      ecognized");
                        }
                }
        } else {
                Assert(true == false && "unsupported core type");
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a4bdab479a34b2695251fda1824813fbc}{
\index{bkEnd.cpp@{bkEnd.cpp}!inFileName@{inFileName}}
\index{inFileName@{inFileName}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{inFileName}]{\setlength{\rightskip}{0pt plus 5cm}string inFileName (
\begin{DoxyParamCaption}
\item[{\char`\"{}../trace\_\-regOnly\_\-bzipSTM\_\-default.out\char`\"{}}]{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a4bdab479a34b2695251fda1824813fbc}
\hypertarget{bkEnd_8cpp_a5d6a55cf1d8b31005873f03a098bc5ed}{
\index{bkEnd.cpp@{bkEnd.cpp}!insTypeCountStat@{insTypeCountStat}}
\index{insTypeCountStat@{insTypeCountStat}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{insTypeCountStat}]{\setlength{\rightskip}{0pt plus 5cm}void insTypeCountStat (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a5d6a55cf1d8b31005873f03a098bc5ed}

\begin{DoxyCode}
                                        {
        type insType = ins->getType();
        switch (insType) {
                case MEM:
                        numMemOps++;
                        if (ins->getMemType() == READ) numReadOps++;
                        else if (ins->getMemType() == WRITE) numWriteOps++;
                        else Assert(true == false && "invalid memory type");
                        break;
                case ALU:
                        numALUOps++;
                        break;
                case FPU:
                        numFPUOps++;
                        break;
                case BR:
                        numBROps++;
                        if (ins->getPrediction() == true) numBrOps_predT++;
                        if (ins->getMissPrediction()==true) {
                                missPredBROps++;
                                if (ins->getPrediction() == false) 
      missPredBROps_NT++;
                        }
                        break;
                case ASSIGN:
                        numAssignOps++;
                        break;
                default:
                        Assert(true == false && "invalid instruction type");
        };
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_adccf4da88f361a0940e757c32241240e}{
\index{bkEnd.cpp@{bkEnd.cpp}!isALUfree@{isALUfree}}
\index{isALUfree@{isALUfree}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{isALUfree}]{\setlength{\rightskip}{0pt plus 5cm}bool isALUfree (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_adccf4da88f361a0940e757c32241240e}

\begin{DoxyCode}
                  {
        for (int i = 0; i < NUM_FUNC_UNIT; i++) {
                if (aluAvail[i]) {return true;}
        }
        return false; //No available ALU
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a956efe210acb292cfb8e75396ef62677}{
\index{bkEnd.cpp@{bkEnd.cpp}!isMisPrePredicted@{isMisPrePredicted}}
\index{isMisPrePredicted@{isMisPrePredicted}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{isMisPrePredicted}]{\setlength{\rightskip}{0pt plus 5cm}bool isMisPrePredicted (
\begin{DoxyParamCaption}
\item[{bool}]{bbPrediction, }
\item[{bool}]{taken}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a956efe210acb292cfb8e75396ef62677}

\begin{DoxyCode}
                                                      {
    if(bbPrediction != taken) {
                return true; //mis-prediction
    } else {
                return false; //correct-prediction
    }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a8787d06d2c8d571bee81ae5887237534}{
\index{bkEnd.cpp@{bkEnd.cpp}!isWinNotEmpty@{isWinNotEmpty}}
\index{isWinNotEmpty@{isWinNotEmpty}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{isWinNotEmpty}]{\setlength{\rightskip}{0pt plus 5cm}bool isWinNotEmpty (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a8787d06d2c8d571bee81ae5887237534}

\begin{DoxyCode}
                      {
        if (iROB->NumElements() > 0) return true;
        else return false;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a4cf2d67fd505b560c46cfc3386bdab9a}{
\index{bkEnd.cpp@{bkEnd.cpp}!outFileName1@{outFileName1}}
\index{outFileName1@{outFileName1}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{outFileName1}]{\setlength{\rightskip}{0pt plus 5cm}string outFileName1 (
\begin{DoxyParamCaption}
\item[{\char`\"{}timingTrace\_\-default\_\-outFile\_\-default.out\char`\"{}}]{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a4cf2d67fd505b560c46cfc3386bdab9a}
\hypertarget{bkEnd_8cpp_a263d48d5587cc05b4b3c9fe77bf86fe8}{
\index{bkEnd.cpp@{bkEnd.cpp}!phrasingFileName@{phrasingFileName}}
\index{phrasingFileName@{phrasingFileName}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{phrasingFileName}]{\setlength{\rightskip}{0pt plus 5cm}string phrasingFileName (
\begin{DoxyParamCaption}
\item[{\char`\"{}../trace\_\-regOnly\_\-bzipSTM\_\-phrased\_\-default.out\char`\"{}}]{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a263d48d5587cc05b4b3c9fe77bf86fe8}
\hypertarget{bkEnd_8cpp_ae394aec2b634fd76cd5c65bcd6ef019e}{
\index{bkEnd.cpp@{bkEnd.cpp}!popFromInsCache@{popFromInsCache}}
\index{popFromInsCache@{popFromInsCache}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{popFromInsCache}]{\setlength{\rightskip}{0pt plus 5cm}bool popFromInsCache (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_ae394aec2b634fd76cd5c65bcd6ef019e}

\begin{DoxyCode}
                       {
        if (ICQ->NumElements() == 0) return true;
        delete ICQ->Nth(0);
        ICQ->RemoveAt(0);
        return false;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a5184890a4947515e205215feed25fdd9}{
\index{bkEnd.cpp@{bkEnd.cpp}!Predict@{Predict}}
\index{Predict@{Predict}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{Predict}]{\setlength{\rightskip}{0pt plus 5cm}bool Predict (
\begin{DoxyParamCaption}
\item[{uint64\_\-t}]{\_\-\_\-pc, }
\item[{void $\ast$\&}]{bp\_\-hist}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a5184890a4947515e205215feed25fdd9}

\begin{DoxyCode}
                                            {
    uint64_t pc = __pc;
    return predictor->lookup(pc, bp_hist);
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a5627ce0f84690d974b96ebb091e67d6e}{
\index{bkEnd.cpp@{bkEnd.cpp}!PredictAndUpdate@{PredictAndUpdate}}
\index{PredictAndUpdate@{PredictAndUpdate}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{PredictAndUpdate}]{\setlength{\rightskip}{0pt plus 5cm}bool PredictAndUpdate (
\begin{DoxyParamCaption}
\item[{uint64\_\-t}]{\_\-\_\-pc, }
\item[{int}]{\_\-\_\-taken}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a5627ce0f84690d974b96ebb091e67d6e}

\begin{DoxyCode}
                                                  {
    bool taken = __taken;
    uint64_t pc = __pc;
    void *bp_hist = NULL;
    bool prediction = predictor->lookup(pc, bp_hist);
    //outfile << hex << "0x" << pc << ": ";
    if(prediction != taken) {
        //outfile << "wrong prediction\n";
                //if (brExeCount.find(pc) != brExeCount.end())  brExeCount[pc] +=
       1;
                //else                                                                                  b
      rExeCount[pc] = 1;
        predictor->update(pc, taken, bp_hist, true);
                return true; //mis-prediction
    } else {
        //outfile << "correct prediction\n";
                //if (correctPred.find(pc) != correctPred.end())        correctPr
      ed[pc] += 1;
                //else                                                                                  c
      orrectPred[pc] = 1;
                //if (brExeCount.find(pc) != brExeCount.end())  brExeCount[pc] +=
       1;
                //else                                                                                  b
      rExeCount[pc] = 1;
        predictor->update(pc, taken, bp_hist, false);
                return false; //correct-prediction
    }
        //return prediction;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a34cf3d53dd637753d853c59ec050c13a}{
\index{bkEnd.cpp@{bkEnd.cpp}!PrePredict@{PrePredict}}
\index{PrePredict@{PrePredict}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{PrePredict}]{\setlength{\rightskip}{0pt plus 5cm}bool PrePredict (
\begin{DoxyParamCaption}
\item[{uint64\_\-t}]{\_\-\_\-pc, }
\item[{void $\ast$\&}]{bp\_\-hist}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a34cf3d53dd637753d853c59ec050c13a}

\begin{DoxyCode}
                                               {
    uint64_t pc = __pc;
    bool pred = predictor->lookup(pc, bp_hist);
        return pred;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_ab08c8d5c859ade3a154bc445acc72565}{
\index{bkEnd.cpp@{bkEnd.cpp}!printMissRatetoFile@{printMissRatetoFile}}
\index{printMissRatetoFile@{printMissRatetoFile}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{printMissRatetoFile}]{\setlength{\rightskip}{0pt plus 5cm}void printMissRatetoFile (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_ab08c8d5c859ade3a154bc445acc72565}

\begin{DoxyCode}
                            {
        FILE* missRateFile;
        if((missRateFile=fopen("/home/milad/esc_project/svn/memTraceMilad/missRat
      e.txt", "w")) == NULL) {
            printf("5-ERROR: Cannot open file(s).\n");
            exit(1);
        }
        map<long int,float>::iterator it;
        for (it=memRdMissRateTable.begin(); it != memRdMissRateTable.end(); it++)
       {
                fprintf(missRateFile, "%ld, %f\n", it->first, it->second);
        }
        fclose(missRateFile);
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_aae29b315f876b102642b3eb99838a9fd}{
\index{bkEnd.cpp@{bkEnd.cpp}!printSTALL@{printSTALL}}
\index{printSTALL@{printSTALL}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{printSTALL}]{\setlength{\rightskip}{0pt plus 5cm}void printSTALL (
\begin{DoxyParamCaption}
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_aae29b315f876b102642b3eb99838a9fd}

\begin{DoxyCode}
                            {
        fprintf(outFile1, "%d\n", cycle);
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a9bec7fac736a429a859566bf1701fd5f}{
\index{bkEnd.cpp@{bkEnd.cpp}!recordMemAccess@{recordMemAccess}}
\index{recordMemAccess@{recordMemAccess}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{recordMemAccess}]{\setlength{\rightskip}{0pt plus 5cm}void recordMemAccess (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{\_\-ins, }
\item[{int}]{lat}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a9bec7fac736a429a859566bf1701fd5f}

\begin{DoxyCode}
                                                 {
        int totCount = 0;
        int missCount = 0;
        long int insAddr = _ins->getInsAddr();
        Assert(insAddr > 0);

        //Keep track of total number of accesses
        if (memRdTotCountTable.count(insAddr) > 0) {
                totCount = memRdTotCountTable.find(insAddr)->second;
                memRdTotCountTable.erase(insAddr);
        }
        totCount++;
        memRdTotCountTable.insert(pair<long int,int>(insAddr,totCount));


        //Keep track of total number of misses
        //If an ins never misses, it will not be in this list
        if (lat > cacheLat[0]) {
                if (memRdMissCountTable.count(insAddr) > 0) {
                        missCount = memRdMissCountTable.find(insAddr)->second;
                        memRdMissCountTable.erase(insAddr);
                        missCount++;
                        memRdMissCountTable.insert(pair<long int,int>(insAddr,mis
      sCount));
                } else {
                        missCount = 1;
                        memRdMissCountTable.insert(pair<long int,int>(insAddr,mis
      sCount));
                }
        }
        Assert(totCount > 0 && missCount >= 0);
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a81faf93556d4154fc76abed8d0f06cd5}{
\index{bkEnd.cpp@{bkEnd.cpp}!removeFrag@{removeFrag}}
\index{removeFrag@{removeFrag}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{removeFrag}]{\setlength{\rightskip}{0pt plus 5cm}void removeFrag (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf fragment} $\ast$ $>$ $\ast$}]{iFr, }
\item[{int}]{frIndx}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a81faf93556d4154fc76abed8d0f06cd5}

\begin{DoxyCode}
                                                  {
        delete iFr->Nth(frIndx);
        iFr->RemoveAt(frIndx);
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a865779257efd579c612bee7d113a4692}{
\index{bkEnd.cpp@{bkEnd.cpp}!removeFromiResStn@{removeFromiResStn}}
\index{removeFromiResStn@{removeFromiResStn}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{removeFromiResStn}]{\setlength{\rightskip}{0pt plus 5cm}void removeFromiResStn (
\begin{DoxyParamCaption}
\item[{{\bf INS\_\-ID}}]{insID}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a865779257efd579c612bee7d113a4692}

\begin{DoxyCode}
                                      {
        //printf("resStn size: %d\n",iResStation->NumElements());
        for (int i = iResStation->NumElements()-1; i >= 0; i--) {
                if (insID <= iResStation->Nth(i)->getInsID()) {
                        squashInsCount++;
                        iResStation->RemoveAt(i);
                }
        }
        for (int i = 0; i < NUM_FUNC_UNIT; i++) {
                for (int j = iResStations[i]->NumElements()-1; j >= 0; j--) {
                        if (insID <= iResStations[i]->Nth(j)->getInsID()) {
                                squashInsCount++;
                                iResStations[i]->RemoveAt(j);
                        }
                }
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a2cc88dd3e5bb835d2853b0692e286158}{
\index{bkEnd.cpp@{bkEnd.cpp}!removeFromiWindow@{removeFromiWindow}}
\index{removeFromiWindow@{removeFromiWindow}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{removeFromiWindow}]{\setlength{\rightskip}{0pt plus 5cm}void removeFromiWindow (
\begin{DoxyParamCaption}
\item[{{\bf INS\_\-ID}}]{insID}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a2cc88dd3e5bb835d2853b0692e286158}

\begin{DoxyCode}
                                      {
        //printf("wind size: %d\n",iWindow->NumElements());
        for (int i = iWindow->NumElements()-1; i >= 0; i--) {
                if (insID <= iWindow->Nth(i)->getInsID()) {
                        squashWinInsCount++;
                        iWindow->RemoveAt(i);
                }
        }
        if (coreType == PHRASEBLOCK) {
                for (int j = 0; j < NUM_PHRASEBLKS; j++) {
                        List<instruction*>* pbList = _pbLists[j];
                        for (int i = pbList->NumElements()-1; i >= 0; i--) { 
                                if (insID <= pbList->Nth(i)->getInsID()) {
                                        squashPhrInsCount++;
                                        pbList->RemoveAt(i);
                                }
                        }
                }
        }
        //printf("wind size: %d\n",iWindow->NumElements());
        //Assert(false == true && "Didn't find the instruction in iWindow");
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a30b10d56e06d16f688d896f71bb5ea58}{
\index{bkEnd.cpp@{bkEnd.cpp}!removeFromROB@{removeFromROB}}
\index{removeFromROB@{removeFromROB}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{removeFromROB}]{\setlength{\rightskip}{0pt plus 5cm}void removeFromROB (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iROB, }
\item[{{\bf INS\_\-ID}}]{insId}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a30b10d56e06d16f688d896f71bb5ea58}

\begin{DoxyCode}
                                                            {
        //printf("rob size: %d\n",iROB->NumElements());
        for (int i = iROB->NumElements()-1; i >= 0; i--) {
                squashInsCount++;
                if (coreType == PHRASEBLOCK) {
                        updateBBboundaries(iROB->Nth(i));
                } else {
                        char *c = new char[INS_STRING_SIZE];
                        strcpy(c, iROB->Nth(i)->getCmdStr());
                        ICQ->InsertAt(c,0);
                }
                if (insId == iROB->Nth(i)->getInsID()) {
                        //insID = iROB->Nth(i)->getInsID()-1; //update global ins
      ID
                        delete iROB->Nth(i);
                        iROB->RemoveAt(i);
                        return;
                }
                delete iROB->Nth(i);
                iROB->RemoveAt(i);
        }
        Assert(false == true && "Didn't find the instruction in ROB");
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_ad1dec997d8c5cff0b27c7b88ca4ab6e0}{
\index{bkEnd.cpp@{bkEnd.cpp}!removePhrase@{removePhrase}}
\index{removePhrase@{removePhrase}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{removePhrase}]{\setlength{\rightskip}{0pt plus 5cm}void removePhrase (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf phrase} $\ast$ $>$ $\ast$}]{iPh, }
\item[{int}]{phIndx}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_ad1dec997d8c5cff0b27c7b88ca4ab6e0}

\begin{DoxyCode}
                                                  {
        //printf("%d\n", iPh->Nth(phIndx)->getPhraseID());
        delete iPh->Nth(phIndx);
        iPh->RemoveAt(phIndx);
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a28571fa314c00095dc96822adb0dd144}{
\index{bkEnd.cpp@{bkEnd.cpp}!reportInsTiming@{reportInsTiming}}
\index{reportInsTiming@{reportInsTiming}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{reportInsTiming}]{\setlength{\rightskip}{0pt plus 5cm}void reportInsTiming (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a28571fa314c00095dc96822adb0dd144}

\begin{DoxyCode}
                                        {
        /*for fragment scheduling*/
        if (coreType == PHRASE || coreType == FRAGMENT || coreType == FRAGMENT2) 
      {
                static int phID = -1;
                if (ins->getMyPhraseID() > phID) {
                        phID = ins->getMyPhraseID();
                        fprintf(outFile1, "------------------------------------PH
      RASE: %d\n", phID);
                }
                static int frID = -1;
                if (ins->getMyFragID() != frID) {
                        frID = ins->getMyFragID();
                        fprintf(outFile1, "----------------FR: %d\n", frID);
                }
                if (ins->getMissrate() > unpredMemOpThreshold) {
                        fprintf(outFile1, "UPLD,  ");
                } else if (ins->getCacheHitLevel() > 1) {
                        fprintf(outFile1, "UNEXP, ");
                }
                fprintf(outFile1, "%ld, %ld, %d,(%d, %d)\t\t%lld(%s)", 
                        //cycle,
                        ins->getExecuteCycle(),
                        ins->getCompleteCycle(),
                        ins->getLatency(),
                        //ins->getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET),
                        //ins->getMemAddr(),
                        ins->getMyPhraseID(), //only for FRAGMENT & PHRASE
                        ins->getMyFragID(),   //only for FRAGMENT & PHRASE
                        ins->getInsID(),
                        ins->getCmdStr());
        }
        /*-----------------------*/
        else {
                fprintf(outFile1, "%ld, %ld,(%d, %d)\t\t%lld(%s)", 
                        //cycle,
                        ins->getExecuteCycle(),
                        ins->getCompleteCycle(),
                        ins->getLatency(),
                        //ins->getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET),
                        //ins->getMemAddr(),
                        ins->getMyFragID(),   //only for FRAGMENT & PHRASE
                        ins->getInsID(),
                        ins->getCmdStr());

        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a8a7960f44b590e5ca0e8cc8273f64dd4}{
\index{bkEnd.cpp@{bkEnd.cpp}!reScheduleFileName@{reScheduleFileName}}
\index{reScheduleFileName@{reScheduleFileName}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{reScheduleFileName}]{\setlength{\rightskip}{0pt plus 5cm}string reScheduleFileName (
\begin{DoxyParamCaption}
\item[{\char`\"{}../trace\_\-regOnly\_\-bzipSTM\_\-rescheduled\_\-default.out\char`\"{}}]{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a8a7960f44b590e5ca0e8cc8273f64dd4}
\hypertarget{bkEnd_8cpp_abec3fc00feaa7527678f9768c30c3fe1}{
\index{bkEnd.cpp@{bkEnd.cpp}!resetInput@{resetInput}}
\index{resetInput@{resetInput}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{resetInput}]{\setlength{\rightskip}{0pt plus 5cm}void resetInput (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{c, }
\item[{int}]{i}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_abec3fc00feaa7527678f9768c30c3fe1}

\begin{DoxyCode}
                                 {
        //this letter is never used in trace
        c[i] = 'z';
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a97c39e40275c8b88452f484247c641e6}{
\index{bkEnd.cpp@{bkEnd.cpp}!run1LD\_\-STAT@{run1LD\_\-STAT}}
\index{run1LD\_\-STAT@{run1LD\_\-STAT}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{run1LD\_\-STAT}]{\setlength{\rightskip}{0pt plus 5cm}void run1LD\_\-STAT (
\begin{DoxyParamCaption}
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a97c39e40275c8b88452f484247c641e6}

\begin{DoxyCode}
                            {
        Assert (ROB_SIZE >= 300);
        //Overwrite num side buffs to be 1 always
        numSideBuffs = 1;
        int iWinWalkIndx = -1;
        int *iSideBfWalkIndx = new int [numSideBuffs];
        iSideBfWalkIndx[0]=-1;

        //bool aSBdraining = false;
        /*-----STAT-----*/
        for (int i = 0; i < numSideBuffs; i++) {
                if (iSideBuff[i]->isFree()==true) SBoffCycles[i]++;
        }
        for (int i = 0; i < numSideBuffs; i++) {
                if (iSideBuff[i]->isFree()==false) {
                        if (mainStreamInsCount >= mainStreamBound) {
                                //aSBdraining = true;
                                break;
                        } else {
                                SBactiveCycles[i]++;
                                totSBactiveCycles++;
                        }
                }
        }
        /*-----STAT-----*/

        //Clear the iWindow & other queues
        if (iSideBuff[0]->isFree() == false && mainStreamInsCount >= 
      mainStreamBound) {//Drain SB
                Assert(mainStreamBound != -1);
                if (mainStreamInsCount == mainStreamBound) numOnSideBuffs--;
                if (iSideBuff[0]->NumElements() > 0) {
                        for (int i = 0; i < iSideBuff[0]->NumElements(); i++) {
                                if (iSideBuff[0]->Nth(i)->isReady(cycle) == true)
       {
                                        //TODO how many dependencies instructions
       
                                        //have at this point? 1 hopefully?
                                        iSideBuff[0]->Nth(i)->setStatus(
      sideReady,-1,-1);
                                        iResStation->Append(iSideBuff[0]->Nth(i))
      ;
                                        iSideBfWalkIndx[0] = i;
                                } else {
                                        break; //in-order side buff
                                }
                        }
                } else {
                        iSideBuff[0]->setFree();
                        mainStreamInsCount = 0;
                        mainStreamBound = -1;
                }
        } else {
                for (int i = 0; i < iWindow->NumElements(); i++) {
                        //Transfer to Reservation Station
                        if (iWindow->Nth(i)->isReady(cycle) == true) {
                                iWindow->Nth(i)->setStatus(ready,-1,-1);
                                iResStation->Append(iWindow->Nth(i));
                                iWinWalkIndx = i;
                        } else {
                                break; //in-order issue dependency
                        }
                }
        }

        /*-----STAT-----*/
        if (numOnSideBuffs == 0) {totSBoffCycles++;}
        /*-----STAT-----*/
        //Updaate the lists
        if (iWinWalkIndx >=0 ) {
                for (int i = iWinWalkIndx; i >= 0; i--) {
                        Assert(iWindow->Nth(i)->getStatus() != sideBuffer);
                        if (iWindow->Nth(i)->getStatus() == ready)
                                iWindow->RemoveAt(i);
                }
        }
        if (iSideBfWalkIndx[0] >= 0) {
               for (int i = iSideBfWalkIndx[0]; i >= 0; i--) {
                        if (iSideBuff[0]->Nth(i)->getStatus() == sideReady)
                                iSideBuff[0]->RemoveAt(i);
               }
        }

        /*-----STAT-----*/
        if (iResStation->NumElements() == 0) {emptyResStation++;}
        //else {
                //printf("cycle/SB_status/msic/msb/sb %d, %d, %d, %d, %d, %d| ",c
      ycle,iSideBuff[0]->isFree(),mainStreamInsCount,mainStreamBound, iSideBuff[0]->Num
      Elements(),iWindow->Nth(0)->_guardian);
                //printf("%d,%d,%ld(%s),|%d,%d,%ld (%s)|", iWindow->Nth(0)->_ance
      stors->Nth(0)->getInsID(),
                //                                       iWindow->Nth(0)->_ancest
      ors->Nth(0)->getStatus(),
                //                                       iWindow->Nth(0)->_ancest
      ors->Nth(0)->getMemAddr(),
                //                                       iWindow->Nth(0)->_ancest
      ors->Nth(0)->getCmdStr(),
                //                                       iWindow->Nth(0)->getInsI
      D(),
                //                                       iWindow->Nth(0)->getStat
      us(),
                //                                       iWindow->Nth(0)->getMemA
      ddr(),
                //                                       iWindow->Nth(0)->getCmdS
      tr());
                //if (iSideBuff[0]->NumElements()>0) printf("%d\n",iSideBuff[0]->
      Nth(0)->getInsID());
                //else printf("\n");
        //}
        iSideBufSize  += iSideBuff[0]->NumElements();
        iWinSize      += iWindow->NumElements();
        iROBSize      += iROB->NumElements();
        iResStnSize   += iResStation->NumElements();
        Assert(iSideBuff[0]->NumElements() >= 0 && 
               iWindow->NumElements()      >= 0 &&
               iROB->NumElements()         >= 0 &&
               iResStation->NumElements()  >= 0);
        /*-----STAT-----*/

        //Check resource availability & execute ins
        while (iResStation->NumElements() > 0) {
               int prevInsCount = insCount;
               for (int i = 0; i < NUM_FUNC_UNIT; i++) {
                        if (aluAvail[i]==true) {
                                if (aluKind[i] == MEM && iResStation->Nth(0)->
      getType() == MEM) {
                                        //Implementing two MEM issue per cycle (t
      wo mem units)
                                        aluAvail[i] = false;
                                        instruction* ins = iResStation->Nth(0);
                                        if (ins->getMemType() == READ) {
                                                long int insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                int latency = 0;
                                                int completeCycle = 0;
                                                //Non-blocking Load Op
                                                if (inFlightLDops.count(insAddr) 
      > 0) {
                                                        latency = inFlightLDops.f
      ind(insAddr)->second - cycle;
                                                        executeIns(ins, cycle, la
      tency);
                                                        if (iSideBuff[0]->isFree(
      ) == false) mainStreamInsCount++;
                                                        getLatency(0,latency); //
      Gen hit latency stat
                                                        completeCycle = cycle+lat
      ency;
                                                } else {
                                                        latency = findLatency(ins
      );
                                                        executeIns(ins, cycle, la
      tency);
                                                        if (iSideBuff[0]->isFree(
      ) == false) mainStreamInsCount++;
                                                        completeCycle = cycle+lat
      ency;
                                                        insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                        inFlightLDops.insert(pair
      <long int,int>(insAddr,completeCycle));
                                                }
                                                //1 Level Deep Staic Cnotingent S
      cheduling Activation
                                                Assert (latency > 0 && completeCy
      cle > 0);
                                                if (latency > xLevDeepLatLevel) {
      
                                                        for (int sb = 0; sb < 
      numSideBuffs; sb++) {
                                                                if (iSideBuff[sb]
      ->isFree() == true) {
                                                                        
      iSideBuff[sb]->setBusy();
                                                                        
      numOnSideBuffs++;
                                                                        ins->
      notifyAllDepGoToSideBuff(sb,ins->getInsID(),numSideBuffs);
                                                                        iWinWalkI
      ndx = -1;
                                                                        //Collect
       Dependent Ins into SB
                                                                        int i = 0
      ;
                                                                        //for (i 
      = 0; i < iWindow->NumElements() && iSideBuff[sb]->NumElements() < SBlength; i++) 
      {
                                                                        //      i
      f (iWindow->Nth(i)->isGotoSideBuff() == true) {
                                                                        //              i
      Window->Nth(i)->setStatus(sideBuffer,-1,-1);
                                                                        //              i
      SideBuff[sb]->Append(iWindow->Nth(i));
                                                                        //              S
      Blist->Append(i);
                                                                        //              i
      WinWalkIndx = i;
                                                                        //      }
      
                                                                        //}

                                                                        /* This i
      s just an experiement */
                                                                        int diff 
      = -1;
                                                                        for (i = 
      0; i < iWindow->NumElements() && diff < SBlength; i++) {
                                                                                i
      f (iWindow->Nth(i)->isGotoSideBuff() == true) {
                                                                                        
      iWindow->Nth(i)->setStatus(sideBuffer,-1,-1);
                                                                                        
      iSideBuff[sb]->Append(iWindow->Nth(i));
                                                                                        
      SBlist->Append(i);
                                                                                        i
      WinWalkIndx = i;
                                                                                }
      
                                                                                d
      iff = (iWinWalkIndx + 1) + (iResStation->NumElements() - 1) - iSideBuff[sb]->NumE
      lements();
                                                                                
      Assert(diff >= 0);
                                                                        }
                                                                        /* This i
      s just an experiement */

                                                                        /*-----ST
      AT-----*/
                                                                        if (i >= 
      iWindow->NumElements() && iSideBuff[sb]->NumElements() < SBlength) { //TODO this 
      stat is broken
                                                                                
      windowSatration++; //TODO make it an array
                                                                        }
                                                                        /*-----ST
      AT-----*/
                                                                        Assert ((
      iWinWalkIndx == -1 && iSideBuff[sb]->NumElements() == 0) || iWinWalkIndx != -1);
                                                                        if (
      iSideBuff[sb]->NumElements() == 0) 
                                                                                
      mainStreamBound = 0;
                                                                        else
                                                                                
      mainStreamBound = (iWinWalkIndx + 1) + (iResStation->NumElements() - 1) - 
      iSideBuff[sb]->NumElements();
                                                                        //Update 
      iWindow
                                                                        if (iWinW
      alkIndx >= 0) {scheduleInsInFlight(SBlist, delList, iWindow, iWinWalkIndx, cycle)
      ;}

                                                                        //Fill up
       the SB
                                                                        Assert(sb
       >= 0 && sb < numSideBuffs);
                                                                        /*-----ST
      AT-----*/
                                                                        
      totNumSBactivations++;
                                                                        
      numSBactivations[sb]++;
                                                                        if (iWinW
      alkIndx >= 0) {
                                                                                
      totFrameSize   += (iWinWalkIndx + 1) + (iResStation->NumElements() - 1);
                                                                                
      totMainStreamBound += mainStreamBound;
                                                                        }
                                                                        /*-----ST
      AT-----*/
                                                                        break;
                                                                } else { //TODO s
      hould this be inside the for loop or ouside?
                                                                        /*-----ST
      AT-----*/
                                                                        
      longLatOpWhenSPisON++;
                                                                        if (
      mainStreamInsCount >= mainStreamBound)
                                                                                
      longLatOpWhenSPisDraining++;
                                                                        else
                                                                                
      longLatOpWhenSPisWaiting++;
                                                                        /*-----ST
      AT-----*/
                                                                }
                                                        }
                                                }
                                        } else if (ins->getMemType() == WRITE) {
                                                int latency = findLatency(ins);
                                                executeIns(ins, cycle, latency);
                                                if (iSideBuff[0]->isFree() == fal
      se) mainStreamInsCount++;
                                        } else {
                                                Assert(ins->getMemType() == 
      WRITE || ins->getMemType() == READ);
                                        }
                                        aluFreeTime[i] = cycle+1;//non-blocking L
      D/ST
                                        iResStation->RemoveAt(0);
                                        /*-----STAT-----*/
                                        //for (int i = 0; i < numSideBuffs; i++) 
      {
                                        if (iSideBuff[0]->isFree()==false) { // &
      & iSideBuff[i]->getExpiration() > cycle) {
                                                InsCountWhenSBon[0]++;
                                                totInsCountWhenSBon++;
                                        }
                                        //}
                                        /*-----STAT-----*/
                                        break;
                                } else if (aluKind[i] == ALU && 
                                           (iResStation->Nth(0)->getType() == 
      ALU ||
                                            iResStation->Nth(0)->getType() == 
      FPU)) {
                                        aluAvail[i] = false;
                                        instruction* ins = iResStation->Nth(0);
                                        int latency = findLatency(ins);
                                        executeIns(ins, cycle, latency);
                                        if (iSideBuff[0]->isFree() == false) 
      mainStreamInsCount++;
                                        aluFreeTime[i] = cycle+latency;
                                        iResStation->RemoveAt(0);
                                        /*-----STAT-----*/
                                        //for (int i = 0; i < numSideBuffs; i++) 
      {
                                        if (iSideBuff[0]->isFree()==false) { // &
      & iSideBuff[i]->getExpiration() > cycle) {
                                                InsCountWhenSBon[0]++;
                                                totInsCountWhenSBon++;
                                        }
                                        //}
                                        /*-----STAT-----*/
                                        break;
                                }
                        }
               }
               if (insCount-prevInsCount == 0) {break;} //in-order issue struct h
      azard
        }
        /*-----STAT-----*/
        inFlightLDopsSize += inFlightLDops.size();
        /*-----STAT-----*/
        delete [] iSideBfWalkIndx;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_ace2244168da67b24c25de5eeb8e324e7}{
\index{bkEnd.cpp@{bkEnd.cpp}!runDueLaneInOcore@{runDueLaneInOcore}}
\index{runDueLaneInOcore@{runDueLaneInOcore}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{runDueLaneInOcore}]{\setlength{\rightskip}{0pt plus 5cm}void runDueLaneInOcore (
\begin{DoxyParamCaption}
\item[{int}]{cycle, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iWindow1, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iWindow2, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iWindow3, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iWindow4, }
\item[{int}]{arbitrate}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_ace2244168da67b24c25de5eeb8e324e7}

\begin{DoxyCode}
                                                                                 
                                                                                       
             {
        int aluBound = NUM_FUNC_UNIT;
        //Cosntruct the ready list
        if (arbitrate == 1) {
                updateResStn(iResStation, iWindow1);
        } else if (arbitrate == 2) {
                updateResStn(iResStation, iWindow2);
        } else if (arbitrate == 3) {
                updateResStn(iResStation, iWindow3);
        } else if (arbitrate == 4) {
                updateResStn(iResStation, iWindow4);
        } else {
                Assert (arbitrate == 1 || arbitrate ==2 || arbitrate ==3 || arbit
      rate == 4);
        }
        /*-----STAT-----*/
        iWinSize      += iWindow1->NumElements()+iWindow2->NumElements()+iWindow3
      ->NumElements()+iWindow4->NumElements();
        iROBSize      += iROB->NumElements();
        iResStnSize   += iResStation->NumElements();
        /*-----STAT-----*/
        //Check resource availability & execute ins
        if (iResStation->NumElements() == 0) {
                if (arbitrate == 1) {
                        updateResStn(iResStation, iWindow2);
                        updateResStn(iResStation, iWindow3);
                        updateResStn(iResStation, iWindow4);
                } else if (arbitrate == 2) {
                        updateResStn(iResStation, iWindow1);
                        updateResStn(iResStation, iWindow3);
                        updateResStn(iResStation, iWindow4);
                } else if (arbitrate == 3) {
                        updateResStn(iResStation, iWindow1);
                        updateResStn(iResStation, iWindow2);
                        updateResStn(iResStation, iWindow4);
                } else if (arbitrate == 4) {
                        updateResStn(iResStation, iWindow1);
                        updateResStn(iResStation, iWindow2);
                        updateResStn(iResStation, iWindow3);
                } else {
                        Assert (arbitrate == 1 || arbitrate ==2 || arbitrate ==3 
      || arbitrate == 4);
                }
        }
        //if (iResStation->NumElements() == 0) {
        //      printf("(%d,%d,%d)", iWindow1->NumElements(),
        //                             iWindow2->NumElements(),
        //                             iWindow3->NumElements());
        //      emptyResStation++;
        //}
        //Choose the number of functional units
        if (numFU == 1) {aluBound = 1;}
        else            {aluBound = NUM_FUNC_UNIT;}
        while (iResStation->NumElements() > 0) {
                int prevInsCount = insCount;
                for (int i = 0; i < aluBound; i++) {
                        if (aluAvail[i]==true) {
                                //printf("size of iResStation = %d\n", iResStatio
      n->NumElements());
                                if ((numFU == 1 || aluKind[i] == MEM) && 
                                    iResStation->Nth(0)->getType() == MEM) {
                                        aluAvail[i] = false;
                                        instruction* ins = iResStation->Nth(0);
                                        if (ins->getMemType() == READ) {
                                                long int insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                if (inFlightLDops.count(insAddr) 
      > 0) {//Non-blocking Load Op
                                                        /*-----STAT-----*/
                                                        nonBlockingMemOp++;
                                                        /*-----STAT-----*/
                                                        int tempLat = 
      inFlightLDops.find(insAddr)->second - cycle;
                                                        executeIns(ins, cycle, te
      mpLat);
                                                        //printf("%s, ",ins->getC
      mdStr());
                                                        //Generate hit latency st
      at
                                                        ins->setCacheHitLevel(
      getLatency(0,tempLat));
                                                } else {
                                                        int latency = 
      findLatency(ins);
                                                        executeIns(ins, cycle, la
      tency);
                                                        //printf("%s, ",ins->getC
      mdStr());
                                                        int completeCycle = 
      cycle+latency;
                                                        insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                        inFlightLDops.insert(pair
      <long int,int>(insAddr,completeCycle));
                                                }
                                        } else if (ins->getMemType() == WRITE) {
                                                int latency = findLatency(ins);
                                                executeIns(ins, cycle, latency);
                                                        //printf("%s, ",ins->getC
      mdStr());
                                        } else {
                                                Assert(ins->getMemType() == 
      WRITE || ins->getMemType() == READ);
                                        }
                                        aluFreeTime[i] = cycle+1;//non-blocking L
      D/ST
                                        iResStation->RemoveAt(0);
                                        break;
                                } else if ((numFU == 1 || aluKind[i] == ALU) && 
                                           (iResStation->Nth(0)->getType() == 
      ALU ||
                                            iResStation->Nth(0)->getType() == 
      FPU)) {
                                        aluAvail[i] = false;
                                        instruction* ins = iResStation->Nth(0);
                                        int latency = findLatency(ins);
                                        executeIns(ins, cycle, latency);
                                        //printf("%s, ",ins->getCmdStr());
                                        aluFreeTime[i] = cycle+latency;
                                        iResStation->RemoveAt(0);
                                        break;
                                }
                        }
                }
                if (insCount-prevInsCount == 0) break; //in-order issue struct ha
      zard
        }
        //printf("\n");
        /*-----STAT-----*/
        inFlightLDopsSize += inFlightLDops.size();
        /*-----STAT-----*/
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a08f23b53db9ac916db6ee3b82c8a80a9}{
\index{bkEnd.cpp@{bkEnd.cpp}!runInOcore@{runInOcore}}
\index{runInOcore@{runInOcore}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{runInOcore}]{\setlength{\rightskip}{0pt plus 5cm}void runInOcore (
\begin{DoxyParamCaption}
\item[{int}]{cycle, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iWindow}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a08f23b53db9ac916db6ee3b82c8a80a9}

\begin{DoxyCode}
                                                        {
        //long int localRunningFragNumber;
        //Cosntruct the ready list
        int iWinWalkIndx = -1;
        int aluBound = NUM_FUNC_UNIT;
        for (int i = 0; i < iWindow->NumElements(); i++) {
                if (iWindow->Nth(i)->isReady(cycle) == true) {
                        iWindow->Nth(i)->setStatus(ready,-1,-1);
                        iResStation->Append(iWindow->Nth(i));
                        iWinWalkIndx = i;
                } else {
                        //printf("ins %s not ready\n", iWindow->Nth(i)->getCmdStr
      ());
                        break; //in-order issue dependency
                }
        }
        //Updaate the fetch list
        for (int i = iWinWalkIndx; i >= 0; i--) {
                if (iWindow->Nth(i)->getStatus() == ready)
                        iWindow->RemoveAt(i);
        }
        /*-----STAT-----*/
        iWinSize      += iWindow->NumElements();
        iROBSize      += iROB->NumElements();
        iResStnSize   += iResStation->NumElements();
        /*-----STAT-----*/
        //Check resource availability & execute ins
        //static int inter=0; static int intera=0;
        if (iResStation->NumElements() == 0) {
                emptyResStation++;
                //if (localRunningFragNumber == runningFragNumber) {
                //      inter++;
                //      printf("Inter-fragment Stall %d\n", inter);
                //} else {
                //      intera++;
                //      //printf("Intera-fragment Stall %d\n", intera);
                //}
        }
        //localRunningFragNumber = runningFragNumber;
        //Choose the number of functional units
        if (numFU == 1) {aluBound = 1;}
        else            {aluBound = NUM_FUNC_UNIT;}
        while (iResStation->NumElements() > 0) {
                int prevInsCount = insCount;
                for (int i = 0; i < aluBound; i++) {
                        if (aluAvail[i]==true) {
                                //printf("size of iResStation = %d\n", iResStatio
      n->NumElements());
                                if ((numFU == 1 || aluKind[i] == MEM) && 
                                    iResStation->Nth(0)->getType() == MEM) {
                                        aluAvail[i] = false;
                                        instruction* ins = iResStation->Nth(0);
                                        if (ins->getMemType() == READ) {
                                                long int insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                if (inFlightLDops.count(insAddr) 
      > 0) {//Non-blocking Load Op
                                                        /*-----STAT-----*/
                                                        nonBlockingMemOp++;
                                                        /*-----STAT-----*/
                                                        int tempLat = 
      inFlightLDops.find(insAddr)->second - cycle;
                                                        executeIns(ins, cycle, te
      mpLat);
                                                        //printf("%s, ",ins->getC
      mdStr());
                                                        //Generate hit latency st
      at
                                                        ins->setCacheHitLevel(
      getLatency(0,tempLat));
                                                } else {
                                                        int latency = 
      findLatency(ins);
                                                        executeIns(ins, cycle, la
      tency);
                                                        //printf("%s, ",ins->getC
      mdStr());
                                                        int completeCycle = 
      cycle+latency;
                                                        insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                        inFlightLDops.insert(pair
      <long int,int>(insAddr,completeCycle));
                                                }
                                        } else if (ins->getMemType() == WRITE) {
                                                int latency = findLatency(ins);
                                                executeIns(ins, cycle, latency);
                                                        //printf("%s, ",ins->getC
      mdStr());
                                        } else {
                                                Assert(ins->getMemType() == 
      WRITE || ins->getMemType() == READ);
                                        }
                                        aluFreeTime[i] = cycle+1;//non-blocking L
      D/ST
                                        iResStation->RemoveAt(0);
                                        break;
                                } else if ((numFU == 1 || aluKind[i] == ALU) && 
                                           (iResStation->Nth(0)->getType() == 
      ALU ||
                                            iResStation->Nth(0)->getType() == BR 
       ||
                                            iResStation->Nth(0)->getType() == 
      ASSIGN ||
                                            iResStation->Nth(0)->getType() == 
      FPU)) {
                                        aluAvail[i] = false;
                                        instruction* ins = iResStation->Nth(0);
                                        int latency = findLatency(ins);
                                        executeIns(ins, cycle, latency);
                                        //printf("%s, ",ins->getCmdStr());
                                        aluFreeTime[i] = cycle+latency;
                                        iResStation->RemoveAt(0);
                                        break;
                                }
                        }
                }
                if (insCount-prevInsCount == 0) {
                        break; //in-order issue struct hazard
                }
        }
        if (reportTrace == true) printSTALL (cycle);
        //printf("\n");
        /*-----STAT-----*/
        inFlightLDopsSize += inFlightLDops.size();
        /*-----STAT-----*/
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_ac12de6e25fc3f32a278fbc174b77bcf8}{
\index{bkEnd.cpp@{bkEnd.cpp}!runInOcore2@{runInOcore2}}
\index{runInOcore2@{runInOcore2}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{runInOcore2}]{\setlength{\rightskip}{0pt plus 5cm}void runInOcore2 (
\begin{DoxyParamCaption}
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_ac12de6e25fc3f32a278fbc174b77bcf8}

\begin{DoxyCode}
                            {
        //Cosntruct the ready list
        //int iWinWalkIndx = -1;
        //int wbb_bypass_count = 0, br_bypass_count = 0;
        //float wbb_chain_accuracy = 1.0, br_chain_accuracy = 1.0;
        set<long int> list_of_wbb;
        for (int i = 0; i < iWindow->NumElements(); i++) {
                /*-----STAT-----*/
                //if (iWindow->Nth(i)->getType() == BR
                //    && iWindow->Nth(i)->isReady(cycle) == false
                //      && iWindow->Nth(i)->getBrBias() >= 0.05 
                //      && iWindow->Nth(i)->getBrBias() <= 0.95) {
                //      list_of_wbb.insert(iWindow->Nth(i)->getInsAddr());
                //      wbb_bypass_count++;
                //      wbb_chain_accuracy *= iWindow->Nth(i)->getBrAccuracy();
                //}
                //if (iWindow->Nth(i)->getType() == BR) {
                //      br_bypass_count++;
                //      br_chain_accuracy *= iWindow->Nth(i)->getBrAccuracy();
                //}
                /*-----STAT-----*/
                if (iWindow->Nth(i)->isReady(cycle) == true) {
                        /*-----STAT-----*/
                        //if (iWindow->Nth(i)->getInsAddr() == 4248075) { //hmmer
      
                        //      fprintf(junk,"\n\n");
                        //      collect_stat = true;
                        //} else if ((iWindow->Nth(i)->getInsAddr() == 4248005 &&
       
                        //                      i+1 < iWindow->NumElements() &&
                        //            iWindow->Nth(i+1)->getInsAddr() != 4248075)
      ||
                        //           iWindow->Nth(i)->getInsAddr() == 4248071) { 
      //hmmer
                        //      collect_stat = false;
                        //}
                        //if (collect_stat == true) {
                        //      fprintf(junk,"%ld, ", iWindow->Nth(i)->getInsAddr
      ());
                        //}
                        //if (num_ins_exe_cnt.find(iWindow->Nth(i)->getInsAddr())
       != num_ins_exe_cnt.end())
                        //      num_ins_exe_cnt[iWindow->Nth(i)->getInsAddr()] +=
       1;
                        //else
                        //      num_ins_exe_cnt[iWindow->Nth(i)->getInsAddr()] = 
      1;
                        //if (num_bypassed_wbb.find(iWindow->Nth(i)->getInsAddr()
      ) != num_bypassed_wbb.end())
                        //      //num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()]
       += list_of_wbb.size(); //static ins
                        //      num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()] +
      = wbb_bypass_count; //dynamic ins
                        //else
                        //      //num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()]
       = list_of_wbb.size(); //static ins
                        //      num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()] =
       wbb_bypass_count; //dynamic ins
                        //if (ins_exe_hoist_accuracy.find(iWindow->Nth(i)->getIns
      Addr()) != ins_exe_hoist_accuracy.end())
                        //      ins_exe_hoist_accuracy[iWindow->Nth(i)->getInsAdd
      r()] += br_chain_accuracy;
                        //else
                        //      ins_exe_hoist_accuracy[iWindow->Nth(i)->getInsAdd
      r()] = br_chain_accuracy;
                        /*-----STAT-----*/
                        iWindow->Nth(i)->setStatus(ready,-1,-1);
                        int indx = findBestResStation();
                        iResStations[indx]->Append(iWindow->Nth(i));
                        //iWinWalkIndx= i;
                } else {
                        break; //in-order issue dependency
                }
        }
        //quicksortInsList(iResStation,0,iResStation->NumElements()-1);
        //quicksortInsList(iMemBuf,0,iMemBuf->NumElements()-1);
        //printf("size of iROB        = %d\n", iROB->NumElements());
        //printf("size of iWindow     = %d\n", iWindow->NumElements());
        //printf("size of iResStation = %d\n", iResStation->NumElements());
        //printf("size of iMemBuf     = %d\n", iMemBuf->NumElements());
        //Updaate the fetch list
        for (int i = iWindow->NumElements()-1; i >= 0; i--) {
                if (iWindow->Nth(i)->getStatus() == ready)
                        iWindow->RemoveAt(i);
        }
        /*-----STAT-----*/
        iWinSize      += iWindow->NumElements();
        iROBSize      += iROB->NumElements();
        for (int i = 0; i < NUM_FUNC_UNIT; i++)
                iResStnsSize[i] += iResStations[i]->NumElements();
        /*-----STAT-----*/
        //Check resource availability & execute ins
        for (int j = 0; j < NUM_FUNC_UNIT; j++) {
                if (aluAvail[j]==true) {
                        if (iResStations[j]->NumElements() > 0 &&
                            iResStations[j]->Nth(0)->getStatus() == ready) {
                                aluAvail[j] = false;
                                instruction* ins = iResStations[j]->Nth(0);
                                if (ins->getType() == MEM && ins->getMemType() ==
       READ) {
                                        if (memoryModel == NAIVE_SPECUL) {
                                                        executeIns(ins, cycle, 
      LONG_LATENCY);
                                        } else {
                                                long int insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                if (inFlightLDops.count(insAddr) 
      > 0) {//Non-blocking Load Op
                                                        int tempLat = 
      inFlightLDops.find(insAddr)->second - cycle;
                                                        executeIns(ins, cycle, te
      mpLat);
                                                        getLatency(0,tempLat); //
      Generate hit latency stat
                                                } else {
                                                        int latency = 
      findLatency(ins);
                                                        executeIns(ins, cycle, la
      tency);
                                                        int completeCycle = 
      cycle+latency;
                                                        insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                        inFlightLDops.insert(pair
      <long int,int>(insAddr,completeCycle));
                                                }
                                        }
                                        aluFreeTime[j] = cycle+1;//non-blocking L
      D/ST
                                } else if (ins->getType() == MEM && ins->
      getMemType() == WRITE) {
                                        if (memoryModel == NAIVE_SPECUL) {
                                                executeIns(ins, cycle, 
      ST_LATENCY);
                                        } else {
                                                int latency = findLatency(ins);
                                                executeIns(ins, cycle, latency);
                                        }
                                        aluFreeTime[j] = cycle+1;//non-blocking L
      D/ST
                                } else if (ins->getType() == ALU || 
                                                   ins->getType() == BR  || 
                                                   ins->getType() == ASSIGN || 
                                                   ins->getType() == FPU) {
                                        int latency = findLatency(ins);
                                        executeIns(ins, cycle, latency);
                                        aluFreeTime[j] = cycle+latency;
                                } else {
                                        Assert(ins->getType() == MEM || ins->
      getType() == ALU ||
                                               ins->getType() == BR  || ins->
      getType() == FPU ||
                                               ins->getType() == BR  || ins->
      getType() == FPU);
                                }
                                iResStations[j]->RemoveAt(0);
                        }
                }
        }
        /*-----STAT-----*/
        inFlightLDopsSize += inFlightLDops.size();
        /*-----STAT-----*/
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a0048e706dd30cad67418041c870d1850}{
\index{bkEnd.cpp@{bkEnd.cpp}!runOOOcore@{runOOOcore}}
\index{runOOOcore@{runOOOcore}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{runOOOcore}]{\setlength{\rightskip}{0pt plus 5cm}void runOOOcore (
\begin{DoxyParamCaption}
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a0048e706dd30cad67418041c870d1850}

\begin{DoxyCode}
                           {
        //Cosntruct the ready list
        int iWinWalkIndx = -1;
        int wbb_bypass_count = 0, br_bypass_count = 0;
        float wbb_chain_accuracy = 1.0, br_chain_accuracy = 1.0;
        set<long int> list_of_wbb;
        int scheduled_mem = 0, scheduled_alu = 0;
        for (int i = 0; i < iWindow->NumElements(); i++) {
                /*-----STAT-----*/
                if (iWindow->Nth(i)->getType() == BR
                    && iWindow->Nth(i)->isReady(cycle) == false
                        && iWindow->Nth(i)->getBrBias() >= 0.05 
                        && iWindow->Nth(i)->getBrBias() <= 0.95) {
                        list_of_wbb.insert(iWindow->Nth(i)->getInsAddr());
                        wbb_bypass_count++;
                        wbb_chain_accuracy *= iWindow->Nth(i)->getBrAccuracy();
                }
                if (iWindow->Nth(i)->getType() == BR) {
                        br_bypass_count++;
                        br_chain_accuracy *= iWindow->Nth(i)->getBrAccuracy();
                }
                /*-----STAT-----*/
                if (iWindow->Nth(i)->isReady(cycle) == true) {
                        /*-----STAT-----*/
                        //if (iWindow->Nth(i)->getInsAddr() == 4214686) { //bzip
                        if (iWindow->Nth(i)->getInsAddr() == 4248075) { //hmmer
                                fprintf(junk,"\n\n");
                                collect_stat = true;
                        //} else if (iWindow->Nth(i)->getInsAddr() == 4214340 ||
                        //           iWindow->Nth(i)->getInsAddr() == 4214683) { 
      //bzip2
                        } else if ((iWindow->Nth(i)->getInsAddr() == 4248005 && 
                                                i+1 < iWindow->NumElements() &&
                                    iWindow->Nth(i+1)->getInsAddr() != 4248075)||
      
                                   iWindow->Nth(i)->getInsAddr() == 4248071) { //
      hmmer
                                collect_stat = false;
                        }
                        if (collect_stat == true) {
                                fprintf(junk,"%llu, ", iWindow->Nth(i)->
      getInsAddr());
                        }
                        if (num_ins_exe_cnt.find(iWindow->Nth(i)->getInsAddr()) !
      = num_ins_exe_cnt.end())
                                num_ins_exe_cnt[iWindow->Nth(i)->getInsAddr()] +=
       1;
                        else
                                num_ins_exe_cnt[iWindow->Nth(i)->getInsAddr()] = 
      1;
                        if (num_bypassed_wbb.find(iWindow->Nth(i)->getInsAddr()) 
      != num_bypassed_wbb.end())
                                //num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()]
       += list_of_wbb.size(); //static ins
                                num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()] +
      = wbb_bypass_count; //dynamic ins
                        else
                                //num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()]
       = list_of_wbb.size(); //static ins
                                num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()] =
       wbb_bypass_count; //dynamic ins
                        if (ins_exe_hoist_accuracy.find(iWindow->Nth(i)->
      getInsAddr()) != ins_exe_hoist_accuracy.end())
                                ins_exe_hoist_accuracy[iWindow->Nth(i)->
      getInsAddr()] += br_chain_accuracy;
                        else
                                ins_exe_hoist_accuracy[iWindow->Nth(i)->
      getInsAddr()] = br_chain_accuracy;
                        /*-----STAT-----*/
                        iWindow->Nth(i)->setStatus(ready,-1,-1);
                        if      (iWindow->Nth(i)->getType() == ALU ||
                                 iWindow->Nth(i)->getType() == FPU ||
                                 iWindow->Nth(i)->getType() == BR) {
                                iResStation->Append(iWindow->Nth(i));
                                scheduled_alu++;
                        } else if  (iWindow->Nth(i)->getType() == MEM) {
                                iMemBuf->Append(iWindow->Nth(i));
                                scheduled_mem++;
                        } else {
                                Assert (iWindow->Nth(i)->getType() == MEM || 
                                        iWindow->Nth(i)->getType() == BR  ||
                                        iWindow->Nth(i)->getType() == ALU ||
                                        iWindow->Nth(i)->getType() == FPU);
                        }
                        iWinWalkIndx = i;
                        //Dont's go too far down the IQ if enough ready instructi
      ons are found (HW constraint modeling)
                        if (scheduled_alu >= NUM_ALU_UNIT && 
                            scheduled_mem >= NUM_MEM_UNIT)
                                break;
                }
        }
        quicksortInsList(iResStation,0,iResStation->NumElements()-1);
        quicksortInsList(iMemBuf,0,iMemBuf->NumElements()-1);
        //printf("size of iROB        = %d\n", iROB->NumElements());
        //printf("size of iWindow     = %d\n", iWindow->NumElements());
        //printf("size of iResStation = %d\n", iResStation->NumElements());
        //printf("size of iMemBuf     = %d\n", iMemBuf->NumElements());
        //Updaate the fetch list
        for (int i = iWinWalkIndx; i >= 0; i--) {
                if (iWindow->Nth(i)->getStatus() == ready)
                        iWindow->RemoveAt(i);
        }
        /*-----STAT-----*/
        iWinSize      += iWindow->NumElements();
        iROBSize      += iROB->NumElements();
        iResStnSize   += iResStation->NumElements();
        iMemBuffSize  += iMemBuf->NumElements();
        /*-----STAT-----*/
        //Check resource availability & execute ins
        for (int j = 0; j < NUM_FUNC_UNIT; j++) {
                if (aluAvail[j]==true) {
                        if (aluKind[j] == MEM && iMemBuf->NumElements() > 0) {
                                aluAvail[j] = false;
                                instruction* ins = iMemBuf->Nth(0);
                                if (ins->getMemType() == READ) {
                                        long int insAddr = ins->getMemAddr() >> (
      BLOCK_OFFSET+WORD_OFFSET);
                                        if (inFlightLDops.count(insAddr) > 0) {//
      Non-blocking Load Op
                                                int tempLat = inFlightLDops.find(
      insAddr)->second - cycle;
                                                executeIns(ins, cycle, tempLat);
                                                getLatency(0,tempLat); //Generate
       hit latency stat
                                        } else {
                                                int latency = findLatency(ins);
                                                executeIns(ins, cycle, latency);
                                                int completeCycle = cycle+latency
      ;
                                                insAddr = ins->getMemAddr() >> (
      BLOCK_OFFSET+WORD_OFFSET);
                                                inFlightLDops.insert(pair<long in
      t,int>(insAddr,completeCycle));
                                        }
                                } else if (ins->getMemType() == WRITE) {
                                        int latency = findLatency(ins);
                                        executeIns(ins, cycle, latency);
                                } else {
                                        Assert(ins->getMemType() == WRITE || ins-
      >getMemType() == READ);
                                }
                                aluFreeTime[j] = cycle+1;//non-blocking LD/ST
                                iMemBuf->RemoveAt(0);
                        } else if (aluKind[j] == ALU && iResStation->NumElements(
      ) > 0) {
                                aluAvail[j] = false;
                                instruction* ins = iResStation->Nth(0);
                                int latency = findLatency(ins);
                                executeIns(ins, cycle, latency);
                                aluFreeTime[j] = cycle+latency;
                                iResStation->RemoveAt(0);
                        }
                }
        }
        /*-----STAT-----*/
        inFlightLDopsSize += inFlightLDops.size();
        /*-----STAT-----*/
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a1e86a57f718ccc5c785cb2f69e4eb150}{
\index{bkEnd.cpp@{bkEnd.cpp}!runOOOcore2@{runOOOcore2}}
\index{runOOOcore2@{runOOOcore2}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{runOOOcore2}]{\setlength{\rightskip}{0pt plus 5cm}void runOOOcore2 (
\begin{DoxyParamCaption}
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a1e86a57f718ccc5c785cb2f69e4eb150}

\begin{DoxyCode}
                            {
        //Cosntruct the ready list
        //int iWinWalkIndx = -1;
        //int wbb_bypass_count = 0, br_bypass_count = 0;
        //float wbb_chain_accuracy = 1.0, br_chain_accuracy = 1.0;
        set<long int> list_of_wbb;
        for (int i = 0; i < iWindow->NumElements(); i++) {
                /*-----STAT-----*/
                //if (iWindow->Nth(i)->getType() == BR
                //    && iWindow->Nth(i)->isReady(cycle) == false
                //      && iWindow->Nth(i)->getBrBias() >= 0.05 
                //      && iWindow->Nth(i)->getBrBias() <= 0.95) {
                //      list_of_wbb.insert(iWindow->Nth(i)->getInsAddr());
                //      wbb_bypass_count++;
                //      wbb_chain_accuracy *= iWindow->Nth(i)->getBrAccuracy();
                //}
                //if (iWindow->Nth(i)->getType() == BR) {
                //      br_bypass_count++;
                //      br_chain_accuracy *= iWindow->Nth(i)->getBrAccuracy();
                //}
                /*-----STAT-----*/
                if (iWindow->Nth(i)->isReady(cycle) == true) {
                        /*-----STAT-----*/
                        //if (iWindow->Nth(i)->getInsAddr() == 4248075) { //hmmer
      
                        //      fprintf(junk,"\n\n");
                        //      collect_stat = true;
                        //} else if ((iWindow->Nth(i)->getInsAddr() == 4248005 &&
       
                        //                      i+1 < iWindow->NumElements() &&
                        //            iWindow->Nth(i+1)->getInsAddr() != 4248075)
      ||
                        //           iWindow->Nth(i)->getInsAddr() == 4248071) { 
      //hmmer
                        //      collect_stat = false;
                        //}
                        //if (collect_stat == true) {
                        //      fprintf(junk,"%ld, ", iWindow->Nth(i)->getInsAddr
      ());
                        //}
                        //if (num_ins_exe_cnt.find(iWindow->Nth(i)->getInsAddr())
       != num_ins_exe_cnt.end())
                        //      num_ins_exe_cnt[iWindow->Nth(i)->getInsAddr()] +=
       1;
                        //else
                        //      num_ins_exe_cnt[iWindow->Nth(i)->getInsAddr()] = 
      1;
                        //if (num_bypassed_wbb.find(iWindow->Nth(i)->getInsAddr()
      ) != num_bypassed_wbb.end())
                        //      //num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()]
       += list_of_wbb.size(); //static ins
                        //      num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()] +
      = wbb_bypass_count; //dynamic ins
                        //else
                        //      //num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()]
       = list_of_wbb.size(); //static ins
                        //      num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()] =
       wbb_bypass_count; //dynamic ins
                        //if (ins_exe_hoist_accuracy.find(iWindow->Nth(i)->getIns
      Addr()) != ins_exe_hoist_accuracy.end())
                        //      ins_exe_hoist_accuracy[iWindow->Nth(i)->getInsAdd
      r()] += br_chain_accuracy;
                        //else
                        //      ins_exe_hoist_accuracy[iWindow->Nth(i)->getInsAdd
      r()] = br_chain_accuracy;
                        /*-----STAT-----*/
                        iWindow->Nth(i)->setStatus(ready,-1,-1);
                        int indx = findBestResStation();
                        iResStations[indx]->Append(iWindow->Nth(i));
                        //iWinWalkIndx = i;
                }
        }
        //quicksortInsList(iResStation,0,iResStation->NumElements()-1);
        //quicksortInsList(iMemBuf,0,iMemBuf->NumElements()-1);
        //printf("size of iROB        = %d\n", iROB->NumElements());
        //printf("size of iWindow     = %d\n", iWindow->NumElements());
        //printf("size of iResStation = %d\n", iResStation->NumElements());
        //printf("size of iMemBuf     = %d\n", iMemBuf->NumElements());
        //Updaate the fetch list
        for (int i = iWindow->NumElements()-1; i >= 0; i--) {
                if (iWindow->Nth(i)->getStatus() == ready)
                        iWindow->RemoveAt(i);
        }
        /*-----STAT-----*/
        iWinSize      += iWindow->NumElements();
        iROBSize      += iROB->NumElements();
        for (int i = 0; i < NUM_FUNC_UNIT; i++)
                iResStnsSize[i] += iResStations[i]->NumElements();
        /*-----STAT-----*/
        //Check resource availability & execute ins
        for (int j = 0; j < NUM_FUNC_UNIT; j++) {
                if (aluAvail[j]==true) {
                        if (iResStations[j]->NumElements() > 0 &&
                            iResStations[j]->Nth(0)->getStatus() == ready) {
                                aluAvail[j] = false;
                                instruction* ins = iResStations[j]->Nth(0);
                                if (ins->getType() == MEM && ins->getMemType() ==
       READ) {
                                        if (memoryModel == NAIVE_SPECUL) {
                                                        executeIns(ins, cycle, 
      LONG_LATENCY);
                                        } else {
                                                long int insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                if (inFlightLDops.count(insAddr) 
      > 0) {//Non-blocking Load Op
                                                        int tempLat = 
      inFlightLDops.find(insAddr)->second - cycle;
                                                        executeIns(ins, cycle, te
      mpLat);
                                                        getLatency(0,tempLat); //
      Generate hit latency stat
                                                } else {
                                                        int latency = 
      findLatency(ins);
                                                        executeIns(ins, cycle, la
      tency);
                                                        int completeCycle = 
      cycle+latency;
                                                        insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                        inFlightLDops.insert(pair
      <long int,int>(insAddr,completeCycle));
                                                }
                                        }
                                        aluFreeTime[j] = cycle+1;//non-blocking L
      D/ST
                                } else if (ins->getType() == MEM && ins->
      getMemType() == WRITE) {
                                        if (memoryModel == NAIVE_SPECUL) {
                                                executeIns(ins, cycle, 
      ST_LATENCY);
                                        } else {
                                                int latency = findLatency(ins);
                                                executeIns(ins, cycle, latency);
                                        }
                                        aluFreeTime[j] = cycle+1;//non-blocking L
      D/ST
                                } else if (ins->getType() == ALU || 
                                                   ins->getType() == BR  || 
                                                   ins->getType() == ASSIGN || 
                                                   ins->getType() == FPU) {
                                        int latency = findLatency(ins);
                                        executeIns(ins, cycle, latency);
                                        aluFreeTime[j] = cycle+latency;
                                } else {
                                        Assert(ins->getType() == MEM || ins->
      getType() == ALU ||
                                               ins->getType() == BR  || ins->
      getType() == FPU ||
                                               ins->getType() == BR  || ins->
      getType() == FPU);
                                }
                                iResStations[j]->RemoveAt(0);
                        }
                }
        }
        /*-----STAT-----*/
        inFlightLDopsSize += inFlightLDops.size();
        /*-----STAT-----*/
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a10447d26aeb9ab403590f64c71683174}{
\index{bkEnd.cpp@{bkEnd.cpp}!runOOOcoreSingleIssue@{runOOOcoreSingleIssue}}
\index{runOOOcoreSingleIssue@{runOOOcoreSingleIssue}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{runOOOcoreSingleIssue}]{\setlength{\rightskip}{0pt plus 5cm}void runOOOcoreSingleIssue (
\begin{DoxyParamCaption}
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a10447d26aeb9ab403590f64c71683174}

\begin{DoxyCode}
                                      {
        //Cosntruct the ready list
        int iWinWalkIndx = -1;
        int wbb_bypass_count = 0, br_bypass_count = 0;
        float wbb_chain_accuracy = 1.0, br_chain_accuracy = 1.0;
        set<long int> list_of_wbb;
        int scheduled_mem = 0, scheduled_alu = 0;
        for (int i = 0; i < iWindow->NumElements(); i++) {
                /*-----STAT-----*/
                if (iWindow->Nth(i)->getType() == BR
                    && iWindow->Nth(i)->isReady(cycle) == false
                        && iWindow->Nth(i)->getBrBias() >= 0.05 
                        && iWindow->Nth(i)->getBrBias() <= 0.95) {
                        list_of_wbb.insert(iWindow->Nth(i)->getInsAddr());
                        wbb_bypass_count++;
                        wbb_chain_accuracy *= iWindow->Nth(i)->getBrAccuracy();
                }
                if (iWindow->Nth(i)->getType() == BR) {
                        br_bypass_count++;
                        br_chain_accuracy *= iWindow->Nth(i)->getBrAccuracy();
                }
                /*-----STAT-----*/
                if (iWindow->Nth(i)->isReady(cycle) == true) {
                        /*-----STAT-----*/
                        //if (upldMissRateProfileMap.find(iWindow->Nth(i)->getIns
      Addr()) != upldMissRateProfileMap.end()) {
                        //if (iWindow->Nth(i)->getInsAddr() == 4248075) { //hmmer
      
                        //      fprintf(junk,"\n\n");
                        //      collect_stat = true;
                        //} else if ((iWindow->Nth(i)->getInsAddr() == 4248005 &&
       
                        //                      i+1 < iWindow->NumElements() &&
                        //            iWindow->Nth(i+1)->getInsAddr() != 4248075)
      ||
                        //           iWindow->Nth(i)->getInsAddr() == 4248071) { 
      //hmmer
                        //      collect_stat = false;
                        //}
                        //if (collect_stat == true) {
                        //      fprintf(junk,"%ld, ", iWindow->Nth(i)->getInsAddr
      ());
                        //}
                        if (num_ins_exe_cnt.find(iWindow->Nth(i)->getInsAddr()) !
      = num_ins_exe_cnt.end())
                                num_ins_exe_cnt[iWindow->Nth(i)->getInsAddr()] +=
       1;
                        else
                                num_ins_exe_cnt[iWindow->Nth(i)->getInsAddr()] = 
      1;
                        if (num_bypassed_wbb.find(iWindow->Nth(i)->getInsAddr()) 
      != num_bypassed_wbb.end())
                                //num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()]
       += list_of_wbb.size(); //static ins
                                num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()] +
      = wbb_bypass_count; //dynamic ins
                        else
                                //num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()]
       = list_of_wbb.size(); //static ins
                                num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()] =
       wbb_bypass_count; //dynamic ins
                        if (ins_exe_hoist_accuracy.find(iWindow->Nth(i)->
      getInsAddr()) != ins_exe_hoist_accuracy.end())
                                ins_exe_hoist_accuracy[iWindow->Nth(i)->
      getInsAddr()] += br_chain_accuracy;
                        else
                                ins_exe_hoist_accuracy[iWindow->Nth(i)->
      getInsAddr()] = br_chain_accuracy;
                        /*-----STAT-----*/
                        iWindow->Nth(i)->setStatus(ready,-1,-1);
                        iResStation->Append(iWindow->Nth(i));
                        iWinWalkIndx = i;
                        //Dont's go too far down the IQ if enough ready instructi
      ons are found (HW constraint modeling)
                        if (scheduled_alu >= NUM_ALU_UNIT && 
                            scheduled_mem >= NUM_MEM_UNIT)
                                break;
                }
        }
        quicksortInsList(iResStation,0,iResStation->NumElements()-1);
        //Updaate the fetch list
        for (int i = iWinWalkIndx; i >= 0; i--) {
                if (iWindow->Nth(i)->getStatus() == ready)
                        iWindow->RemoveAt(i);
        }
        /*-----STAT-----*/
        iWinSize      += iWindow->NumElements();
        iROBSize      += iROB->NumElements();
        iResStnSize   += iResStation->NumElements();
        /*-----STAT-----*/
        //Check resource availability & execute ins
        if (iResStation->NumElements() == 0 && print_count < laten) {
                ;//printf("STALL, ");
        }
        //if (start_print && iResStation->NumElements() == 0 && print_count >= la
      ten) {
        if (start_print && iResStation->NumElements() == 0 && print_count >= 
      laten) {
                start_print = false;
                printf("\n");
        }
        print_count++;
        /*-----STAT-----*/
        for (int j = 0; j < 1; j++) {
                if (aluAvail[j]==true) {
                        if (iResStation->NumElements() > 0 && 
                            iResStation->Nth(0)->getType() == MEM) {
                                aluAvail[j] = false;
                                instruction* ins = iResStation->Nth(0);
                                if (ins->getMemType() == READ) {
                                        long int insAddr = ins->getMemAddr() >> (
      BLOCK_OFFSET+WORD_OFFSET);
                                        if (inFlightLDops.count(insAddr) > 0) {//
      Non-blocking Load Op
                                                int tempLat = inFlightLDops.find(
      insAddr)->second - cycle;
                                                executeIns(ins, cycle, tempLat);
                                                getLatency(0,tempLat); //Generate
       hit latency stat
                                        } else {
                                                int latency = findLatency(ins);
                                                executeIns(ins, cycle, latency);
                                                int completeCycle = cycle+latency
      ;
                                                insAddr = ins->getMemAddr() >> (
      BLOCK_OFFSET+WORD_OFFSET);
                                                inFlightLDops.insert(pair<long in
      t,int>(insAddr,completeCycle));
                                        }
                                } else if (ins->getMemType() == WRITE) {
                                        int latency = findLatency(ins);
                                        executeIns(ins, cycle, latency);
                                } else {
                                        Assert(ins->getMemType() == WRITE || ins-
      >getMemType() == READ);
                                }
                                /*-----STAT-----*/
                                aluFreeTime[j] = cycle+1;//non-blocking LD/ST
                                if (iResStation->Nth(0)->getInsAddr() == 4356400 
      || 
                                        iResStation->Nth(0)->getInsAddr() == 4248
      208 || 
                                    iResStation->Nth(0)->getInsAddr() == 4397864)
       {
                                        //if (start_print) printf("\n");
                                        if (!start_print) printf("%d, , ", laten)
      ;
                                        start_print = true;
                                        print_count = 0;
                                        laten = iResStation->Nth(0)->getLatency()
      ;
                                }
                                if (start_print && print_count < laten) {
                                        printf("%lld, ", iResStation->Nth(0)->
      getInsID());
                                } else if (start_print) {
                                        start_print = false;
                                        printf("\n");
                                }
                                /*-----STAT-----*/
                                iResStation->RemoveAt(0);
                        } else if (iResStation->NumElements() > 0 && 
                                  (iResStation->Nth(0)->getType() == ALU ||
                                   iResStation->Nth(0)->getType() == BR  ||
                                       iResStation->Nth(0)->getType() == FPU)) {
                                aluAvail[j] = false;
                                instruction* ins = iResStation->Nth(0);
                                int latency = findLatency(ins);
                                executeIns(ins, cycle, latency);
                                aluFreeTime[j] = cycle+latency;
                                iResStation->RemoveAt(0);
                                if (start_print && print_count < laten) {
                                        printf("%lld, ", iResStation->Nth(0)->
      getInsID());
                                } else if (start_print) {
                                        start_print = false;
                                        printf("\n");
                                }
                                /*-----STAT-----*/
                        }
                }
        }
        /*-----STAT-----*/
        inFlightLDopsSize += inFlightLDops.size();
        /*-----STAT-----*/
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a6ce7251cbd93290a7c6774649b96b166}{
\index{bkEnd.cpp@{bkEnd.cpp}!runPhraseblockCore@{runPhraseblockCore}}
\index{runPhraseblockCore@{runPhraseblockCore}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{runPhraseblockCore}]{\setlength{\rightskip}{0pt plus 5cm}void runPhraseblockCore (
\begin{DoxyParamCaption}
\item[{int}]{cycle, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$$\ast$}]{pbLists}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a6ce7251cbd93290a7c6774649b96b166}

\begin{DoxyCode}
                                                                 {
        //Cosntruct the ready list
        int iWinWalkIndx[NUM_PHRASEBLKS];
        for (int j = 0; j < NUM_PHRASEBLKS; j++)
                iWinWalkIndx[j] = -1;
        for (int j = 0; j < NUM_PHRASEBLKS; j++) {
                List<instruction*>* pbList = pbLists[j];
                for (int i = 0; i < pbList->NumElements(); i++) { 
                        instruction* ins = pbList->Nth(i);
                        if (ins->isReady(cycle) == true) {
                                ins->setStatus(ready,-1,-1);
                                //int indx = j/2;
                                int indx = findBestResStation();
                                iResStations[indx]->Append(ins);
                                //createStrand(ins, indx, i+1, pbList);
                                iWinWalkIndx[j] = i;
                        } else {
                                break; //in-order issue dependency
                        }
                }
        }
        //Updaate the fetch list
        for (int j = 0; j < NUM_PHRASEBLKS; j++) {
                List<instruction*>* pbList = pbLists[j];
                //for (int i = iWinWalkIndx[j]; i >= 0; i--) {
                for (int i = pbLists[j]->NumElements()-1; i >= 0; i--) {
                        if (pbList->Nth(i)->getStatus() == ready) {
                                pbList->RemoveAt(i);
                        } else if (pbList->Nth(i)->getStatus() == chain) {
                                pbList->RemoveAt(i);
                        }
                }
                /*-----STAT-----*/
                if (iWinWalkIndx[j] != -1) activeBuffCnt++;
                /*-----STAT-----*/
        }
        for (int i = 0; i < NUM_FUNC_UNIT; i++) {
                for (int j = 0; j < iResStations[i]->NumElements(); j++) {
                        if (iResStations[i]->Nth(j)->isReady(cycle) &&
                            iResStations[i]->Nth(j)->getStatus() == chain) {
                                iResStations[i]->Nth(j)->setStatus(ready, -1, -1)
      ;
                        }
                }
        }
        /*-----STAT-----*/
        iROBSize      += iROB->NumElements();
        for (int i = 0; i < NUM_FUNC_UNIT; i++)
                iResStnsSize[i] += iResStations[i]->NumElements();
        for (int i = 0; i < NUM_PHRASEBLKS; i++)
                pbListsSize[i] += pbLists[i]->NumElements();
        /*-----STAT-----*/
        //Check resource availability & execute ins
        for (int j = 0; j < NUM_FUNC_UNIT; j++) {
                if (aluAvail[j]==true) {
                        if (iResStations[j]->NumElements() > 0 &&
                            iResStations[j]->Nth(0)->getStatus() == ready) {
                                aluAvail[j] = false;
                                instruction* ins = iResStations[j]->Nth(0);
                                if (ins->getType() == MEM && ins->getMemType() ==
       READ) {
                                        long int insAddr = ins->getMemAddr() >> (
      BLOCK_OFFSET+WORD_OFFSET);
                                        if (memoryModel == NAIVE_SPECUL) {
                                                        executeIns(ins, cycle, 
      LONG_LATENCY);
                                        } else {
                                                //if (inFlightLDops.count(insAddr
      ) > 0) {//Non-blocking Load Op
                                                if (inFlightLDops.find(insAddr)->
      second >= cycle) {//Non-blocking Load Op
                                                        int tempLat = 
      inFlightLDops.find(insAddr)->second - cycle;
                                                        executeIns(ins, cycle, te
      mpLat);
                                                        getLatency(0,tempLat); //
      Generate hit latency stat
                                                } else {
                                                        int latency = 
      findLatency(ins);
                                                        executeIns(ins, cycle, la
      tency);
                                                        int completeCycle = 
      cycle+latency;
                                                        insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                        inFlightLDops.insert(pair
      <long int,int>(insAddr,completeCycle));
                                                }
                                        }
                                        aluFreeTime[j] = cycle+1;//non-blocking L
      D/ST
                                } else if (ins->getType() == MEM && ins->
      getMemType() == WRITE) {
                                        if (memoryModel == NAIVE_SPECUL) {
                                                executeIns(ins, cycle, 
      ST_LATENCY);
                                        } else {
                                                int latency = findLatency(ins);
                                                executeIns(ins, cycle, latency);
                                        }
                                        aluFreeTime[j] = cycle+1;//non-blocking L
      D/ST
                                } else if (ins->getType() == ALU || 
                                                   ins->getType() == BR  || 
                                                   ins->getType() == ASSIGN || 
                                                   ins->getType() == FPU) {
                                        int latency = findLatency(ins);
                                        executeIns(ins, cycle, latency);
                                        aluFreeTime[j] = cycle+latency;
                                        if(ins->getType() == BR && branchMode == 
      dynPredBr) {
                                                brInsCount++;
                                                br_pred_update_dist += cycle-
      br_pred_update_distance[ins->getInsAddr()];
                                                br_pred_update_distance.erase(ins
      ->getInsAddr());
                                        }
                                } else {
                                        Assert(ins->getType() == MEM || ins->
      getType() == ALU ||
                                               ins->getType() == BR  || ins->
      getType() == FPU ||
                                               ins->getType() == BR  || ins->
      getType() == FPU);
                                }
                                iResStations[j]->RemoveAt(0);
                        }
                }
        }
        /*-----STAT-----*/
        inFlightLDopsSize += inFlightLDops.size();
        /*-----STAT-----*/
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_aeb3bb6faa3048d5856d06e6205cc3248}{
\index{bkEnd.cpp@{bkEnd.cpp}!runStoreQueue@{runStoreQueue}}
\index{runStoreQueue@{runStoreQueue}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{runStoreQueue}]{\setlength{\rightskip}{0pt plus 5cm}void runStoreQueue (
\begin{DoxyParamCaption}
\item[{{\bf lsq} $\ast$}]{loadStoreQue, }
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_aeb3bb6faa3048d5856d06e6205cc3248}

\begin{DoxyCode}
                                                 {
        /* Pop SQ */
        oooLD_sqDequ (loadStoreQue, cycle);
        /* Write To Cache */
        if (isCacheBusFree) { //Support at most ONE store to cache per cycle
                if (loadStoreQue->hasCommittedUncachedSQentry()) {
                        isCacheBusFree = false;
                        int *lat = new int; //TODO stupid setup... get rid of lat
      
                        INS_ID id = loadStoreQue->
      get_OldestCommittedUncachedSQentry_ID();
                        ADDRS memAddr = loadStoreQue->
      get_oldestCommittedUncachedSQentry_MemAddr(id);
                        int latency = cacheCtrl(WRITE, memAddr, 4, _L1, _L2, _L3)
      ;
                        loadStoreQue->
      set_OldestCommittedUncachedSQentry_setLatency(latency, cycle, id);
                        delete lat;
                }
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a72051851d4c12247aaab4ed481b9c2d1}{
\index{bkEnd.cpp@{bkEnd.cpp}!runStrandcore@{runStrandcore}}
\index{runStrandcore@{runStrandcore}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{runStrandcore}]{\setlength{\rightskip}{0pt plus 5cm}void runStrandcore (
\begin{DoxyParamCaption}
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a72051851d4c12247aaab4ed481b9c2d1}

\begin{DoxyCode}
                              {
        //Cosntruct the ready list
        //int iWinWalkIndx = -1;
        //int wbb_bypass_count = 0, br_bypass_count = 0;
        //float wbb_chain_accuracy = 1.0, br_chain_accuracy = 1.0;
        set<long int> list_of_wbb;
        for (int i = 0; i < iWindow->NumElements(); i++) {
                /*-----STAT-----*/
                //if (iWindow->Nth(i)->getType() == BR
                //    && iWindow->Nth(i)->isReady(cycle) == false
                //      && iWindow->Nth(i)->getBrBias() >= 0.05 
                //      && iWindow->Nth(i)->getBrBias() <= 0.95) {
                //      list_of_wbb.insert(iWindow->Nth(i)->getInsAddr());
                //      wbb_bypass_count++;
                //      wbb_chain_accuracy *= iWindow->Nth(i)->getBrAccuracy();
                //}
                //if (iWindow->Nth(i)->getType() == BR) {
                //      br_bypass_count++;
                //      br_chain_accuracy *= iWindow->Nth(i)->getBrAccuracy();
                //}
                /*-----STAT-----*/
                if (iWindow->Nth(i)->isReady(cycle) == true) {
                        /*-----STAT-----*/
                        //if (iWindow->Nth(i)->getInsAddr() == 4248075) { //hmmer
      
                        //      fprintf(junk,"\n\n");
                        //      collect_stat = true;
                        //} else if ((iWindow->Nth(i)->getInsAddr() == 4248005 &&
       
                        //                      i+1 < iWindow->NumElements() &&
                        //            iWindow->Nth(i+1)->getInsAddr() != 4248075)
      ||
                        //           iWindow->Nth(i)->getInsAddr() == 4248071) { 
      //hmmer
                        //      collect_stat = false;
                        //}
                        //if (collect_stat == true) {
                        //      fprintf(junk,"%ld, ", iWindow->Nth(i)->getInsAddr
      ());
                        //}
                        //if (num_ins_exe_cnt.find(iWindow->Nth(i)->getInsAddr())
       != num_ins_exe_cnt.end())
                        //      num_ins_exe_cnt[iWindow->Nth(i)->getInsAddr()] +=
       1;
                        //else
                        //      num_ins_exe_cnt[iWindow->Nth(i)->getInsAddr()] = 
      1;
                        //if (num_bypassed_wbb.find(iWindow->Nth(i)->getInsAddr()
      ) != num_bypassed_wbb.end())
                        //      //num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()]
       += list_of_wbb.size(); //static ins
                        //      num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()] +
      = wbb_bypass_count; //dynamic ins
                        //else
                        //      //num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()]
       = list_of_wbb.size(); //static ins
                        //      num_bypassed_wbb[iWindow->Nth(i)->getInsAddr()] =
       wbb_bypass_count; //dynamic ins
                        //if (ins_exe_hoist_accuracy.find(iWindow->Nth(i)->getIns
      Addr()) != ins_exe_hoist_accuracy.end())
                        //      ins_exe_hoist_accuracy[iWindow->Nth(i)->getInsAdd
      r()] += br_chain_accuracy;
                        //else
                        //      ins_exe_hoist_accuracy[iWindow->Nth(i)->getInsAdd
      r()] = br_chain_accuracy;
                        /*-----STAT-----*/
                        //iWindow->Nth(i)->setStatus(ready,-1,-1);
                        //if      (iWindow->Nth(i)->getType() == ALU ||
                        //         iWindow->Nth(i)->getType() == FPU ||
                        //         iWindow->Nth(i)->getType() == BR) {
                        //      iResStation->Append(iWindow->Nth(i));
                        //} else if  (iWindow->Nth(i)->getType() == MEM) {
                        //      iMemBuf->Append(iWindow->Nth(i));
                        //} else {
                        //      Assert (iWindow->Nth(i)->getType() == MEM || 
                        //              iWindow->Nth(i)->getType() == BR  ||
                        //              iWindow->Nth(i)->getType() == ALU ||
                        //              iWindow->Nth(i)->getType() == FPU);
                        //}
                        //iWinWalkIndx = i;
                        iWindow->Nth(i)->setStatus(ready,-1,-1);
                        int indx = findBestResStation();
                        iResStations[indx]->Append(iWindow->Nth(i));
                        createStrand(iWindow->Nth(i), indx, i+1, iWindow);
                        //printf("\n>> ");
                        //iWinWalkIndx = i;
                }
        }
        //quicksortInsList(iResStation,0,iResStation->NumElements()-1);
        //quicksortInsList(iMemBuf,0,iMemBuf->NumElements()-1);
        //printf("size of iROB        = %d\n", iROB->NumElements());
        //printf("size of iWindow     = %d\n", iWindow->NumElements());
        //printf("size of iResStation = %d\n", iResStation->NumElements());
        //printf("size of iMemBuf     = %d\n", iMemBuf->NumElements());
        //Updaate the fetch list
        for (int i = iWindow->NumElements()-1; i >= 0; i--) {
                if (iWindow->Nth(i)->getStatus() == ready) {
                        iWindow->RemoveAt(i);
                } else if (iWindow->Nth(i)->getStatus() == chain) {
                        iWindow->RemoveAt(i);
                }
        }
        for (int i = 0; i < NUM_FUNC_UNIT; i++) {
                //printf("(%d, %d), ", iResStations[i]->Nth(0)->getInsID(), iResS
      tations[i]->Nth(0)->getNumAncestors());
                for (int j = 0; j < iResStations[i]->NumElements(); j++) {
                        if (iResStations[i]->Nth(j)->isReady(cycle) &&
                            iResStations[i]->Nth(j)->getStatus() == chain) {
                                iResStations[i]->Nth(j)->setStatus(ready, -1, -1)
      ;
                        }
                }
        }
        //printf("\n");
        /*-----STAT-----*/
        iWinSize      += iWindow->NumElements();
        iROBSize      += iROB->NumElements();
        for (int i = 0; i < NUM_FUNC_UNIT; i++)
                iResStnsSize[i] += iResStations[i]->NumElements();
        /*-----STAT-----*/
        //Check resource availability & execute ins
        for (int j = 0; j < NUM_FUNC_UNIT; j++) {
                if (aluAvail[j]==true) {
                        if (iResStations[j]->NumElements() > 0 &&
                            iResStations[j]->Nth(0)->getStatus() == ready) {
                                aluAvail[j] = false;
                                instruction* ins = iResStations[j]->Nth(0);
                                if (ins->getType() == MEM && ins->getMemType() ==
       READ) {
                                        long int insAddr = ins->getMemAddr() >> (
      BLOCK_OFFSET+WORD_OFFSET);
                                        if (inFlightLDops.count(insAddr) > 0) {//
      Non-blocking Load Op
                                                int tempLat = inFlightLDops.find(
      insAddr)->second - cycle;
                                                executeIns(ins, cycle, tempLat);
                                                getLatency(0,tempLat); //Generate
       hit latency stat
                                        } else {
                                                int latency = findLatency(ins);
                                                executeIns(ins, cycle, latency);
                                                int completeCycle = cycle+latency
      ;
                                                insAddr = ins->getMemAddr() >> (
      BLOCK_OFFSET+WORD_OFFSET);
                                                inFlightLDops.insert(pair<long in
      t,int>(insAddr,completeCycle));
                                        }
                                        aluFreeTime[j] = cycle+1;//non-blocking L
      D/ST
                                } else if (ins->getType() == MEM && ins->
      getMemType() == WRITE) {
                                        int latency = findLatency(ins);
                                        executeIns(ins, cycle, latency);
                                        aluFreeTime[j] = cycle+1;//non-blocking L
      D/ST
                                } else if (ins->getType() == ALU || 
                                                   ins->getType() == BR  || 
                                                   ins->getType() == ASSIGN || 
                                                   ins->getType() == FPU) {
                                        int latency = findLatency(ins);
                                        executeIns(ins, cycle, latency);
                                        aluFreeTime[j] = cycle+latency;
                                } else {
                                        Assert(ins->getType() == MEM || ins->
      getType() == ALU ||
                                               ins->getType() == BR  || ins->
      getType() == FPU ||
                                               ins->getType() == BR  || ins->
      getType() == FPU);
                                }
                                iResStations[j]->RemoveAt(0);
                        }
                }
        }
        /*-----STAT-----*/
        inFlightLDopsSize += inFlightLDops.size();
        /*-----STAT-----*/
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a63d6bd6a56d403ccb003d08d98681a3b}{
\index{bkEnd.cpp@{bkEnd.cpp}!runxLD\_\-STAT@{runxLD\_\-STAT}}
\index{runxLD\_\-STAT@{runxLD\_\-STAT}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{runxLD\_\-STAT}]{\setlength{\rightskip}{0pt plus 5cm}void runxLD\_\-STAT (
\begin{DoxyParamCaption}
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a63d6bd6a56d403ccb003d08d98681a3b}

\begin{DoxyCode}
                            {
        Assert (ROB_SIZE >= 300);
        Assert (numSideBuffs <= 2 && numSideBuffs > 0);
        Assert (numActiveSideBuffs <= numSideBuffs);
        int iWinWalkIndx = -1;
        int *iSideBfWalkIndx = new int [numSideBuffs];
        for (int j = 0; j < numActiveSideBuffs; j++)
                iSideBfWalkIndx[j] = -1;

        //bool aSBdraining = false;
        /*-----STAT-----*/
        //for (int i = 0; i < numSideBuffs; i++) {
        //      if (iSideBuff[i]->isFree()==true) SBoffCycles[i]++;
        //}
        //for (int i = 0; i < numSideBuffs; i++) {
        //      if (iSideBuff[i]->isFree()==false) {
        //              if (mainStreamInsCount >= mainStreamBound) {
        //                      aSBdraining = true;
        //                      break;
        //              } else {
        //                      SBactiveCycles[i]++;
        //                      totSBactiveCycles++;
        //              }
        //      }
        //}
        /*-----STAT-----*/

        //Clear the iWindow & other queues
        if (iSideBuff[numActiveSideBuffs-1]->isFree() == false && 
      mainStreamInsCount >= mainStreamBound) {//Drain SB
                Assert(mainStreamBound != -1);
                //if (mainStreamInsCount == mainStreamBound) numOnSideBuffs--;
                for (int j = 0; j < numActiveSideBuffs; j++) {
                        if (iSideBuff[j]->NumElements() > 0) {
                                for (int i = 0; i < iSideBuff[j]->NumElements(); 
      i++) {
                                        if (iSideBuff[j]->Nth(i)->isReady(cycle) 
      == true) {
                                                //TODO how many dependencies inst
      ructions 
                                                //have at this point? 1 hopefully
      ?
                                                iSideBuff[j]->Nth(i)->setStatus(
      sideReady,-1,-1);
                                                iResStation->Append(iSideBuff[j]-
      >Nth(i));
                                                iSideBfWalkIndx[j] = i;
                                        } else {
                                                break; //in-order side buff ins i
      ssue
                                        }
                                }
                        }
                        if (iSideBfWalkIndx[j] >= 0) {
                               for (int i = iSideBfWalkIndx[j]; i >= 0; i--) {
                                        if (iSideBuff[j]->Nth(i)->getStatus() == 
      sideReady)
                                                iSideBuff[j]->RemoveAt(i);
                               }
                        }
                        if (iSideBuff[j]->NumElements() > 0)
                                break; //in-order SB drain sequence
                }
                bool allSBdrained = true;
                for (int j = 0; j < numActiveSideBuffs; j++) {
                        if (iSideBuff[j]->NumElements() > 0) {
                                allSBdrained = false;
                                break;
                        }
                }
                //if (drainedSBcount == numActiveSideBuffs) {allSBdrained = true;
       printf("hi\n");}
                //else allSBdrained = false;
                if (allSBdrained == true) {
                        //Free all SB's together
                        for (int j = 0; j < numActiveSideBuffs; j++)
                                iSideBuff[j]->setFree();
                        numActiveSideBuffs = 1; //default
                        mainStreamBound = -1;
                        //drainedSBcount = 0;
                }
        } else {
                printf("%d,%d,%d,%d,%d\n",cycle,numActiveSideBuffs,
      mainStreamInsCount,mainStreamBound,iSideBuff[numActiveSideBuffs-1]->isFree());
                for (int i = 0; i < iWindow->NumElements(); i++) {
                        //Transfer to Reservation Station
                        if (iWindow->Nth(i)->isReady(cycle) == true) {
                                iWindow->Nth(i)->setStatus(ready,-1,-1);
                                iResStation->Append(iWindow->Nth(i));
                                iWinWalkIndx = i;
                        } else {
                                break; //in-order issue dependency
                        }
                }
        }

        /*-----STAT-----*/
        if (numOnSideBuffs == 0) {totSBoffCycles++;}
        /*-----STAT-----*/
        //Updaate the lists
        if (iWinWalkIndx >=0 ) {
                for (int i = iWinWalkIndx; i >= 0; i--) {
                        Assert(iWindow->Nth(i)->getStatus() != sideBuffer);
                        if (iWindow->Nth(i)->getStatus() == ready)
                                iWindow->RemoveAt(i);
                }
        }
        //for (int j = 0; j < numActiveSideBuffs; j++) {
        //      if (iSideBfWalkIndx[j] >= 0) {
        //             for (int i = iSideBfWalkIndx[j]; i >= 0; i--) {
        //                      if (iSideBuff[j]->Nth(i)->getStatus() == sideRead
      y)
        //                              iSideBuff[j]->RemoveAt(i);
        //             }
        //      }
        //}

        /*-----STAT-----*/
        if (iResStation->NumElements() == 0) {emptyResStation++;}
        //else {
                printf("cycle/SB_status/msic/msb/sb %d, %d, %d, %d, %d, %d| ",
      cycle,iSideBuff[0]->isFree(),mainStreamInsCount,mainStreamBound, iSideBuff[1]->Nu
      mElements(),iWindow->Nth(0)->_guardian);
                printf("%lld,%d,%llu(%s)|%lld,%d,%llu (%s)|", iWindow->Nth(0)->
      _ancestors->Nth(0)->getInsID(),
                                                         iWindow->Nth(0)->
      _ancestors->Nth(0)->getStatus(),
                                                         iWindow->Nth(0)->
      _ancestors->Nth(0)->getMemAddr(),
                                                         iWindow->Nth(0)->
      _ancestors->Nth(0)->getCmdStr(),
                                                         //iWindow->Nth(0)->_ance
      stors->Nth(0)->getSideBuffNum(),
                                                         iWindow->Nth(0)->
      getInsID(),
                                                         iWindow->Nth(0)->
      getStatus(),
                                                         iWindow->Nth(0)->
      getMemAddr(),
                                                         iWindow->Nth(0)->
      getCmdStr());
                if (iSideBuff[0]->NumElements()>0) printf("%lld,%d\n",iSideBuff[0
      ]->Nth(0)->getInsID(),iSideBuff[0]->NumElements());
                else printf("\n");
        //}
        iSideBufSize  += iSideBuff[0]->NumElements();
        iWinSize      += iWindow->NumElements();
        iROBSize      += iROB->NumElements();
        iResStnSize   += iResStation->NumElements();
        Assert(iSideBuff[0]->NumElements() >= 0 && 
               iWindow->NumElements()      >= 0 &&
               iROB->NumElements()         >= 0 &&
               iResStation->NumElements()  >= 0);
        /*-----STAT-----*/

        //Check resource availability & execute ins
        while (iResStation->NumElements() > 0) {
               int prevInsCount = insCount;
               for (int i = 0; i < NUM_FUNC_UNIT; i++) {
                        if (aluAvail[i]==true) {
                                if (aluKind[i] == MEM && iResStation->Nth(0)->
      getType() == MEM) {
                                        //Implementing two MEM issue per cycle (t
      wo mem units)
                                        aluAvail[i] = false;
                                        instruction* ins = iResStation->Nth(0);
                                        if (ins->getMemType() == READ) {
                                                long int insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                int latency = 0;
                                                int completeCycle = 0;
                                                //Non-blocking Load Op
                                                if (inFlightLDops.count(insAddr) 
      > 0) {
                                                        latency = inFlightLDops.f
      ind(insAddr)->second - cycle;
                                                        executeIns(ins, cycle, la
      tency);
                                                        if (iSideBuff[numActiveSi
      deBuffs-1]->isFree() == false) mainStreamInsCount++;
                                                        getLatency(0,latency); //
      Gen hit latency stat
                                                        completeCycle = cycle+lat
      ency;
                                                } else {
                                                        latency = findLatency(ins
      );
                                                        executeIns(ins, cycle, la
      tency);
                                                        if (iSideBuff[numActiveSi
      deBuffs-1]->isFree() == false) mainStreamInsCount++;
                                                        completeCycle = cycle+lat
      ency;
                                                        insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                        inFlightLDops.insert(pair
      <long int,int>(insAddr,completeCycle));
                                                }
                                                //X Level Deep Staic Cnotingent S
      cheduling Activation
                                                Assert (latency > 0 && completeCy
      cle > 0);
                                                if (latency > xLevDeepLatLevel) {
      
                                                        for (int sb = 0; sb < 
      numSideBuffs; sb++) {
                                                                if (iSideBuff[sb]
      ->isFree() == true) {
                                                                        
      iSideBuff[sb]->setBusy();
                                                                        numActive
      SideBuffs = sb + 1;
                                                                        
      numOnSideBuffs++; //STAT
                                                                        ins->
      notifyAllDepGoToSideBuff(sb,ins->getInsID(),numSideBuffs);
                                                                        for (int 
      m = 0; m < numSideBuffs; m++)
                                                                                i
      f (m != sb && iSideBuff[m]->NumElements() > 0)
                                                                                        
      iSideBuff[m]->Nth(0)->notifyAllDepGoToSideBuff(iSideBuff[m]->Nth(0)->getSideBuffN
      um(), iSideBuff[m]->Nth(0)->getCauseOfSBinsID(), numSideBuffs);
                                                                        //Move De
      pendent Ins's into SB
                                                                        //if (sb 
      > 0) {
                                                                        //      f
      or (int j = 1; j <= sb; j++) {
                                                                        //              i
      SideBfWalkIndx[sb-j] = -1;
                                                                        //              f
      or (int i = 0; i < iSideBuff[sb-j]->NumElements() && iSideBuff[sb]->NumElements()
       < SBlength; i++) {
                                                                        //                      i
      f (iSideBuff[sb-j]->Nth(i)->getSideBuffNum() == sb) {
                                                                        //                              i
      SideBuff[sb-j]->Nth(i)->setStatus(sideBuffer,-1,-1);
                                                                        //                              i
      SideBuff[sb]->Append(iSideBuff[sb-j]->Nth(i));
                                                                        //                              S
      Blist->Append(i);
                                                                        //                              i
      SideBfWalkIndx[sb-j] = i;
                                                                        //                      }
      
                                                                        //              }
      
                                                                        //              f
      or (int i = iSideBfWalkIndx[sb-j]; i >= 0; i--) {
                                                                        //                      i
      f (iSideBuff[sb-j]->Nth(i)->getSideBuffNum() == sb) {
                                                                        //                              i
      SideBuff[sb-j]->RemoveAt(i);
                                                                        //                      }
      
                                                                        //                      i
      f (iSideBuff[sb-j]->NumElements() == 0) {
                                                                        //                              d
      rainedSBcount++;
                                                                        //                      }
      
                                                                        //              }
      
                                                                        //      }
      
                                                                        //} else 
      {
                                                                        //      A
      ssert(iSideBuff[sb]->NumElements() == 0);
                                                                        //}
                                                                        iWinWalkI
      ndx = -1;
                                                                        int SBtoS
      BNumElements = 0; //iSideBuff[sb]->NumElements();
                                                                        int i = 0
      ;
                                                                        for (i = 
      0; i < iWindow->NumElements() && iSideBuff[sb]->NumElements() < SBlength; i++) {
                                                                                i
      f (iWindow->Nth(i)->isGotoSideBuff() == true) {
                                                                                        
      iWindow->Nth(i)->setStatus(sideBuffer,-1,-1);
                                                                                        i
      nt s = iWindow->Nth(i)->getSideBuffNum();
                                                                                        
      Assert(s >= 0 && s < numSideBuffs);
                                                                                        
      iSideBuff[s]->Append(iWindow->Nth(i));
                                                                                        
      SBlist->Append(i);
                                                                                        i
      WinWalkIndx = i;
                                                                                }
      
                                                                        }
                                                                        /*-----ST
      AT-----*/
                                                                        //if (i >
      = iWindow->NumElements() && iSideBuff[sb]->NumElements() < SBlength) {
                                                                        //      w
      indowSatration++; //TODO make it an array
                                                                        //}
                                                                        /*-----ST
      AT-----*/
                                                                        Assert ((
      iWinWalkIndx == -1 && iSideBuff[sb]->NumElements() == 0) || iWinWalkIndx != -1);
                                                                        Assert (
      iSideBuff[sb]->NumElements() >= SBtoSBNumElements);
                                                                        
      mainStreamInsCount = 0; //TODO verify moving this line to here is not wrong (with
       -c 5)
                                                                        if (
      iSideBuff[sb]->NumElements() == 0) 
                                                                                
      mainStreamBound = 0;
                                                                        else
                                                                                
      mainStreamBound = (iWinWalkIndx + 1) + (iResStation->NumElements() - 1) - (
      iSideBuff[sb]->NumElements() - SBtoSBNumElements);
                                                                        //Update 
      iWindow
                                                                        //if (iWi
      nWalkIndx >= 0) {scheduleInsInFlight(SBlist, delList, iWindow, iWinWalkIndx, cycl
      e);}
                                                                        for (int 
      m = iWinWalkIndx; m >= 0; m--)
                                                                                i
      f (iWindow->Nth(m)->getStatus() == sideBuffer) iWindow->RemoveAt(m);

                                                                        //Fill up
       the SB
                                                                        Assert(sb
       >= 0 && sb < numSideBuffs);
                                                                        /*-----ST
      AT-----*/
                                                                        //totNumS
      Bactivations++;
                                                                        //numSBac
      tivations[sb]++;
                                                                        //if (iWi
      nWalkIndx >= 0) {
                                                                        //      t
      otFrameSize   += (iWinWalkIndx + 1) + (iResStation->NumElements() - 1);
                                                                        //      t
      otMainStreamBound += mainStreamBound;
                                                                        //}
                                                                        /*-----ST
      AT-----*/
                                                                        for (int 
      m = 0; m < numSideBuffs; m++)
                                                                                i
      f (iSideBuff[m]->NumElements() > 0) {
                                                                                        
      iSideBuff[m]->Nth(0)->notifyAllDepGetOutSideBuff(iSideBuff[m]->Nth(0)->getSideBuf
      fNum(), iSideBuff[m]->Nth(0)->getCauseOfSBinsID(), numSideBuffs);
                                                                                }
      
                                                                        break;
                                                                } else { //TODO s
      hould this be inside the for loop or ouside?
                                                                        /*-----ST
      AT-----*/
                                                                        
      longLatOpWhenSPisON++;
                                                                        if (
      mainStreamInsCount >= mainStreamBound)
                                                                                
      longLatOpWhenSPisDraining++;
                                                                        else
                                                                                
      longLatOpWhenSPisWaiting++;
                                                                        /*-----ST
      AT-----*/
                                                                }
                                                        }
                                                }
                                        } else if (ins->getMemType() == WRITE) {
                                                int latency = findLatency(ins);
                                                executeIns(ins, cycle, latency);
                                                if (iSideBuff[numActiveSideBuffs-
      1]->isFree() == false) mainStreamInsCount++;
                                        } else {
                                                Assert(ins->getMemType() == 
      WRITE || ins->getMemType() == READ);
                                        }
                                        aluFreeTime[i] = cycle+1;//non-blocking L
      D/ST
                                        iResStation->RemoveAt(0);
                                        /*-----STAT-----*/
                                        //for (int i = 0; i < numSideBuffs; i++) 
      {
                                        if (iSideBuff[0]->isFree()==false) { // &
      & iSideBuff[i]->getExpiration() > cycle) {
                                                InsCountWhenSBon[0]++;
                                                totInsCountWhenSBon++;
                                        }
                                        //}
                                        /*-----STAT-----*/
                                        break;
                                } else if (aluKind[i] == ALU && 
                                           (iResStation->Nth(0)->getType() == 
      ALU ||
                                            iResStation->Nth(0)->getType() == 
      FPU)) {
                                        aluAvail[i] = false;
                                        instruction* ins = iResStation->Nth(0);
                                        int latency = findLatency(ins);
                                        executeIns(ins, cycle, latency);
                                        if (iSideBuff[numActiveSideBuffs-1]->isFr
      ee() == false) mainStreamInsCount++;
                                        aluFreeTime[i] = cycle+latency;
                                        iResStation->RemoveAt(0);
                                        /*-----STAT-----*/
                                        //for (int i = 0; i < numSideBuffs; i++) 
      {
                                        if (iSideBuff[0]->isFree()==false) { // &
      & iSideBuff[i]->getExpiration() > cycle) {
                                                InsCountWhenSBon[0]++;
                                                totInsCountWhenSBon++;
                                        }
                                        //}
                                        /*-----STAT-----*/
                                        break;
                                }
                        }
               }
               if (insCount-prevInsCount == 0) {break;} //in-order issue struct h
      azard
        }
        /*-----STAT-----*/
        inFlightLDopsSize += inFlightLDops.size();
        /*-----STAT-----*/
        delete [] iSideBfWalkIndx;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a00dd14f5dbcba28599ade0a3d5c47091}{
\index{bkEnd.cpp@{bkEnd.cpp}!runxLDcore\_\-DYN@{runxLDcore\_\-DYN}}
\index{runxLDcore\_\-DYN@{runxLDcore\_\-DYN}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{runxLDcore\_\-DYN}]{\setlength{\rightskip}{0pt plus 5cm}void runxLDcore\_\-DYN (
\begin{DoxyParamCaption}
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a00dd14f5dbcba28599ade0a3d5c47091}

\begin{DoxyCode}
                               {
        //Cosntruct the ready list
        int iWinWalkIndx = -1;
        int *iSideBfWalkIndx = new int [numSideBuffs];


        //if(cycle > 10) printf("0)iWin/iSB/RS size = %d,%d,%d,|%s|,%d,%d|%d\n", 
      iWindow->NumElements(), iSideBuff[0]->NumElements(),iResStation->NumElements(),iR
      esStation->Nth(0)->getCmdStr(),iResStation->Nth(0)->getInsID(),iResStation->Nth(0
      )->getType(),cycle);

        //bool aSBdraining = false;
        /*-----STAT-----*/
        for (int i = 0; i < numSideBuffs; i++) {
                if (iSideBuff[i]->isFree()==true) SBoffCycles[i]++;
        }
        for (int i = 0; i < numSideBuffs; i++) {
                if (iSideBuff[i]->isFree()==false) {
                        if (iSideBuff[i]->getExpiration() <= cycle) {
                                //aSBdraining = true;
                                break;
                        } else {
                                SBactiveCycles[i]++;
                                totSBactiveCycles++;
                        }
                }
        }
        /*-----STAT-----*/

        //Assign instructions to the right buffer
        //if (aSBdraining == false) {
                for (int i = 0; i < iWindow->NumElements(); i++) {
                        if (iWindow->Nth(i)->isGotoSideBuff() == true &&
                            iSideBuff[iWindow->Nth(i)->getSideBuffNum()]->isFree(
      ) == false &&
                            iSideBuff[iWindow->Nth(i)->getSideBuffNum()]->
      getExpiration() > cycle) {
                                //printf("BS: %d,  ", iWindow->Nth(i)->getType())
      ;
                                iWindow->Nth(i)->setStatus(sideBuffer,-1,-1);
                                int indx = iWindow->Nth(i)->getSideBuffNum();
                                //if (iWindow->Nth(i)->getMemAddr() == 1407359289
      07336) printf("GOT in SB %s, cycle=%d\n",iWindow->Nth(i)->getCmdStr(),cycle);
                                iSideBuff[indx]->Append(iWindow->Nth(i));
                                iWinWalkIndx = i;
                                /*-----STAT-----*/
                                totInsVisitingSBcount++;
                                insVisitingSBcount[indx]++;
                                /*-----STAT-----*/
                        } else {
                                //Transfer to Reservation Station
                                if (iWindow->Nth(i)->isReady(cycle) == true) {
                                        //printf("%d,  ", iWindow->Nth(i)->getTyp
      e());
                                        iWindow->Nth(i)->setStatus(ready,-1,-1);
                                //if (iWindow->Nth(i)->getMemAddr() == 1407359289
      07336) printf("GOT in RS %s, cycle=%d\n",iWindow->Nth(i)->getCmdStr(),cycle);
                                        iResStation->Append(iWindow->Nth(i));
                                        iWinWalkIndx = i;
                                } else {
                                        //depFailiniWin++;
                                        break; //in-order issue dependency
                                }
                        }
                }
        //}
        //Clear the iWindow

        for (int indx = 0; indx < SBpriorityList->NumElements(); indx++) {
                int sb = SBpriorityList->Nth(indx);
                iSideBfWalkIndx[sb]=-1; //TODO verify correctness of this line
                if (iSideBuff[sb]->isFree()==false && iSideBuff[sb]->getExpiratio
      n() <= cycle) {//Drain SB
                        if (iSideBuff[sb]->getExpiration() == cycle) 
      numOnSideBuffs--;
                        if (iSideBuff[sb]->NumElements() > 0) {
                                for (int i = 0; i < iSideBuff[sb]->NumElements();
       i++) {
                                        if (iSideBuff[sb]->Nth(i)->isReady(cycle)
       == true) {
                                                //TODO how many dependencies inst
      ructions 
                                                //have at this point? 1 hopefully
      ?
                                                iSideBuff[sb]->Nth(i)->setStatus(
      sideReady,-1,-1);
                                                //if (iSideBuff[sb]->Nth(i)->getM
      emAddr() == 140735928907336) printf("GOT in SB1%s, cycle=%d, size=%d\n",iSideBuff
      [sb]->Nth(i)->getCmdStr(),cycle,iSideBuff[sb]->NumElements());
                                                iResStation->Append(iSideBuff[sb]
      ->Nth(i));
                                                //iWinWalkIndx = -1;
                                                iSideBfWalkIndx[sb] = i;
                                        } else {
                                                //depFailinSideBuf++;
                                                break; //in-order side buff
                                        }
                                }
                        } else {
                                iSideBuff[sb]->setFree();
                                iSideBuff[sb]->setExpiration(-1);
                                SBpriorityList->RemoveAt(indx);
                        }
                }
        }

        //Transfer to Reservation Station
        /*-----STAT-----*/
        if (numOnSideBuffs == 0) {totSBoffCycles++;}
        /*-----STAT-----*/
        //Updaate the fetch list
        //printf("1)iWin/iSB/RS size = %d,%d,%d,|%s|,%d,%d|%d\n", iWindow->NumEle
      ments(), iSideBuff[0]->NumElements(),iResStation->NumElements(),iResStation->Nth(
      0)->getCmdStr(),iResStation->Nth(0)->getInsID(),iResStation->Nth(0)->getType(),cy
      cle);
        if (iWinWalkIndx >=0 ) {
               for (int i = iWinWalkIndx; i >= 0; i--) {
                if (iWindow->Nth(i)->getStatus() == ready ||
                    iWindow->Nth(i)->getStatus() == sideBuffer)
                        iWindow->RemoveAt(i);
               }
        }
        //printf("here\n");
        for (int indx = 0; indx < SBpriorityList->NumElements(); indx++) {
                int sb = SBpriorityList->Nth(indx);
                //printf("sb = %d,%d\n",sb,iSideBfWalkIndx[sb]);
                if (iSideBfWalkIndx[sb] >= 0 && iSideBuff[sb]->NumElements()!=0) 
      {
                       for (int i = iSideBuff[sb]->NumElements()-1; i >= 0; i--) 
      {
                                if (iSideBuff[sb]->Nth(i)->getStatus() == 
      sideReady)
                                        iSideBuff[sb]->RemoveAt(i);
                       }
                }
                /*-----STAT-----*/
                iSideBufSize  += iSideBuff[sb]->NumElements();
                /*-----STAT-----*/
        }
        //printf("2)iWin/iSB/RS size = %d,%d,%d,|%s|,%d,%d|%d\n", iWindow->NumEle
      ments(), iSideBuff[0]->NumElements(),iResStation->NumElements(),iResStation->Nth(
      0)->getCmdStr(),iResStation->Nth(0)->getInsID(),iResStation->Nth(0)->getType(),cy
      cle);
        
        //printf("iWin/iSB/RS size = %d,%d,%d,%s|%s|%s,%d\n", iWindow->NumElement
      s(), iSideBuff->NumElements(),iResStation->NumElements(),iWindow->Nth(0)->getCmdS
      tr(),iSideBuff[0].Nth(0)->getCmdStr(),iSideBuff[1].Nth(0)->getCmdStr(),  iResStat
      ion->Nth(0)->getStatus());
        //printf("iWin/iSB/RS size = %d,%d,%d,|%s|,%d\n", iWindow->NumElements(),
       iSideBuff->NumElements(),iResStation->NumElements(),iResStation->Nth(0)->getCmdS
      tr(),iResStation->Nth(0)->getType());
        //printf("%d, %d, %d, %d\n", iWindow->NumElements(), iSideBuff[0]->NumEle
      ments(),iSideBuff[1]->NumElements(),iResStation->NumElements());
        /*-----STAT-----*/
        if (iResStation->NumElements() == 0) emptyResStation++;
        iWinSize      += iWindow->NumElements();
        iROBSize      += iROB->NumElements();
        iResStnSize   += iResStation->NumElements();
        Assert(iSideBuff[0]->NumElements() >= 0 && 
              iWindow->NumElements() >= 0 &&
              iROB->NumElements() >= 0 &&
              iResStation->NumElements() >= 0);
        /*-----STAT-----*/
        //Check resource availability & execute ins
        while (iResStation->NumElements() > 0) {
        //printf("3)iWin/iSB/RS size = %d,%d,%d,|%s|,%d,%d|%d\n", iWindow->NumEle
      ments(), iSideBuff[0]->NumElements(),iResStation->NumElements(),iResStation->Nth(
      0)->getCmdStr(),iResStation->Nth(0)->getInsID(),iResStation->Nth(0)->getType(),cy
      cle);
               int prevInsCount = insCount;
               for (int i = 0; i < NUM_FUNC_UNIT; i++) {
                        if (aluAvail[i]==true) {
                                //printf("size of iResStation = %d\n", iResStatio
      n->NumElements());
                                if (aluKind[i] == MEM && iResStation->Nth(0)->
      getType() == MEM) {
                                        //Implementing two MEM issue per cycle (t
      wo mem units)
                                        aluAvail[i] = false;
                                        instruction* ins = iResStation->Nth(0);
                                        if (ins->getMemType() == READ) {
                                                long int insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                int latency = 0;
                                                int completeCycle = 0;
                                                //Non-blocking Load Op
                                                if (inFlightLDops.count(insAddr) 
      > 0) {
                                                        latency = inFlightLDops.f
      ind(insAddr)->second - cycle;
                                                        executeIns(ins, cycle, la
      tency);
                                                        getLatency(0,latency); //
      Gen hit latency stat
                                                        completeCycle = cycle+lat
      ency;
                                                } else {
                                                        latency = findLatency(ins
      );
                                                        executeIns(ins, cycle, la
      tency);
                                                        completeCycle = cycle+lat
      ency;
                                                        insAddr = ins->
      getMemAddr() >> (BLOCK_OFFSET+WORD_OFFSET);
                                                        inFlightLDops.insert(pair
      <long int,int>(insAddr,completeCycle));
                                                }
                                                //X Level Deep Activation
                                                Assert (latency > 0 && completeCy
      cle > 0);
                                                if (latency > xLevDeepLatLevel) {
      
                                                        //Find ONE free side-buff
      er
                                                        if (ins->getStatus() == 
      sideReady) {
                                                                int sb = ins->
      getSideBuffNum();
                                                                iSideBuff[sb]->
      setBusy();
                                                                numOnSideBuffs++;
      
                                                                /*-----STAT-----*
      /
                                                                
      totNumSBactivations++;
                                                                numSBactivations[
      sb]++;
                                                                /*-----STAT-----*
      /
                                                                for (int i = 0; i
       < SBpriorityList->NumElements(); i++) {
                                                                        if (
      SBpriorityList->Nth(i) == sb) {
                                                                                
      SBpriorityList->RemoveAt(i);
                                                                                /
      *-----STAT-----*/
                                                                                
      totNumSBreactivations++;
                                                                                
      numSBreactivations[sb]++;
                                                                                /
      *-----STAT-----*/
                                                                                b
      reak;
                                                                        }
                                                                }
                                                                ins->
      notifyAllDepGoToSideBuff(sb,ins->getInsID(),numSideBuffs);
                                                                iSideBuff[sb]->
      setExpiration(completeCycle);
                                                                SBpriorityList->
      Append(sb);//SB Access Prioriyt list
                                                                Assert(sb >= 0 &&
       sb < numSideBuffs);
                                                                Assert(
      SBpriorityList->NumElements() >= 0 &&
                                                                       
      SBpriorityList->NumElements() <= numSideBuffs);
                                                        } else {
                                                                for (int sb = 0; 
      sb < numSideBuffs; sb++) {
                                                                        if (
      iSideBuff[sb]->isFree() == true) {
                                                                                
      iSideBuff[sb]->setBusy();
                                                                                
      numOnSideBuffs++;
                                                                                /
      *-----STAT-----*/
                                                                                
      totNumSBactivations++;
                                                                                
      numSBactivations[sb]++;
                                                                                /
      *-----STAT-----*/
                                                                                i
      ns->notifyAllDepGoToSideBuff(sb,ins->getInsID(),numSideBuffs);
                                                                                
      iSideBuff[sb]->setExpiration(completeCycle);
                                                                                
      SBpriorityList->Append(sb);//SB Access Prioriyt list
                                                                                
      Assert(sb >= 0 && sb < numSideBuffs);
                                                                                
      Assert(SBpriorityList->NumElements() >= 0 &&
                                                                                 
            SBpriorityList->NumElements() <= numSideBuffs);
                                                                                b
      reak;
                                                                        }
                                                                }
                                                        }
                                                }
                                        } else if (ins->getMemType() == WRITE) {
                                                //printf("mem write %d\n", ins->g
      etInsID());
                                                int latency = findLatency(ins);
                                                executeIns(ins, cycle, latency);
                                        } else {
                                                Assert(ins->getMemType() == 
      WRITE || ins->getMemType() == READ);
                                        }
                                        aluFreeTime[i] = cycle+1;//non-blocking L
      D/ST
                                        //printf("mem removed %d\n", ins->getInsI
      D());
                                        iResStation->RemoveAt(0);
                                        /*-----STAT-----*/
                                        for (int i = 0; i < numSideBuffs; i++) {
                                                if (iSideBuff[i]->isFree()==false
       && iSideBuff[i]->getExpiration() > cycle) {
                                                        InsCountWhenSBon[i]++;
                                                        totInsCountWhenSBon++;
                                                }
                                        }
                                        /*-----STAT-----*/
                                        break;
                                } else if (aluKind[i] == ALU && 
                                           (iResStation->Nth(0)->getType() == 
      ALU ||
                                           iResStation->Nth(0)->getType() == FPU)
      ) {
                                        aluAvail[i] = false;
                                        instruction* ins = iResStation->Nth(0);
                                        int latency = findLatency(ins);
                                        executeIns(ins, cycle, latency);
                                        aluFreeTime[i] = cycle+latency;
                                        //printf("removed %d\n", ins->getInsID())
      ;
                                        iResStation->RemoveAt(0);
                                        /*-----STAT-----*/
                                        for (int i = 0; i < numSideBuffs; i++) {
                                                if (iSideBuff[i]->isFree()==false
       && iSideBuff[i]->getExpiration() > cycle) {
                                                        InsCountWhenSBon[i]++;
                                                        totInsCountWhenSBon++;
                                                }
                                        }
                                        /*-----STAT-----*/
                                        break;
                                }
                        }
               }
               if (insCount-prevInsCount == 0) {break;} //in-order issue struct h
      azard
        }
        /*-----STAT-----*/
        inFlightLDopsSize += inFlightLDops.size();
        /*-----STAT-----*/
        //printf("5)iWin/iSB/RS size = %d,%d,%d,|%s|,%d,%d|%d\n", iWindow->NumEle
      ments(), iSideBuff[0]->NumElements(),iResStation->NumElements(),iResStation->Nth(
      0)->getCmdStr(),iResStation->Nth(0)->getInsID(),iResStation->Nth(0)->getType(),cy
      cle);
        delete [] iSideBfWalkIndx;
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a62811b6c8089a0b9969bcfa219fe4326}{
\index{bkEnd.cpp@{bkEnd.cpp}!scheduleInsInFlight@{scheduleInsInFlight}}
\index{scheduleInsInFlight@{scheduleInsInFlight}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{scheduleInsInFlight}]{\setlength{\rightskip}{0pt plus 5cm}void scheduleInsInFlight (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ int $>$ $\ast$}]{SBlist, }
\item[{{\bf List}$<$ int $>$ $\ast$}]{delList, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iWindow, }
\item[{int}]{top, }
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a62811b6c8089a0b9969bcfa219fe4326}

\begin{DoxyCode}
                                                                                 
                                      {
        while (SBlist->NumElements() > 0) {
                int bottom = SBlist->Nth(0); //findBottom(iWindow, SBlist); //TOD
      O this is inaccurate
                bool swapped = false;
                //if (bottom >= top) break; //TODO do I need it... is it correct?
      
                //printf("SB: %d\n",SBlist->Nth(0));
                //printf("bottom %d, top %d\n", bottom, top);
                for (int j =  bottom+1; j <= top; j++) {
                        //Assert (j > SBlist->Nth(0));
                        bool result = checkAncestor(iWindow->Nth(j),bottom,j,
      iWindow);
                        if (result == true) {
                                //printf("hi %d\n",j);
                                swap(iWindow,j,SBlist->Nth(0));
                                swapped = true;
                                SBlist->Append(j);
                                break;
                        }
                }
                //printf("hiii %d\n",SBlist->NumElements());
                if (swapped == false) {
                        delList->Append(SBlist->Nth(0));
                        SBlist->RemoveAt(0);
                } else {
                        SBlist->RemoveAt(0);
                        quicksort(SBlist,0,SBlist->NumElements()-1,cycle);
                }
        }
        quicksort(delList,0,delList->NumElements()-1,cycle);
        for (int i = delList->NumElements()-1; i >= 0; i--) {
                //printf("%d\n",delList->Nth(i));
                iWindow->RemoveAt(delList->Nth(i));
        }
        while (delList->NumElements() > 0) {
                delList->RemoveAt(0);
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_ae65f5a08a89109ce2afb34faaf30edac}{
\index{bkEnd.cpp@{bkEnd.cpp}!setupNewIns@{setupNewIns}}
\index{setupNewIns@{setupNewIns}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{setupNewIns}]{\setlength{\rightskip}{0pt plus 5cm}int setupNewIns (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_ae65f5a08a89109ce2afb34faaf30edac}

\begin{DoxyCode}
                                   {
        int rt=-1;
        ADDRS addr, insAddr;
        long int memAccessSize;
        long int r=-1;
        long int brTaken = -1;
        double missRate;
        char cTemp[INS_STRING_SIZE], c[INS_STRING_SIZE];
        //if (fgets (c, INS_STRING_SIZE, pinFile) == NULL) return -1; //EOF
        if (ICQ->NumElements() == 0) return -1; //EOC
        strcpy(c, ICQ->Nth(0));
        Assert(c[0] != 'z');
        strcpy (cTemp, c);
        ins->setBrMode(branchMode);
        //if (debug) printf ("%s", c);
        switch (c[0]) {
                case 'A':  
                        //printf ("%s", c);
                        ins->setCmdStr(cTemp);
                        resetInput (c, 0);
                        ins->setType(ALU);
                        insAddr = getAddr(c); //getANumber(c);
                        if (insAddr == 0) {
                                printf("WARNING: Instruction address corrupttion.
       Skipping %s\n", cTemp);
                                corruptInsCount++;
                                return -2;
                        } else {
                                ins->setInsAddr(insAddr);
                        }
                        if (makePhrase == true || parseHitMiss == 1) {
                                missRate = (double)getANumber(c)/(double)COEFF;
                                //Do nothing productive!
                        }
                        while (rt != 0) {
                            r = getReg(c);
                            rt = getRegType(c);
                            //if (debug) printf("r = %ld, rt = %d\n", r,rt);
                            //if (rt > 0 && rt < 3 && r > 0 && r < RF->getNumberO
      fRegs()+1) {ins->setRegister(&r, &rt);}
                            //if (rt > 0 && rt < 3 && r > 0 && r < NUM_REGISTERS)
       {ins->setRegister(&r, &rt);}
                            if (rt > 0 && rt < 3 && (r > 0  || r < -99)) {ins->
      setRegister(&r, &rt);}  
                            else if (rt == -3 || r == -3) {break;} //reached the 
      end of line
                            else {
                                        if (debug) printf("WARNING: Instruction C
      orruption. Skipping %s\n",cTemp);
                                        corruptInsCount++;
                                return -2;
                            }
                        }
                        ins->setPiepelineLat(ALU_LATENCY);
                        break;
                case 'F':
                        //printf ("%s", c);
                        ins->setCmdStr(cTemp);
                        resetInput (c, 0);
                        ins->setType(FPU);
                        insAddr = getAddr(c); //getANumber(c);
                        if (insAddr == 0) {
                                printf("WARNING: Instruction address corrupttion.
       Skipping %s\n", cTemp);
                                corruptInsCount++;
                                return -2;
                        } else {
                                ins->setInsAddr(insAddr);
                        }
                        if (makePhrase == true || parseHitMiss == 1) {
                                missRate = (double)getANumber(c)/(double)COEFF;
                                //Do nothing productive!
                        }
                        while (rt != 0) {
                            r = getReg(c);
                            rt = getRegType(c);
                            //if (debug) printf("r = %d, rt = %d\n", r,rt);
                            //if (rt > 0 && rt < 3 && r > 0 && r < RF->getNumberO
      fRegs()+1) {ins->setRegister(&r, &rt);}
                            //if (rt > 0 && rt < 3 && r > 0 && r < NUM_REGISTERS)
       {ins->setRegister(&r, &rt);}
                            if (rt > 0 && rt < 3 && (r > 0 || r < -99)) {ins->
      setRegister(&r, &rt);}
                            else if (rt == -3 || r == -3) {break;} //reached the 
      end of line
                            else {
                            if (debug) printf("WARNING: Instruction Corruption. S
      kipping %s\n",cTemp);
                                        corruptInsCount++;
                                return -2;
                            }
                        }
                        ins->setPiepelineLat(FPU_LATENCY);
                        break;
                case 'B':  
                        //printf ("%s", c);
                        ins->setCmdStr(cTemp);
                        resetInput (c, 0);
                        ins->setType(BR);
                insAddr = getAddr(c); //getANumber(c);
                if (insAddr == 0) {
                                printf("WARNING: Instruction address corrupttion.
       Skipping %s\n", cTemp);
                                corruptInsCount++;
                        return -2;
                } else {
                                ins->setInsAddr(insAddr);
                        }
                        if (branchBiasProfileMap.find(insAddr) != 
      branchBiasProfileMap.end()) {
                                ins->setBrBias(branchBiasProfileMap[insAddr]);
                        }
                        if (branchAccuracyMap.find(insAddr) != branchAccuracyMap.
      end()) {
                                ins->setBrAccuracy(branchAccuracyMap[insAddr]);
                        } else {
                                missingAccuracyBranches.insert(ins->getInsAddr())
      ;
                        }
                ins->setBrSide(getANumber(c));
                        brTaken = getANumber(c);
                        if (brTaken == 0) {
                                printf("WARNING: Instruction Corruption. Skipping
       %s\n",cTemp);
                                corruptInsCount++;
                                return -2;
                        } else {
                                ins->setBrTarget(brTaken);
                        }
                        ins->setBrForward();
                        bool missPred;
                        void *bp_hist;
                        bp_hist = NULL;
                        bool prediction;
                        prediction = Predict((uint64_t)ins->getInsAddr(), bp_hist
      );
                        if(prediction != ins->getBrSide())
                                missPred = true; //mis-prediction
                        else
                                missPred = false; //correct-prediction
                        Assert(bp_hist != NULL);
                        ins->setPredHistObj(bp_hist);
                        ins->setPrediction(prediction);
                        ins->findMissPrediction(missPred);
                        if (makePhrase == true || parseHitMiss == 1) {
                                missRate = (double)getANumber(c)/(double)COEFF;
                                //Do nothing productive!
                        }
                        while (rt != 0) {
                            r = getReg(c);
                            rt = getRegType(c);
                            //if (debug) printf("r = %d, rt = %d\n", r,rt);
                            //if (rt > 0 && rt < 3 && r > 0 && r < RF->getNumberO
      fRegs()+1) {ins->setRegister(&r, &rt);}
                            //if (rt > 0 && rt < 3 && r > 0 && r < NUM_REGISTERS)
       {ins->setRegister(&r, &rt);}
                            if (rt > 0 && rt < 3 && r > 0) {ins->setRegister(&r, 
      &rt);}
                            else if (rt == -3 || r == -3) {break;} //reached the 
      end of line
                            else {
                                if (debug) printf("WARNING: Instruction Corruptio
      n. Skipping %s\n",cTemp);
                                        corruptInsCount++;
                                return -2;
                            }
                        }
                        if (branchMode == statPredBr) {
                                if (ins->getPrediction() == true) 
      numBrOps_predT_fetch++;
                                if (ins->getMissPrediction()==true)  {//Static br
      anch prediction
                                        ins->setPiepelineLat(BR_LATENCY);
                                        missPredBROps_fetch++;
                                        if (prediction == false) 
      missPredBROps_NT_fetch++;
                                } else {
                                        ins->setPiepelineLat(ALU_LATENCY);
                                }
                        } else if (branchMode == dynPredBr) {
                                if (ins->getPrediction() == true) 
      numBrOps_predT_fetch++;
                                if (ins->getMissPrediction()==true)  {//Dynamic b
      ranch prediction
                                        ins->setPiepelineLat(BR_LATENCY); //laten
      cy from zsim
                                        missPredBROps_fetch++;
                                        if (prediction == false) 
      missPredBROps_NT_fetch++;
                                } else {
                                        ins->setPiepelineLat(ALU_LATENCY);
                                }
                        } else if (branchMode == scheduleBr || branchMode == 
      noBr) {
                                ins->setPiepelineLat(ALU_LATENCY);
                        } else {
                                ins->setPiepelineLat(BR_LATENCY);
                        }
                        break;
        case 'R':  
                        //printf ("%s", c);
                        ins->setCmdStr(cTemp);
                resetInput (c, 0);
                ins->setType(MEM);
                ins->setMemType(READ);
                addr = getAddr(c);
                insAddr = getAddr(c); //getANumber(c);
                        memAccessSize= getANumber(c);
                if (addr == 0 || insAddr == 0 || memAccessSize == 0) {
                                printf("WARNING: Instruction address corrupttion.
       Skipping %s\n", cTemp);
                                corruptInsCount++;
                        return -2;
                } else {
                                ins->setMemAddr(addr);
                                ins->setInsAddr(insAddr);
                                ins->setMemAccessSize(memAccessSize);
                        }
                        if (makePhrase == true || parseHitMiss == 1) {
                                missRate = (double)getANumber(c)/(double)COEFF;
                                ins->setMissRate(missRate);
                        }
                while (rt != 0) {
                    r  = getReg(c);
                    rt = getRegType(c);
                    //if (debug) printf("r = %ld, rt = %d\n", r,rt);
                    //if (rt > 0 && rt < 3 && r > 0 && r < RF->getNumberOfRegs()+
      1) {ins->setRegister(&r, &rt);}
                    //if (rt > 0 && rt < 3 && r > 0 && r < NUM_REGISTERS) {ins->s
      etRegister(&r, &rt);}
                    if ((rt > 0 && rt < 3) && (r > 0 || r < -99)) {ins->
      setRegister(&r, &rt);}
                    else if (rt == -3 || r == -3) {break;} //reached the end of l
      ine
                    else { //when r = -2  or -1 or ...
                        if (debug) printf("WARNING: Instruction reg MAY BE corrup
      t. Skipping %s\n", cTemp);
                                        corruptInsCount++;
                                return -2;
                    }
                    if (rt == -1) break; //nothing was set!
                }
                        ins->setPiepelineLat(cacheLat[0]);
                break;
        case 'W':  
                //printf ("%s", c);
                        ins->setCmdStr(cTemp);
                resetInput (c, 0);
                ins->setType(MEM);
                ins->setMemType(WRITE);
                addr = getAddr(c);
                insAddr = getAddr(c); //getANumber(c);
                        memAccessSize = getANumber(c);
                if (addr == 0 || insAddr == 0 || memAccessSize == 0) {
                                printf("WARNING: Instruction address corrupttion.
       Skipping %s\n", cTemp);
                                corruptInsCount++;
                        return -2;
                } else {
                                ins->setMemAddr(addr);
                                ins->setInsAddr(insAddr);
                                ins->setMemAccessSize(memAccessSize);
                        }
                        if (makePhrase == true || parseHitMiss == 1) {
                                missRate = (double)getANumber(c)/(double)COEFF;
                                ins->setMissRate(missRate);
                        }
                while (rt != 0) {
                    r  = getReg(c);
                    rt = getRegType(c);
                    //if (debug) printf("r = %d, rt = %d\n", r,rt);
                    //if (rt > 0 && rt < 3 && r > 0 && r < RF->getNumberOfRegs()+
      1) {ins->setRegister(&r, &rt);}
                    //if (rt > 0 && rt < 3 && r > 0 && r < NUM_REGISTERS) {ins->s
      etRegister(&r, &rt);}
                    if (rt > 0 && rt < 3 && r > 0) {ins->setRegister(&r, &rt);}
                    else if (rt == -3 || r == -3) {break;} //reached the end of l
      ine
                    else { //when r = -2  or -1 or ...
                        if (debug) printf("WARNING: Instruction reg MAY BE corrup
      t. Skipping %s\n", cTemp);
                                        corruptInsCount++;
                                        return -2;
                    }
                    if (rt == -1) break; //nothing was set!
                }
                        ins->setPiepelineLat(cacheLat[0]);
                break;
                case 'T':  
                        //printf ("%s", c);
                        ins->setCmdStr(cTemp);
                        resetInput (c, 0);
                        ins->setType(ASSIGN);
                        insAddr = getAddr(c); //getANumber(c);
                        if (insAddr == 0) {
                                printf("WARNING: Instruction address corrupttion.
       Skipping %s\n", cTemp);
                                corruptInsCount++;
                                return -2;
                        } else {
                                ins->setInsAddr(insAddr);
                        }
                        if (makePhrase == true || parseHitMiss == 1) {
                                missRate = (double)getANumber(c)/(double)COEFF;
                                //Do nothing productive!
                        }
                        while (rt != 0) {
                            r = getReg(c);
                            rt = getRegType(c);
                            //if (debug) printf("r = %d, rt = %d\n", r,rt);
                            //if (rt > 0 && rt < 3 && r > 0 && r < RF->getNumberO
      fRegs()+1) {ins->setRegister(&r, &rt);}
                            //if (rt > 0 && rt < 3 && r > 0 && r < NUM_REGISTERS)
       {ins->setRegister(&r, &rt);}
                            if (rt > 0 && rt < 3 && (r > 0 || r < -99)) {ins->
      setRegister(&r, &rt);}
                            else if (rt == -3 || r == -3) {break;} //reached the 
      end of line
                            else {
                                if (debug) printf("WARNING: Instruction Corruptio
      n. Skipping %s\n",cTemp);
                                        corruptInsCount++;
                                return -2;
                            }
                        }
                        ins->setPiepelineLat(ASSIGN_LATENCY);
                        break;
                case '{':
                        if (debug) printf("WARNING: Unrecognized Instruction. Ski
      pping (%s)\n", cTemp);
                        return -2;
                case '}':
                        if (debug) printf("WARNING: Unrecognized Instruction. Ski
      pping (%s)\n", cTemp);
                        return -2;
                case 'H':
                        if (debug) printf("WARNING: Unrecognized Instruction. Ski
      pping (%s)\n", cTemp);
                        return -2;
                default:
                        if (debug) printf("WARNING: Unrecognized Instruction. Ski
      pping (%s)\n", cTemp);
                        corruptInsCount++;
                        return -2;
        };
        return 0; //Successful completion (TODO: fix return values)
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_ab5a65ee867edd1ec1db1265dd7ca57d2}{
\index{bkEnd.cpp@{bkEnd.cpp}!setupNewInsV2@{setupNewInsV2}}
\index{setupNewInsV2@{setupNewInsV2}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{setupNewInsV2}]{\setlength{\rightskip}{0pt plus 5cm}int setupNewInsV2 (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins, }
\item[{char $\ast$}]{c}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_ab5a65ee867edd1ec1db1265dd7ca57d2}


if (debug) printf(\char`\"{}ins addr: \%llu$\backslash$n\char`\"{}, insAddr); 


\begin{DoxyCode}
                                              {
        int rt=-1;
        ADDRS addr; ADDRS insAddr;
        long int memAccessSize;
        long int r=-1;
        long int brTaken = -1;
        char cTemp[INS_STRING_SIZE];
        strcpy (cTemp, c);
        // if (debug) printf ("%s", c);
        float missRate;
        ins->setBrMode(branchMode);
        switch (c[0]) {
                case 'A':  
                        //printf ("%s", c);
                        ins->setCmdStr(cTemp);
                        resetInput (c, 0);
                        ins->setType(ALU);
                        insAddr = getAddr(c); //getANumber(c);
                        if (insAddr == 0) {
                                printf("WARNING: Instruction address corrupttion.
       Skipping %s\n", cTemp);
                                corruptInsCount++;
                                return -2;
                        } else {
                                ins->setInsAddr(insAddr);
                        }
                        if (makePhrase == true || parseHitMiss == 1) {
                                missRate = (double)getANumber(c)/(double)COEFF;
                                //Do nothing productive!
                        }
                        while (rt != 0) {
                            r = getReg(c);
                            rt = getRegType(c);
                            //if (debug) printf("r = %d, rt = %d\n", r,rt);
                            //if (rt > 0 && rt < 3 && r > 0 && r < RF->getNumberO
      fRegs()+1) {ins->setRegister(&r, &rt);}
                            //if (rt > 0 && rt < 3 && r > 0 && r < NUM_REGISTERS)
       {ins->setRegister(&r, &rt);}
                            if (rt > 0 && rt < 3 && (r > 0 || r < -99)) {ins->
      setRegister(&r, &rt);}
                            else if (rt == -3 || r == -3) {break;} //reached the 
      end of line
                            else {
                            if (debug) printf("WARNING: Instruction Corruption. S
      kipping %s\n",cTemp);
                                        corruptInsCount++;
                                return -2;
                            }
                        }
                        ins->setPiepelineLat(ALU_LATENCY);
                        break;
                case 'F':
                        //printf ("%s", c);
                        ins->setCmdStr(cTemp);
                        resetInput (c, 0);
                        ins->setType(FPU);
                        insAddr = getAddr(c); //getANumber(c);
                        if (insAddr == 0) {
                                printf("WARNING: Instruction address corrupttion.
       Skipping %s\n", cTemp);
                                corruptInsCount++;
                                return -2;
                        } else {
                                ins->setInsAddr(insAddr);
                        }
                        if (makePhrase == true || parseHitMiss == 1) {
                                missRate = (double)getANumber(c)/(double)COEFF;
                                //Do nothing productive!
                        }
                        while (rt != 0) {
                            r = getReg(c);
                            rt = getRegType(c);
                            //if (debug) printf("r = %d, rt = %d\n", r,rt);
                            //if (rt > 0 && rt < 3 && r > 0 && r < RF->getNumberO
      fRegs()+1) {ins->setRegister(&r, &rt);}
                            //if (rt > 0 && rt < 3 && r > 0 && r < NUM_REGISTERS)
       {ins->setRegister(&r, &rt);}
                            if (rt > 0 && rt < 3 && (r > 0 || r < -99)) {ins->
      setRegister(&r, &rt);}
                            else if (rt == -3 || r == -3) {break;} //reached the 
      end of line
                            else {
                            if (debug) printf("WARNING: Instruction Corruption. S
      kipping %s\n",cTemp);
                                        corruptInsCount++;
                                return -2;
                            }
                        }
                        ins->setPiepelineLat(FPU_LATENCY);
                        break;
                case 'B':  
                        //printf ("%s", c);
                        ins->setCmdStr(cTemp);
                        resetInput (c, 0);
                        ins->setType(BR);
                insAddr = getAddr(c); //getANumber(c);
                if (insAddr == 0) {
                                printf("WARNING: Instruction address corrupttion.
       Skipping %s\n", cTemp);
                                corruptInsCount++;
                        return -2;
                } else {
                                ins->setInsAddr(insAddr);
                        }
                        if (branchBiasProfileMap.find(insAddr) != 
      branchBiasProfileMap.end()) {
                                ins->setBrBias(branchBiasProfileMap[insAddr]);
                        }
                        if (branchAccuracyMap.find(insAddr) != branchAccuracyMap.
      end()) {
                                ins->setBrAccuracy(branchAccuracyMap[insAddr]);
                        } else {
                                missingAccuracyBranches.insert(ins->getInsAddr())
      ;
                        }
                ins->setBrSide(getANumber(c));
                        brTaken = getANumber(c);
                        if (brTaken == 0) {
                                printf("WARNING: Instruction Corruption. Skipping
       %s\n",cTemp);
                                corruptInsCount++;
                                return -2;
                        } else {
                                ins->setBrTarget(brTaken);
                        }
                        ins->setBrForward();
                        bool missPred;
                        missPred = isMisPrePredicted(bbPrediction, ins->
      getBrSide());
                        //if (ins->getBrSide() == true)
                        //      missPred = Predict((uint64_t)ins->getInsAddr(), 1
      );
                        //      //missPred = PredictAndUpdate((uint64_t)ins->getI
      nsAddr(), 1);
                        //else
                        //      missPred = Predict((uint64_t)ins->getInsAddr(), 0
      );
                        //      //missPred = PredictAndUpdate((uint64_t)ins->getI
      nsAddr(), 0);
                        //ins->setPredHistObj(bp_hist_list->Nth(0));
                        //bp_hist_list->RemoveAt(0);
                        //ins->setPrediction(bbPrediction);
                        ins->findMissPrediction(missPred);
                        if (makePhrase == true || parseHitMiss == 1) {
                                missRate = (double)getANumber(c)/(double)COEFF;
                                //Do nothing productive!
                        }
                        while (rt != 0) {
                            r = getReg(c);
                            rt = getRegType(c);
                            //if (debug) printf("r = %d, rt = %d\n", r,rt);
                            //if (rt > 0 && rt < 3 && r > 0 && r < RF->getNumberO
      fRegs()+1) {ins->setRegister(&r, &rt);}
                            //if (rt > 0 && rt < 3 && r > 0 && r < NUM_REGISTERS)
       {ins->setRegister(&r, &rt);}
                            if (rt > 0 && rt < 3 && r > 0) {ins->setRegister(&r, 
      &rt);}
                            else if (rt == -3 || r == -3) {break;} //reached the 
      end of line
                            else {
                                if (debug) printf("WARNING: Instruction Corruptio
      n. Skipping %s\n",cTemp);
                                        corruptInsCount++;
                                return -2;
                            }
                        }
                        if (branchMode == statPredBr) {
                                if (ins->getPrediction() == true) 
      numBrOps_predT_fetch++;
                                if (ins->getMissPrediction()==true)  {//Static br
      anch prediction
                                        ins->setPiepelineLat(BR_LATENCY);
                                        missPredBROps_fetch++;
                                        if (ins->getPrediction() == false) 
      missPredBROps_NT_fetch++;
                                } else {
                                        ins->setPiepelineLat(ALU_LATENCY);
                                }
                        } else if (branchMode == dynPredBr) {
                                if (ins->getPrediction() == true) 
      numBrOps_predT_fetch++;
                                if (ins->getMissPrediction()==true)  {//Static br
      anch prediction
                                        ins->setPiepelineLat(BR_LATENCY); //laten
      cy from zsim
                                        missPredBROps_fetch++;
                                        if (ins->getPrediction() == false) 
      missPredBROps_NT_fetch++;
                                } else {
                                        ins->setPiepelineLat(ALU_LATENCY);
                                }
                        } else if (branchMode == scheduleBr || branchMode == 
      noBr) {
                                ins->setPiepelineLat(ALU_LATENCY);
                        } else {
                                ins->setPiepelineLat(BR_LATENCY);
                        }
                        break;
        case 'R':  
                //printf ("%s", c);
                        ins->setCmdStr(cTemp);
                resetInput (c, 0);
                ins->setType(MEM);
                ins->setMemType(READ);
                addr = getAddr(c);
                insAddr = getAddr(c); //getANumber(c);
                        memAccessSize = getANumber(c);
                if (addr == 0 || insAddr == 0) {
                                printf("WARNING: Instruction address corrupttion.
       Skipping %s\n", cTemp);
                                corruptInsCount++;
                        return -2;
                } else {
                                ins->setMemAddr(addr);
                                ins->setInsAddr(insAddr);
                        }
                        if (makePhrase == true || parseHitMiss == 1) {
                                missRate = (double)getANumber(c)/(double)COEFF;
                                ins->setMissRate(missRate);
                        }
                while (rt != 0) {
                    r  = getReg(c);
                    rt = getRegType(c);
                    //if (debug) printf("r = %d, rt = %d\n", r,rt);
                    //if (rt > 0 && rt < 3 && r > 0 && r < RF->getNumberOfRegs()+
      1) {ins->setRegister(&r, &rt);}
                    //if (rt > 0 && rt < 3 && r > 0 && r < NUM_REGISTERS) {ins->s
      etRegister(&r, &rt);}
                    if (rt > 0 && rt < 3 && (r > 0 || r < -99)) {ins->
      setRegister(&r, &rt);}
                    else if (rt == -3 || r == -3) {break;} //reached the end of l
      ine
                    else { //when r = -2  or -1 or ...
                        //if (debug) 
                                        printf("WARNING: Instruction reg MAY BE c
      orrupt. Skipping %s\n", cTemp);
                                        corruptInsCount++;
                                return -2;
                    }
                    if (rt == -1) break; //nothing was set!
                }
                        ins->setPiepelineLat(cacheLat[0]);
                break;
        case 'W':  
                //printf ("%s", c);
                        ins->setCmdStr(cTemp);
                resetInput (c, 0);
                ins->setType(MEM);
                ins->setMemType(WRITE);
                addr = getAddr(c);
                insAddr = getAddr(c); //getANumber(c);
                        memAccessSize = getANumber(c);
                if (addr == 0 || insAddr == 0) {
                                printf("WARNING: Instruction address corrupttion.
       Skipping %s\n", cTemp);
                                corruptInsCount++;
                        return -2;
                } else {
                                ins->setMemAddr(addr);
                                ins->setInsAddr(insAddr);
                        }
                        if (makePhrase == true || parseHitMiss == 1) {
                                missRate = (double)getANumber(c)/(double)COEFF;
                                ins->setMissRate(missRate);
                        }
                while (rt != 0) {
                    r  = getReg(c);
                    rt = getRegType(c);
                    //if (debug) printf("r = %d, rt = %d\n", r,rt);
                    //if (rt > 0 && rt < 3 && r > 0 && r < RF->getNumberOfRegs()+
      1) {ins->setRegister(&r, &rt);}
                    //if (rt > 0 && rt < 3 && r > 0 && r < NUM_REGISTERS) {ins->s
      etRegister(&r, &rt);}
                    if (rt > 0 && rt < 3 && r > 0) {ins->setRegister(&r, &rt);}
                    else if (rt == -3 || r == -3) {break;} //reached the end of l
      ine
                    else { //when r = -2  or -1 or ...
                        //if (debug) 
                                        printf("WARNING: Instruction reg MAY BE c
      orrupt. Skipping %s\n", cTemp);
                                        corruptInsCount++;
                                return -2;
                    }
                    if (rt == -1) break; //nothing was set!
                }
                        ins->setPiepelineLat(cacheLat[0]);
                break;
                case 'T':  
                        //printf ("%s", c);
                        ins->setCmdStr(cTemp);
                        resetInput (c, 0);
                        ins->setType(ASSIGN);
                insAddr = getAddr(c);//getANumber(c);
                if (insAddr == 0) {
                                printf("WARNING: Instruction address corrupttion.
       Skipping %s\n", cTemp);
                                corruptInsCount++;
                        return -2;
                } else {
                                ins->setInsAddr(insAddr);
                        }
                        if (makePhrase == true || parseHitMiss == 1) {
                                missRate = (double)getANumber(c)/(double)COEFF;
                                //Do nothing productive!
                        }
                        while (rt != 0) {
                            r = getReg(c);
                            rt = getRegType(c);
                            //if (debug) printf("r = %d, rt = %d\n", r,rt);
                            //if (rt > 0 && rt < 3 && r > 0 && r < RF->getNumberO
      fRegs()+1) {ins->setRegister(&r, &rt);}
                            //if (rt > 0 && rt < 3 && r > 0 && r < NUM_REGISTERS)
       {ins->setRegister(&r, &rt);}
                            if (rt > 0 && rt < 3 && (r > 0 || r < -99)) {ins->
      setRegister(&r, &rt);}
                            else if (rt == -3 || r == -3) {break;} //reached the 
      end of line
                            else {
                                if (debug) printf("WARNING: Instruction Corruptio
      n. Skipping %s\n",cTemp);
                                        corruptInsCount++;
                                return -2;
                            }
                        }
                        ins->setPiepelineLat(ASSIGN_LATENCY);
                        break;
                default:
                        if (debug) printf("WARNING: Unrecognized Instruction. Ski
      pping (%s)\n", cTemp);
                        corruptInsCount++;
                        return -2;
        };
        return 0; //Successful completion (TODO: fix return values)
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_ab66b103fb7f2942ca9fd5379cf47893f}{
\index{bkEnd.cpp@{bkEnd.cpp}!squash@{squash}}
\index{squash@{squash}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void squash (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iROB, }
\item[{{\bf INS\_\-ID}}]{insID, }
\item[{{\bf lsq} $\ast$}]{oooLd\_\-inoSt\_\-LSQ}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_ab66b103fb7f2942ca9fd5379cf47893f}

\begin{DoxyCode}
                                                                           {
        for (int i = iROB->NumElements()-1; i >= 0; i--) {
                //Remove Ancesotor Dependencies
                iROB->Nth(i)->notifyAllAncISquashed();
                //Remove Dependency Table Elements (BR,MEM,REG)
                iROB->Nth(i)->delDepTableEntris(depTables, coreType, 
      perfectRegRen);
                //Reset Register Renaming Table
                if (!perfectRegRen && coreType != IN_ORDER) {
                        iROB->Nth(i)->squashRenameReg(GRF);
                }
                if (coreType == PHRASEBLOCK) {
                        for (int k = 0; k < NUM_PHRASEBLKS; k++) {
                                iROB->Nth(i)->delDepTableEntris_LRF(LRFTables[k],
       coreType, perfectRegRen);
                        }
                }
                getSquashRFstatForStatus(iROB->Nth(i), iROB->Nth(i)->getStatus())
      ;
                getSquashRFstat(iROB->Nth(i));
                if (iROB->Nth(i)->getType() == BR) squashBRinsCount++;
                if (insID == iROB->Nth(i)->getInsID()) break;
                //ATTENTION: Don't add code here
        }
        //Flush LSQ
        if (memoryModel == NAIVE_SPECUL) {
                squashLQinsCount += oooLD_squashLQ (loadStoreQue, insID);
                squashSQinsCount += oooLD_squashSQ (loadStoreQue, insID);
        }
        //Reset the ICQ Ins Pointer &
        //Remove Instruction from ROB
        removeFromiWindow(insID);
        removeFromiResStn (insID);
        removeFromROB (iROB, insID);
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a870d541d0ad8aae66f1b83a348dec2e2}{
\index{bkEnd.cpp@{bkEnd.cpp}!Update@{Update}}
\index{Update@{Update}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{Update}]{\setlength{\rightskip}{0pt plus 5cm}void Update (
\begin{DoxyParamCaption}
\item[{uint64\_\-t}]{\_\-\_\-pc, }
\item[{bool}]{\_\-\_\-taken, }
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a870d541d0ad8aae66f1b83a348dec2e2}

\begin{DoxyCode}
                                                           {
    bool taken = __taken;
    uint64_t pc = __pc;
    void *bp_hist = ins->getPredHistObj();
        Assert(bp_hist != NULL);
    if(ins->getPrediction() != taken) {
        predictor->update(pc, taken, bp_hist, true);
    } else {
        predictor->update(pc, taken, bp_hist, false);
    }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a3d96f03b51c73d69d52d695fc3b67751}{
\index{bkEnd.cpp@{bkEnd.cpp}!updateBBboundaries@{updateBBboundaries}}
\index{updateBBboundaries@{updateBBboundaries}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{updateBBboundaries}]{\setlength{\rightskip}{0pt plus 5cm}void updateBBboundaries (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a3d96f03b51c73d69d52d695fc3b67751}

\begin{DoxyCode}
                                          {
        //if (ins->getInsAddr() == 245515768464) printf("is header: %d\n", ins->i
      sBBhead());
        if (ins->isBBhead() && ins->isBBtail()) {
                INS_ADDR brAddr;
                brAddr = ins->getBrHeaderAddr();
                char *c1 = new char[INS_STRING_SIZE];
                char *c2 = new char[INS_STRING_SIZE];
                char *c3 = new char[INS_STRING_SIZE];
                char *c4 = new char[INS_STRING_SIZE];
                if (strcmp(ICQ->Nth(0),"{") != 0 && strcmp(ICQ->Nth(0),"{\n") != 
      0) {
                        char *c = new char[INS_STRING_SIZE];
                        strcpy(c, "{");
                        ICQ->InsertAt(c,0);
                        //printf("%s\n",ICQ->Nth(0));
                }
                strcpy(c4, "}");
                //printf("%s\n",c3);
                ICQ->InsertAt(c4,0);
                std::stringstream ss;
                strcpy(c3,ins->getCmdStr());
                //printf("%s\n",c3);
                ICQ->InsertAt(c3,0);
                //printf("%s",ICQ->Nth(0));
                ss << "H," << brAddr << "\n";
                string s = ss.str();
                strcpy(c2,s.c_str());
                //printf("%s",c2);
                ICQ->InsertAt(c2,0);
                //printf("%s\n",ICQ->Nth(0));
                strcpy(c1, "{");
                //printf("%s\n",c1);
                ICQ->InsertAt(c1,0);
                //printf("%s\n",ICQ->Nth(0));
        } else if (ins->isBBhead()) {
                //if (ins->getInsAddr() == 245515768464) printf("is header: %d, %
      llu\n", ins->isBBhead(),ins->getBrHeaderAddr());
                INS_ADDR brAddr;
                brAddr = ins->getBrHeaderAddr();
                char *c1 = new char[INS_STRING_SIZE];
                char *c2 = new char[INS_STRING_SIZE];
                char *c3 = new char[INS_STRING_SIZE];
                std::stringstream ss;
                strcpy(c3,ins->getCmdStr());
                //printf("%s\n",c3);
                ICQ->InsertAt(c3,0);
                //printf("%s",ICQ->Nth(0));
                ss << "H," << brAddr << "\n";
                string s = ss.str();
                strcpy(c2,s.c_str());
                //printf("%s",c2);
                ICQ->InsertAt(c2,0);
                //printf("%s\n",ICQ->Nth(0));
                strcpy(c1, "{");
                //printf("%s\n",c1);
                ICQ->InsertAt(c1,0);
                //printf("%s\n",ICQ->Nth(0));
        } else if (ins->isBBtail()) {
                char *c1 = new char[INS_STRING_SIZE];
                char *c2 = new char[INS_STRING_SIZE];
                if (strcmp(ICQ->Nth(0),"{") != 0 && strcmp(ICQ->Nth(0),"{\n") != 
      0) {
                        char *c = new char[INS_STRING_SIZE];
                        strcpy(c, "{");
                        //printf("%s\n",c);
                        ICQ->InsertAt(c,0);
                        //printf("%s\n",ICQ->Nth(0));
                }
                strcpy(c2, "}");
                //printf("%s\n",c2);
                ICQ->InsertAt(c2,0);
                //printf("%s\n",ICQ->Nth(0));
                strcpy(c1,ins->getCmdStr());
                //printf("%s\n",c1);
                ICQ->InsertAt(c1,0);
                //printf("%s",ICQ->Nth(0));
        } else {
                char *c = new char[INS_STRING_SIZE];
                strcpy(c,ins->getCmdStr());
                //printf("%s\n",c);
                ICQ->InsertAt(c,0);
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a40f88a65aa975103ceb5a3ca6cbab13f}{
\index{bkEnd.cpp@{bkEnd.cpp}!updateInsLatency@{updateInsLatency}}
\index{updateInsLatency@{updateInsLatency}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{updateInsLatency}]{\setlength{\rightskip}{0pt plus 5cm}void updateInsLatency (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{\_\-ins, }
\item[{int}]{\_\-cycle, }
\item[{int}]{\_\-latency}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a40f88a65aa975103ceb5a3ca6cbab13f}

\begin{DoxyCode}
                                                                    {
        Assert(_ins->getType() == MEM && "Only memory ops have unpredictable late
      ncy");
        Assert(_ins->getStatus() == execute);
        Assert(_latency >= 0);
        _ins->updateLatency(_cycle, _latency);
        //if (reportTrace == true) reportInsTiming(_ins);
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_a95df5d21c6f8468a37ead48e9bf899c7}{
\index{bkEnd.cpp@{bkEnd.cpp}!updateResStn@{updateResStn}}
\index{updateResStn@{updateResStn}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{updateResStn}]{\setlength{\rightskip}{0pt plus 5cm}void updateResStn (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iResStation, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{iWindow}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a95df5d21c6f8468a37ead48e9bf899c7}

\begin{DoxyCode}
                                                                                {
      
        int iWinWalkIndx = -1;
        for (int i = 0; i < iWindow->NumElements(); i++) {
                if (iWindow->Nth(i)->isReady(cycle) == true) {
                        iWindow->Nth(i)->setStatus(ready,-1,-1);
                        iResStation->Append(iWindow->Nth(i));
                        iWinWalkIndx = i;
                } else {
                        //printf("ins %s not ready\n", iWindow->Nth(i)->getCmdStr
      ());
                        break; //in-order issue dependency
                }
        }
        //Updaate the fetch list
        for (int i = iWinWalkIndx; i >= 0; i--) {
                if (iWindow->Nth(i)->getStatus() == ready)
                        iWindow->RemoveAt(i);
        }
}
\end{DoxyCode}
\hypertarget{bkEnd_8cpp_afff51beec397710490f251f8e36fc167}{
\index{bkEnd.cpp@{bkEnd.cpp}!upldProfileFileName@{upldProfileFileName}}
\index{upldProfileFileName@{upldProfileFileName}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{upldProfileFileName}]{\setlength{\rightskip}{0pt plus 5cm}string upldProfileFileName (
\begin{DoxyParamCaption}
\item[{\char`\"{}/home/milad/esc\_\-project/svn/memTraceMilad/TraceSim/results/hmmer/unpredictableLDs.csv\char`\"{}}]{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_afff51beec397710490f251f8e36fc167}
\hypertarget{bkEnd_8cpp_a26c1e64683b2450f033b67ba14be8a97}{
\index{bkEnd.cpp@{bkEnd.cpp}!wbb\_\-skip\_\-count@{wbb\_\-skip\_\-count}}
\index{wbb\_\-skip\_\-count@{wbb\_\-skip\_\-count}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{wbb\_\-skip\_\-count}]{\setlength{\rightskip}{0pt plus 5cm}string wbb\_\-skip\_\-count (
\begin{DoxyParamCaption}
\item[{\char`\"{}wbb\_\-skip\_\-count.csv\char`\"{}}]{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8cpp_a26c1e64683b2450f033b67ba14be8a97}


\subsection{Variable Documentation}
\hypertarget{bkEnd_8cpp_a594bdd547bbe5b3f5f4ca0429647a941}{
\index{bkEnd.cpp@{bkEnd.cpp}!\_\-\_\-g\_\-var@{\_\-\_\-g\_\-var}}
\index{\_\-\_\-g\_\-var@{\_\-\_\-g\_\-var}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{\_\-\_\-g\_\-var}]{\setlength{\rightskip}{0pt plus 5cm}{\bf g\_\-variable}$\ast$ {\bf \_\-\_\-g\_\-var}}}
\label{bkEnd_8cpp_a594bdd547bbe5b3f5f4ca0429647a941}
\hypertarget{bkEnd_8cpp_aff6a511d0f79b17fa32081abfd2b5bc6}{
\index{bkEnd.cpp@{bkEnd.cpp}!\_\-L1@{\_\-L1}}
\index{\_\-L1@{\_\-L1}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{\_\-L1}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cache}$\ast$ {\bf \_\-L1}}}
\label{bkEnd_8cpp_aff6a511d0f79b17fa32081abfd2b5bc6}
\hypertarget{bkEnd_8cpp_a36621f4e017586bf3fd070b443755da2}{
\index{bkEnd.cpp@{bkEnd.cpp}!\_\-L2@{\_\-L2}}
\index{\_\-L2@{\_\-L2}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{\_\-L2}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cache}$\ast$ {\bf \_\-L2}}}
\label{bkEnd_8cpp_a36621f4e017586bf3fd070b443755da2}
\hypertarget{bkEnd_8cpp_ad3c630a534ba16b1ffdc565033ad36ee}{
\index{bkEnd.cpp@{bkEnd.cpp}!\_\-L3@{\_\-L3}}
\index{\_\-L3@{\_\-L3}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{\_\-L3}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cache}$\ast$ {\bf \_\-L3}}}
\label{bkEnd_8cpp_ad3c630a534ba16b1ffdc565033ad36ee}
\hypertarget{bkEnd_8cpp_a8c85ae26ca2aa6181da521dfdb7626b7}{
\index{bkEnd.cpp@{bkEnd.cpp}!\_\-pbLists@{\_\-pbLists}}
\index{\_\-pbLists@{\_\-pbLists}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{\_\-pbLists}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<${\bf instruction}$\ast$$>$$\ast$$\ast$ {\bf \_\-pbLists}}}
\label{bkEnd_8cpp_a8c85ae26ca2aa6181da521dfdb7626b7}
\hypertarget{bkEnd_8cpp_a0cbaf833a38f9d2dc7a056c175c1b6bd}{
\index{bkEnd.cpp@{bkEnd.cpp}!activeBuffCnt@{activeBuffCnt}}
\index{activeBuffCnt@{activeBuffCnt}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{activeBuffCnt}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf activeBuffCnt} = 0}}
\label{bkEnd_8cpp_a0cbaf833a38f9d2dc7a056c175c1b6bd}
\hypertarget{bkEnd_8cpp_ac894a295997e8bd0440d43cafc9a630d}{
\index{bkEnd.cpp@{bkEnd.cpp}!aluAvail@{aluAvail}}
\index{aluAvail@{aluAvail}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{aluAvail}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf aluAvail}\mbox{[}NUM\_\-FUNC\_\-UNIT\mbox{]}}}
\label{bkEnd_8cpp_ac894a295997e8bd0440d43cafc9a630d}
\hypertarget{bkEnd_8cpp_a09ed74baaab433989cac4334dd14838f}{
\index{bkEnd.cpp@{bkEnd.cpp}!aluFreeTime@{aluFreeTime}}
\index{aluFreeTime@{aluFreeTime}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{aluFreeTime}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf aluFreeTime}\mbox{[}NUM\_\-FUNC\_\-UNIT\mbox{]}}}
\label{bkEnd_8cpp_a09ed74baaab433989cac4334dd14838f}
\hypertarget{bkEnd_8cpp_a229b024d8df7a4e3507e2746da8bf972}{
\index{bkEnd.cpp@{bkEnd.cpp}!aluKind@{aluKind}}
\index{aluKind@{aluKind}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{aluKind}]{\setlength{\rightskip}{0pt plus 5cm}{\bf type} {\bf aluKind}\mbox{[}NUM\_\-FUNC\_\-UNIT\mbox{]}}}
\label{bkEnd_8cpp_a229b024d8df7a4e3507e2746da8bf972}
\hypertarget{bkEnd_8cpp_a71ca470c14cd7c280dc06f84dcb1ebd5}{
\index{bkEnd.cpp@{bkEnd.cpp}!aluStat@{aluStat}}
\index{aluStat@{aluStat}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{aluStat}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf aluStat}\mbox{[}NUM\_\-FUNC\_\-UNIT\mbox{]}}}
\label{bkEnd_8cpp_a71ca470c14cd7c280dc06f84dcb1ebd5}
\hypertarget{bkEnd_8cpp_add0bef1c5cb38bedd4e253cc424d48ca}{
\index{bkEnd.cpp@{bkEnd.cpp}!bbCount@{bbCount}}
\index{bbCount@{bbCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{bbCount}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf bbCount} = 0}}
\label{bkEnd_8cpp_add0bef1c5cb38bedd4e253cc424d48ca}
\hypertarget{bkEnd_8cpp_a155d4466ed8ddecb8cbb21f3b798904c}{
\index{bkEnd.cpp@{bkEnd.cpp}!bbPrediction@{bbPrediction}}
\index{bbPrediction@{bbPrediction}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{bbPrediction}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf bbPrediction}}}
\label{bkEnd_8cpp_a155d4466ed8ddecb8cbb21f3b798904c}
\hypertarget{bkEnd_8cpp_a5726e3725395e6cca4a0f649f0d9b9dd}{
\index{bkEnd.cpp@{bkEnd.cpp}!bp\_\-hist\_\-list@{bp\_\-hist\_\-list}}
\index{bp\_\-hist\_\-list@{bp\_\-hist\_\-list}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{bp\_\-hist\_\-list}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$void$\ast$$>$$\ast$ {\bf bp\_\-hist\_\-list} = new {\bf List}$<$void$\ast$$>$}}
\label{bkEnd_8cpp_a5726e3725395e6cca4a0f649f0d9b9dd}
\hypertarget{bkEnd_8cpp_a48c38e208d1bbc2c7fca2ecd344652b1}{
\index{bkEnd.cpp@{bkEnd.cpp}!br\_\-pred\_\-update\_\-dist@{br\_\-pred\_\-update\_\-dist}}
\index{br\_\-pred\_\-update\_\-dist@{br\_\-pred\_\-update\_\-dist}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{br\_\-pred\_\-update\_\-dist}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf br\_\-pred\_\-update\_\-dist} = 0}}
\label{bkEnd_8cpp_a48c38e208d1bbc2c7fca2ecd344652b1}
\hypertarget{bkEnd_8cpp_aa5a81a60745b2467840283669f49ce28}{
\index{bkEnd.cpp@{bkEnd.cpp}!br\_\-pred\_\-update\_\-distance@{br\_\-pred\_\-update\_\-distance}}
\index{br\_\-pred\_\-update\_\-distance@{br\_\-pred\_\-update\_\-distance}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{br\_\-pred\_\-update\_\-distance}]{\setlength{\rightskip}{0pt plus 5cm}map$<${\bf ADDRS},int$>$ {\bf br\_\-pred\_\-update\_\-distance}}}
\label{bkEnd_8cpp_aa5a81a60745b2467840283669f49ce28}
\hypertarget{bkEnd_8cpp_a828d20f0028160082fefe7d78033f5ee}{
\index{bkEnd.cpp@{bkEnd.cpp}!branchAccuracy@{branchAccuracy}}
\index{branchAccuracy@{branchAccuracy}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{branchAccuracy}]{\setlength{\rightskip}{0pt plus 5cm}FILE$\ast$ {\bf branchAccuracy}}}
\label{bkEnd_8cpp_a828d20f0028160082fefe7d78033f5ee}
\hypertarget{bkEnd_8cpp_adf10622e01bd8d6fdf36e5c73cc7fdac}{
\index{bkEnd.cpp@{bkEnd.cpp}!branchAccuracyMap@{branchAccuracyMap}}
\index{branchAccuracyMap@{branchAccuracyMap}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{branchAccuracyMap}]{\setlength{\rightskip}{0pt plus 5cm}map$<$long int,float$>$ {\bf branchAccuracyMap}}}
\label{bkEnd_8cpp_adf10622e01bd8d6fdf36e5c73cc7fdac}
\hypertarget{bkEnd_8cpp_a6f1336f38aabf029a0d9b4e4428e9a5e}{
\index{bkEnd.cpp@{bkEnd.cpp}!branchBiasProfileMap@{branchBiasProfileMap}}
\index{branchBiasProfileMap@{branchBiasProfileMap}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{branchBiasProfileMap}]{\setlength{\rightskip}{0pt plus 5cm}map$<$long int,float$>$ {\bf branchBiasProfileMap}}}
\label{bkEnd_8cpp_a6f1336f38aabf029a0d9b4e4428e9a5e}
\hypertarget{bkEnd_8cpp_ac7bd9648b0cf77fbafdeb4490e46e7de}{
\index{bkEnd.cpp@{bkEnd.cpp}!branchMode@{branchMode}}
\index{branchMode@{branchMode}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{branchMode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf brMode} {\bf branchMode} = noBrMode}}
\label{bkEnd_8cpp_ac7bd9648b0cf77fbafdeb4490e46e7de}
\hypertarget{bkEnd_8cpp_a51689c6d1f78b1fbc43733c1c4fd445a}{
\index{bkEnd.cpp@{bkEnd.cpp}!branchProfile@{branchProfile}}
\index{branchProfile@{branchProfile}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{branchProfile}]{\setlength{\rightskip}{0pt plus 5cm}FILE$\ast$ {\bf branchProfile}}}
\label{bkEnd_8cpp_a51689c6d1f78b1fbc43733c1c4fd445a}
\hypertarget{bkEnd_8cpp_a8486b3a365530862ecd746e9277391c2}{
\index{bkEnd.cpp@{bkEnd.cpp}!branchProfileFlag@{branchProfileFlag}}
\index{branchProfileFlag@{branchProfileFlag}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{branchProfileFlag}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf branchProfileFlag} = false}}
\label{bkEnd_8cpp_a8486b3a365530862ecd746e9277391c2}
\hypertarget{bkEnd_8cpp_add9c322dd68dbffceca88b569baf8842}{
\index{bkEnd.cpp@{bkEnd.cpp}!brInsCount@{brInsCount}}
\index{brInsCount@{brInsCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{brInsCount}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf brInsCount} = 0}}
\label{bkEnd_8cpp_add9c322dd68dbffceca88b569baf8842}
\hypertarget{bkEnd_8cpp_a7d813c308490d9e10a54861418d277aa}{
\index{bkEnd.cpp@{bkEnd.cpp}!brSkipAccuracyFile@{brSkipAccuracyFile}}
\index{brSkipAccuracyFile@{brSkipAccuracyFile}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{brSkipAccuracyFile}]{\setlength{\rightskip}{0pt plus 5cm}FILE$\ast$ {\bf brSkipAccuracyFile}}}
\label{bkEnd_8cpp_a7d813c308490d9e10a54861418d277aa}
\hypertarget{bkEnd_8cpp_abf2fc095166550665fe650cc1b5f6a74}{
\index{bkEnd.cpp@{bkEnd.cpp}!cacheAccessMemOp@{cacheAccessMemOp}}
\index{cacheAccessMemOp@{cacheAccessMemOp}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{cacheAccessMemOp}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf cacheAccessMemOp} = 0}}
\label{bkEnd_8cpp_abf2fc095166550665fe650cc1b5f6a74}
\hypertarget{bkEnd_8cpp_abca2f358bc2b145a7d9fbb9395ad9c89}{
\index{bkEnd.cpp@{bkEnd.cpp}!cacheLat@{cacheLat}}
\index{cacheLat@{cacheLat}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{cacheLat}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf cacheLat}\mbox{[}MEM\_\-HIGHERARCHY\mbox{]}}}
\label{bkEnd_8cpp_abca2f358bc2b145a7d9fbb9395ad9c89}
\hypertarget{bkEnd_8cpp_acc1a97d6ee9b32a86dc0697b17860f31}{
\index{bkEnd.cpp@{bkEnd.cpp}!collect\_\-stat@{collect\_\-stat}}
\index{collect\_\-stat@{collect\_\-stat}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{collect\_\-stat}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf collect\_\-stat} = false}}
\label{bkEnd_8cpp_acc1a97d6ee9b32a86dc0697b17860f31}
\hypertarget{bkEnd_8cpp_a25dae25c3bf9b28d54eb4df7afb2a491}{
\index{bkEnd.cpp@{bkEnd.cpp}!comment@{comment}}
\index{comment@{comment}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{comment}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ {\bf comment}}}
\label{bkEnd_8cpp_a25dae25c3bf9b28d54eb4df7afb2a491}
\hypertarget{bkEnd_8cpp_aec0b962de2a1d8dc9d6c4de39385886a}{
\index{bkEnd.cpp@{bkEnd.cpp}!completeInsCount@{completeInsCount}}
\index{completeInsCount@{completeInsCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{completeInsCount}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf completeInsCount}}}
\label{bkEnd_8cpp_aec0b962de2a1d8dc9d6c4de39385886a}
\hypertarget{bkEnd_8cpp_a617ce1763c0446f48a6d3a158d507f46}{
\index{bkEnd.cpp@{bkEnd.cpp}!coreType@{coreType}}
\index{coreType@{coreType}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{coreType}]{\setlength{\rightskip}{0pt plus 5cm}{\bf core} {\bf coreType}}}
\label{bkEnd_8cpp_a617ce1763c0446f48a6d3a158d507f46}
\hypertarget{bkEnd_8cpp_a9e3229bf4d007be6b9e5e4cc9473e304}{
\index{bkEnd.cpp@{bkEnd.cpp}!correlationHist@{correlationHist}}
\index{correlationHist@{correlationHist}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{correlationHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf hist}$\ast$ {\bf correlationHist}}}
\label{bkEnd_8cpp_a9e3229bf4d007be6b9e5e4cc9473e304}
\hypertarget{bkEnd_8cpp_a933fdb35e831942cf441b78ecbc3d3a7}{
\index{bkEnd.cpp@{bkEnd.cpp}!correlationMap@{correlationMap}}
\index{correlationMap@{correlationMap}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{correlationMap}]{\setlength{\rightskip}{0pt plus 5cm}map$<$long int,float$>$ {\bf correlationMap}}}
\label{bkEnd_8cpp_a933fdb35e831942cf441b78ecbc3d3a7}
\hypertarget{bkEnd_8cpp_a4c2112621e10ca7f39e060af81ccaab1}{
\index{bkEnd.cpp@{bkEnd.cpp}!corruptInsCount@{corruptInsCount}}
\index{corruptInsCount@{corruptInsCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{corruptInsCount}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf corruptInsCount}}}
\label{bkEnd_8cpp_a4c2112621e10ca7f39e060af81ccaab1}
\hypertarget{bkEnd_8cpp_a10a5299fe321f662b02fa5dd316c5216}{
\index{bkEnd.cpp@{bkEnd.cpp}!crCount@{crCount}}
\index{crCount@{crCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{crCount}]{\setlength{\rightskip}{0pt plus 5cm}int64\_\-t {\bf crCount} = 0}}
\label{bkEnd_8cpp_a10a5299fe321f662b02fa5dd316c5216}
\hypertarget{bkEnd_8cpp_a24ddb63d7b594cb1489ae68dfa66e584}{
\index{bkEnd.cpp@{bkEnd.cpp}!cycle@{cycle}}
\index{cycle@{cycle}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{cycle}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf cycle}}}
\label{bkEnd_8cpp_a24ddb63d7b594cb1489ae68dfa66e584}
\hypertarget{bkEnd_8cpp_a398527b3e9e358c345c5047b16871957}{
\index{bkEnd.cpp@{bkEnd.cpp}!debug@{debug}}
\index{debug@{debug}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{debug}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf debug}}}
\label{bkEnd_8cpp_a398527b3e9e358c345c5047b16871957}
\hypertarget{bkEnd_8cpp_a5d56c51d0584a2183c83a3dfe157e724}{
\index{bkEnd.cpp@{bkEnd.cpp}!delList@{delList}}
\index{delList@{delList}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{delList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$int$>$$\ast$ {\bf delList} = new {\bf List}$<$int$>$}}
\label{bkEnd_8cpp_a5d56c51d0584a2183c83a3dfe157e724}
\hypertarget{bkEnd_8cpp_ab1dae06b10269a1b683512c8ecb25def}{
\index{bkEnd.cpp@{bkEnd.cpp}!depTables@{depTables}}
\index{depTables@{depTables}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{depTables}]{\setlength{\rightskip}{0pt plus 5cm}{\bf dependencyTable}$\ast$ {\bf depTables}}}
\label{bkEnd_8cpp_ab1dae06b10269a1b683512c8ecb25def}
\hypertarget{bkEnd_8cpp_a18ef05402bcffc4388618f03462778da}{
\index{bkEnd.cpp@{bkEnd.cpp}!drainedSBcount@{drainedSBcount}}
\index{drainedSBcount@{drainedSBcount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{drainedSBcount}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf drainedSBcount} = 0}}
\label{bkEnd_8cpp_a18ef05402bcffc4388618f03462778da}
\hypertarget{bkEnd_8cpp_adbdb9667280430c4647823ce818645db}{
\index{bkEnd.cpp@{bkEnd.cpp}!dyn\_\-num\_\-strands@{dyn\_\-num\_\-strands}}
\index{dyn\_\-num\_\-strands@{dyn\_\-num\_\-strands}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{dyn\_\-num\_\-strands}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf dyn\_\-num\_\-strands} = 0}}
\label{bkEnd_8cpp_adbdb9667280430c4647823ce818645db}
\hypertarget{bkEnd_8cpp_ac6a2252e34991ece96daab9fac67d3ed}{
\index{bkEnd.cpp@{bkEnd.cpp}!emptyResStation@{emptyResStation}}
\index{emptyResStation@{emptyResStation}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{emptyResStation}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf emptyResStation} = 0}}
\label{bkEnd_8cpp_ac6a2252e34991ece96daab9fac67d3ed}
\hypertarget{bkEnd_8cpp_a5bc2e7d32b5d98c548bd9c05ea0336e5}{
\index{bkEnd.cpp@{bkEnd.cpp}!eoc@{eoc}}
\index{eoc@{eoc}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{eoc}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf eoc}}}
\label{bkEnd_8cpp_a5bc2e7d32b5d98c548bd9c05ea0336e5}
\hypertarget{bkEnd_8cpp_a6c052602d1d43227768ad3807f7b7268}{
\index{bkEnd.cpp@{bkEnd.cpp}!eof@{eof}}
\index{eof@{eof}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{eof}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf eof}}}
\label{bkEnd_8cpp_a6c052602d1d43227768ad3807f7b7268}
\hypertarget{bkEnd_8cpp_a0a3ac309d2b8e9c712629d4bc1f6ac9d}{
\index{bkEnd.cpp@{bkEnd.cpp}!evaltMissRtCorrel@{evaltMissRtCorrel}}
\index{evaltMissRtCorrel@{evaltMissRtCorrel}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{evaltMissRtCorrel}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf evaltMissRtCorrel} = 0}}
\label{bkEnd_8cpp_a0a3ac309d2b8e9c712629d4bc1f6ac9d}
\hypertarget{bkEnd_8cpp_a2aa917380abc6bd6e4a5af04ad15fa20}{
\index{bkEnd.cpp@{bkEnd.cpp}!executeInsCount@{executeInsCount}}
\index{executeInsCount@{executeInsCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{executeInsCount}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf executeInsCount}}}
\label{bkEnd_8cpp_a2aa917380abc6bd6e4a5af04ad15fa20}
\hypertarget{bkEnd_8cpp_a36872c8ab2563fdb198259c76b40c4b3}{
\index{bkEnd.cpp@{bkEnd.cpp}!fetchStallCycle@{fetchStallCycle}}
\index{fetchStallCycle@{fetchStallCycle}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{fetchStallCycle}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf fetchStallCycle} = 0}}
\label{bkEnd_8cpp_a36872c8ab2563fdb198259c76b40c4b3}
\hypertarget{bkEnd_8cpp_a40d804e4f2ea76bca108eb373fa6ae65}{
\index{bkEnd.cpp@{bkEnd.cpp}!frCycle@{frCycle}}
\index{frCycle@{frCycle}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{frCycle}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf frCycle} = 0}}
\label{bkEnd_8cpp_a40d804e4f2ea76bca108eb373fa6ae65}
\hypertarget{bkEnd_8cpp_afa2bf6bba12df3c2a5a49fd5ef7646c6}{
\index{bkEnd.cpp@{bkEnd.cpp}!frLatHist@{frLatHist}}
\index{frLatHist@{frLatHist}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{frLatHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf hist}$\ast$ {\bf frLatHist}}}
\label{bkEnd_8cpp_afa2bf6bba12df3c2a5a49fd5ef7646c6}
\hypertarget{bkEnd_8cpp_a37d85a3b8a3536e66166c451d5e2e713}{
\index{bkEnd.cpp@{bkEnd.cpp}!frSizeHist@{frSizeHist}}
\index{frSizeHist@{frSizeHist}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{frSizeHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf hist}$\ast$ {\bf frSizeHist}}}
\label{bkEnd_8cpp_a37d85a3b8a3536e66166c451d5e2e713}
\hypertarget{bkEnd_8cpp_af5a59016fe141b79dfa006fac24d657e}{
\index{bkEnd.cpp@{bkEnd.cpp}!GRF@{GRF}}
\index{GRF@{GRF}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{GRF}]{\setlength{\rightskip}{0pt plus 5cm}{\bf registerRename}$\ast$ GRF}}
\label{bkEnd_8cpp_af5a59016fe141b79dfa006fac24d657e}
\hypertarget{bkEnd_8cpp_aba6b75941fb6bb5d268f339b9cd68312}{
\index{bkEnd.cpp@{bkEnd.cpp}!grfCount@{grfCount}}
\index{grfCount@{grfCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{grfCount}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf grfCount} = 0}}
\label{bkEnd_8cpp_aba6b75941fb6bb5d268f339b9cd68312}
\hypertarget{bkEnd_8cpp_a9559f8e45d45ac943aca5b966aacda55}{
\index{bkEnd.cpp@{bkEnd.cpp}!grfRdCountPerIns@{grfRdCountPerIns}}
\index{grfRdCountPerIns@{grfRdCountPerIns}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{grfRdCountPerIns}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf grfRdCountPerIns} = 0}}
\label{bkEnd_8cpp_a9559f8e45d45ac943aca5b966aacda55}
\hypertarget{bkEnd_8cpp_a7bf86f930cb5df55e96c5b80ccd9e9b3}{
\index{bkEnd.cpp@{bkEnd.cpp}!grfWrCountPerIns@{grfWrCountPerIns}}
\index{grfWrCountPerIns@{grfWrCountPerIns}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{grfWrCountPerIns}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf grfWrCountPerIns} = 0}}
\label{bkEnd_8cpp_a7bf86f930cb5df55e96c5b80ccd9e9b3}
\hypertarget{bkEnd_8cpp_a8fab7d3c15974f28a194e46d5041a7a6}{
\index{bkEnd.cpp@{bkEnd.cpp}!ICQ@{ICQ}}
\index{ICQ@{ICQ}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{ICQ}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$char$\ast$$>$$\ast$ {\bf ICQ}}}
\label{bkEnd_8cpp_a8fab7d3c15974f28a194e46d5041a7a6}
\hypertarget{bkEnd_8cpp_a42869d36a7a91edc4e9dd046cc56dab8}{
\index{bkEnd.cpp@{bkEnd.cpp}!idleCount@{idleCount}}
\index{idleCount@{idleCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{idleCount}]{\setlength{\rightskip}{0pt plus 5cm}int64\_\-t {\bf idleCount} = 0}}
\label{bkEnd_8cpp_a42869d36a7a91edc4e9dd046cc56dab8}
\hypertarget{bkEnd_8cpp_abb15b2b37e31156813a393e46cb18ba1}{
\index{bkEnd.cpp@{bkEnd.cpp}!iMemBuf@{iMemBuf}}
\index{iMemBuf@{iMemBuf}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{iMemBuf}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<${\bf instruction}$\ast$$>$$\ast$ {\bf iMemBuf}}}
\label{bkEnd_8cpp_abb15b2b37e31156813a393e46cb18ba1}
\hypertarget{bkEnd_8cpp_ab381424ceda4b88473c155e7eb6e70cb}{
\index{bkEnd.cpp@{bkEnd.cpp}!iMemBuffSize@{iMemBuffSize}}
\index{iMemBuffSize@{iMemBuffSize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{iMemBuffSize}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf iMemBuffSize} = 0}}
\label{bkEnd_8cpp_ab381424ceda4b88473c155e7eb6e70cb}
\hypertarget{bkEnd_8cpp_a4b4b7dee6e38ef31b4c9cca4d54523a1}{
\index{bkEnd.cpp@{bkEnd.cpp}!inCompleteBBbuffIndx@{inCompleteBBbuffIndx}}
\index{inCompleteBBbuffIndx@{inCompleteBBbuffIndx}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{inCompleteBBbuffIndx}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf inCompleteBBbuffIndx} = -\/1}}
\label{bkEnd_8cpp_a4b4b7dee6e38ef31b4c9cca4d54523a1}
\hypertarget{bkEnd_8cpp_a06e3b7f24bea52d1e3f4b9729aacd514}{
\index{bkEnd.cpp@{bkEnd.cpp}!inFlightLDops@{inFlightLDops}}
\index{inFlightLDops@{inFlightLDops}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{inFlightLDops}]{\setlength{\rightskip}{0pt plus 5cm}map$<$long int,int$>$ {\bf inFlightLDops}}}
\label{bkEnd_8cpp_a06e3b7f24bea52d1e3f4b9729aacd514}
\hypertarget{bkEnd_8cpp_a6e3caa21589fa52000a11353bb59e34c}{
\index{bkEnd.cpp@{bkEnd.cpp}!inFlightLDopsSize@{inFlightLDopsSize}}
\index{inFlightLDopsSize@{inFlightLDopsSize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{inFlightLDopsSize}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf inFlightLDopsSize} = 0}}
\label{bkEnd_8cpp_a6e3caa21589fa52000a11353bb59e34c}
\hypertarget{bkEnd_8cpp_a6b39a22d9e7e986ea0df5ebfb42e9f24}{
\index{bkEnd.cpp@{bkEnd.cpp}!ins\_\-exe\_\-hoist\_\-accuracy@{ins\_\-exe\_\-hoist\_\-accuracy}}
\index{ins\_\-exe\_\-hoist\_\-accuracy@{ins\_\-exe\_\-hoist\_\-accuracy}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{ins\_\-exe\_\-hoist\_\-accuracy}]{\setlength{\rightskip}{0pt plus 5cm}map$<$long int, float$>$ {\bf ins\_\-exe\_\-hoist\_\-accuracy}}}
\label{bkEnd_8cpp_a6b39a22d9e7e986ea0df5ebfb42e9f24}
\hypertarget{bkEnd_8cpp_a22c7fe5fbee20c3db9579adc7a36335f}{
\index{bkEnd.cpp@{bkEnd.cpp}!insCount@{insCount}}
\index{insCount@{insCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{insCount}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf insCount}}}
\label{bkEnd_8cpp_a22c7fe5fbee20c3db9579adc7a36335f}
\hypertarget{bkEnd_8cpp_a0e2d51cb13db227f9dc3a8c90f4b24e4}{
\index{bkEnd.cpp@{bkEnd.cpp}!InsCountWhenSBon@{InsCountWhenSBon}}
\index{InsCountWhenSBon@{InsCountWhenSBon}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{InsCountWhenSBon}]{\setlength{\rightskip}{0pt plus 5cm}long int$\ast$ {\bf InsCountWhenSBon} = new long int \mbox{[}{\bf numSideBuffs}\mbox{]}}}
\label{bkEnd_8cpp_a0e2d51cb13db227f9dc3a8c90f4b24e4}
\hypertarget{bkEnd_8cpp_a9a3892377020df8367aca5dcaede5232}{
\index{bkEnd.cpp@{bkEnd.cpp}!insID@{insID}}
\index{insID@{insID}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{insID}]{\setlength{\rightskip}{0pt plus 5cm}{\bf INS\_\-ID} {\bf insID}}}
\label{bkEnd_8cpp_a9a3892377020df8367aca5dcaede5232}
\hypertarget{bkEnd_8cpp_ac00b6eff67b68a541747526ab37ce1f3}{
\index{bkEnd.cpp@{bkEnd.cpp}!insParseCap@{insParseCap}}
\index{insParseCap@{insParseCap}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{insParseCap}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf insParseCap} = -\/1}}
\label{bkEnd_8cpp_ac00b6eff67b68a541747526ab37ce1f3}
\hypertarget{bkEnd_8cpp_a413be8a490fd3df8f42aae278091b987}{
\index{bkEnd.cpp@{bkEnd.cpp}!insVisitingSBcount@{insVisitingSBcount}}
\index{insVisitingSBcount@{insVisitingSBcount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{insVisitingSBcount}]{\setlength{\rightskip}{0pt plus 5cm}long int$\ast$ {\bf insVisitingSBcount} = new long int \mbox{[}{\bf numSideBuffs}\mbox{]}}}
\label{bkEnd_8cpp_a413be8a490fd3df8f42aae278091b987}
\hypertarget{bkEnd_8cpp_aa6649eec80584c1612637ea9e63fbd9c}{
\index{bkEnd.cpp@{bkEnd.cpp}!interFragStallCycle@{interFragStallCycle}}
\index{interFragStallCycle@{interFragStallCycle}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{interFragStallCycle}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf interFragStallCycle} = 0}}
\label{bkEnd_8cpp_aa6649eec80584c1612637ea9e63fbd9c}
\hypertarget{bkEnd_8cpp_aa5174ce0e698d30e1a35dcc9a95aa9f4}{
\index{bkEnd.cpp@{bkEnd.cpp}!invalidInsCount@{invalidInsCount}}
\index{invalidInsCount@{invalidInsCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{invalidInsCount}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf invalidInsCount}}}
\label{bkEnd_8cpp_aa5174ce0e698d30e1a35dcc9a95aa9f4}
\hypertarget{bkEnd_8cpp_a26c3037ee5ff6d9c3abfd650323b039c}{
\index{bkEnd.cpp@{bkEnd.cpp}!ipc@{ipc}}
\index{ipc@{ipc}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{ipc}]{\setlength{\rightskip}{0pt plus 5cm}float {\bf ipc}}}
\label{bkEnd_8cpp_a26c3037ee5ff6d9c3abfd650323b039c}
\hypertarget{bkEnd_8cpp_a1fe2792cb7bb7af1e331c6d059b53925}{
\index{bkEnd.cpp@{bkEnd.cpp}!iResStation@{iResStation}}
\index{iResStation@{iResStation}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{iResStation}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<${\bf instruction}$\ast$$>$$\ast$ {\bf iResStation}}}
\label{bkEnd_8cpp_a1fe2792cb7bb7af1e331c6d059b53925}
\hypertarget{bkEnd_8cpp_ab0e03ef58c817c2f8faa2ee8cb4db257}{
\index{bkEnd.cpp@{bkEnd.cpp}!iResStations@{iResStations}}
\index{iResStations@{iResStations}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{iResStations}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<${\bf instruction}$\ast$$>$$\ast$ {\bf iResStations}\mbox{[}NUM\_\-FUNC\_\-UNIT\mbox{]}}}
\label{bkEnd_8cpp_ab0e03ef58c817c2f8faa2ee8cb4db257}
\hypertarget{bkEnd_8cpp_a5458bd6aadaa6a425617e8fffc205295}{
\index{bkEnd.cpp@{bkEnd.cpp}!iResStnSize@{iResStnSize}}
\index{iResStnSize@{iResStnSize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{iResStnSize}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf iResStnSize} = 0}}
\label{bkEnd_8cpp_a5458bd6aadaa6a425617e8fffc205295}
\hypertarget{bkEnd_8cpp_a87be851ed79d85fbdd80b6832c080aea}{
\index{bkEnd.cpp@{bkEnd.cpp}!iResStnsSize@{iResStnsSize}}
\index{iResStnsSize@{iResStnsSize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{iResStnsSize}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf iResStnsSize}\mbox{[}NUM\_\-FUNC\_\-UNIT\mbox{]}}}
\label{bkEnd_8cpp_a87be851ed79d85fbdd80b6832c080aea}
\hypertarget{bkEnd_8cpp_ad73ae25f81e6e99482f3fbd5ba9664ce}{
\index{bkEnd.cpp@{bkEnd.cpp}!iROB@{iROB}}
\index{iROB@{iROB}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{iROB}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<${\bf instruction}$\ast$$>$$\ast$ {\bf iROB}}}
\label{bkEnd_8cpp_ad73ae25f81e6e99482f3fbd5ba9664ce}
\hypertarget{bkEnd_8cpp_a6773b2c2bce2cabc7252077c70015122}{
\index{bkEnd.cpp@{bkEnd.cpp}!iROBSize@{iROBSize}}
\index{iROBSize@{iROBSize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{iROBSize}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf iROBSize} = 0}}
\label{bkEnd_8cpp_a6773b2c2bce2cabc7252077c70015122}
\hypertarget{bkEnd_8cpp_aca6f12e6524e5175a4ea527b5eb137e6}{
\index{bkEnd.cpp@{bkEnd.cpp}!isCacheBusFree@{isCacheBusFree}}
\index{isCacheBusFree@{isCacheBusFree}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{isCacheBusFree}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf isCacheBusFree} = true}}
\label{bkEnd_8cpp_aca6f12e6524e5175a4ea527b5eb137e6}
\hypertarget{bkEnd_8cpp_a940bb8467f99fe8b410375e47613acc9}{
\index{bkEnd.cpp@{bkEnd.cpp}!iSideBuff@{iSideBuff}}
\index{iSideBuff@{iSideBuff}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{iSideBuff}]{\setlength{\rightskip}{0pt plus 5cm}{\bf sideBuff}$\ast$$\ast$ {\bf iSideBuff}}}
\label{bkEnd_8cpp_a940bb8467f99fe8b410375e47613acc9}
\hypertarget{bkEnd_8cpp_a27b503b3b0cd16ca59209476a997c0ba}{
\index{bkEnd.cpp@{bkEnd.cpp}!iSideBufSize@{iSideBufSize}}
\index{iSideBufSize@{iSideBufSize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{iSideBufSize}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf iSideBufSize} = 0}}
\label{bkEnd_8cpp_a27b503b3b0cd16ca59209476a997c0ba}
\hypertarget{bkEnd_8cpp_a1d888710b2006447c5080e525cdccd4d}{
\index{bkEnd.cpp@{bkEnd.cpp}!isSquashed@{isSquashed}}
\index{isSquashed@{isSquashed}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{isSquashed}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf isSquashed} = false}}
\label{bkEnd_8cpp_a1d888710b2006447c5080e525cdccd4d}
\hypertarget{bkEnd_8cpp_a901b5b3874c558101a1c250f2f2d0662}{
\index{bkEnd.cpp@{bkEnd.cpp}!iWindow@{iWindow}}
\index{iWindow@{iWindow}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{iWindow}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<${\bf instruction}$\ast$$>$$\ast$ {\bf iWindow}}}
\label{bkEnd_8cpp_a901b5b3874c558101a1c250f2f2d0662}
\hypertarget{bkEnd_8cpp_a296533024000eaee9a17e3b8e5249869}{
\index{bkEnd.cpp@{bkEnd.cpp}!iWinSize@{iWinSize}}
\index{iWinSize@{iWinSize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{iWinSize}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf iWinSize} = 0}}
\label{bkEnd_8cpp_a296533024000eaee9a17e3b8e5249869}
\hypertarget{bkEnd_8cpp_a657f56ad87b88b8b18377a96c1e606f8}{
\index{bkEnd.cpp@{bkEnd.cpp}!junk@{junk}}
\index{junk@{junk}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{junk}]{\setlength{\rightskip}{0pt plus 5cm}FILE$\ast$ {\bf junk}}}
\label{bkEnd_8cpp_a657f56ad87b88b8b18377a96c1e606f8}
\hypertarget{bkEnd_8cpp_aa40c785bbba5c399bea190f191d3ebcd}{
\index{bkEnd.cpp@{bkEnd.cpp}!laten@{laten}}
\index{laten@{laten}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{laten}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf laten} = -\/1}}
\label{bkEnd_8cpp_aa40c785bbba5c399bea190f191d3ebcd}
\hypertarget{bkEnd_8cpp_ad6065125a6a2298f4e8d8fc1cbe70927}{
\index{bkEnd.cpp@{bkEnd.cpp}!loadStoreQue@{loadStoreQue}}
\index{loadStoreQue@{loadStoreQue}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{loadStoreQue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf lsq}$\ast$ {\bf loadStoreQue}}}
\label{bkEnd_8cpp_ad6065125a6a2298f4e8d8fc1cbe70927}
\hypertarget{bkEnd_8cpp_ac7c424dd8e041d935c7660903f51e3aa}{
\index{bkEnd.cpp@{bkEnd.cpp}!longLatOpWhenSPisDraining@{longLatOpWhenSPisDraining}}
\index{longLatOpWhenSPisDraining@{longLatOpWhenSPisDraining}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{longLatOpWhenSPisDraining}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf longLatOpWhenSPisDraining} = 0}}
\label{bkEnd_8cpp_ac7c424dd8e041d935c7660903f51e3aa}
\hypertarget{bkEnd_8cpp_a4525b6c832e1577aa761e33b2f7f8828}{
\index{bkEnd.cpp@{bkEnd.cpp}!longLatOpWhenSPisON@{longLatOpWhenSPisON}}
\index{longLatOpWhenSPisON@{longLatOpWhenSPisON}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{longLatOpWhenSPisON}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf longLatOpWhenSPisON} = 0}}
\label{bkEnd_8cpp_a4525b6c832e1577aa761e33b2f7f8828}
\hypertarget{bkEnd_8cpp_a6b51da567e6b8a11bba9ec1f241f1c97}{
\index{bkEnd.cpp@{bkEnd.cpp}!longLatOpWhenSPisWaiting@{longLatOpWhenSPisWaiting}}
\index{longLatOpWhenSPisWaiting@{longLatOpWhenSPisWaiting}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{longLatOpWhenSPisWaiting}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf longLatOpWhenSPisWaiting} = 0}}
\label{bkEnd_8cpp_a6b51da567e6b8a11bba9ec1f241f1c97}
\hypertarget{bkEnd_8cpp_ad5a50c792dddaaaec411854653939d8d}{
\index{bkEnd.cpp@{bkEnd.cpp}!lqSize@{lqSize}}
\index{lqSize@{lqSize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{lqSize}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf lqSize} = 0}}
\label{bkEnd_8cpp_ad5a50c792dddaaaec411854653939d8d}
\hypertarget{bkEnd_8cpp_a6952280a935d46003680da298022dd98}{
\index{bkEnd.cpp@{bkEnd.cpp}!lrfCount@{lrfCount}}
\index{lrfCount@{lrfCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{lrfCount}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf lrfCount} = 0}}
\label{bkEnd_8cpp_a6952280a935d46003680da298022dd98}
\hypertarget{bkEnd_8cpp_a049a2414981f3c3a351ce982f8ab0982}{
\index{bkEnd.cpp@{bkEnd.cpp}!lrfRdCountPerIns@{lrfRdCountPerIns}}
\index{lrfRdCountPerIns@{lrfRdCountPerIns}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{lrfRdCountPerIns}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf lrfRdCountPerIns} = 0}}
\label{bkEnd_8cpp_a049a2414981f3c3a351ce982f8ab0982}
\hypertarget{bkEnd_8cpp_a96c2987acbb47290afce74588a45ea49}{
\index{bkEnd.cpp@{bkEnd.cpp}!LRFTables@{LRFTables}}
\index{LRFTables@{LRFTables}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{LRFTables}]{\setlength{\rightskip}{0pt plus 5cm}{\bf dependencyTable}$\ast$ {\bf LRFTables}\mbox{[}NUM\_\-PHRASEBLKS\mbox{]}}}
\label{bkEnd_8cpp_a96c2987acbb47290afce74588a45ea49}
\hypertarget{bkEnd_8cpp_a8ce9db15f8587f6c52ec4475a875d399}{
\index{bkEnd.cpp@{bkEnd.cpp}!lrfWrCountPerIns@{lrfWrCountPerIns}}
\index{lrfWrCountPerIns@{lrfWrCountPerIns}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{lrfWrCountPerIns}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf lrfWrCountPerIns} = 0}}
\label{bkEnd_8cpp_a8ce9db15f8587f6c52ec4475a875d399}
\hypertarget{bkEnd_8cpp_a118e471f7e27b0e5a45d2e0b2d7d8a1a}{
\index{bkEnd.cpp@{bkEnd.cpp}!mainStreamBound@{mainStreamBound}}
\index{mainStreamBound@{mainStreamBound}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{mainStreamBound}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf mainStreamBound} = -\/1}}
\label{bkEnd_8cpp_a118e471f7e27b0e5a45d2e0b2d7d8a1a}
\hypertarget{bkEnd_8cpp_a9d371f0f4b31309fd4613ce93821c162}{
\index{bkEnd.cpp@{bkEnd.cpp}!mainStreamInsCount@{mainStreamInsCount}}
\index{mainStreamInsCount@{mainStreamInsCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{mainStreamInsCount}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf mainStreamInsCount} = 0}}
\label{bkEnd_8cpp_a9d371f0f4b31309fd4613ce93821c162}
\hypertarget{bkEnd_8cpp_a11a86001d145184dffcc82c55772537c}{
\index{bkEnd.cpp@{bkEnd.cpp}!makePhrase@{makePhrase}}
\index{makePhrase@{makePhrase}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{makePhrase}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf makePhrase} = false}}
\label{bkEnd_8cpp_a11a86001d145184dffcc82c55772537c}
\hypertarget{bkEnd_8cpp_ac3e602b1cb0c363bc4dcb6e133d35200}{
\index{bkEnd.cpp@{bkEnd.cpp}!maxSBsize@{maxSBsize}}
\index{maxSBsize@{maxSBsize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{maxSBsize}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf maxSBsize} = -\/1}}
\label{bkEnd_8cpp_ac3e602b1cb0c363bc4dcb6e133d35200}
\hypertarget{bkEnd_8cpp_a4b11b7c87b23b4b281fdcf9c67725e39}{
\index{bkEnd.cpp@{bkEnd.cpp}!memoryModel@{memoryModel}}
\index{memoryModel@{memoryModel}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{memoryModel}]{\setlength{\rightskip}{0pt plus 5cm}{\bf memModel} {\bf memoryModel} = PERFECT}}
\label{bkEnd_8cpp_a4b11b7c87b23b4b281fdcf9c67725e39}
\hypertarget{bkEnd_8cpp_a4a9366847a52b92f577935eed2f002df}{
\index{bkEnd.cpp@{bkEnd.cpp}!memRdMissCountTable@{memRdMissCountTable}}
\index{memRdMissCountTable@{memRdMissCountTable}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{memRdMissCountTable}]{\setlength{\rightskip}{0pt plus 5cm}map$<$long int,int$>$ {\bf memRdMissCountTable}}}
\label{bkEnd_8cpp_a4a9366847a52b92f577935eed2f002df}
\hypertarget{bkEnd_8cpp_ab14bebb6d6e05c80319f2d8f4d01ca3a}{
\index{bkEnd.cpp@{bkEnd.cpp}!memRdMissRateTable@{memRdMissRateTable}}
\index{memRdMissRateTable@{memRdMissRateTable}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{memRdMissRateTable}]{\setlength{\rightskip}{0pt plus 5cm}map$<$long int,float$>$ {\bf memRdMissRateTable}}}
\label{bkEnd_8cpp_ab14bebb6d6e05c80319f2d8f4d01ca3a}
\hypertarget{bkEnd_8cpp_a38d70a0557186ae085098575fbab0cb3}{
\index{bkEnd.cpp@{bkEnd.cpp}!memRdTotCountTable@{memRdTotCountTable}}
\index{memRdTotCountTable@{memRdTotCountTable}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{memRdTotCountTable}]{\setlength{\rightskip}{0pt plus 5cm}map$<$long int,int$>$ {\bf memRdTotCountTable}}}
\label{bkEnd_8cpp_a38d70a0557186ae085098575fbab0cb3}
\hypertarget{bkEnd_8cpp_abd4b229feea4f321d63060675b7348bd}{
\index{bkEnd.cpp@{bkEnd.cpp}!minSBsize@{minSBsize}}
\index{minSBsize@{minSBsize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{minSBsize}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf minSBsize} = 100000000000}}
\label{bkEnd_8cpp_abd4b229feea4f321d63060675b7348bd}
\hypertarget{bkEnd_8cpp_aa8f7dd26d3ed214b8a93eca6f30cd6ea}{
\index{bkEnd.cpp@{bkEnd.cpp}!missingAccuracyBranches@{missingAccuracyBranches}}
\index{missingAccuracyBranches@{missingAccuracyBranches}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{missingAccuracyBranches}]{\setlength{\rightskip}{0pt plus 5cm}set$<$long int$>$ {\bf missingAccuracyBranches}}}
\label{bkEnd_8cpp_aa8f7dd26d3ed214b8a93eca6f30cd6ea}
\hypertarget{bkEnd_8cpp_ac01b32c964c6071fd4f45869b33b9284}{
\index{bkEnd.cpp@{bkEnd.cpp}!missPredBROps@{missPredBROps}}
\index{missPredBROps@{missPredBROps}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{missPredBROps}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf missPredBROps} = 0}}
\label{bkEnd_8cpp_ac01b32c964c6071fd4f45869b33b9284}
\hypertarget{bkEnd_8cpp_a82767088fb8520248dff1da53476f47d}{
\index{bkEnd.cpp@{bkEnd.cpp}!missPredBROps\_\-fetch@{missPredBROps\_\-fetch}}
\index{missPredBROps\_\-fetch@{missPredBROps\_\-fetch}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{missPredBROps\_\-fetch}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf missPredBROps\_\-fetch} = 0}}
\label{bkEnd_8cpp_a82767088fb8520248dff1da53476f47d}
\hypertarget{bkEnd_8cpp_a7b30f72f4f83f3f8f1841216e7091739}{
\index{bkEnd.cpp@{bkEnd.cpp}!missPredBROps\_\-NT@{missPredBROps\_\-NT}}
\index{missPredBROps\_\-NT@{missPredBROps\_\-NT}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{missPredBROps\_\-NT}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf missPredBROps\_\-NT} = 0}}
\label{bkEnd_8cpp_a7b30f72f4f83f3f8f1841216e7091739}
\hypertarget{bkEnd_8cpp_afc0974196154292eb093fa44f778d54d}{
\index{bkEnd.cpp@{bkEnd.cpp}!missPredBROps\_\-NT\_\-fetch@{missPredBROps\_\-NT\_\-fetch}}
\index{missPredBROps\_\-NT\_\-fetch@{missPredBROps\_\-NT\_\-fetch}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{missPredBROps\_\-NT\_\-fetch}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf missPredBROps\_\-NT\_\-fetch} = 0}}
\label{bkEnd_8cpp_afc0974196154292eb093fa44f778d54d}
\hypertarget{bkEnd_8cpp_a7b72b8299099888d04bef51d3bdd490c}{
\index{bkEnd.cpp@{bkEnd.cpp}!nonBlockingMemOp@{nonBlockingMemOp}}
\index{nonBlockingMemOp@{nonBlockingMemOp}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{nonBlockingMemOp}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf nonBlockingMemOp} = 0}}
\label{bkEnd_8cpp_a7b72b8299099888d04bef51d3bdd490c}
\hypertarget{bkEnd_8cpp_acf42f0f2445bdd6c9d588d0e642e3f0b}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-bypassed\_\-wbb@{num\_\-bypassed\_\-wbb}}
\index{num\_\-bypassed\_\-wbb@{num\_\-bypassed\_\-wbb}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-bypassed\_\-wbb}]{\setlength{\rightskip}{0pt plus 5cm}map$<$long int, int$>$ {\bf num\_\-bypassed\_\-wbb}}}
\label{bkEnd_8cpp_acf42f0f2445bdd6c9d588d0e642e3f0b}
\hypertarget{bkEnd_8cpp_afe56689ffc9fa80e64c2b5cbd7c975cb}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-ins\_\-exe\_\-cnt@{num\_\-ins\_\-exe\_\-cnt}}
\index{num\_\-ins\_\-exe\_\-cnt@{num\_\-ins\_\-exe\_\-cnt}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-ins\_\-exe\_\-cnt}]{\setlength{\rightskip}{0pt plus 5cm}map$<$long int, int$>$ {\bf num\_\-ins\_\-exe\_\-cnt}}}
\label{bkEnd_8cpp_afe56689ffc9fa80e64c2b5cbd7c975cb}
\hypertarget{bkEnd_8cpp_a38fd9dc636261f7b48415dff41b44e0d}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-grf\_\-rd\_\-complete\_\-reg@{num\_\-squashed\_\-grf\_\-rd\_\-complete\_\-reg}}
\index{num\_\-squashed\_\-grf\_\-rd\_\-complete\_\-reg@{num\_\-squashed\_\-grf\_\-rd\_\-complete\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-grf\_\-rd\_\-complete\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-grf\_\-rd\_\-complete\_\-reg} = 0}}
\label{bkEnd_8cpp_a38fd9dc636261f7b48415dff41b44e0d}
\hypertarget{bkEnd_8cpp_a1bc3804191941684f302988c1a2b5a97}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-grf\_\-rd\_\-execute\_\-reg@{num\_\-squashed\_\-grf\_\-rd\_\-execute\_\-reg}}
\index{num\_\-squashed\_\-grf\_\-rd\_\-execute\_\-reg@{num\_\-squashed\_\-grf\_\-rd\_\-execute\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-grf\_\-rd\_\-execute\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-grf\_\-rd\_\-execute\_\-reg} = 0}}
\label{bkEnd_8cpp_a1bc3804191941684f302988c1a2b5a97}
\hypertarget{bkEnd_8cpp_aca08ffd71d4708a90ff27b13e60c1171}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-grf\_\-rd\_\-fetch\_\-reg@{num\_\-squashed\_\-grf\_\-rd\_\-fetch\_\-reg}}
\index{num\_\-squashed\_\-grf\_\-rd\_\-fetch\_\-reg@{num\_\-squashed\_\-grf\_\-rd\_\-fetch\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-grf\_\-rd\_\-fetch\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-grf\_\-rd\_\-fetch\_\-reg} = 0}}
\label{bkEnd_8cpp_aca08ffd71d4708a90ff27b13e60c1171}
\hypertarget{bkEnd_8cpp_afcfce379af6def85e339f519477e23fe}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-grf\_\-rd\_\-ready\_\-reg@{num\_\-squashed\_\-grf\_\-rd\_\-ready\_\-reg}}
\index{num\_\-squashed\_\-grf\_\-rd\_\-ready\_\-reg@{num\_\-squashed\_\-grf\_\-rd\_\-ready\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-grf\_\-rd\_\-ready\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-grf\_\-rd\_\-ready\_\-reg} = 0}}
\label{bkEnd_8cpp_afcfce379af6def85e339f519477e23fe}
\hypertarget{bkEnd_8cpp_a86a76ec07deef440147ede7b0664358c}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-grf\_\-rd\_\-reg@{num\_\-squashed\_\-grf\_\-rd\_\-reg}}
\index{num\_\-squashed\_\-grf\_\-rd\_\-reg@{num\_\-squashed\_\-grf\_\-rd\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-grf\_\-rd\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-grf\_\-rd\_\-reg} = 0}}
\label{bkEnd_8cpp_a86a76ec07deef440147ede7b0664358c}
\hypertarget{bkEnd_8cpp_a409c0ede2016a5a944ea82c1225f80d4}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-grf\_\-wr\_\-complete\_\-reg@{num\_\-squashed\_\-grf\_\-wr\_\-complete\_\-reg}}
\index{num\_\-squashed\_\-grf\_\-wr\_\-complete\_\-reg@{num\_\-squashed\_\-grf\_\-wr\_\-complete\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-grf\_\-wr\_\-complete\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-grf\_\-wr\_\-complete\_\-reg} = 0}}
\label{bkEnd_8cpp_a409c0ede2016a5a944ea82c1225f80d4}
\hypertarget{bkEnd_8cpp_adcbe2621722be0f220d104181e11a7d0}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-grf\_\-wr\_\-execute\_\-reg@{num\_\-squashed\_\-grf\_\-wr\_\-execute\_\-reg}}
\index{num\_\-squashed\_\-grf\_\-wr\_\-execute\_\-reg@{num\_\-squashed\_\-grf\_\-wr\_\-execute\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-grf\_\-wr\_\-execute\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-grf\_\-wr\_\-execute\_\-reg} = 0}}
\label{bkEnd_8cpp_adcbe2621722be0f220d104181e11a7d0}
\hypertarget{bkEnd_8cpp_a294e848610ffe17cdab79ed24123bd01}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-grf\_\-wr\_\-fetch\_\-reg@{num\_\-squashed\_\-grf\_\-wr\_\-fetch\_\-reg}}
\index{num\_\-squashed\_\-grf\_\-wr\_\-fetch\_\-reg@{num\_\-squashed\_\-grf\_\-wr\_\-fetch\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-grf\_\-wr\_\-fetch\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-grf\_\-wr\_\-fetch\_\-reg} = 0}}
\label{bkEnd_8cpp_a294e848610ffe17cdab79ed24123bd01}
\hypertarget{bkEnd_8cpp_a03b0149a23ebc201907949388fe562ec}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-grf\_\-wr\_\-ready\_\-reg@{num\_\-squashed\_\-grf\_\-wr\_\-ready\_\-reg}}
\index{num\_\-squashed\_\-grf\_\-wr\_\-ready\_\-reg@{num\_\-squashed\_\-grf\_\-wr\_\-ready\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-grf\_\-wr\_\-ready\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-grf\_\-wr\_\-ready\_\-reg} = 0}}
\label{bkEnd_8cpp_a03b0149a23ebc201907949388fe562ec}
\hypertarget{bkEnd_8cpp_a844295d5a281e437cceae9db2865a4ce}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-grf\_\-wr\_\-reg@{num\_\-squashed\_\-grf\_\-wr\_\-reg}}
\index{num\_\-squashed\_\-grf\_\-wr\_\-reg@{num\_\-squashed\_\-grf\_\-wr\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-grf\_\-wr\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-grf\_\-wr\_\-reg} = 0}}
\label{bkEnd_8cpp_a844295d5a281e437cceae9db2865a4ce}
\hypertarget{bkEnd_8cpp_af336deada0618ea56c44ba90f1e16421}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-lrf\_\-rd\_\-complete\_\-reg@{num\_\-squashed\_\-lrf\_\-rd\_\-complete\_\-reg}}
\index{num\_\-squashed\_\-lrf\_\-rd\_\-complete\_\-reg@{num\_\-squashed\_\-lrf\_\-rd\_\-complete\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-lrf\_\-rd\_\-complete\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-lrf\_\-rd\_\-complete\_\-reg} = 0}}
\label{bkEnd_8cpp_af336deada0618ea56c44ba90f1e16421}
\hypertarget{bkEnd_8cpp_a40bffc89ce6f958b3318f572dafcdcb1}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-lrf\_\-rd\_\-execute\_\-reg@{num\_\-squashed\_\-lrf\_\-rd\_\-execute\_\-reg}}
\index{num\_\-squashed\_\-lrf\_\-rd\_\-execute\_\-reg@{num\_\-squashed\_\-lrf\_\-rd\_\-execute\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-lrf\_\-rd\_\-execute\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-lrf\_\-rd\_\-execute\_\-reg} = 0}}
\label{bkEnd_8cpp_a40bffc89ce6f958b3318f572dafcdcb1}
\hypertarget{bkEnd_8cpp_aad90d32e2ca559f064b10531d78fb8f9}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-lrf\_\-rd\_\-fetch\_\-reg@{num\_\-squashed\_\-lrf\_\-rd\_\-fetch\_\-reg}}
\index{num\_\-squashed\_\-lrf\_\-rd\_\-fetch\_\-reg@{num\_\-squashed\_\-lrf\_\-rd\_\-fetch\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-lrf\_\-rd\_\-fetch\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-lrf\_\-rd\_\-fetch\_\-reg} = 0}}
\label{bkEnd_8cpp_aad90d32e2ca559f064b10531d78fb8f9}
\hypertarget{bkEnd_8cpp_a755444f10a85ea8212fd5beff948521e}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-lrf\_\-rd\_\-ready\_\-reg@{num\_\-squashed\_\-lrf\_\-rd\_\-ready\_\-reg}}
\index{num\_\-squashed\_\-lrf\_\-rd\_\-ready\_\-reg@{num\_\-squashed\_\-lrf\_\-rd\_\-ready\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-lrf\_\-rd\_\-ready\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-lrf\_\-rd\_\-ready\_\-reg} = 0}}
\label{bkEnd_8cpp_a755444f10a85ea8212fd5beff948521e}
\hypertarget{bkEnd_8cpp_a1fa21c200e5d00578252d37246b857ad}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-lrf\_\-rd\_\-reg@{num\_\-squashed\_\-lrf\_\-rd\_\-reg}}
\index{num\_\-squashed\_\-lrf\_\-rd\_\-reg@{num\_\-squashed\_\-lrf\_\-rd\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-lrf\_\-rd\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-lrf\_\-rd\_\-reg} = 0}}
\label{bkEnd_8cpp_a1fa21c200e5d00578252d37246b857ad}
\hypertarget{bkEnd_8cpp_a2ce0e6721860e7f0e00f1e786363265f}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-lrf\_\-wr\_\-complete\_\-reg@{num\_\-squashed\_\-lrf\_\-wr\_\-complete\_\-reg}}
\index{num\_\-squashed\_\-lrf\_\-wr\_\-complete\_\-reg@{num\_\-squashed\_\-lrf\_\-wr\_\-complete\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-lrf\_\-wr\_\-complete\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-lrf\_\-wr\_\-complete\_\-reg} = 0}}
\label{bkEnd_8cpp_a2ce0e6721860e7f0e00f1e786363265f}
\hypertarget{bkEnd_8cpp_a6fecb1d1e47a460f2d215df7146c9804}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-lrf\_\-wr\_\-execute\_\-reg@{num\_\-squashed\_\-lrf\_\-wr\_\-execute\_\-reg}}
\index{num\_\-squashed\_\-lrf\_\-wr\_\-execute\_\-reg@{num\_\-squashed\_\-lrf\_\-wr\_\-execute\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-lrf\_\-wr\_\-execute\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-lrf\_\-wr\_\-execute\_\-reg} = 0}}
\label{bkEnd_8cpp_a6fecb1d1e47a460f2d215df7146c9804}
\hypertarget{bkEnd_8cpp_a4f7c62b80c5be8c541a7a924ac1f7a60}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-lrf\_\-wr\_\-fetch\_\-reg@{num\_\-squashed\_\-lrf\_\-wr\_\-fetch\_\-reg}}
\index{num\_\-squashed\_\-lrf\_\-wr\_\-fetch\_\-reg@{num\_\-squashed\_\-lrf\_\-wr\_\-fetch\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-lrf\_\-wr\_\-fetch\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-lrf\_\-wr\_\-fetch\_\-reg} = 0}}
\label{bkEnd_8cpp_a4f7c62b80c5be8c541a7a924ac1f7a60}
\hypertarget{bkEnd_8cpp_a25e3c694cc23a732aabf5f2b2a023519}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-lrf\_\-wr\_\-ready\_\-reg@{num\_\-squashed\_\-lrf\_\-wr\_\-ready\_\-reg}}
\index{num\_\-squashed\_\-lrf\_\-wr\_\-ready\_\-reg@{num\_\-squashed\_\-lrf\_\-wr\_\-ready\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-lrf\_\-wr\_\-ready\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-lrf\_\-wr\_\-ready\_\-reg} = 0}}
\label{bkEnd_8cpp_a25e3c694cc23a732aabf5f2b2a023519}
\hypertarget{bkEnd_8cpp_a231286cf17c5cfc1e4c48193eaf61836}{
\index{bkEnd.cpp@{bkEnd.cpp}!num\_\-squashed\_\-lrf\_\-wr\_\-reg@{num\_\-squashed\_\-lrf\_\-wr\_\-reg}}
\index{num\_\-squashed\_\-lrf\_\-wr\_\-reg@{num\_\-squashed\_\-lrf\_\-wr\_\-reg}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{num\_\-squashed\_\-lrf\_\-wr\_\-reg}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf num\_\-squashed\_\-lrf\_\-wr\_\-reg} = 0}}
\label{bkEnd_8cpp_a231286cf17c5cfc1e4c48193eaf61836}
\hypertarget{bkEnd_8cpp_aa1ce2c4c6b8b37f120c7d5f8672a61a1}{
\index{bkEnd.cpp@{bkEnd.cpp}!numActiveSideBuffs@{numActiveSideBuffs}}
\index{numActiveSideBuffs@{numActiveSideBuffs}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numActiveSideBuffs}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numActiveSideBuffs} = 1}}
\label{bkEnd_8cpp_aa1ce2c4c6b8b37f120c7d5f8672a61a1}
\hypertarget{bkEnd_8cpp_a99e158204dabc119d57a8ddf66d413c9}{
\index{bkEnd.cpp@{bkEnd.cpp}!numALUOps@{numALUOps}}
\index{numALUOps@{numALUOps}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numALUOps}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf numALUOps} = 0}}
\label{bkEnd_8cpp_a99e158204dabc119d57a8ddf66d413c9}
\hypertarget{bkEnd_8cpp_a749b154cd6624c9481b25d12c7f267f1}{
\index{bkEnd.cpp@{bkEnd.cpp}!numAssignOps@{numAssignOps}}
\index{numAssignOps@{numAssignOps}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numAssignOps}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf numAssignOps} = 0}}
\label{bkEnd_8cpp_a749b154cd6624c9481b25d12c7f267f1}
\hypertarget{bkEnd_8cpp_a60d14c1c616033f85bff10082d441222}{
\index{bkEnd.cpp@{bkEnd.cpp}!numBROps@{numBROps}}
\index{numBROps@{numBROps}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numBROps}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf numBROps} = 0}}
\label{bkEnd_8cpp_a60d14c1c616033f85bff10082d441222}
\hypertarget{bkEnd_8cpp_aaead9f67122e91f57171b797c893b832}{
\index{bkEnd.cpp@{bkEnd.cpp}!numBrOps\_\-predT@{numBrOps\_\-predT}}
\index{numBrOps\_\-predT@{numBrOps\_\-predT}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numBrOps\_\-predT}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf numBrOps\_\-predT} = 0}}
\label{bkEnd_8cpp_aaead9f67122e91f57171b797c893b832}
\hypertarget{bkEnd_8cpp_aed1c14b28f4f14e669c73847aa18524f}{
\index{bkEnd.cpp@{bkEnd.cpp}!numBrOps\_\-predT\_\-fetch@{numBrOps\_\-predT\_\-fetch}}
\index{numBrOps\_\-predT\_\-fetch@{numBrOps\_\-predT\_\-fetch}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numBrOps\_\-predT\_\-fetch}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf numBrOps\_\-predT\_\-fetch} = 0}}
\label{bkEnd_8cpp_aed1c14b28f4f14e669c73847aa18524f}
\hypertarget{bkEnd_8cpp_a9c0332d1a8ff0a6bd8af16de918bf90a}{
\index{bkEnd.cpp@{bkEnd.cpp}!numChildrenHist@{numChildrenHist}}
\index{numChildrenHist@{numChildrenHist}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numChildrenHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf hist}$\ast$ {\bf numChildrenHist}}}
\label{bkEnd_8cpp_a9c0332d1a8ff0a6bd8af16de918bf90a}
\hypertarget{bkEnd_8cpp_a0a0796a6caa647405fec70ca633e777f}{
\index{bkEnd.cpp@{bkEnd.cpp}!numDepInOtherSBs@{numDepInOtherSBs}}
\index{numDepInOtherSBs@{numDepInOtherSBs}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numDepInOtherSBs}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf numDepInOtherSBs} = 0}}
\label{bkEnd_8cpp_a0a0796a6caa647405fec70ca633e777f}
\hypertarget{bkEnd_8cpp_a00f80363001f9affede7c0feb25eac16}{
\index{bkEnd.cpp@{bkEnd.cpp}!numFPUOps@{numFPUOps}}
\index{numFPUOps@{numFPUOps}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numFPUOps}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf numFPUOps} = 0}}
\label{bkEnd_8cpp_a00f80363001f9affede7c0feb25eac16}
\hypertarget{bkEnd_8cpp_ae0b3cf4db09e8c26c2ab03dbe18bfb19}{
\index{bkEnd.cpp@{bkEnd.cpp}!numFU@{numFU}}
\index{numFU@{numFU}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numFU}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf numFU} = NUM\_\-FUNC\_\-UNIT}}
\label{bkEnd_8cpp_ae0b3cf4db09e8c26c2ab03dbe18bfb19}
\hypertarget{bkEnd_8cpp_ac8d2ba075f1720da64e00e03081ce681}{
\index{bkEnd.cpp@{bkEnd.cpp}!numMemOps@{numMemOps}}
\index{numMemOps@{numMemOps}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numMemOps}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf numMemOps} = 0}}
\label{bkEnd_8cpp_ac8d2ba075f1720da64e00e03081ce681}
\hypertarget{bkEnd_8cpp_ae78c4cfb3041a36224ee6a1246904a74}{
\index{bkEnd.cpp@{bkEnd.cpp}!numOnSideBuffs@{numOnSideBuffs}}
\index{numOnSideBuffs@{numOnSideBuffs}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numOnSideBuffs}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf numOnSideBuffs} = 0}}
\label{bkEnd_8cpp_ae78c4cfb3041a36224ee6a1246904a74}
\hypertarget{bkEnd_8cpp_a3ef201c944505a0c7cc1d3367a773586}{
\index{bkEnd.cpp@{bkEnd.cpp}!numParentsHist@{numParentsHist}}
\index{numParentsHist@{numParentsHist}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numParentsHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf hist}$\ast$ {\bf numParentsHist}}}
\label{bkEnd_8cpp_a3ef201c944505a0c7cc1d3367a773586}
\hypertarget{bkEnd_8cpp_ac95e4e39b07dbbbd1026abd949169dba}{
\index{bkEnd.cpp@{bkEnd.cpp}!numReadOps@{numReadOps}}
\index{numReadOps@{numReadOps}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numReadOps}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf numReadOps} = 0}}
\label{bkEnd_8cpp_ac95e4e39b07dbbbd1026abd949169dba}
\hypertarget{bkEnd_8cpp_aaf53c801386a341acc33d0ff2d6e4f05}{
\index{bkEnd.cpp@{bkEnd.cpp}!numReadyFrags@{numReadyFrags}}
\index{numReadyFrags@{numReadyFrags}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numReadyFrags}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf numReadyFrags} = 0}}
\label{bkEnd_8cpp_aaf53c801386a341acc33d0ff2d6e4f05}
\hypertarget{bkEnd_8cpp_a280978aed4c98c12ac739598e05e85e0}{
\index{bkEnd.cpp@{bkEnd.cpp}!numSBactivations@{numSBactivations}}
\index{numSBactivations@{numSBactivations}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numSBactivations}]{\setlength{\rightskip}{0pt plus 5cm}long int$\ast$ {\bf numSBactivations} = new long int \mbox{[}{\bf numSideBuffs}\mbox{]}}}
\label{bkEnd_8cpp_a280978aed4c98c12ac739598e05e85e0}
\hypertarget{bkEnd_8cpp_a00a3fa92a491104663c3650d4bccc137}{
\index{bkEnd.cpp@{bkEnd.cpp}!numSBreactivations@{numSBreactivations}}
\index{numSBreactivations@{numSBreactivations}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numSBreactivations}]{\setlength{\rightskip}{0pt plus 5cm}long int$\ast$ {\bf numSBreactivations} = new long int \mbox{[}{\bf numSideBuffs}\mbox{]}}}
\label{bkEnd_8cpp_a00a3fa92a491104663c3650d4bccc137}
\hypertarget{bkEnd_8cpp_ae6c3a951ad171705af12e339de84894f}{
\index{bkEnd.cpp@{bkEnd.cpp}!numSideBuffs@{numSideBuffs}}
\index{numSideBuffs@{numSideBuffs}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numSideBuffs}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf numSideBuffs} = NUM\_\-SIDE\_\-BUFFERS}}
\label{bkEnd_8cpp_ae6c3a951ad171705af12e339de84894f}
\hypertarget{bkEnd_8cpp_afb39d8142b31567500131a68f648a699}{
\index{bkEnd.cpp@{bkEnd.cpp}!numWriteOps@{numWriteOps}}
\index{numWriteOps@{numWriteOps}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{numWriteOps}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf numWriteOps} = 0}}
\label{bkEnd_8cpp_afb39d8142b31567500131a68f648a699}
\hypertarget{bkEnd_8cpp_aea9ee59506f5a334d39148183b7e41fa}{
\index{bkEnd.cpp@{bkEnd.cpp}!oneLevDeepLatLevel@{oneLevDeepLatLevel}}
\index{oneLevDeepLatLevel@{oneLevDeepLatLevel}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{oneLevDeepLatLevel}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf oneLevDeepLatLevel}}}
\label{bkEnd_8cpp_aea9ee59506f5a334d39148183b7e41fa}
\hypertarget{bkEnd_8cpp_a58b968b0b4c5babf4eafd809481c7a9f}{
\index{bkEnd.cpp@{bkEnd.cpp}!outFile@{outFile}}
\index{outFile@{outFile}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{outFile}]{\setlength{\rightskip}{0pt plus 5cm}FILE$\ast$ {\bf outFile}}}
\label{bkEnd_8cpp_a58b968b0b4c5babf4eafd809481c7a9f}
\hypertarget{bkEnd_8cpp_a61d6eeffda4f719d0f542ee6a9e407db}{
\index{bkEnd.cpp@{bkEnd.cpp}!outFile1@{outFile1}}
\index{outFile1@{outFile1}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{outFile1}]{\setlength{\rightskip}{0pt plus 5cm}FILE$\ast$ {\bf outFile1}}}
\label{bkEnd_8cpp_a61d6eeffda4f719d0f542ee6a9e407db}
\hypertarget{bkEnd_8cpp_a168197596d43af3ce1d178cc4c9f578f}{
\index{bkEnd.cpp@{bkEnd.cpp}!outFile2@{outFile2}}
\index{outFile2@{outFile2}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{outFile2}]{\setlength{\rightskip}{0pt plus 5cm}FILE$\ast$ {\bf outFile2}}}
\label{bkEnd_8cpp_a168197596d43af3ce1d178cc4c9f578f}
\hypertarget{bkEnd_8cpp_a777274a5678acb2b7b90ccc870ccf090}{
\index{bkEnd.cpp@{bkEnd.cpp}!outFileName2@{outFileName2}}
\index{outFileName2@{outFileName2}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{outFileName2}]{\setlength{\rightskip}{0pt plus 5cm}char {\bf outFileName2}\mbox{[}400\mbox{]}}}
\label{bkEnd_8cpp_a777274a5678acb2b7b90ccc870ccf090}
\hypertarget{bkEnd_8cpp_a9b8e7669bda57879d8abc5234b2f0b19}{
\index{bkEnd.cpp@{bkEnd.cpp}!parse@{parse}}
\index{parse@{parse}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{parse}]{\setlength{\rightskip}{0pt plus 5cm}{\bf parser}$\ast$ {\bf parse}}}
\label{bkEnd_8cpp_a9b8e7669bda57879d8abc5234b2f0b19}
\hypertarget{bkEnd_8cpp_ab89bce3b6c39af4337cdc6d48e717238}{
\index{bkEnd.cpp@{bkEnd.cpp}!parseHitMiss@{parseHitMiss}}
\index{parseHitMiss@{parseHitMiss}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{parseHitMiss}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf parseHitMiss} = 0}}
\label{bkEnd_8cpp_ab89bce3b6c39af4337cdc6d48e717238}
\hypertarget{bkEnd_8cpp_a2a44290329192be0c7810087d3c92cb4}{
\index{bkEnd.cpp@{bkEnd.cpp}!pbListsSize@{pbListsSize}}
\index{pbListsSize@{pbListsSize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{pbListsSize}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf pbListsSize}\mbox{[}NUM\_\-PHRASEBLKS\mbox{]}}}
\label{bkEnd_8cpp_a2a44290329192be0c7810087d3c92cb4}
\hypertarget{bkEnd_8cpp_a992518257eb58a8e76b23747fbd88f9e}{
\index{bkEnd.cpp@{bkEnd.cpp}!pbROB@{pbROB}}
\index{pbROB@{pbROB}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{pbROB}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<${\bf basicblock}$\ast$$>$$\ast$ {\bf pbROB}}}
\label{bkEnd_8cpp_a992518257eb58a8e76b23747fbd88f9e}
\hypertarget{bkEnd_8cpp_aeb8271044b5f2f0cc0d6b3ef8d3f288d}{
\index{bkEnd.cpp@{bkEnd.cpp}!pbROBsize@{pbROBsize}}
\index{pbROBsize@{pbROBsize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{pbROBsize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf pbROBsize}}}
\label{bkEnd_8cpp_aeb8271044b5f2f0cc0d6b3ef8d3f288d}
\hypertarget{bkEnd_8cpp_a24de26574dd41fb459f4e9c7eef97d2d}{
\index{bkEnd.cpp@{bkEnd.cpp}!perfectRegRen@{perfectRegRen}}
\index{perfectRegRen@{perfectRegRen}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{perfectRegRen}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf perfectRegRen} = false}}
\label{bkEnd_8cpp_a24de26574dd41fb459f4e9c7eef97d2d}
\hypertarget{bkEnd_8cpp_aa9f966543a1fad5f317290d2529dee5b}{
\index{bkEnd.cpp@{bkEnd.cpp}!phCritPathHist@{phCritPathHist}}
\index{phCritPathHist@{phCritPathHist}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{phCritPathHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf hist}$\ast$ {\bf phCritPathHist}}}
\label{bkEnd_8cpp_aa9f966543a1fad5f317290d2529dee5b}
\hypertarget{bkEnd_8cpp_a1985e535946ec8df48f67faaa3f0e2bf}{
\index{bkEnd.cpp@{bkEnd.cpp}!phCycle@{phCycle}}
\index{phCycle@{phCycle}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{phCycle}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf phCycle} = 0}}
\label{bkEnd_8cpp_a1985e535946ec8df48f67faaa3f0e2bf}
\hypertarget{bkEnd_8cpp_ad56ae4aa91c8a06d94f2b137fa93258d}{
\index{bkEnd.cpp@{bkEnd.cpp}!PhListSize@{PhListSize}}
\index{PhListSize@{PhListSize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{PhListSize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf PhListSize} = 100}}
\label{bkEnd_8cpp_ad56ae4aa91c8a06d94f2b137fa93258d}
\hypertarget{bkEnd_8cpp_a77fc2d35c5f7077be762435e06e16bd2}{
\index{bkEnd.cpp@{bkEnd.cpp}!phraseFile@{phraseFile}}
\index{phraseFile@{phraseFile}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{phraseFile}]{\setlength{\rightskip}{0pt plus 5cm}FILE$\ast$ {\bf phraseFile}}}
\label{bkEnd_8cpp_a77fc2d35c5f7077be762435e06e16bd2}
\hypertarget{bkEnd_8cpp_a3709ef01c299a1b84a1b023b9a44d4bc}{
\index{bkEnd.cpp@{bkEnd.cpp}!phraseID@{phraseID}}
\index{phraseID@{phraseID}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{phraseID}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf phraseID} = 0}}
\label{bkEnd_8cpp_a3709ef01c299a1b84a1b023b9a44d4bc}
\hypertarget{bkEnd_8cpp_a2e417281295ec1ce0e132e2a37ad227d}{
\index{bkEnd.cpp@{bkEnd.cpp}!phraseSizeBound@{phraseSizeBound}}
\index{phraseSizeBound@{phraseSizeBound}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{phraseSizeBound}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf phraseSizeBound} = MAX\_\-NUM\_\-INS\_\-VISITORS}}
\label{bkEnd_8cpp_a2e417281295ec1ce0e132e2a37ad227d}
\hypertarget{bkEnd_8cpp_a6bf02640e739260e991ef79f520ec0a4}{
\index{bkEnd.cpp@{bkEnd.cpp}!phSizeHist@{phSizeHist}}
\index{phSizeHist@{phSizeHist}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{phSizeHist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf hist}$\ast$ {\bf phSizeHist}}}
\label{bkEnd_8cpp_a6bf02640e739260e991ef79f520ec0a4}
\hypertarget{bkEnd_8cpp_ac4589ec3ae9811cdbbcaa0388bd1a557}{
\index{bkEnd.cpp@{bkEnd.cpp}!pinFile@{pinFile}}
\index{pinFile@{pinFile}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{pinFile}]{\setlength{\rightskip}{0pt plus 5cm}FILE$\ast$ {\bf pinFile}}}
\label{bkEnd_8cpp_ac4589ec3ae9811cdbbcaa0388bd1a557}
\hypertarget{bkEnd_8cpp_a00d2c11cba3a3f23cf4967a1e481ff7c}{
\index{bkEnd.cpp@{bkEnd.cpp}!predictor@{predictor}}
\index{predictor@{predictor}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{predictor}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TournamentBP}$\ast$ {\bf predictor} = NULL}}
\label{bkEnd_8cpp_a00d2c11cba3a3f23cf4967a1e481ff7c}
\hypertarget{bkEnd_8cpp_a3940161b607133ebd851ec48a8eb6e51}{
\index{bkEnd.cpp@{bkEnd.cpp}!print\_\-count@{print\_\-count}}
\index{print\_\-count@{print\_\-count}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{print\_\-count}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf print\_\-count} = 0}}
\label{bkEnd_8cpp_a3940161b607133ebd851ec48a8eb6e51}
\hypertarget{bkEnd_8cpp_a36c2cd06ade9d3098dde0c50717fa838}{
\index{bkEnd.cpp@{bkEnd.cpp}!reportTrace@{reportTrace}}
\index{reportTrace@{reportTrace}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{reportTrace}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf reportTrace} = false}}
\label{bkEnd_8cpp_a36c2cd06ade9d3098dde0c50717fa838}
\hypertarget{bkEnd_8cpp_abff560f06193e35b78e72071d5653eb0}{
\index{bkEnd.cpp@{bkEnd.cpp}!reportTraceAndHitMiss@{reportTraceAndHitMiss}}
\index{reportTraceAndHitMiss@{reportTraceAndHitMiss}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{reportTraceAndHitMiss}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf reportTraceAndHitMiss} = false}}
\label{bkEnd_8cpp_abff560f06193e35b78e72071d5653eb0}
\hypertarget{bkEnd_8cpp_a880392d0383fea210f5ae5b88cc5eeba}{
\index{bkEnd.cpp@{bkEnd.cpp}!reschedule@{reschedule}}
\index{reschedule@{reschedule}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{reschedule}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf reschedule} = false}}
\label{bkEnd_8cpp_a880392d0383fea210f5ae5b88cc5eeba}
\hypertarget{bkEnd_8cpp_a0e5f51d6a6b1d82437b223b600c984c2}{
\index{bkEnd.cpp@{bkEnd.cpp}!reScheduleFile@{reScheduleFile}}
\index{reScheduleFile@{reScheduleFile}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{reScheduleFile}]{\setlength{\rightskip}{0pt plus 5cm}FILE$\ast$ {\bf reScheduleFile}}}
\label{bkEnd_8cpp_a0e5f51d6a6b1d82437b223b600c984c2}
\hypertarget{bkEnd_8cpp_a2d3dfa31b077f1d81553e749601f1c58}{
\index{bkEnd.cpp@{bkEnd.cpp}!RF@{RF}}
\index{RF@{RF}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{RF}]{\setlength{\rightskip}{0pt plus 5cm}{\bf regFile}$\ast$ {\bf RF}}}
\label{bkEnd_8cpp_a2d3dfa31b077f1d81553e749601f1c58}
\hypertarget{bkEnd_8cpp_a06a6e046fd7b9a66b03d334b1df5e3ad}{
\index{bkEnd.cpp@{bkEnd.cpp}!ROBsize@{ROBsize}}
\index{ROBsize@{ROBsize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{ROBsize}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf ROBsize}}}
\label{bkEnd_8cpp_a06a6e046fd7b9a66b03d334b1df5e3ad}
\hypertarget{bkEnd_8cpp_a960c872c7813979fde70109b980a40d6}{
\index{bkEnd.cpp@{bkEnd.cpp}!rrSize@{rrSize}}
\index{rrSize@{rrSize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{rrSize}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf rrSize} = 0}}
\label{bkEnd_8cpp_a960c872c7813979fde70109b980a40d6}
\hypertarget{bkEnd_8cpp_a1dd7dc7ec5b0445afcc24d3fc4bd4164}{
\index{bkEnd.cpp@{bkEnd.cpp}!runningFragNumber@{runningFragNumber}}
\index{runningFragNumber@{runningFragNumber}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{runningFragNumber}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf runningFragNumber}}}
\label{bkEnd_8cpp_a1dd7dc7ec5b0445afcc24d3fc4bd4164}
\hypertarget{bkEnd_8cpp_a782a546d55a0f531f577aab7342c5ae8}{
\index{bkEnd.cpp@{bkEnd.cpp}!SBactiveCycles@{SBactiveCycles}}
\index{SBactiveCycles@{SBactiveCycles}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{SBactiveCycles}]{\setlength{\rightskip}{0pt plus 5cm}long int$\ast$ {\bf SBactiveCycles} = new long int \mbox{[}{\bf numSideBuffs}\mbox{]}}}
\label{bkEnd_8cpp_a782a546d55a0f531f577aab7342c5ae8}
\hypertarget{bkEnd_8cpp_ac80333f7873dfd04b73922669d3df554}{
\index{bkEnd.cpp@{bkEnd.cpp}!SBlength@{SBlength}}
\index{SBlength@{SBlength}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{SBlength}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf SBlength} = SB\_\-SIZE\_\-LIMIT}}
\label{bkEnd_8cpp_ac80333f7873dfd04b73922669d3df554}
\hypertarget{bkEnd_8cpp_a441b50ca30ab742e02e0d1aca889307b}{
\index{bkEnd.cpp@{bkEnd.cpp}!SBlist@{SBlist}}
\index{SBlist@{SBlist}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{SBlist}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$int$>$$\ast$ {\bf SBlist} = new {\bf List}$<$int$>$}}
\label{bkEnd_8cpp_a441b50ca30ab742e02e0d1aca889307b}
\hypertarget{bkEnd_8cpp_a8e6f89aabd81d260a14e7c203d6e08a7}{
\index{bkEnd.cpp@{bkEnd.cpp}!SBoffCycles@{SBoffCycles}}
\index{SBoffCycles@{SBoffCycles}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{SBoffCycles}]{\setlength{\rightskip}{0pt plus 5cm}long int$\ast$ {\bf SBoffCycles} = new long int \mbox{[}{\bf numSideBuffs}\mbox{]}}}
\label{bkEnd_8cpp_a8e6f89aabd81d260a14e7c203d6e08a7}
\hypertarget{bkEnd_8cpp_acb9a5d4416a8eae707a46571f8e54bff}{
\index{bkEnd.cpp@{bkEnd.cpp}!SBpriorityList@{SBpriorityList}}
\index{SBpriorityList@{SBpriorityList}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{SBpriorityList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$int$>$$\ast$ {\bf SBpriorityList}}}
\label{bkEnd_8cpp_acb9a5d4416a8eae707a46571f8e54bff}
\hypertarget{bkEnd_8cpp_aaae1ecdf840d99afd76706706450524b}{
\index{bkEnd.cpp@{bkEnd.cpp}!SBsize@{SBsize}}
\index{SBsize@{SBsize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{SBsize}]{\setlength{\rightskip}{0pt plus 5cm}long unsigned$\ast$ {\bf SBsize} = new long unsigned \mbox{[}{\bf numSideBuffs}\mbox{]}}}
\label{bkEnd_8cpp_aaae1ecdf840d99afd76706706450524b}
\hypertarget{bkEnd_8cpp_a11210922214a240fb374152864c598ca}{
\index{bkEnd.cpp@{bkEnd.cpp}!SBsizeList@{SBsizeList}}
\index{SBsizeList@{SBsizeList}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{SBsizeList}]{\setlength{\rightskip}{0pt plus 5cm}{\bf List}$<$int$>$$\ast$ {\bf SBsizeList} = new {\bf List}$<$int$>$}}
\label{bkEnd_8cpp_a11210922214a240fb374152864c598ca}
\hypertarget{bkEnd_8cpp_a906e52723622864ac6f5d1942021545c}{
\index{bkEnd.cpp@{bkEnd.cpp}!sqSize@{sqSize}}
\index{sqSize@{sqSize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{sqSize}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf sqSize} = 0}}
\label{bkEnd_8cpp_a906e52723622864ac6f5d1942021545c}
\hypertarget{bkEnd_8cpp_a0e845623020a577aea1623384ed5d9eb}{
\index{bkEnd.cpp@{bkEnd.cpp}!squashBRinsCount@{squashBRinsCount}}
\index{squashBRinsCount@{squashBRinsCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{squashBRinsCount}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf squashBRinsCount} = 0}}
\label{bkEnd_8cpp_a0e845623020a577aea1623384ed5d9eb}
\hypertarget{bkEnd_8cpp_a8b2251d5f55aba867043997b1f794fa7}{
\index{bkEnd.cpp@{bkEnd.cpp}!squashCount@{squashCount}}
\index{squashCount@{squashCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{squashCount}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf squashCount} = 0}}
\label{bkEnd_8cpp_a8b2251d5f55aba867043997b1f794fa7}
\hypertarget{bkEnd_8cpp_a514b3db4380a7c56e04f22b24fd94fc2}{
\index{bkEnd.cpp@{bkEnd.cpp}!squashInsCount@{squashInsCount}}
\index{squashInsCount@{squashInsCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{squashInsCount}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf squashInsCount} = 0}}
\label{bkEnd_8cpp_a514b3db4380a7c56e04f22b24fd94fc2}
\hypertarget{bkEnd_8cpp_a389709682848b6b5fb2dd86394287e27}{
\index{bkEnd.cpp@{bkEnd.cpp}!squashLQinsCount@{squashLQinsCount}}
\index{squashLQinsCount@{squashLQinsCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{squashLQinsCount}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf squashLQinsCount} = 0}}
\label{bkEnd_8cpp_a389709682848b6b5fb2dd86394287e27}
\hypertarget{bkEnd_8cpp_ab8599a08e3c482c99e25b917e8342c2e}{
\index{bkEnd.cpp@{bkEnd.cpp}!squashLRFcount@{squashLRFcount}}
\index{squashLRFcount@{squashLRFcount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{squashLRFcount}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf squashLRFcount} = 0}}
\label{bkEnd_8cpp_ab8599a08e3c482c99e25b917e8342c2e}
\hypertarget{bkEnd_8cpp_a0a4857c3deadd79ab3ea72b120ba0fe8}{
\index{bkEnd.cpp@{bkEnd.cpp}!squashPhrInsCount@{squashPhrInsCount}}
\index{squashPhrInsCount@{squashPhrInsCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{squashPhrInsCount}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf squashPhrInsCount} = 0}}
\label{bkEnd_8cpp_a0a4857c3deadd79ab3ea72b120ba0fe8}
\hypertarget{bkEnd_8cpp_abc0f16ebe353acf6b6fdb8a253af477d}{
\index{bkEnd.cpp@{bkEnd.cpp}!squashRegRenCount@{squashRegRenCount}}
\index{squashRegRenCount@{squashRegRenCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{squashRegRenCount}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf squashRegRenCount} = 0}}
\label{bkEnd_8cpp_abc0f16ebe353acf6b6fdb8a253af477d}
\hypertarget{bkEnd_8cpp_a18e20b819b11dbfb38a06e026142f8e0}{
\index{bkEnd.cpp@{bkEnd.cpp}!squashRSinsCount@{squashRSinsCount}}
\index{squashRSinsCount@{squashRSinsCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{squashRSinsCount}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf squashRSinsCount} = 0}}
\label{bkEnd_8cpp_a18e20b819b11dbfb38a06e026142f8e0}
\hypertarget{bkEnd_8cpp_a2cd5012e008846c3d0473aea56dc0421}{
\index{bkEnd.cpp@{bkEnd.cpp}!squashSQinsCount@{squashSQinsCount}}
\index{squashSQinsCount@{squashSQinsCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{squashSQinsCount}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf squashSQinsCount} = 0}}
\label{bkEnd_8cpp_a2cd5012e008846c3d0473aea56dc0421}
\hypertarget{bkEnd_8cpp_a1ee4089bacf27c9f9cb690babeb57b55}{
\index{bkEnd.cpp@{bkEnd.cpp}!squashWinInsCount@{squashWinInsCount}}
\index{squashWinInsCount@{squashWinInsCount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{squashWinInsCount}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf squashWinInsCount} = 0}}
\label{bkEnd_8cpp_a1ee4089bacf27c9f9cb690babeb57b55}
\hypertarget{bkEnd_8cpp_ada310e7f72b38fadd4b24d80ed3438ee}{
\index{bkEnd.cpp@{bkEnd.cpp}!start@{start}}
\index{start@{start}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{start}]{\setlength{\rightskip}{0pt plus 5cm}time\_\-t {\bf start}}}
\label{bkEnd_8cpp_ada310e7f72b38fadd4b24d80ed3438ee}
\hypertarget{bkEnd_8cpp_a73bd470252d42e355346dfd2575c776d}{
\index{bkEnd.cpp@{bkEnd.cpp}!start\_\-print@{start\_\-print}}
\index{start\_\-print@{start\_\-print}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{start\_\-print}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf start\_\-print} = false}}
\label{bkEnd_8cpp_a73bd470252d42e355346dfd2575c776d}
\hypertarget{bkEnd_8cpp_a11e3878a580a088bd3ce667a54e8a62d}{
\index{bkEnd.cpp@{bkEnd.cpp}!stFwdMemOp@{stFwdMemOp}}
\index{stFwdMemOp@{stFwdMemOp}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{stFwdMemOp}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf stFwdMemOp} = 0}}
\label{bkEnd_8cpp_a11e3878a580a088bd3ce667a54e8a62d}
\hypertarget{bkEnd_8cpp_a295eb046e3bc33d7d17cf3e21c71910e}{
\index{bkEnd.cpp@{bkEnd.cpp}!total\_\-num\_\-strand\_\-ins@{total\_\-num\_\-strand\_\-ins}}
\index{total\_\-num\_\-strand\_\-ins@{total\_\-num\_\-strand\_\-ins}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{total\_\-num\_\-strand\_\-ins}]{\setlength{\rightskip}{0pt plus 5cm}long long int {\bf total\_\-num\_\-strand\_\-ins} = 0}}
\label{bkEnd_8cpp_a295eb046e3bc33d7d17cf3e21c71910e}
\hypertarget{bkEnd_8cpp_a373fbba4cafdbfeb353503c4dc35d1e4}{
\index{bkEnd.cpp@{bkEnd.cpp}!totalSBsize@{totalSBsize}}
\index{totalSBsize@{totalSBsize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totalSBsize}]{\setlength{\rightskip}{0pt plus 5cm}long unsigned {\bf totalSBsize} = 0}}
\label{bkEnd_8cpp_a373fbba4cafdbfeb353503c4dc35d1e4}
\hypertarget{bkEnd_8cpp_a60db58d54ff9814390e82ed746c7e484}{
\index{bkEnd.cpp@{bkEnd.cpp}!totFrameSize@{totFrameSize}}
\index{totFrameSize@{totFrameSize}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totFrameSize}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totFrameSize} = 0}}
\label{bkEnd_8cpp_a60db58d54ff9814390e82ed746c7e484}
\hypertarget{bkEnd_8cpp_adff839258d7ad49e2b0fc21c1eafad40}{
\index{bkEnd.cpp@{bkEnd.cpp}!totFrStall@{totFrStall}}
\index{totFrStall@{totFrStall}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totFrStall}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totFrStall} = 0}}
\label{bkEnd_8cpp_adff839258d7ad49e2b0fc21c1eafad40}
\hypertarget{bkEnd_8cpp_a1f95e2dbf2d6bbd0969150ab292206ec}{
\index{bkEnd.cpp@{bkEnd.cpp}!totInsCountWhenSBon@{totInsCountWhenSBon}}
\index{totInsCountWhenSBon@{totInsCountWhenSBon}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totInsCountWhenSBon}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totInsCountWhenSBon} = 0}}
\label{bkEnd_8cpp_a1f95e2dbf2d6bbd0969150ab292206ec}
\hypertarget{bkEnd_8cpp_a4bfc1483b6aefe8b6422fc04f4cfb7e0}{
\index{bkEnd.cpp@{bkEnd.cpp}!totInsVisitingSBcount@{totInsVisitingSBcount}}
\index{totInsVisitingSBcount@{totInsVisitingSBcount}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totInsVisitingSBcount}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totInsVisitingSBcount} = 0}}
\label{bkEnd_8cpp_a4bfc1483b6aefe8b6422fc04f4cfb7e0}
\hypertarget{bkEnd_8cpp_af259df35d99544e6c1940312d65e3658}{
\index{bkEnd.cpp@{bkEnd.cpp}!totMainStreamBound@{totMainStreamBound}}
\index{totMainStreamBound@{totMainStreamBound}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totMainStreamBound}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totMainStreamBound} = 0}}
\label{bkEnd_8cpp_af259df35d99544e6c1940312d65e3658}
\hypertarget{bkEnd_8cpp_a148b0106fd99040a9fd6aba42a7f5a51}{
\index{bkEnd.cpp@{bkEnd.cpp}!totNumCritPathViol@{totNumCritPathViol}}
\index{totNumCritPathViol@{totNumCritPathViol}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totNumCritPathViol}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totNumCritPathViol} = 0}}
\label{bkEnd_8cpp_a148b0106fd99040a9fd6aba42a7f5a51}
\hypertarget{bkEnd_8cpp_a7014445eaece6bc443d6b47b3076d4db}{
\index{bkEnd.cpp@{bkEnd.cpp}!totNumFrag@{totNumFrag}}
\index{totNumFrag@{totNumFrag}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totNumFrag}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totNumFrag} = 0}}
\label{bkEnd_8cpp_a7014445eaece6bc443d6b47b3076d4db}
\hypertarget{bkEnd_8cpp_a7067d74f5505d4c1e8d8ac5ec020a1b8}{
\index{bkEnd.cpp@{bkEnd.cpp}!totNumOfSigleFragPhrases@{totNumOfSigleFragPhrases}}
\index{totNumOfSigleFragPhrases@{totNumOfSigleFragPhrases}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totNumOfSigleFragPhrases}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totNumOfSigleFragPhrases} = 0}}
\label{bkEnd_8cpp_a7067d74f5505d4c1e8d8ac5ec020a1b8}
\hypertarget{bkEnd_8cpp_a4e77e421d1fab38cc99f0b8d6fe32381}{
\index{bkEnd.cpp@{bkEnd.cpp}!totNumPhGenResets@{totNumPhGenResets}}
\index{totNumPhGenResets@{totNumPhGenResets}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totNumPhGenResets}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totNumPhGenResets} = 0}}
\label{bkEnd_8cpp_a4e77e421d1fab38cc99f0b8d6fe32381}
\hypertarget{bkEnd_8cpp_aa0401948da1730abb47403f5abfb0177}{
\index{bkEnd.cpp@{bkEnd.cpp}!totNumPhrase@{totNumPhrase}}
\index{totNumPhrase@{totNumPhrase}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totNumPhrase}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totNumPhrase} = 0}}
\label{bkEnd_8cpp_aa0401948da1730abb47403f5abfb0177}
\hypertarget{bkEnd_8cpp_af11920776ab445587c1ce2f48679e512}{
\index{bkEnd.cpp@{bkEnd.cpp}!totNumPhraseAncestors@{totNumPhraseAncestors}}
\index{totNumPhraseAncestors@{totNumPhraseAncestors}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totNumPhraseAncestors}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totNumPhraseAncestors} = 0}}
\label{bkEnd_8cpp_af11920776ab445587c1ce2f48679e512}
\hypertarget{bkEnd_8cpp_a17080a3e155de1ec688dbf44eac39838}{
\index{bkEnd.cpp@{bkEnd.cpp}!totNumPhUnpredMemOp@{totNumPhUnpredMemOp}}
\index{totNumPhUnpredMemOp@{totNumPhUnpredMemOp}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totNumPhUnpredMemOp}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totNumPhUnpredMemOp} = 0}}
\label{bkEnd_8cpp_a17080a3e155de1ec688dbf44eac39838}
\hypertarget{bkEnd_8cpp_a68b1015c6457559a53773263cbf73dfa}{
\index{bkEnd.cpp@{bkEnd.cpp}!totNumRealFrag@{totNumRealFrag}}
\index{totNumRealFrag@{totNumRealFrag}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totNumRealFrag}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totNumRealFrag} = 0}}
\label{bkEnd_8cpp_a68b1015c6457559a53773263cbf73dfa}
\hypertarget{bkEnd_8cpp_a74ec424cfa117db797896d4ba741ef85}{
\index{bkEnd.cpp@{bkEnd.cpp}!totNumRootIns@{totNumRootIns}}
\index{totNumRootIns@{totNumRootIns}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totNumRootIns}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totNumRootIns} = 0}}
\label{bkEnd_8cpp_a74ec424cfa117db797896d4ba741ef85}
\hypertarget{bkEnd_8cpp_ade40078060c9ea45a4a30adbcad861bf}{
\index{bkEnd.cpp@{bkEnd.cpp}!totNumRootPh@{totNumRootPh}}
\index{totNumRootPh@{totNumRootPh}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totNumRootPh}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totNumRootPh} = 0}}
\label{bkEnd_8cpp_ade40078060c9ea45a4a30adbcad861bf}
\hypertarget{bkEnd_8cpp_ac753d4e26142b8751fabcf2793ffd2b3}{
\index{bkEnd.cpp@{bkEnd.cpp}!totNumSBactivations@{totNumSBactivations}}
\index{totNumSBactivations@{totNumSBactivations}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totNumSBactivations}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totNumSBactivations} = 0}}
\label{bkEnd_8cpp_ac753d4e26142b8751fabcf2793ffd2b3}
\hypertarget{bkEnd_8cpp_ac4f66ee745d0d0159ccf3630448f1bca}{
\index{bkEnd.cpp@{bkEnd.cpp}!totNumSBreactivations@{totNumSBreactivations}}
\index{totNumSBreactivations@{totNumSBreactivations}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totNumSBreactivations}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totNumSBreactivations} = 0}}
\label{bkEnd_8cpp_ac4f66ee745d0d0159ccf3630448f1bca}
\hypertarget{bkEnd_8cpp_a97ad0b6082503d6f33a93ac5c590e480}{
\index{bkEnd.cpp@{bkEnd.cpp}!totNumSoftBound@{totNumSoftBound}}
\index{totNumSoftBound@{totNumSoftBound}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totNumSoftBound}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totNumSoftBound} = 0}}
\label{bkEnd_8cpp_a97ad0b6082503d6f33a93ac5c590e480}
\hypertarget{bkEnd_8cpp_a5ee417237aef174d8cd2bb79d099f4e2}{
\index{bkEnd.cpp@{bkEnd.cpp}!totPhStall@{totPhStall}}
\index{totPhStall@{totPhStall}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totPhStall}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totPhStall} = 0}}
\label{bkEnd_8cpp_a5ee417237aef174d8cd2bb79d099f4e2}
\hypertarget{bkEnd_8cpp_aff18f359b22d2e65871b803be6edc8c1}{
\index{bkEnd.cpp@{bkEnd.cpp}!totSBactiveCycles@{totSBactiveCycles}}
\index{totSBactiveCycles@{totSBactiveCycles}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totSBactiveCycles}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totSBactiveCycles} = 0}}
\label{bkEnd_8cpp_aff18f359b22d2e65871b803be6edc8c1}
\hypertarget{bkEnd_8cpp_ace3198fb3de7e5dc13d0995f38b530fb}{
\index{bkEnd.cpp@{bkEnd.cpp}!totSBoffCycles@{totSBoffCycles}}
\index{totSBoffCycles@{totSBoffCycles}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totSBoffCycles}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totSBoffCycles} = 0}}
\label{bkEnd_8cpp_ace3198fb3de7e5dc13d0995f38b530fb}
\hypertarget{bkEnd_8cpp_a048055f984c4d0c31fc8a133c206f73e}{
\index{bkEnd.cpp@{bkEnd.cpp}!totSizRealFrag@{totSizRealFrag}}
\index{totSizRealFrag@{totSizRealFrag}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{totSizRealFrag}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf totSizRealFrag} = 0}}
\label{bkEnd_8cpp_a048055f984c4d0c31fc8a133c206f73e}
\hypertarget{bkEnd_8cpp_a839b51bce9a6c8b6c9d9080c1e86c2cc}{
\index{bkEnd.cpp@{bkEnd.cpp}!unexpectedMiss@{unexpectedMiss}}
\index{unexpectedMiss@{unexpectedMiss}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{unexpectedMiss}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf unexpectedMiss} = 0}}
\label{bkEnd_8cpp_a839b51bce9a6c8b6c9d9080c1e86c2cc}
\hypertarget{bkEnd_8cpp_a04887990fda36c4ec9170f07fc7de069}{
\index{bkEnd.cpp@{bkEnd.cpp}!unexpecteedLat@{unexpecteedLat}}
\index{unexpecteedLat@{unexpecteedLat}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{unexpecteedLat}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf unexpecteedLat} = 0}}
\label{bkEnd_8cpp_a04887990fda36c4ec9170f07fc7de069}
\hypertarget{bkEnd_8cpp_a04ebe6ac3125163359d4a78297881816}{
\index{bkEnd.cpp@{bkEnd.cpp}!unpredMemInsCnt@{unpredMemInsCnt}}
\index{unpredMemInsCnt@{unpredMemInsCnt}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{unpredMemInsCnt}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf unpredMemInsCnt} = 0}}
\label{bkEnd_8cpp_a04ebe6ac3125163359d4a78297881816}
\hypertarget{bkEnd_8cpp_a63c4fc64877e8bbc0f9a2b03e75747b8}{
\index{bkEnd.cpp@{bkEnd.cpp}!unpredMemOpCnt@{unpredMemOpCnt}}
\index{unpredMemOpCnt@{unpredMemOpCnt}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{unpredMemOpCnt}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf unpredMemOpCnt} = 0}}
\label{bkEnd_8cpp_a63c4fc64877e8bbc0f9a2b03e75747b8}
\hypertarget{bkEnd_8cpp_a88cfebd9f1e296c291bf05c5a78a6177}{
\index{bkEnd.cpp@{bkEnd.cpp}!unpredMemOpThreshold@{unpredMemOpThreshold}}
\index{unpredMemOpThreshold@{unpredMemOpThreshold}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{unpredMemOpThreshold}]{\setlength{\rightskip}{0pt plus 5cm}float {\bf unpredMemOpThreshold} = UNPRED\_\-MEM\_\-THRESHOLD}}
\label{bkEnd_8cpp_a88cfebd9f1e296c291bf05c5a78a6177}
\hypertarget{bkEnd_8cpp_a7277fb65c975b154a18137469afeb3f2}{
\index{bkEnd.cpp@{bkEnd.cpp}!UPLDhoist@{UPLDhoist}}
\index{UPLDhoist@{UPLDhoist}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{UPLDhoist}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf UPLDhoist} = false}}
\label{bkEnd_8cpp_a7277fb65c975b154a18137469afeb3f2}
\hypertarget{bkEnd_8cpp_ad10d3c35c7ebe4161160c67b1f711335}{
\index{bkEnd.cpp@{bkEnd.cpp}!upldMissRateProfileMap@{upldMissRateProfileMap}}
\index{upldMissRateProfileMap@{upldMissRateProfileMap}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{upldMissRateProfileMap}]{\setlength{\rightskip}{0pt plus 5cm}map$<$long int,float$>$ {\bf upldMissRateProfileMap}}}
\label{bkEnd_8cpp_ad10d3c35c7ebe4161160c67b1f711335}
\hypertarget{bkEnd_8cpp_aff570ff1dcf13ad70c23459a2ebb4c8e}{
\index{bkEnd.cpp@{bkEnd.cpp}!upldProfile@{upldProfile}}
\index{upldProfile@{upldProfile}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{upldProfile}]{\setlength{\rightskip}{0pt plus 5cm}FILE$\ast$ {\bf upldProfile}}}
\label{bkEnd_8cpp_aff570ff1dcf13ad70c23459a2ebb4c8e}
\hypertarget{bkEnd_8cpp_a3e399a2c5b99f032319799880f78cf0b}{
\index{bkEnd.cpp@{bkEnd.cpp}!upldProfileFlag@{upldProfileFlag}}
\index{upldProfileFlag@{upldProfileFlag}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{upldProfileFlag}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf upldProfileFlag} = true}}
\label{bkEnd_8cpp_a3e399a2c5b99f032319799880f78cf0b}
\hypertarget{bkEnd_8cpp_af363413293438e60d03cba536e49a584}{
\index{bkEnd.cpp@{bkEnd.cpp}!wbbSkipCountFile@{wbbSkipCountFile}}
\index{wbbSkipCountFile@{wbbSkipCountFile}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{wbbSkipCountFile}]{\setlength{\rightskip}{0pt plus 5cm}FILE$\ast$ {\bf wbbSkipCountFile}}}
\label{bkEnd_8cpp_af363413293438e60d03cba536e49a584}
\hypertarget{bkEnd_8cpp_a683df1ef3f168d6cbca3bfb0d5f97bc6}{
\index{bkEnd.cpp@{bkEnd.cpp}!windowSatration@{windowSatration}}
\index{windowSatration@{windowSatration}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{windowSatration}]{\setlength{\rightskip}{0pt plus 5cm}long int {\bf windowSatration} = 0}}
\label{bkEnd_8cpp_a683df1ef3f168d6cbca3bfb0d5f97bc6}
\hypertarget{bkEnd_8cpp_adddd54573e6076312789ea401c93718b}{
\index{bkEnd.cpp@{bkEnd.cpp}!xLevDeepLatLevel@{xLevDeepLatLevel}}
\index{xLevDeepLatLevel@{xLevDeepLatLevel}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{xLevDeepLatLevel}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf xLevDeepLatLevel}}}
\label{bkEnd_8cpp_adddd54573e6076312789ea401c93718b}
\hypertarget{bkEnd_8cpp_a6c1acac6218b4ae58652b78892eaf778}{
\index{bkEnd.cpp@{bkEnd.cpp}!xLevelDeepEnable@{xLevelDeepEnable}}
\index{xLevelDeepEnable@{xLevelDeepEnable}!bkEnd.cpp@{bkEnd.cpp}}
\subsubsection[{xLevelDeepEnable}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf xLevelDeepEnable} = false}}
\label{bkEnd_8cpp_a6c1acac6218b4ae58652b78892eaf778}
