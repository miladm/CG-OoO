\hypertarget{classmemory}{
\section{memory Class Reference}
\label{classmemory}\index{memory@{memory}}
}


{\ttfamily \#include $<$memory.h$>$}



Inheritance diagram for memory:


Collaboration diagram for memory:
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmemory_aa3d14e073d23a27348155f95e040862a}{memory} (\hyperlink{classport}{port}$<$ \hyperlink{classdynInstruction}{dynInstruction} $\ast$ $>$ \&execution\_\-to\_\-memory\_\-port, \hyperlink{classport}{port}$<$ \hyperlink{classdynInstruction}{dynInstruction} $\ast$ $>$ \&memory\_\-to\_\-scheduler\_\-port, \hyperlink{classCAMtable}{CAMtable}$<$ \hyperlink{classdynInstruction}{dynInstruction} $\ast$ $>$ $\ast$iROB, \hyperlink{global_2global_8h_a6fa2e24b8a418fa215e183264cbea3aa}{WIDTH} memory\_\-width, \hyperlink{classsysClock}{sysClock} $\ast$\hyperlink{g__objs_8h_afc4784c140eed1743728e83840e91c12}{clk}, string stage\_\-name)
\item 
\hyperlink{classmemory_ae5893b724ce22f38b776558384f21680}{$\sim$memory} ()
\item 
void \hyperlink{classmemory_a5b12309e3a0e50f08be4f09dbd207e9f}{doMEMORY} ()
\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmemory_aa3d14e073d23a27348155f95e040862a}{
\index{memory@{memory}!memory@{memory}}
\index{memory@{memory}!memory@{memory}}
\subsubsection[{memory}]{\setlength{\rightskip}{0pt plus 5cm}memory::memory (
\begin{DoxyParamCaption}
\item[{{\bf port}$<$ {\bf dynInstruction} $\ast$ $>$ \&}]{execution\_\-to\_\-memory\_\-port, }
\item[{{\bf port}$<$ {\bf dynInstruction} $\ast$ $>$ \&}]{memory\_\-to\_\-scheduler\_\-port, }
\item[{{\bf CAMtable}$<$ {\bf dynInstruction} $\ast$ $>$ $\ast$}]{iROB, }
\item[{{\bf WIDTH}}]{memory\_\-width, }
\item[{{\bf sysClock} $\ast$}]{clk, }
\item[{string}]{stage\_\-name}
\end{DoxyParamCaption}
)}}
\label{classmemory_aa3d14e073d23a27348155f95e040862a}

\begin{DoxyCode}
        : stage (memory_width, stage_name, g_cfg->_root["cpu"]["backend"]["ino_pi
      pe"]["memory"], clk),
      _mem_buff (20, 1, clk, "mem_buff"),
      _mshr (clk, g_cfg->_root["cpu"]["backend"]["table"]["mshr"], "MSHR"),
      _st_buff (clk, g_cfg->_root["cpu"]["backend"]["table"]["st_buff"], "stBuff"
      ),
//      _L1 (1, 64, 32768),
//      _L2 (1, 64, 2097152),
//      _L3 (1, 64, 8388608),
      _cache ("/home/milad/esc_project/svn/PARS/src/config/simple.yaml"),
      s_cache_miss_cnt (g_stats.newScalarStat (stage_name, "cache_miss_cnt", "Num
      ber of cache misses", 0, PRINT_ZERO)),
      s_cache_hit_cnt  (g_stats.newScalarStat (stage_name, "cache_hit_cnt", "Numb
      er of cache hits", 0, PRINT_ZERO)),
      s_ld_miss_cnt (g_stats.newScalarStat (stage_name, "ld_miss_cnt", "Number of
       load misses", 0, PRINT_ZERO)),
      s_ld_hit_cnt  (g_stats.newScalarStat (stage_name, "ld_hit_cnt", "Number of 
      load hits", 0, PRINT_ZERO)),
      s_st_miss_cnt (g_stats.newScalarStat (stage_name, "st_miss_cnt", "Number of
       store misses", 0, PRINT_ZERO)),
      s_st_hit_cnt  (g_stats.newScalarStat (stage_name, "st_hit_cnt", "Number of 
      store hits", 0, PRINT_ZERO))
{
    _execution_to_memory_port = &execution_to_memory_port;
    _memory_to_scheduler_port = &memory_to_scheduler_port;
    _iROB = iROB;
}
\end{DoxyCode}
\hypertarget{classmemory_ae5893b724ce22f38b776558384f21680}{
\index{memory@{memory}!$\sim$memory@{$\sim$memory}}
\index{$\sim$memory@{$\sim$memory}!memory@{memory}}
\subsubsection[{$\sim$memory}]{\setlength{\rightskip}{0pt plus 5cm}memory::$\sim$memory (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmemory_ae5893b724ce22f38b776558384f21680}

\begin{DoxyCode}
{}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{classmemory_a5b12309e3a0e50f08be4f09dbd207e9f}{
\index{memory@{memory}!doMEMORY@{doMEMORY}}
\index{doMEMORY@{doMEMORY}!memory@{memory}}
\subsubsection[{doMEMORY}]{\setlength{\rightskip}{0pt plus 5cm}void memory::doMEMORY (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmemory_a5b12309e3a0e50f08be4f09dbd207e9f}

\begin{DoxyCode}
                       {
    /* STAT + DEBUG */
    dbg.print (DBG_MEMORY, "%s: (cyc: %d)\n", _stage_name.c_str (), _clk->now ())
      ;
    regStat ();
    PIPE_ACTIVITY pipe_stall = PIPE_STALL;

    /* WRITEBACK RESULT */
    completeIns ();

    /* SQUASH HANDLING */
    if (g_var.g_pipe_state == PIPE_FLUSH) { squash (); }

    pipe_stall = memoryImpl ();

    /* STAT */
    if (pipe_stall == PIPE_STALL) s_stall_cycles++;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:




The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
/home/milad/esc\_\-project/svn/PARS/src/backend/ino/\hyperlink{ino_2memory_8h}{memory.h}\item 
/home/milad/esc\_\-project/svn/PARS/src/backend/ino/\hyperlink{ino_2memory_8cpp}{memory.cpp}\end{DoxyCompactItemize}
