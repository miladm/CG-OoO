\hypertarget{pars_8cpp}{
\section{/home/milad/esc\_\-project/svn/PARS/src/frontend/pars.cpp File Reference}
\label{pars_8cpp}\index{/home/milad/esc\_\-project/svn/PARS/src/frontend/pars.cpp@{/home/milad/esc\_\-project/svn/PARS/src/frontend/pars.cpp}}
}
{\ttfamily \#include \char`\"{}pars.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}../global/g\_\-info.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}../backend/bp/tournament.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}../backend/bp/hybrid\_\-skew.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}../backend/bp/btb.h\char`\"{}}\par
{\ttfamily \#include $<$bp\_\-lib/types.hh$>$}\par
{\ttfamily \#include $<$bp\_\-lib/intmath.hh$>$}\par
{\ttfamily \#include \char`\"{}utilities.h\char`\"{}}\par
Include dependency graph for pars.cpp:
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{pars_8cpp_ac1d2415e53b66a9ce46f38808e3627fc}{INS\_\-CNT\_\-THR}~10000
\item 
\#define \hyperlink{pars_8cpp_a6411ebb972f38013759ad3cb1f6a546f}{BB\_\-CNT\_\-THR}~500 + BB\_\-NEAR\_\-EMPTY\_\-SIZE
\item 
\#define \hyperlink{pars_8cpp_aac9e46837cb485689883754c8bd83023}{G\_\-I\_\-INFO\_\-EN}~1
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{pars_8cpp_a505f360905b4ad0fa6e18f19405539ea}{recover} ()
\item 
EXCEPT\_\-HANDLING\_\-RESULT \hyperlink{pars_8cpp_a14053986557d22a3e7d5d06d3f3b5bee}{handlePinException} (THREADID tid, EXCEPTION\_\-INFO $\ast$pExceptInfo, PHYSICAL\_\-CONTEXT $\ast$pPhysCtxt, VOID $\ast$v)
\item 
BOOL \hyperlink{pars_8cpp_a5f145c9581fdc13b0459253871f0338a}{signal\_\-handler} (THREADID tid, INT32 sig, CONTEXT $\ast$ctxt, BOOL hasHandler, const EXCEPTION\_\-INFO $\ast$pExceptInfo, VOID $\ast$v)
\item 
VOID \hyperlink{pars_8cpp_a4f97b9fe13219e7257f0199e22d96637}{HandleInst} (UINT32 uid, BOOL \_\-\_\-is\_\-call, BOOL \_\-\_\-is\_\-ret, BOOL \_\-\_\-is\_\-far\_\-ret)
\item 
VOID \hyperlink{pars_8cpp_a2648ea029809fc0d174d8b1021b99523}{countTrace} (TRACE trace, VOID $\ast$v)
\item 
VOID \hyperlink{pars_8cpp_ad357c3e6fd5bfcbcdfafb58d203f464c}{FlushOnFull} (UINT32 trace\_\-size, UINT32 stub\_\-size)
\item 
VOID \hyperlink{pars_8cpp_af45c42930cc9f7fbe74c2469301fa5f6}{backEnd} (void $\ast$ptr)
\item 
VOID \hyperlink{pars_8cpp_aa757cbb2413d35022392e871acee9978}{pin\_\-\_\-runPARS} (string bench\_\-path, string config\_\-path, string out\_\-dir)
\item 
VOID \hyperlink{pars_8cpp_af75ae1f1ce75a8d6b4c83920963399ef}{pin\_\-\_\-parseConfig} (string bench\_\-path, string config\_\-path, string out\_\-dir)
\item 
VOID \hyperlink{pars_8cpp_a6a2bb09a97d90cc11d502199ce1a432d}{pin\_\-\_\-init} (string bench\_\-path, string config\_\-path, string out\_\-dir)
\item 
VOID \hyperlink{pars_8cpp_a6f5943fb0a6ecd3d79a70a0ccfb72a91}{pin\_\-\_\-doFinish} ()
\item 
VOID \hyperlink{pars_8cpp_a691cde548f8aff0f0cf3e992b3b79d26}{pin\_\-\_\-fini} (INT32 code, VOID $\ast$v)
\item 
EXCEPT\_\-HANDLING\_\-RESULT \hyperlink{pars_8cpp_aeba21456eeaae4baf6f7d0137dc3b242}{handle} (THREADID tid, EXCEPTION\_\-INFO $\ast$pExceptInfo, PHYSICAL\_\-CONTEXT $\ast$pPhysCtxt, VOID $\ast$v)
\item 
void \hyperlink{pars_8cpp_a0958ec4bf081af6c5cf63c9b50a3b65e}{read\_\-mem\_\-orig} (ADDRINT eaddr, ADDRINT len)
\item 
VOID \hyperlink{pars_8cpp_acb954ff3c5105a038d6722b6debb2056}{GetMemWriteOrigValue} (UINT32 uid, CONTEXT $\ast$c, ADDRINT eaddr, ADDRINT len)
\item 
VOID \hyperlink{pars_8cpp_aa22b6461bb9abbe232edce2559997942}{GetMemWriteNewValue} (UINT32 uid, CONTEXT $\ast$c)
\item 
VOID \hyperlink{pars_8cpp_aefef2ba62649f25c8db406d1a4272061}{GetMemReadBypass} (UINT32 uid, CONTEXT $\ast$c, ADDRINT eaddr, ADDRINT len)
\item 
VOID \hyperlink{pars_8cpp_af53ac0627b1cf2178bbce73ab6edbe09}{HandleBranch} (UINT32 uid, BOOL taken, ADDRINT tgt, ADDRINT fthru, ADDRINT \_\-\_\-pc, BOOL \_\-\_\-has\_\-ft, UINT32 \_\-bbInsCnt)
\item 
VOID \hyperlink{pars_8cpp_a2f963499b00d63afb51fc73afb703ef3}{HandleContext} (CONTEXT $\ast$c)
\item 
VOID \hyperlink{pars_8cpp_abdf3999377ed06fdc9507279d3381d70}{HandleSyscall} (UINT32 uid, CONTEXT $\ast$c)
\item 
VOID \hyperlink{pars_8cpp_a7c6b63b21bc5971968616e3f621da22f}{doBBcount} (UINT32 ins\_\-cnt)
\item 
VOID \hyperlink{pars_8cpp_a357d7e4914ba9327454143adda33f0f8}{pin\_\-\_\-instruction} (TRACE trace, VOID $\ast$val)
\item 
ADDRINT \hyperlink{pars_8cpp_a094db9936840dd4a66eec07dbf8b228f}{PredictAndUpdate} (const ADDRINT \_\-\_\-pc, const INT32 \_\-\_\-taken, ADDRINT tgt, const ADDRINT fthru, const UINT32 \_\-blkInsCnt)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
FILTER \hyperlink{pars_8cpp_aa415b778ddffd669c113279e23602671}{filter}
\item 
unsigned char \hyperlink{pars_8cpp_a5e14965f9e14d6406bb5b10e49d24b85}{g\_\-store\_\-buffer} \mbox{[}MAX\_\-MEM\_\-WRITE\_\-LEN\mbox{]}
\item 
map$<$ unsigned, i\_\-info $>$ \hyperlink{pars_8cpp_aab998b67eb0b3b2e5a85862cd87c17db}{g\_\-i\_\-info}
\item 
clock\_\-t \hyperlink{pars_8cpp_a0161597891c90043c55ef8ecc6855e49}{start\_\-pars}
\item 
clock\_\-t \hyperlink{pars_8cpp_aae1c5d9a4ab56767590309b25a7dfa67}{stop\_\-pars}
\item 
\hyperlink{classTournamentBP}{TournamentBP} $\ast$ \hyperlink{pars_8cpp_a4837669c7790ce1a19610a935ffe7383}{g\_\-tournament\_\-bp} = NULL
\item 
\hyperlink{classHybridBPskew}{HybridBPskew} $\ast$ \hyperlink{pars_8cpp_a62e59cbd1759ceca29472f8ed1cfda43}{g\_\-2bcgskew\_\-bp} = NULL
\item 
\hyperlink{classBTB}{BTB} $\ast$ \hyperlink{pars_8cpp_a1de8d6b3a152ca4ca2dec4a1f6d0df9e}{btb} = NULL
\item 
PIN\_\-SEMAPHORE \hyperlink{pars_8cpp_a3780f840dcb4b8cfe00bde4a6cd55d16}{semaphore0}
\item 
PIN\_\-SEMAPHORE \hyperlink{pars_8cpp_ad27290b1818ecaa97935c4d181a158f0}{semaphore1}
\item 
void $\ast$ \hyperlink{pars_8cpp_a1e853eca8d9b1c61c314eed5b83b538a}{rootThreadArg} = (void $\ast$)0xABBA
\item 
PIN\_\-THREAD\_\-UID \hyperlink{pars_8cpp_a5b351a9cd233c0a893b976831dce607c}{rootThreadUid}
\item 
\hyperlink{classstaticCodeParser}{staticCodeParser} $\ast$ \hyperlink{pars_8cpp_ae1f49acdc02bc860091a9c0826042e9a}{g\_\-staticCode}
\item 
\hyperlink{classbenchAddrRangeParser}{benchAddrRangeParser} $\ast$ \hyperlink{pars_8cpp_ab8497513f9992352953a905ed69eea4c}{bench\_\-addr\_\-space}
\item 
\hyperlink{classtable__energy}{table\_\-energy} $\ast$ \hyperlink{pars_8cpp_a45d0afedcd6ed9bf3d004d95b175b77f}{\_\-e\_\-table1}
\item 
\hyperlink{classwire__energy}{wire\_\-energy} $\ast$ \hyperlink{pars_8cpp_a37bce466ede0008f1fc7788ca04a16ce}{\_\-e\_\-wire1}
\item 
\hyperlink{classtable__energy}{table\_\-energy} $\ast$ \hyperlink{pars_8cpp_acad1e9b9ecb9c6b88ac37de527662852}{\_\-e\_\-table2}
\item 
\hyperlink{classwire__energy}{wire\_\-energy} $\ast$ \hyperlink{pars_8cpp_ac9068594a93808f864502caa4a718fb7}{\_\-e\_\-wire2}
\item 
\hyperlink{classtable__energy}{table\_\-energy} $\ast$ \hyperlink{pars_8cpp_a3400e8124ea1d142f61c9ee6e82ff0c3}{\_\-e\_\-btb}
\item 
\hyperlink{classmemory__buffer}{memory\_\-buffer} \hyperlink{pars_8cpp_a627bf9888cdd16a64ce1336bca064d71}{g\_\-log}
\item 
UINT32 \hyperlink{pars_8cpp_aa59b48c7ebc2f8ff62e162b3ca17ebae}{bbInsCnt} = 0
\end{DoxyCompactItemize}


\subsection{Define Documentation}
\hypertarget{pars_8cpp_a6411ebb972f38013759ad3cb1f6a546f}{
\index{pars.cpp@{pars.cpp}!BB\_\-CNT\_\-THR@{BB\_\-CNT\_\-THR}}
\index{BB\_\-CNT\_\-THR@{BB\_\-CNT\_\-THR}!pars.cpp@{pars.cpp}}
\subsubsection[{BB\_\-CNT\_\-THR}]{\setlength{\rightskip}{0pt plus 5cm}\#define BB\_\-CNT\_\-THR~500 + BB\_\-NEAR\_\-EMPTY\_\-SIZE}}
\label{pars_8cpp_a6411ebb972f38013759ad3cb1f6a546f}
\hypertarget{pars_8cpp_aac9e46837cb485689883754c8bd83023}{
\index{pars.cpp@{pars.cpp}!G\_\-I\_\-INFO\_\-EN@{G\_\-I\_\-INFO\_\-EN}}
\index{G\_\-I\_\-INFO\_\-EN@{G\_\-I\_\-INFO\_\-EN}!pars.cpp@{pars.cpp}}
\subsubsection[{G\_\-I\_\-INFO\_\-EN}]{\setlength{\rightskip}{0pt plus 5cm}\#define G\_\-I\_\-INFO\_\-EN~1}}
\label{pars_8cpp_aac9e46837cb485689883754c8bd83023}
\hypertarget{pars_8cpp_ac1d2415e53b66a9ce46f38808e3627fc}{
\index{pars.cpp@{pars.cpp}!INS\_\-CNT\_\-THR@{INS\_\-CNT\_\-THR}}
\index{INS\_\-CNT\_\-THR@{INS\_\-CNT\_\-THR}!pars.cpp@{pars.cpp}}
\subsubsection[{INS\_\-CNT\_\-THR}]{\setlength{\rightskip}{0pt plus 5cm}\#define INS\_\-CNT\_\-THR~10000}}
\label{pars_8cpp_ac1d2415e53b66a9ce46f38808e3627fc}


\subsection{Function Documentation}
\hypertarget{pars_8cpp_af45c42930cc9f7fbe74c2469301fa5f6}{
\index{pars.cpp@{pars.cpp}!backEnd@{backEnd}}
\index{backEnd@{backEnd}!pars.cpp@{pars.cpp}}
\subsubsection[{backEnd}]{\setlength{\rightskip}{0pt plus 5cm}VOID backEnd (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{ptr}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_af45c42930cc9f7fbe74c2469301fa5f6}

\begin{DoxyCode}
                         {
        while (!g_var.g_appEnd) { //TODO fix this while loop
                PIN_SemaphoreWait (&semaphore0);
                PIN_SemaphoreClear (&semaphore0);
        if (g_var.g_appEnd) break;
                ADDRINT __pc = g_var.g_pc;
                BOOL taken = g_var.g_taken;
                ADDRINT tgt = g_var.g_tgt;
                ADDRINT fthru = g_var.g_fthru;
        if (g_var.g_enable_wp) {
            if (g_var.g_core_type == BASICBLOCK)
                g_var.g_pred_eip = PredictAndUpdate (__pc, taken, tgt, fthru, 1);
      
            else
                g_var.g_pred_eip = PredictAndUpdate (__pc, taken, tgt, fthru, 
      bbInsCnt);
        }

        if (g_var.g_enable_bkEnd) {
            if (g_var.g_core_type == BASICBLOCK) {
                if (g_var.g_bbCache->NumElements () >= BB_CNT_THR && !g_var.
      g_wrong_path) {
                    //  cout << "FRONTEND->BACKEND " << endl;
//                    g_var.stat.matchIns = 0;
                    bbBkEndRun (FRONTEND_RUNNING);
                    s_pin_fr_to_bk_cnt++;
                    // cout << "BACKEND->FRONTEND" << endl;
                }
            } else { /* INO & O3 */
                if (g_var.g_codeCache->NumElements () >= INS_CNT_THR && !g_var.
      g_wrong_path) {
//                     cout << "FRONTEND->BACKEND " << endl;
//                    g_var.stat.matchIns = 0;
                    if (g_var.g_core_type == OUT_OF_ORDER) oooBkEndRun (
      FRONTEND_RUNNING);
                    else if (g_var.g_core_type == IN_ORDER) inoBkEndRun (
      FRONTEND_RUNNING);
                    s_pin_fr_to_bk_cnt++;
//                     cout << "BACKEND->FRONTEND" << endl;
                }
            }
        }

                PIN_SemaphoreSet (&semaphore1);
        }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_a2648ea029809fc0d174d8b1021b99523}{
\index{pars.cpp@{pars.cpp}!countTrace@{countTrace}}
\index{countTrace@{countTrace}!pars.cpp@{pars.cpp}}
\subsubsection[{countTrace}]{\setlength{\rightskip}{0pt plus 5cm}VOID countTrace (
\begin{DoxyParamCaption}
\item[{TRACE}]{trace, }
\item[{VOID $\ast$}]{v}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_a2648ea029809fc0d174d8b1021b99523}

\begin{DoxyCode}
{
    s_pin_trace_cnt++;
    g_var.g_codeCacheSize +=  TRACE_CodeCacheSize (trace);
    if (g_var.g_debug_level & DBG_CC) cout << "--Code Cache Size Limit: " << CODE
      CACHE_CacheSizeLimit () / (1024 * 1024) << "MB.\n";
    if (g_var.g_debug_level & DBG_CC) cout << "Adding Trace #" << s_pin_trace_cnt
      .getValue () << " (Addr: " << TRACE_CodeCacheAddress (trace) << ") to code cache 
      with size " << TRACE_CodeCacheSize (trace) << " Bytes.\n";
    if (g_var.g_debug_level & DBG_CC) cout << "Total code cache size: " << g_var.
      g_codeCacheSize / (1024 * 1024) << "MB.\n";
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_a7c6b63b21bc5971968616e3f621da22f}{
\index{pars.cpp@{pars.cpp}!doBBcount@{doBBcount}}
\index{doBBcount@{doBBcount}!pars.cpp@{pars.cpp}}
\subsubsection[{doBBcount}]{\setlength{\rightskip}{0pt plus 5cm}VOID doBBcount (
\begin{DoxyParamCaption}
\item[{UINT32}]{ins\_\-cnt}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_a7c6b63b21bc5971968616e3f621da22f}

\begin{DoxyCode}
{
    s_pin_ins_cnt += (SCALAR)ins_cnt; /*total ins count: wrong and right path*/
    bool finished_last_simpoint = doCount (s_pin_ins_cnt, s_pin_trace_cnt, 
                                           s_pin_wp_cnt, s_pin_sig_cnt, 
                                           s_pin_flush_cnt, s_pin_sig_recover_cnt
      , 
                                           ins_cnt, 
                                           SIMPLE_SLICE_MODE);

    if (finished_last_simpoint) {
        pin__doFinish ();
        exit (-1);
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_ad357c3e6fd5bfcbcdfafb58d203f464c}{
\index{pars.cpp@{pars.cpp}!FlushOnFull@{FlushOnFull}}
\index{FlushOnFull@{FlushOnFull}!pars.cpp@{pars.cpp}}
\subsubsection[{FlushOnFull}]{\setlength{\rightskip}{0pt plus 5cm}VOID FlushOnFull (
\begin{DoxyParamCaption}
\item[{UINT32}]{trace\_\-size, }
\item[{UINT32}]{stub\_\-size}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_ad357c3e6fd5bfcbcdfafb58d203f464c}

\begin{DoxyCode}
{
        s_pin_flush_cnt++;
    if (g_var.g_debug_level & DBG_CC) cout << "Trying to insert trace size " << t
      race_size << " and exit stub size " << stub_size << ".\n";
        CODECACHE_FlushCache ();
        if (g_var.g_debug_level & DBG_CC) cout << "Code Cache Flushed at size " <
      < g_var.g_codeCacheSize / (1024 * 1024) << "MB! (Flush count: " << s_pin_flush_cn
      t.getValue () << ")" << endl;
        g_var.g_codeCacheSize=0;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_aefef2ba62649f25c8db406d1a4272061}{
\index{pars.cpp@{pars.cpp}!GetMemReadBypass@{GetMemReadBypass}}
\index{GetMemReadBypass@{GetMemReadBypass}!pars.cpp@{pars.cpp}}
\subsubsection[{GetMemReadBypass}]{\setlength{\rightskip}{0pt plus 5cm}VOID GetMemReadBypass (
\begin{DoxyParamCaption}
\item[{UINT32}]{uid, }
\item[{CONTEXT $\ast$}]{c, }
\item[{ADDRINT}]{eaddr, }
\item[{ADDRINT}]{len}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_aefef2ba62649f25c8db406d1a4272061}

\begin{DoxyCode}
{
    if (!g_var.g_enable_wp) return;
    if (g_var.g_enable_wp && !g_var.g_wrong_path) return;

#ifdef G_I_INFO_EN
        Assert (g_i_info.find (uid)!=g_i_info.end ());
        const i_info &i = g_i_info[uid];
        if (g_var.g_debug_level & DBG_READ_MEM) cout << "EXEC rb " << (g_var.
      g_wrong_path?"*":" ") << " " << dec << g_var.g_seq_num << " : " << hex << i.pc <<
       " " << i.diss << " : ";
#endif

        // TODO: bypass real memory?
        return;
}
\end{DoxyCode}
\hypertarget{pars_8cpp_aa22b6461bb9abbe232edce2559997942}{
\index{pars.cpp@{pars.cpp}!GetMemWriteNewValue@{GetMemWriteNewValue}}
\index{GetMemWriteNewValue@{GetMemWriteNewValue}!pars.cpp@{pars.cpp}}
\subsubsection[{GetMemWriteNewValue}]{\setlength{\rightskip}{0pt plus 5cm}VOID GetMemWriteNewValue (
\begin{DoxyParamCaption}
\item[{UINT32}]{uid, }
\item[{CONTEXT $\ast$}]{c}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_aa22b6461bb9abbe232edce2559997942}

\begin{DoxyCode}
{
    if (!g_var.g_enable_wp) return;
    if (g_var.g_enable_wp && !g_var.g_wrong_path) return;

#ifdef G_I_INFO_EN
        Assert (g_i_info.find (uid)!=g_i_info.end ());
        const i_info &i = g_i_info[uid];
        if (g_var.g_debug_level & DBG_WRITE_MEM) cout << "EXEC wa " << (g_var.
      g_wrong_path?"*":" ") << " " << dec << g_var.g_seq_num << " : " << hex << i.pc <<
       " " << i.diss << " : ";
#endif

        // TODO: bypass real memory?
        // read_mem_new ();
        // restore_mem_orig ();
        return;
}
\end{DoxyCode}
\hypertarget{pars_8cpp_acb954ff3c5105a038d6722b6debb2056}{
\index{pars.cpp@{pars.cpp}!GetMemWriteOrigValue@{GetMemWriteOrigValue}}
\index{GetMemWriteOrigValue@{GetMemWriteOrigValue}!pars.cpp@{pars.cpp}}
\subsubsection[{GetMemWriteOrigValue}]{\setlength{\rightskip}{0pt plus 5cm}VOID GetMemWriteOrigValue (
\begin{DoxyParamCaption}
\item[{UINT32}]{uid, }
\item[{CONTEXT $\ast$}]{c, }
\item[{ADDRINT}]{eaddr, }
\item[{ADDRINT}]{len}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_acb954ff3c5105a038d6722b6debb2056}

\begin{DoxyCode}
{
    if (!g_var.g_enable_wp) return;
    if (g_var.g_enable_wp && !g_var.g_wrong_path) return;

#ifdef G_I_INFO_EN
        Assert (g_i_info.find (uid)!=g_i_info.end ());
        const i_info &i = g_i_info[uid];
        if (g_var.g_debug_level & DBG_WRITE_MEM) cout << "EXEC wb " << (g_var.
      g_wrong_path?"*":" ") << " " << dec << g_var.g_seq_num << " : " << hex << i.pc <<
       " " << i.diss << " : ";
#endif
        read_mem_orig (eaddr, len);
        return;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_aeba21456eeaae4baf6f7d0137dc3b242}{
\index{pars.cpp@{pars.cpp}!handle@{handle}}
\index{handle@{handle}!pars.cpp@{pars.cpp}}
\subsubsection[{handle}]{\setlength{\rightskip}{0pt plus 5cm}EXCEPT\_\-HANDLING\_\-RESULT handle (
\begin{DoxyParamCaption}
\item[{THREADID}]{tid, }
\item[{EXCEPTION\_\-INFO $\ast$}]{pExceptInfo, }
\item[{PHYSICAL\_\-CONTEXT $\ast$}]{pPhysCtxt, }
\item[{VOID $\ast$}]{v}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_aeba21456eeaae4baf6f7d0137dc3b242}

\begin{DoxyCode}
{
        s_pin_sig_cnt++;
        if (g_var.g_debug_level & DBG_SPEC) cout << " pintool signal count = " <<
       dec << s_pin_sig_cnt.getValue () << endl;
        longjmp (g_var.g_env, 1);
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_af53ac0627b1cf2178bbce73ab6edbe09}{
\index{pars.cpp@{pars.cpp}!HandleBranch@{HandleBranch}}
\index{HandleBranch@{HandleBranch}!pars.cpp@{pars.cpp}}
\subsubsection[{HandleBranch}]{\setlength{\rightskip}{0pt plus 5cm}VOID HandleBranch (
\begin{DoxyParamCaption}
\item[{UINT32}]{uid, }
\item[{BOOL}]{taken, }
\item[{ADDRINT}]{tgt, }
\item[{ADDRINT}]{fthru, }
\item[{ADDRINT}]{\_\-\_\-pc, }
\item[{BOOL}]{\_\-\_\-has\_\-ft, }
\item[{UINT32}]{\_\-bbInsCnt}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_af53ac0627b1cf2178bbce73ab6edbe09}

\begin{DoxyCode}
{
    if (!g_var.g_enable_wp) {
        if (g_var.g_enable_bkEnd) {
            PIN_SemaphoreSet (&semaphore0);
            PIN_SemaphoreWait (&semaphore1); 
            PIN_SemaphoreClear (&semaphore1);
        }
        return;
    }
    if (g_var.g_wrong_path) return;

#ifdef G_I_INFO_EN
        Assert (g_i_info.find (uid)!=g_i_info.end ());
        //const i_info &i = g_i_info[uid];
#endif
        g_var.g_was_wp = false;

    if (true) { // uasd to be if (__has_ft) { - clean up? (TODO)
        g_var.g_pc = __pc;
        g_var.g_taken = taken;
        g_var.g_tgt = tgt;
        g_var.g_fthru = fthru;
        bbInsCnt = _bbInsCnt; /* TODO remove - this is a hacl */
        PIN_SemaphoreSet (&semaphore0);
        PIN_SemaphoreWait (&semaphore1); 
        PIN_SemaphoreClear (&semaphore1);
    }
        return;
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{pars_8cpp_a2f963499b00d63afb51fc73afb703ef3}{
\index{pars.cpp@{pars.cpp}!HandleContext@{HandleContext}}
\index{HandleContext@{HandleContext}!pars.cpp@{pars.cpp}}
\subsubsection[{HandleContext}]{\setlength{\rightskip}{0pt plus 5cm}VOID HandleContext (
\begin{DoxyParamCaption}
\item[{CONTEXT $\ast$}]{c}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_a2f963499b00d63afb51fc73afb703ef3}

\begin{DoxyCode}
{
    if (!g_var.g_enable_wp) return;
    if (!(g_var.g_wrong_path && !g_var.g_was_wp)) return;

    ADDRINT eip = g_var.g_taken ? g_var.g_tgt : g_var.g_fthru;
    ADDRINT pred_eip = g_var.g_pred_eip;
    Assert (eip != pred_eip && "Invalid program state");

    g_var.g_was_wp = true;
    s_pin_wp_cnt++;
    if (g_var.g_debug_level & DBG_SPEC) cout << "  *** transitioning to wrong pat
      h ***\n";
    if (g_var.g_debug_level & DBG_SPEC) cout << "  wrong path number = " << dec <
      < s_pin_wp_cnt.getValue () << endl;
    PIN_SaveContext (c, &g_var.g_context);

    if (g_var.g_debug_level & DBG_SPEC) cout << "  *** forcing PIN to change cont
      rol flow ***\n";
    if (g_var.g_debug_level & DBG_SPEC) cout << "      predicted EIP = " << hex <
      < pred_eip << "\n";
    PIN_SetContextReg (c, REG_INST_PTR, pred_eip);
    g_var.g_context_call_depth = 0;
    PIN_ExecuteAt (c);
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_a4f97b9fe13219e7257f0199e22d96637}{
\index{pars.cpp@{pars.cpp}!HandleInst@{HandleInst}}
\index{HandleInst@{HandleInst}!pars.cpp@{pars.cpp}}
\subsubsection[{HandleInst}]{\setlength{\rightskip}{0pt plus 5cm}VOID HandleInst (
\begin{DoxyParamCaption}
\item[{UINT32}]{uid, }
\item[{BOOL}]{\_\-\_\-is\_\-call, }
\item[{BOOL}]{\_\-\_\-is\_\-ret, }
\item[{BOOL}]{\_\-\_\-is\_\-far\_\-ret}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_a4f97b9fe13219e7257f0199e22d96637}

\begin{DoxyCode}
{
    if (!g_var.g_enable_wp) return;
#ifdef G_I_INFO_EN
    Assert (g_i_info.find (uid)!=g_i_info.end ());
    const i_info &i = g_i_info[uid];
#endif

    if (!g_var.g_wrong_path) g_var.g_icount++;

#ifdef G_I_INFO_EN
    if (g_var.g_debug_level & DBG_EXEC) cout << "EXEC i  " << (g_var.
      g_wrong_path?"*":" ") << " " << dec << g_var.g_seq_num << " : " << hex << i.pc <<
       " " << i.diss << " : ";
#endif

    if (g_var.g_wrong_path) {
        g_var.g_wrong_path_count++;
        if (__is_call) g_var.g_context_call_depth++;
        if (g_var.g_debug_level & DBG_SPEC) cout << " *** wrong path *** count = 
      " << dec << g_var.g_wrong_path_count << "\n";
        if ((g_var.g_wrong_path_count >= g_cfg->brMisspredDelay ()) ||
           ((g_var.g_context_call_depth==0) && __is_ret) ||
                g_var.g_invalid_size || g_var.g_invalid_addr || g_var.
      g_spec_syscall || __is_far_ret || __is_call || __is_ret) {
            recover ();
            if (g_var.g_debug_level & DBG_SPEC) cout << "Recovered from signal." 
      << endl;
            if (g_var.g_enable_wp) { PIN_ExecuteAt (&g_var.g_context); }
        }
    } else if (g_var.g_debug_level & DBG_EXEC) cout << endl;
    return;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_a14053986557d22a3e7d5d06d3f3b5bee}{
\index{pars.cpp@{pars.cpp}!handlePinException@{handlePinException}}
\index{handlePinException@{handlePinException}!pars.cpp@{pars.cpp}}
\subsubsection[{handlePinException}]{\setlength{\rightskip}{0pt plus 5cm}EXCEPT\_\-HANDLING\_\-RESULT handlePinException (
\begin{DoxyParamCaption}
\item[{THREADID}]{tid, }
\item[{EXCEPTION\_\-INFO $\ast$}]{pExceptInfo, }
\item[{PHYSICAL\_\-CONTEXT $\ast$}]{pPhysCtxt, }
\item[{VOID $\ast$}]{v}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_a14053986557d22a3e7d5d06d3f3b5bee}

\begin{DoxyCode}
{
        g_var.g_pin_signal_count++;
    if (g_var.g_wrong_path) {
        if (g_var.g_debug_level & DBG_SPEC) cout << " caught signal " << dec << P
      IN_GetExceptionCode (pExceptInfo) << " on wrong path " << endl;
        if (g_var.g_debug_level & DBG_SPEC) cout << " execption Info: " << PIN_Ex
      ceptionToString (pExceptInfo) << endl;
        if (g_var.g_debug_level & DBG_SPEC) cout << " pin signal count = " << dec
       << g_var.g_pin_signal_count << endl;
        recover ();
        PIN_ExecuteAt (&g_var.g_context);
        if (g_var.g_debug_level & DBG_SPEC) cout << "Recovered from signal." << e
      ndl;
    } else {
        cout << "ERROR for REAL: caught signal " << dec << PIN_GetExceptionCode (
      pExceptInfo) << " on correct path " << endl;
        cout << " execption Info: " << PIN_ExceptionToString (pExceptInfo) << end
      l;
        cout << " pin signal count = " << dec << g_var.g_pin_signal_count << endl
      ;
    }
        return EHR_UNHANDLED;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_abdf3999377ed06fdc9507279d3381d70}{
\index{pars.cpp@{pars.cpp}!HandleSyscall@{HandleSyscall}}
\index{HandleSyscall@{HandleSyscall}!pars.cpp@{pars.cpp}}
\subsubsection[{HandleSyscall}]{\setlength{\rightskip}{0pt plus 5cm}VOID HandleSyscall (
\begin{DoxyParamCaption}
\item[{UINT32}]{uid, }
\item[{CONTEXT $\ast$}]{c}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_abdf3999377ed06fdc9507279d3381d70}

\begin{DoxyCode}
{
    if (!g_var.g_enable_wp) return;
#ifdef G_I_INFO_EN
        Assert (g_i_info.find (uid) != g_i_info.end ());
        const i_info &i = g_i_info[uid];
        if (g_var.g_debug_level & DBG_EXEC) 
        cout << "EXEC hs " << (g_var.g_wrong_path?"*":" ") << " " << dec << 
      g_var.g_seq_num << " : " << hex << i.pc << " " << i.diss << " : ";
#endif
        if (g_var.g_wrong_path) {
            if (g_var.g_debug_level & DBG_SPEC) cout << " *** detected system cal
      l on wrong path ***\n";
                g_var.g_spec_syscall = true;    
        }
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{pars_8cpp_a6f5943fb0a6ecd3d79a70a0ccfb72a91}{
\index{pars.cpp@{pars.cpp}!pin\_\-\_\-doFinish@{pin\_\-\_\-doFinish}}
\index{pin\_\-\_\-doFinish@{pin\_\-\_\-doFinish}!pars.cpp@{pars.cpp}}
\subsubsection[{pin\_\-\_\-doFinish}]{\setlength{\rightskip}{0pt plus 5cm}VOID pin\_\-\_\-doFinish (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_a6f5943fb0a6ecd3d79a70a0ccfb72a91}

\begin{DoxyCode}
                      {
        g_msg.simStep ("FRONTEND TERMINATED");
        stop_pars = clock ();
        g_var.g_appEnd = true;
        cout << "finishing" << endl;
        PIN_SemaphoreSet (&semaphore0);
        PIN_SemaphoreSet (&semaphore1);
        cout << "finished" << endl;
        double exe_time = double (stop_pars-start_pars)/CLOCKS_PER_SEC;
        double ins_per_sec = double (s_pin_ins_cnt.getValue ()) / exe_time;
        cout << "Execution Time Under Pin: " << exe_time << " sec , Num Executed 
      Ops: " << s_pin_ins_cnt.getValue () << endl;
        cout << "Instructions Executed Per Second Under Pin: " << ins_per_sec << 
      endl;
        cout << "Num traces generated: " << s_pin_trace_cnt.getValue () << "; Cod
      e cach used for traces: " << g_var.g_codeCacheSize / (1024 * 1024) << " MB" << en
      dl;
//    endBackEnd ();
        PIN_SemaphoreFini (&semaphore0);
        PIN_SemaphoreFini (&semaphore1);
        g_msg.simStep ("BACKEND TERMINATED");

    /*-- DUMP STAT --*/
    if (g_cfg->isEnProfiling ()) {
        g_msg.simStep ("STORE PROFILING DATA");
        g_prof.dump ();
    }
        g_msg.simStep ("STORE STAT");
    g_stats.dump ();

        /*-- FINISH BACKEND --*/
    if (g_var.g_core_type == OUT_OF_ORDER) oooBkEnd_fini ();
    else if (g_var.g_core_type == IN_ORDER) inoBkEnd_fini ();
    else if (g_var.g_core_type == BASICBLOCK) bbBkEnd_fini ();

    /*-- DEL OBJS --*/
        delete g_var.g_insList;
        delete g_var.g_codeCache;
        delete g_var.g_bbCache;
        delete g_var.g_blockCache;
        delete g_tournament_bp;
    delete g_2bcgskew_bp;
        delete g_staticCode;
    delete g_bbStat;
    delete btb;

        g_msg.simStep ("END OF SIMULATION");
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_a691cde548f8aff0f0cf3e992b3b79d26}{
\index{pars.cpp@{pars.cpp}!pin\_\-\_\-fini@{pin\_\-\_\-fini}}
\index{pin\_\-\_\-fini@{pin\_\-\_\-fini}!pars.cpp@{pars.cpp}}
\subsubsection[{pin\_\-\_\-fini}]{\setlength{\rightskip}{0pt plus 5cm}VOID pin\_\-\_\-fini (
\begin{DoxyParamCaption}
\item[{INT32}]{code, }
\item[{VOID $\ast$}]{v}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_a691cde548f8aff0f0cf3e992b3b79d26}

\begin{DoxyCode}
{
    pin__doFinish ();
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_a6a2bb09a97d90cc11d502199ce1a432d}{
\index{pars.cpp@{pars.cpp}!pin\_\-\_\-init@{pin\_\-\_\-init}}
\index{pin\_\-\_\-init@{pin\_\-\_\-init}!pars.cpp@{pars.cpp}}
\subsubsection[{pin\_\-\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}VOID pin\_\-\_\-init (
\begin{DoxyParamCaption}
\item[{string}]{bench\_\-path, }
\item[{string}]{config\_\-path, }
\item[{string}]{out\_\-dir}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_a6a2bb09a97d90cc11d502199ce1a432d}

\begin{DoxyCode}
                                                                       {
        pin__parseConfig (bench_path, config_path, out_dir);

    _e_btb = new table_energy("BTB", g_cfg->_root["cpu"]["backend"]["table"]["BTB
      "]);

        g_msg.simStep ("SETUP BENCHMARK ADDRESS SPACE");
    string bench_name = g_cfg->getProgName ();
    bench_addr_space = new benchAddrRangeParser (bench_name);

        g_msg.simStep ("SIMULATOR FRONTEND INITIALIZATION");
        PIN_SemaphoreInit (&semaphore0);
        PIN_SemaphoreInit (&semaphore1);
        PIN_SemaphoreClear (&semaphore0);
        PIN_SemaphoreClear (&semaphore1);
    btb = new BTB (4096, 16, 2);
    if (g_cfg->getBPtype () == GSHARE_LOCAL_BP) {
        _e_table1 = new table_energy("tournament", g_cfg->_root["cpu"]["backend"]
      ["bp"]["tournament"]);
        _e_wire1 = new wire_energy("tournament.wire", g_cfg->_root["cpu"]["backen
      d"]["bp"]["tournament"]);
        g_tournament_bp = new TournamentBP (2048, 2, 2048, 11, 8192, 13, 2, 8192,
       2, 0);
    } else if (g_cfg->getBPtype () == BCG_SKEW_BP) {
        int width; g_cfg->_root["cpu"]["backend"]["width"] >> width;
        _e_table2 = new table_energy("2bc_gskew", g_cfg->_root["cpu"]["backend"][
      "bp"]["bc_gskew"]);
        _e_wire2 = new wire_energy("2bc_gskew.wire", g_cfg->_root["cpu"]["backend
      "]["bp"]["bc_gskew"]);
        g_2bcgskew_bp   = new HybridBPskew (8192, 2, 8192, 13, 2, 8192, 2, 0, wid
      th);
    } else {
        Assert (0 && "Invalid BP type chosen");
    }

        g_msg.simStep ("PARS COMPILED CODE");
    g_var.scheduling_mode = STATIC_SCH;//DYNAMIC_SCH;
        g_var.g_insList = new List<string*>;
        g_var.g_codeCache = new List<dynInstruction*>;
        g_var.g_bbCache = new List<dynBasicblock*>;
        g_var.g_blockCache = new List<block*>;
    g_var.g_core_type = g_cfg->getCoreType ();
    g_var.g_mem_model = g_cfg->getMemModel ();
        g_staticCode = new staticCodeParser (g_cfg);
    g_bbStat = new bbStat;

        pin__uOpGenInit (*g_staticCode);

    /* TODO take care of these cout's*/
    cout << "CORE: " << g_var.g_core_type << endl;
    cout << "MEM MODEL: " << g_var.g_mem_model << endl;
    cout << "SCHEDULING MODE: " << g_var.scheduling_mode << endl;
    cout << "BENCH: " << g_cfg->getProgName () << endl;

        g_msg.simStep ("SIMULATOR BACKEND INITIALIZATION");
    if (g_var.g_core_type == OUT_OF_ORDER) oooBkEnd_init ();
    else if (g_var.g_core_type == IN_ORDER) inoBkEnd_init ();
    else if (g_var.g_core_type == BASICBLOCK) bbBkEnd_init ();

        g_msg.simStep ("START OF SIMULATION");
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_a357d7e4914ba9327454143adda33f0f8}{
\index{pars.cpp@{pars.cpp}!pin\_\-\_\-instruction@{pin\_\-\_\-instruction}}
\index{pin\_\-\_\-instruction@{pin\_\-\_\-instruction}!pars.cpp@{pars.cpp}}
\subsubsection[{pin\_\-\_\-instruction}]{\setlength{\rightskip}{0pt plus 5cm}VOID pin\_\-\_\-instruction (
\begin{DoxyParamCaption}
\item[{TRACE}]{trace, }
\item[{VOID $\ast$}]{val}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_a357d7e4914ba9327454143adda33f0f8}

\begin{DoxyCode}
{
    if (!filter.SelectTrace (trace)) {
        printf ("NOTE: SKIPPING TRACE\n");
        return;
    }

    //    bool first_bb = true;
    for (BBL bbl = TRACE_BblHead (trace); BBL_Valid (bbl); bbl = BBL_Next (bbl))
    {
        //        if (g_var.g_enable_bkEnd) {
        //            ADDRINT bb_addr = BBL_Address (bbl);
        //            if (g_var.g_core_type == BASICBLOCK) {
        //                if (first_bb) {
        //                    first_bb = false;
        //                    INS bb_head = BBL_InsHead (bbl);
        //                    pin__get_bb_header (bb_addr, bb_head);
        //                }
        //                INS bb_tail = BBL_InsTail (bbl);
        //                pin__get_bb_header (bb_addr, bb_tail);
        //            } //TODO simpoint commands do not apply here - fix if put b
      ack
        //        }

        BBL_InsertCall (bbl, IPOINT_BEFORE, (AFUNPTR) doBBcount, IARG_UINT32, BBL
      _NumIns(bbl), IARG_END);

        if (g_var.g_enable_instrumentation) 
        {
            for (INS ins = BBL_InsHead (bbl); INS_Valid (ins); ins = INS_Next (in
      s))
            {
                /* INSTRUMENT ONLY INSTRUCTIONS IN THE APPLICATION CODE */
                if (!(INS_Address (ins) >= bench_addr_space->getStartAddr () && 
                      INS_Address (ins) <= bench_addr_space->getEndAddr ())) cont
      inue;

                ADDRINT pc = INS_Address (ins);
                string diss =  INS_Disassemble (ins);
                static unsigned long uid=0;
                ++uid;
#ifdef G_I_INFO_EN
                OPCODE opcode = INS_Opcode (ins);
                bool is_call = INS_IsCall (ins);
                bool is_ret = INS_IsRet (ins);
                bool has_ft = INS_HasFallThrough (ins);
                g_i_info[uid] = i_info (pc,opcode,diss,is_call,is_ret,has_ft);
                if (uid==0) g_i_info[0] = i_info (pc,opcode,diss,is_call,is_ret,h
      as_ft);
#endif
                if (INS_IsMemoryWrite (ins)) {
                    if (g_var.g_debug_level & DBG_INS) cout << "INS  " << hex << 
      pc << " " << diss << " [mem write]\n";
                    INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) 
      GetMemWriteOrigValue,
                            IARG_UINT32, uid,
                            IARG_CONTEXT,
                            IARG_MEMORYWRITE_EA,
                            IARG_MEMORYWRITE_SIZE,
                            IARG_END);
                    /*
                       if (INS_IsCall (ins) || INS_IsProcedureCall (ins)) {
                       INS_InsertCall (ins, IPOINT_TAKEN_BRANCH, (AFUNPTR) GetMem
      WriteNewValue,
                       IARG_UINT32, uid,
                       IARG_CONTEXT,
                       IARG_END);
                       } else {
                       INS_InsertCall (ins, IPOINT_AFTER, (AFUNPTR) GetMemWriteNe
      wValue,
                       IARG_UINT32, uid,
                       IARG_CONTEXT,
                       IARG_END);
                       }
                       */
                }
                /*
                   if (INS_IsMemoryRead (ins)) {
                   if (g_var.g_debug_level & DBG_INS) cout << "INS  " << hex << p
      c << " " << diss << " [mem read]\n";
                   INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) GetMemReadBypass
      ,
                   IARG_UINT32, uid,
                   IARG_CONTEXT,
                   IARG_MEMORYREAD_EA,
                   IARG_MEMORYREAD_SIZE,
                   IARG_END);
                   }
                   */

                if (INS_IsBranchOrCall (ins) || INS_IsDirectBranchOrCall (ins) ||
      
                        INS_IsFarRet (ins) || INS_IsRet (ins) || INS_IsSysret (in
      s) || 
                        INS_IsDirectFarJump (ins) || INS_IsFarJump (ins) ||
                        INS_IsCall (ins) || INS_IsFarCall (ins) || INS_IsProcedur
      eCall (ins) ||
                        INS_IsDirectCall (ins) || INS_IsDirectBranch (ins)) {
                    if (g_var.g_debug_level & DBG_INS) cout << "INS  " << hex << 
      pc << " " << diss << " [branch]\n";
                    if (INS_HasFallThrough (ins)) {
                        INS_InsertCall (ins, IPOINT_AFTER, (AFUNPTR) 
      HandleBranch,
                                IARG_UINT32, uid,
                                IARG_BRANCH_TAKEN,
                                IARG_BRANCH_TARGET_ADDR, 
                                IARG_FALLTHROUGH_ADDR,
                                IARG_ADDRINT, INS_Address (ins),
                                IARG_BOOL, INS_HasFallThrough (ins),
                                IARG_UINT32, BBL_NumIns(bbl),
                                IARG_END);
                    }
                    INS_InsertCall (ins, IPOINT_TAKEN_BRANCH, (AFUNPTR) HandleBra
      nch,
                            IARG_UINT32, uid,
                            IARG_BRANCH_TAKEN,
                            IARG_BRANCH_TARGET_ADDR, 
                            IARG_FALLTHROUGH_ADDR,
                            IARG_ADDRINT, INS_Address (ins),
                            IARG_BOOL, INS_HasFallThrough (ins),
                            IARG_UINT32, BBL_NumIns(bbl),
                            IARG_END);
                }

                if (INS_IsSyscall (ins)) {
                    INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) HandleSyscall,
                            IARG_UINT32, uid,
                            IARG_CONTEXT,
                            IARG_END);
                }

                /* CREARE OPERATION OBJECTS FOR TEH BACKEWND */
                if (g_var.g_enable_bkEnd) pin__getOp (ins);

                /* HANDLE CHANGE OF CONTEXT */
                if (INS_IsBranchOrCall (ins) || INS_IsDirectBranchOrCall (ins) ||
      
                        INS_IsFarRet (ins) || INS_IsRet (ins) || INS_IsSysret (in
      s) || 
                        INS_IsDirectFarJump (ins) || INS_IsFarJump (ins) ||
                        INS_IsCall (ins) || INS_IsFarCall (ins) || INS_IsProcedur
      eCall (ins) ||
                        INS_IsDirectCall (ins) || INS_IsDirectBranch (ins)) {
                    if (g_var.g_debug_level & DBG_INS) cout << "INS  " << hex << 
      pc << " " << diss << " [branch]\n";
                    if (INS_HasFallThrough (ins))
                        INS_InsertCall (ins, IPOINT_AFTER, (AFUNPTR) 
      HandleContext, IARG_CONTEXT, IARG_END);
                    INS_InsertCall (ins, IPOINT_TAKEN_BRANCH, (AFUNPTR) 
      HandleContext, IARG_CONTEXT, IARG_END);
                }

                INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) HandleInst,
                        IARG_UINT32, uid,
                        IARG_BOOL, INS_IsCall (ins),
                        IARG_BOOL, INS_IsRet (ins),
                        IARG_BOOL, INS_IsFarRet (ins),
                        IARG_END);
            }
        }
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_af75ae1f1ce75a8d6b4c83920963399ef}{
\index{pars.cpp@{pars.cpp}!pin\_\-\_\-parseConfig@{pin\_\-\_\-parseConfig}}
\index{pin\_\-\_\-parseConfig@{pin\_\-\_\-parseConfig}!pars.cpp@{pars.cpp}}
\subsubsection[{pin\_\-\_\-parseConfig}]{\setlength{\rightskip}{0pt plus 5cm}VOID pin\_\-\_\-parseConfig (
\begin{DoxyParamCaption}
\item[{string}]{bench\_\-path, }
\item[{string}]{config\_\-path, }
\item[{string}]{out\_\-dir}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_af75ae1f1ce75a8d6b4c83920963399ef}

\begin{DoxyCode}
                                                                              {
        g_cfg = new config (bench_path, config_path, out_dir);
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{pars_8cpp_aa757cbb2413d35022392e871acee9978}{
\index{pars.cpp@{pars.cpp}!pin\_\-\_\-runPARS@{pin\_\-\_\-runPARS}}
\index{pin\_\-\_\-runPARS@{pin\_\-\_\-runPARS}!pars.cpp@{pars.cpp}}
\subsubsection[{pin\_\-\_\-runPARS}]{\setlength{\rightskip}{0pt plus 5cm}VOID pin\_\-\_\-runPARS (
\begin{DoxyParamCaption}
\item[{string}]{bench\_\-path, }
\item[{string}]{config\_\-path, }
\item[{string}]{out\_\-dir}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_aa757cbb2413d35022392e871acee9978}

\begin{DoxyCode}
{
    pin__init (bench_path, config_path, out_dir);

        // REGISTER A ROUTINE THAT GETS CALLED EVERY TIME THE TRACE IS INSERTED
    CODECACHE_AddTraceInsertedFunction (countTrace, 0);
        // REGISTER A ROUTINE THAT GETS CALLED EVERY TIME THE CACHE IS FULL
        CODECACHE_AddFullCacheFunction (FlushOnFull, 0); 

        //Handle pin-generated exceptions
        PIN_AddInternalExceptionHandler (handlePinException,NULL);
        //HANDLE APPLICATION-GENERATED EXCEPTIONS
        PIN_InterceptSignal (SIGTRAP,signal_handler,NULL);
        PIN_UnblockSignal (SIGTRAP,TRUE);
        PIN_InterceptSignal (SIGILL,signal_handler,NULL);
        PIN_UnblockSignal (SIGILL,TRUE);
        PIN_InterceptSignal (SIGSEGV,signal_handler,NULL);
        PIN_UnblockSignal (SIGSEGV,TRUE);
        PIN_InterceptSignal (SIGFPE,signal_handler,NULL);
        PIN_UnblockSignal (SIGFPE,TRUE);
        PIN_InterceptSignal (SIGBUS,signal_handler,NULL);
        PIN_UnblockSignal (SIGBUS,TRUE);
        PIN_InterceptSignal (SIGABRT,signal_handler,NULL);
        PIN_UnblockSignal (SIGABRT,TRUE);

    TRACE_AddInstrumentFunction (pin__instruction, 0);
    PIN_AddFiniFunction (pin__fini, 0);

    PIN_SpawnInternalThread (backEnd, rootThreadArg, 0, &rootThreadUid);

        filter.Activate ();

        start_pars = clock ();
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_a094db9936840dd4a66eec07dbf8b228f}{
\index{pars.cpp@{pars.cpp}!PredictAndUpdate@{PredictAndUpdate}}
\index{PredictAndUpdate@{PredictAndUpdate}!pars.cpp@{pars.cpp}}
\subsubsection[{PredictAndUpdate}]{\setlength{\rightskip}{0pt plus 5cm}ADDRINT PredictAndUpdate (
\begin{DoxyParamCaption}
\item[{const ADDRINT}]{\_\-\_\-pc, }
\item[{const INT32}]{\_\-\_\-taken, }
\item[{ADDRINT}]{tgt, }
\item[{const ADDRINT}]{fthru, }
\item[{const UINT32}]{\_\-blkInsCnt}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_a094db9936840dd4a66eec07dbf8b228f}

\begin{DoxyCode}
{
    bool taken = __taken;
    ADDRINT pc = __pc;
    void *bp_hist = NULL;
    bool pred = taken;

    /* ESTIMATE THE NUMBER OF LOOKUPS BY EACH BLOCK OF CODE - THIS WON'T WORK
     * FOR THE CASE WHERE MORE THAN ONE BRANCH/CALL/JUMP/REG ARE IN THE BLOC */
    int width; g_cfg->_root["cpu"]["backend"]["width"] >> width;
    if (g_var.g_core_type == IN_ORDER) g_cfg->_root["cpu"]["backend"]["ino_pipe"]
      ["fetch"]["width"] >> width;
    else if (g_var.g_core_type == OUT_OF_ORDER) g_cfg->_root["cpu"]["backend"]["o
      3_pipe"]["fetch"]["width"] >> width;
    else if (g_var.g_core_type == BASICBLOCK) width = 1;
    int num_lookup = int(ceil(float(_blkInsCnt) / width));
    s_bpu_lookup_cnt += num_lookup;
    Assert (num_lookup > 0);

    /*-- WIRE ACCESSES --*/
    list<string> wires;
    for (int i = 0; i < num_lookup; i++) {
        if (g_var.g_core_type == IN_ORDER) wires.push_back ("e_w_bp2cache_ino");
        else if (g_var.g_core_type == OUT_OF_ORDER) wires.push_back ("e_w_bp2cach
      e_o3");
        else if (g_var.g_core_type == BASICBLOCK) wires.push_back ("e_w_bp2cache_
      bb");
    }

    /*-- BP LOOKUP --*/
    if (g_cfg->getBPtype () == GSHARE_LOCAL_BP) {
        int num_tables = 3;
        pred = g_tournament_bp->lookup (pc, bp_hist);
        _e_table1->ramAccess (num_tables * num_lookup);
        _e_wire1->wireAccess (wires);
    } else if (g_cfg->getBPtype () == BCG_SKEW_BP) {
        int num_tables = 4;
        pred = g_2bcgskew_bp->lookup (pc, bp_hist, (unsigned)0); //TODO the last 
      element MUST NOT be 0
        _e_table2->ramAccess (num_tables * num_lookup);
        _e_wire2->wireAccess (wires);
    } else {
        Assert (0 && "Unsupported BP model");
    }

    /*-- BTB LOOKUP --*/
    ADDRS pred_tgt = 0;
    {
        if (btb->valid (pc)) {
            pred_tgt = btb->lookup (pc);
        } else {
            if (g_cfg->getBPtype () == GSHARE_LOCAL_BP) {
                g_tournament_bp->BTBUpdate (pc, bp_hist);
            } else if (g_cfg->getBPtype () == BCG_SKEW_BP) {
                g_2bcgskew_bp->BTBUpdate (pc, bp_hist);
            }
            pred = false;
            pred_tgt = 0;
        }
        _e_btb->camAccess (num_lookup); /* ASSUMING SEQUENTIAL BP->BTB ACCESS */
    }

    /*-- BP UPDATE --*/
    if (g_var.g_debug_level & DBG_BP) cout << "  prediction = " << (pred?"T":"N")
      ;
    if (!g_var.g_wrong_path) {
        if (g_var.g_debug_level & DBG_BP) cout << ", actual = " << (taken?"T":"N"
      ) << " : ";

        if (pred != taken) { /* BP MISPRED */
            if (g_var.g_debug_level & DBG_BP) cout << "mispredicted!\n";
            g_var.g_wrong_path = true;
            s_bp_misspred_cnt++;
            if (taken && tgt != pred_tgt) {
                /* ALSO UPDATE BTB  ON TAKEN */
                btb->update (pc, tgt);
                _e_btb->camAccess (1);
                s_btb_misspred_cnt++;
            }
        } else if (taken && tgt != pred_tgt) { /* BTB MISPRED */
            if (pred_tgt != 0) { /* AVOID STUPID ADDRESSES */
                tgt = pred_tgt;
                g_var.g_wrong_path = true;
            }
            btb->update (pc, tgt);
            _e_btb->camAccess (1);
            s_btb_misspred_cnt++;
        } else {
            if (g_var.g_debug_level & DBG_BP) cout << "correct prediction\n";
        }

        int num_tables = 2;
        if (g_cfg->getBPtype () == GSHARE_LOCAL_BP) {
            g_tournament_bp->update (pc, taken, bp_hist, false);
            _e_table1->ramAccess (num_tables * num_lookup);
        } else if (g_cfg->getBPtype () == BCG_SKEW_BP) {
            g_2bcgskew_bp->update (pc, taken, bp_hist, false);
            g_2bcgskew_bp->histUpdate (pc, taken, bp_hist, false);
            _e_table2->ramAccess (num_tables * num_lookup);
        }
    } else {
        if (g_var.g_debug_level & DBG_BP) cout << " on wrong path\n";
    }

    if (g_cfg->isEnProfiling ()) {
        g_prof.update_br_profiler (__pc, taken);
    }

    return  pred ? tgt : fthru;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_a0958ec4bf081af6c5cf63c9b50a3b65e}{
\index{pars.cpp@{pars.cpp}!read\_\-mem\_\-orig@{read\_\-mem\_\-orig}}
\index{read\_\-mem\_\-orig@{read\_\-mem\_\-orig}!pars.cpp@{pars.cpp}}
\subsubsection[{read\_\-mem\_\-orig}]{\setlength{\rightskip}{0pt plus 5cm}void read\_\-mem\_\-orig (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{eaddr, }
\item[{ADDRINT}]{len}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_a0958ec4bf081af6c5cf63c9b50a3b65e}

\begin{DoxyCode}
{
        if (g_var.g_debug_level & DBG_WRITE_MEM) cout << "  mem[" << hex << eaddr
       << " ] = ";
        //Assert (len <= MAX_MEM_WRITE_LEN);
        g_var.g_invalid_size = false;
        if (len > MAX_MEM_WRITE_LEN) {
                if (g_var.g_debug_level & DBG_SPEC) cout << " (invalid memory acc
      ess size - read_mem_orig ()) - " << (int) len << "Bytes\n";
                g_var.g_invalid_size = true;
                return;
        }
        g_var.g_last_len = len;
        g_var.g_last_eaddr = eaddr;
        g_var.g_invalid_addr = false;

        THREADID tid = PIN_ThreadId ();
        if (tid == INVALID_THREADID) {
                cout << " could not get thread id\n";
                exit (1);
        }

        PIN_TryStart (tid,handle,0);
        int val = setjmp (g_var.g_env);
        if (val) {
                if (g_var.g_debug_level & DBG_SPEC) cout << " (invalid memory loc
      ation - read_mem_orig ())\n";
                g_var.g_invalid_addr = true;
                PIN_TryEnd (tid);
                return;
        }

        for (int i=len-1; i >= 0; i--) {
                PIN_SafeCopy (&g_store_buffer[i], (ADDRINT*) (eaddr+i), sizeof (u
      nsigned char));
                //g_store_buffer[i] = * (((unsigned char*)eaddr)+i);
                if (g_var.g_debug_level & DBG_WRITE_MEM) cout << hex << (unsigned
      ) g_store_buffer[i] << " ";
        }

        PIN_TryEnd (tid);

        g_log.save (eaddr, len, g_store_buffer);

        if (g_var.g_debug_level & DBG_WRITE_MEM) cout << "\n";
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{pars_8cpp_a505f360905b4ad0fa6e18f19405539ea}{
\index{pars.cpp@{pars.cpp}!recover@{recover}}
\index{recover@{recover}!pars.cpp@{pars.cpp}}
\subsubsection[{recover}]{\setlength{\rightskip}{0pt plus 5cm}void recover (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_a505f360905b4ad0fa6e18f19405539ea}

\begin{DoxyCode}
{
        g_var.g_wrong_path = false;
        g_var.g_was_wp = false;
        g_var.g_total_wrong_path_count += g_var.g_wrong_path_count;
        s_wp_ins_cnt_avg1 += g_var.g_wrong_path_count;
        s_wp_ins_cnt_avg2 += g_var.g_wrong_path_count;
        s_pin_sig_recover_cnt++;
        if (g_var.g_debug_level & DBG_SPEC) {
                cout << " *** recovering to correct path ***\n";
                cout << " recovery count = " << dec << s_pin_sig_recover_cnt.
      getValue () << endl;
                cout << " wrong path ins count = " << g_var.g_wrong_path_count <<
       " instructions (avg: " 
                          << (double) g_var.g_total_wrong_path_count/ s_pin_sig_r
      ecover_cnt.getValue () << ")\n";
        }
        g_var.g_wrong_path_count = 0;
        g_var.g_spec_syscall = false;
        g_var.g_context_call_depth=0;
        g_log.recover ();
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{pars_8cpp_a5f145c9581fdc13b0459253871f0338a}{
\index{pars.cpp@{pars.cpp}!signal\_\-handler@{signal\_\-handler}}
\index{signal\_\-handler@{signal\_\-handler}!pars.cpp@{pars.cpp}}
\subsubsection[{signal\_\-handler}]{\setlength{\rightskip}{0pt plus 5cm}BOOL signal\_\-handler (
\begin{DoxyParamCaption}
\item[{THREADID}]{tid, }
\item[{INT32}]{sig, }
\item[{CONTEXT $\ast$}]{ctxt, }
\item[{BOOL}]{hasHandler, }
\item[{const EXCEPTION\_\-INFO $\ast$}]{pExceptInfo, }
\item[{VOID $\ast$}]{v}
\end{DoxyParamCaption}
)}}
\label{pars_8cpp_a5f145c9581fdc13b0459253871f0338a}

\begin{DoxyCode}
{
    if (sig != 11 && sig != 4 && sig != 7) cout << sig << ',' << g_var.
      g_wrong_path << endl;
    g_var.g_app_signal_count++;
    if (g_var.g_wrong_path) {
        if (g_var.g_debug_level & DBG_SPEC) cout << " caught signal " << dec << s
      ig << " on wrong path " << endl;
        if (g_var.g_debug_level & DBG_SPEC) cout << " application signal count = 
      " << dec << g_var.g_app_signal_count << endl;
        recover ();
        PIN_SaveContext (&g_var.g_context, ctxt);
        if (g_var.g_debug_level & DBG_SPEC) cout << "Recovered from signal." << e
      ndl;
        return FALSE;
    } else {
        cout << "ERROR for REAL: caught signal " << dec << sig << " on correct pa
      th " << endl;
        cout << " application signal count = " << dec << g_var.
      g_app_signal_count << endl;
        return TRUE; // pass exception 
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:




\subsection{Variable Documentation}
\hypertarget{pars_8cpp_a3400e8124ea1d142f61c9ee6e82ff0c3}{
\index{pars.cpp@{pars.cpp}!\_\-e\_\-btb@{\_\-e\_\-btb}}
\index{\_\-e\_\-btb@{\_\-e\_\-btb}!pars.cpp@{pars.cpp}}
\subsubsection[{\_\-e\_\-btb}]{\setlength{\rightskip}{0pt plus 5cm}{\bf table\_\-energy}$\ast$ {\bf \_\-e\_\-btb}}}
\label{pars_8cpp_a3400e8124ea1d142f61c9ee6e82ff0c3}
\hypertarget{pars_8cpp_a45d0afedcd6ed9bf3d004d95b175b77f}{
\index{pars.cpp@{pars.cpp}!\_\-e\_\-table1@{\_\-e\_\-table1}}
\index{\_\-e\_\-table1@{\_\-e\_\-table1}!pars.cpp@{pars.cpp}}
\subsubsection[{\_\-e\_\-table1}]{\setlength{\rightskip}{0pt plus 5cm}{\bf table\_\-energy}$\ast$ {\bf \_\-e\_\-table1}}}
\label{pars_8cpp_a45d0afedcd6ed9bf3d004d95b175b77f}
\hypertarget{pars_8cpp_acad1e9b9ecb9c6b88ac37de527662852}{
\index{pars.cpp@{pars.cpp}!\_\-e\_\-table2@{\_\-e\_\-table2}}
\index{\_\-e\_\-table2@{\_\-e\_\-table2}!pars.cpp@{pars.cpp}}
\subsubsection[{\_\-e\_\-table2}]{\setlength{\rightskip}{0pt plus 5cm}{\bf table\_\-energy}$\ast$ {\bf \_\-e\_\-table2}}}
\label{pars_8cpp_acad1e9b9ecb9c6b88ac37de527662852}
\hypertarget{pars_8cpp_a37bce466ede0008f1fc7788ca04a16ce}{
\index{pars.cpp@{pars.cpp}!\_\-e\_\-wire1@{\_\-e\_\-wire1}}
\index{\_\-e\_\-wire1@{\_\-e\_\-wire1}!pars.cpp@{pars.cpp}}
\subsubsection[{\_\-e\_\-wire1}]{\setlength{\rightskip}{0pt plus 5cm}{\bf wire\_\-energy}$\ast$ {\bf \_\-e\_\-wire1}}}
\label{pars_8cpp_a37bce466ede0008f1fc7788ca04a16ce}
\hypertarget{pars_8cpp_ac9068594a93808f864502caa4a718fb7}{
\index{pars.cpp@{pars.cpp}!\_\-e\_\-wire2@{\_\-e\_\-wire2}}
\index{\_\-e\_\-wire2@{\_\-e\_\-wire2}!pars.cpp@{pars.cpp}}
\subsubsection[{\_\-e\_\-wire2}]{\setlength{\rightskip}{0pt plus 5cm}{\bf wire\_\-energy}$\ast$ {\bf \_\-e\_\-wire2}}}
\label{pars_8cpp_ac9068594a93808f864502caa4a718fb7}
\hypertarget{pars_8cpp_aa59b48c7ebc2f8ff62e162b3ca17ebae}{
\index{pars.cpp@{pars.cpp}!bbInsCnt@{bbInsCnt}}
\index{bbInsCnt@{bbInsCnt}!pars.cpp@{pars.cpp}}
\subsubsection[{bbInsCnt}]{\setlength{\rightskip}{0pt plus 5cm}UINT32 {\bf bbInsCnt} = 0}}
\label{pars_8cpp_aa59b48c7ebc2f8ff62e162b3ca17ebae}
\hypertarget{pars_8cpp_ab8497513f9992352953a905ed69eea4c}{
\index{pars.cpp@{pars.cpp}!bench\_\-addr\_\-space@{bench\_\-addr\_\-space}}
\index{bench\_\-addr\_\-space@{bench\_\-addr\_\-space}!pars.cpp@{pars.cpp}}
\subsubsection[{bench\_\-addr\_\-space}]{\setlength{\rightskip}{0pt plus 5cm}{\bf benchAddrRangeParser}$\ast$ {\bf bench\_\-addr\_\-space}}}
\label{pars_8cpp_ab8497513f9992352953a905ed69eea4c}
\hypertarget{pars_8cpp_a1de8d6b3a152ca4ca2dec4a1f6d0df9e}{
\index{pars.cpp@{pars.cpp}!btb@{btb}}
\index{btb@{btb}!pars.cpp@{pars.cpp}}
\subsubsection[{btb}]{\setlength{\rightskip}{0pt plus 5cm}{\bf BTB}$\ast$ {\bf btb} = NULL}}
\label{pars_8cpp_a1de8d6b3a152ca4ca2dec4a1f6d0df9e}
\hypertarget{pars_8cpp_aa415b778ddffd669c113279e23602671}{
\index{pars.cpp@{pars.cpp}!filter@{filter}}
\index{filter@{filter}!pars.cpp@{pars.cpp}}
\subsubsection[{filter}]{\setlength{\rightskip}{0pt plus 5cm}FILTER {\bf filter}}}
\label{pars_8cpp_aa415b778ddffd669c113279e23602671}
\hypertarget{pars_8cpp_a62e59cbd1759ceca29472f8ed1cfda43}{
\index{pars.cpp@{pars.cpp}!g\_\-2bcgskew\_\-bp@{g\_\-2bcgskew\_\-bp}}
\index{g\_\-2bcgskew\_\-bp@{g\_\-2bcgskew\_\-bp}!pars.cpp@{pars.cpp}}
\subsubsection[{g\_\-2bcgskew\_\-bp}]{\setlength{\rightskip}{0pt plus 5cm}{\bf HybridBPskew}$\ast$ {\bf g\_\-2bcgskew\_\-bp} = NULL}}
\label{pars_8cpp_a62e59cbd1759ceca29472f8ed1cfda43}
\hypertarget{pars_8cpp_aab998b67eb0b3b2e5a85862cd87c17db}{
\index{pars.cpp@{pars.cpp}!g\_\-i\_\-info@{g\_\-i\_\-info}}
\index{g\_\-i\_\-info@{g\_\-i\_\-info}!pars.cpp@{pars.cpp}}
\subsubsection[{g\_\-i\_\-info}]{\setlength{\rightskip}{0pt plus 5cm}map$<$unsigned,i\_\-info$>$ {\bf g\_\-i\_\-info}}}
\label{pars_8cpp_aab998b67eb0b3b2e5a85862cd87c17db}
\hypertarget{pars_8cpp_a627bf9888cdd16a64ce1336bca064d71}{
\index{pars.cpp@{pars.cpp}!g\_\-log@{g\_\-log}}
\index{g\_\-log@{g\_\-log}!pars.cpp@{pars.cpp}}
\subsubsection[{g\_\-log}]{\setlength{\rightskip}{0pt plus 5cm}{\bf memory\_\-buffer} {\bf g\_\-log}}}
\label{pars_8cpp_a627bf9888cdd16a64ce1336bca064d71}
\hypertarget{pars_8cpp_ae1f49acdc02bc860091a9c0826042e9a}{
\index{pars.cpp@{pars.cpp}!g\_\-staticCode@{g\_\-staticCode}}
\index{g\_\-staticCode@{g\_\-staticCode}!pars.cpp@{pars.cpp}}
\subsubsection[{g\_\-staticCode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf staticCodeParser}$\ast$ {\bf g\_\-staticCode}}}
\label{pars_8cpp_ae1f49acdc02bc860091a9c0826042e9a}
\hypertarget{pars_8cpp_a5e14965f9e14d6406bb5b10e49d24b85}{
\index{pars.cpp@{pars.cpp}!g\_\-store\_\-buffer@{g\_\-store\_\-buffer}}
\index{g\_\-store\_\-buffer@{g\_\-store\_\-buffer}!pars.cpp@{pars.cpp}}
\subsubsection[{g\_\-store\_\-buffer}]{\setlength{\rightskip}{0pt plus 5cm}unsigned char {\bf g\_\-store\_\-buffer}\mbox{[}MAX\_\-MEM\_\-WRITE\_\-LEN\mbox{]}}}
\label{pars_8cpp_a5e14965f9e14d6406bb5b10e49d24b85}
\hypertarget{pars_8cpp_a4837669c7790ce1a19610a935ffe7383}{
\index{pars.cpp@{pars.cpp}!g\_\-tournament\_\-bp@{g\_\-tournament\_\-bp}}
\index{g\_\-tournament\_\-bp@{g\_\-tournament\_\-bp}!pars.cpp@{pars.cpp}}
\subsubsection[{g\_\-tournament\_\-bp}]{\setlength{\rightskip}{0pt plus 5cm}{\bf TournamentBP}$\ast$ {\bf g\_\-tournament\_\-bp} = NULL}}
\label{pars_8cpp_a4837669c7790ce1a19610a935ffe7383}
\hypertarget{pars_8cpp_a1e853eca8d9b1c61c314eed5b83b538a}{
\index{pars.cpp@{pars.cpp}!rootThreadArg@{rootThreadArg}}
\index{rootThreadArg@{rootThreadArg}!pars.cpp@{pars.cpp}}
\subsubsection[{rootThreadArg}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ {\bf rootThreadArg} = (void $\ast$)0xABBA}}
\label{pars_8cpp_a1e853eca8d9b1c61c314eed5b83b538a}
\hypertarget{pars_8cpp_a5b351a9cd233c0a893b976831dce607c}{
\index{pars.cpp@{pars.cpp}!rootThreadUid@{rootThreadUid}}
\index{rootThreadUid@{rootThreadUid}!pars.cpp@{pars.cpp}}
\subsubsection[{rootThreadUid}]{\setlength{\rightskip}{0pt plus 5cm}PIN\_\-THREAD\_\-UID {\bf rootThreadUid}}}
\label{pars_8cpp_a5b351a9cd233c0a893b976831dce607c}
\hypertarget{pars_8cpp_a3780f840dcb4b8cfe00bde4a6cd55d16}{
\index{pars.cpp@{pars.cpp}!semaphore0@{semaphore0}}
\index{semaphore0@{semaphore0}!pars.cpp@{pars.cpp}}
\subsubsection[{semaphore0}]{\setlength{\rightskip}{0pt plus 5cm}PIN\_\-SEMAPHORE {\bf semaphore0}}}
\label{pars_8cpp_a3780f840dcb4b8cfe00bde4a6cd55d16}
\hypertarget{pars_8cpp_ad27290b1818ecaa97935c4d181a158f0}{
\index{pars.cpp@{pars.cpp}!semaphore1@{semaphore1}}
\index{semaphore1@{semaphore1}!pars.cpp@{pars.cpp}}
\subsubsection[{semaphore1}]{\setlength{\rightskip}{0pt plus 5cm}PIN\_\-SEMAPHORE {\bf semaphore1}}}
\label{pars_8cpp_ad27290b1818ecaa97935c4d181a158f0}
\hypertarget{pars_8cpp_a0161597891c90043c55ef8ecc6855e49}{
\index{pars.cpp@{pars.cpp}!start\_\-pars@{start\_\-pars}}
\index{start\_\-pars@{start\_\-pars}!pars.cpp@{pars.cpp}}
\subsubsection[{start\_\-pars}]{\setlength{\rightskip}{0pt plus 5cm}clock\_\-t {\bf start\_\-pars}}}
\label{pars_8cpp_a0161597891c90043c55ef8ecc6855e49}
\hypertarget{pars_8cpp_aae1c5d9a4ab56767590309b25a7dfa67}{
\index{pars.cpp@{pars.cpp}!stop\_\-pars@{stop\_\-pars}}
\index{stop\_\-pars@{stop\_\-pars}!pars.cpp@{pars.cpp}}
\subsubsection[{stop\_\-pars}]{\setlength{\rightskip}{0pt plus 5cm}clock\_\-t {\bf stop\_\-pars}}}
\label{pars_8cpp_aae1c5d9a4ab56767590309b25a7dfa67}
