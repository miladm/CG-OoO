\hypertarget{classvliwScheduler}{
\section{vliwScheduler Class Reference}
\label{classvliwScheduler}\index{vliwScheduler@{vliwScheduler}}
}


{\ttfamily \#include $<$vliwScheduler.h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classvliwScheduler_a99727364e47615fde6a54426b135df7a}{vliwScheduler} ()
\item 
\hyperlink{classvliwScheduler_a845a2546d4f6eccf05a853c3f56f30d6}{$\sim$vliwScheduler} ()
\item 
void \hyperlink{classvliwScheduler_afa9961197e83bf8ac47cc7f15232b70c}{findMostCritIns} (\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$list, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, bool UPLDhoisting)
\item 
bool \hyperlink{classvliwScheduler_a29a8e438bea013f48b2cc7b3e672dfe6}{scheduleIns} (\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$inList, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$outList, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, bool UPLDhoisting, long int \hyperlink{bkEnd_8cpp_a3709ef01c299a1b84a1b023b9a44d4bc}{phraseID})
\item 
bool \hyperlink{classvliwScheduler_a6b42ca4f7436dc7dfac2848dabc10416}{scheduleIns\_\-1FU} (\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$inList, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$outList, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, bool UPLDhoisting, long int \hyperlink{bkEnd_8cpp_a3709ef01c299a1b84a1b023b9a44d4bc}{phraseID})
\item 
bool \hyperlink{classvliwScheduler_a0c1dd56c752aee739de1aa373fc16078}{scheduleInsStream} (\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$inList, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, bool UPLDhoisting, FILE $\ast$\hyperlink{bkEnd_8cpp_a0e5f51d6a6b1d82437b223b600c984c2}{reScheduleFile}, float \hyperlink{binaryTranslator_2dot_8cpp_a88cfebd9f1e296c291bf05c5a78a6177}{unpredMemOpThreshold})
\item 
bool \hyperlink{classvliwScheduler_aab01a955d85779eeeddb36cf921e8e80}{scheduleInsStream\_\-1FU} (\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$inList, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, bool UPLDhoisting, FILE $\ast$\hyperlink{bkEnd_8cpp_a0e5f51d6a6b1d82437b223b600c984c2}{reScheduleFile})
\item 
void \hyperlink{classvliwScheduler_aa7078d3900e7edcb82304e988339d33a}{sortLists} (\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$rootALUins, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$rootMEMins, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, bool UPLDhoisting, long int \hyperlink{bkEnd_8cpp_a3709ef01c299a1b84a1b023b9a44d4bc}{phraseID})
\item 
void \hyperlink{classvliwScheduler_aae6254bfac1e348447643a0dec8cbf03}{completeIns} (int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, \hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$list, bool del)
\item 
\hyperlink{classinstruction}{instruction} $\ast$ \hyperlink{classvliwScheduler_afd1ec0df4e12e892ef2e1d6cd5a1ad3c}{setupNewIns} (\hyperlink{classinstruction}{instruction} $\ast$ins, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{classvliwScheduler_a9fde0b92fb06b843f278907413661df1}{parseIns} (int \hyperlink{bkEnd_8cpp_a06a6e046fd7b9a66b03d334b1df5e3ad}{ROBsize}, \hyperlink{classparser}{parser} $\ast$\hyperlink{bkEnd_8cpp_a9b8e7669bda57879d8abc5234b2f0b19}{parse}, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle})
\item 
void \hyperlink{classvliwScheduler_ae3dceea059708a0c576983d42eeeb929}{delFromInsMap} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
void \hyperlink{classvliwScheduler_a003d398e327890ff6b77d565207f970d}{insertToInsMap} (\hyperlink{classinstruction}{instruction} $\ast$newIns)
\item 
int \hyperlink{classvliwScheduler_a730c35e836911d4e81eaccea4bee931d}{getSizeOfInsMap} ()
\item 
void \hyperlink{classvliwScheduler_adc49e9c2b4208f4bf4fe3d1a465e409b}{injectIns} (\hyperlink{classinstruction}{instruction} $\ast$ins)
\item 
bool \hyperlink{classvliwScheduler_a5abce2c71dce559d07f8f5de8f04c146}{schedulePhraseinsStream} (\hyperlink{classList}{List}$<$ \hyperlink{classinstruction}{instruction} $\ast$ $>$ $\ast$inList, int \hyperlink{vliwScheduler_8cpp_a1f4871d45089b039d95d3832dd123827}{cycle}, bool UPLDhoisting, FILE $\ast$\hyperlink{bkEnd_8cpp_a0e5f51d6a6b1d82437b223b600c984c2}{reScheduleFile}, float \hyperlink{binaryTranslator_2dot_8cpp_a88cfebd9f1e296c291bf05c5a78a6177}{unpredMemOpThreshold}, \hyperlink{classList}{List}$<$ \hyperlink{classphrase}{phrase} $\ast$ $>$ $\ast$phList)
\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classvliwScheduler_a99727364e47615fde6a54426b135df7a}{
\index{vliwScheduler@{vliwScheduler}!vliwScheduler@{vliwScheduler}}
\index{vliwScheduler@{vliwScheduler}!vliwScheduler@{vliwScheduler}}
\subsubsection[{vliwScheduler}]{\setlength{\rightskip}{0pt plus 5cm}vliwScheduler::vliwScheduler (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_a99727364e47615fde6a54426b135df7a}

\begin{DoxyCode}
                             {
        rootALUins = new List<instruction*>;
        rootMEMins = new List<instruction*>;
        outListTemp = new List<instruction*>;
        rootInsIndx = new List<int>;
        rootSize = 0;
        phID = -1;
        tempReg = -100;
}
\end{DoxyCode}
\hypertarget{classvliwScheduler_a845a2546d4f6eccf05a853c3f56f30d6}{
\index{vliwScheduler@{vliwScheduler}!$\sim$vliwScheduler@{$\sim$vliwScheduler}}
\index{$\sim$vliwScheduler@{$\sim$vliwScheduler}!vliwScheduler@{vliwScheduler}}
\subsubsection[{$\sim$vliwScheduler}]{\setlength{\rightskip}{0pt plus 5cm}vliwScheduler::$\sim$vliwScheduler (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_a845a2546d4f6eccf05a853c3f56f30d6}

\begin{DoxyCode}
                              {
        delete rootALUins;
        delete rootMEMins;
        delete rootInsIndx;
        delete outListTemp;
}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{classvliwScheduler_aae6254bfac1e348447643a0dec8cbf03}{
\index{vliwScheduler@{vliwScheduler}!completeIns@{completeIns}}
\index{completeIns@{completeIns}!vliwScheduler@{vliwScheduler}}
\subsubsection[{completeIns}]{\setlength{\rightskip}{0pt plus 5cm}void vliwScheduler::completeIns (
\begin{DoxyParamCaption}
\item[{int}]{cycle, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{list, }
\item[{bool}]{del}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_aae6254bfac1e348447643a0dec8cbf03}

\begin{DoxyCode}
                                                                             {
        for (int i = list->NumElements()-1; i >= 0; i--) {
                if ((list->Nth(i))->getStatus() == execute && 
                    (list->Nth(i))->getCompleteCycle() <= cycle) {
                        //Release dependencies
                        list->Nth(i)->notifyAllBrAncestorsICompleted();
                        list->Nth(i)->notifyAllDepICompleted();
                        list->Nth(i)->delDepTableEntris(depTables, coreType, true
      ); //assuming always perfect register renaming (04/24/13)
                        list->Nth(i)->setStatus(complete, -1, -1); //TODO double 
      check this line. Is it compatible with the rest of the program?
                        if (del == true) delete list->Nth(i);
                        list->RemoveAt(i);
                }
        }
}
\end{DoxyCode}
\hypertarget{classvliwScheduler_ae3dceea059708a0c576983d42eeeb929}{
\index{vliwScheduler@{vliwScheduler}!delFromInsMap@{delFromInsMap}}
\index{delFromInsMap@{delFromInsMap}!vliwScheduler@{vliwScheduler}}
\subsubsection[{delFromInsMap}]{\setlength{\rightskip}{0pt plus 5cm}void vliwScheduler::delFromInsMap (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_ae3dceea059708a0c576983d42eeeb929}

\begin{DoxyCode}
                                                  {
        if (insMap.count(ins->getInsID()) == 1) {
                insMap.erase(ins->getInsID());
        } else {
                printf("\nERROR: Instruction Map Detected an Invalid Conflict\n")
      ;
                exit(-1);
        }
}
\end{DoxyCode}
\hypertarget{classvliwScheduler_afa9961197e83bf8ac47cc7f15232b70c}{
\index{vliwScheduler@{vliwScheduler}!findMostCritIns@{findMostCritIns}}
\index{findMostCritIns@{findMostCritIns}!vliwScheduler@{vliwScheduler}}
\subsubsection[{findMostCritIns}]{\setlength{\rightskip}{0pt plus 5cm}void vliwScheduler::findMostCritIns (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{list, }
\item[{int}]{cycle, }
\item[{bool}]{UPLDhoisting}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_afa9961197e83bf8ac47cc7f15232b70c}

\begin{DoxyCode}
                                                                                 
               {
        if (list->NumElements() == 0) return;
        instruction* critIns = list->Nth(0);
        int critIndx = 0;
        int critPathLen = critIns->findLongestPathDynamicly(cycle, UPLDhoisting);
      
        for (int i = 1; i < list->NumElements(); i++) {
                int tempCritPathLen = list->Nth(i)->findLongestPathDynamicly(
      cycle, UPLDhoisting);
                if (critPathLen < tempCritPathLen) {
                    critIns = list->Nth(i);
                    critIndx = i;
                    critPathLen = tempCritPathLen;
                }
        }
        list->RemoveAt(critIndx);
        list->InsertAt(critIns,0);
}
\end{DoxyCode}
\hypertarget{classvliwScheduler_a730c35e836911d4e81eaccea4bee931d}{
\index{vliwScheduler@{vliwScheduler}!getSizeOfInsMap@{getSizeOfInsMap}}
\index{getSizeOfInsMap@{getSizeOfInsMap}!vliwScheduler@{vliwScheduler}}
\subsubsection[{getSizeOfInsMap}]{\setlength{\rightskip}{0pt plus 5cm}int vliwScheduler::getSizeOfInsMap (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_a730c35e836911d4e81eaccea4bee931d}

\begin{DoxyCode}
                                   {
        return (int) insMap.size();
}
\end{DoxyCode}
\hypertarget{classvliwScheduler_adc49e9c2b4208f4bf4fe3d1a465e409b}{
\index{vliwScheduler@{vliwScheduler}!injectIns@{injectIns}}
\index{injectIns@{injectIns}!vliwScheduler@{vliwScheduler}}
\subsubsection[{injectIns}]{\setlength{\rightskip}{0pt plus 5cm}void vliwScheduler::injectIns (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_adc49e9c2b4208f4bf4fe3d1a465e409b}

\begin{DoxyCode}
                                              {
        instruction *newIns = setupNewIns(ins, cycle);
        if (newIns->isReady(cycle) == true) newIns->goToReadyList(); //Catch root
       instructions
        else insertToInsMap(newIns);
}
\end{DoxyCode}
\hypertarget{classvliwScheduler_a003d398e327890ff6b77d565207f970d}{
\index{vliwScheduler@{vliwScheduler}!insertToInsMap@{insertToInsMap}}
\index{insertToInsMap@{insertToInsMap}!vliwScheduler@{vliwScheduler}}
\subsubsection[{insertToInsMap}]{\setlength{\rightskip}{0pt plus 5cm}void vliwScheduler::insertToInsMap (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{newIns}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_a003d398e327890ff6b77d565207f970d}

\begin{DoxyCode}
                                                      {
        if (insMap.count(newIns->getInsID()) == 0) {
                insMap.insert(pair<long int, instruction*>(newIns->getInsID(),new
      Ins));
        } else {
                printf("\nERROR: Instruction Map Detected an Invalid Conflict\n")
      ;
                exit(-1);
        }
}
\end{DoxyCode}
\hypertarget{classvliwScheduler_a9fde0b92fb06b843f278907413661df1}{
\index{vliwScheduler@{vliwScheduler}!parseIns@{parseIns}}
\index{parseIns@{parseIns}!vliwScheduler@{vliwScheduler}}
\subsubsection[{parseIns}]{\setlength{\rightskip}{0pt plus 5cm}void vliwScheduler::parseIns (
\begin{DoxyParamCaption}
\item[{int}]{ROBsize, }
\item[{{\bf parser} $\ast$}]{parse, }
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_a9fde0b92fb06b843f278907413661df1}

\begin{DoxyCode}
                                                                   {
        if (insMap.size() < (unsigned int)ROBsize) {
                int diff = ROBsize - insMap.size();
                for (int i = 0; i < diff; i++) {
                        instruction *newIns = new instruction;
                        if (parse->parseIns(newIns) == false) break; //EOF
                        newIns->setReadyLists(rootALUins, rootMEMins);
                        newIns->setVliwScheduler(this);
                        if (newIns->isReady(cycle) == true) newIns->
      goToReadyList(); //Catch root instructions
                        else insertToInsMap(newIns);
                        insCount++;
                }
        }
}
\end{DoxyCode}
\hypertarget{classvliwScheduler_a29a8e438bea013f48b2cc7b3e672dfe6}{
\index{vliwScheduler@{vliwScheduler}!scheduleIns@{scheduleIns}}
\index{scheduleIns@{scheduleIns}!vliwScheduler@{vliwScheduler}}
\subsubsection[{scheduleIns}]{\setlength{\rightskip}{0pt plus 5cm}bool vliwScheduler::scheduleIns (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{inList, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{outList, }
\item[{int}]{cycle, }
\item[{bool}]{UPLDhoisting, }
\item[{long int}]{phraseID}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_a29a8e438bea013f48b2cc7b3e672dfe6}

\begin{DoxyCode}
                                                                                 
                                                             {
        for (int i = 0; i < inList->NumElements(); i++) {
                if (inList->Nth(i)->isReady(cycle) == true) {
                        inList->Nth(i)->findLongestPath(cycle, UPLDhoisting, 
      phraseID);
                }
        }
        quicksortLongestPath(rootALUins,0,rootALUins->NumElements()-1,cycle, UPLD
      hoisting);
        while (inList->NumElements() > 0 || rootALUins->NumElements() > 0 || root
      MEMins->NumElements() > 0 || outListTemp->NumElements() > 0) {
                cycle++;
                for (int i = 0; i < inList->NumElements(); i++) {
                        instruction* ins = inList->Nth(i);
                        if (ins->isReady(cycle) == true) {
                                if (ins->getType() == ALU || ins->getType() == 
      FPU) {
                                        rootALUins->Append(ins);
                                        rootInsIndx->Append(i);
                                } else if (ins->getType() == MEM) {
                                        rootMEMins->Append(ins);
                                        rootInsIndx->Append(i);
                                } else {
                                        printf("WARNING: THERE IS A PROBLEM1!\n")
      ;
                                        exit(1);
                                }
                        }
                }
                for (int j = rootInsIndx->NumElements()-1; j >= 0; j--) {
                        int indx = rootInsIndx->Nth(j);
                        inList->RemoveAt(indx);
                        rootInsIndx->RemoveAt(j);
                }
                Assert(rootInsIndx->NumElements() == 0);
                int j=0;
                for (j = 0; j < NUM_MEM_UNIT && rootMEMins->NumElements() > 0; j+
      +) {
                        outList->Append(rootMEMins->Nth(0));
                        outListTemp->Append(rootMEMins->Nth(0));
                        rootMEMins->Nth(0)->setStatus(execute, cycle, cacheLat[0]
      -1); //excute state has no meaning here (just an internal setting)
                        rootMEMins->RemoveAt(0);
                }
                for (j = 0; j < NUM_ALU_UNIT && rootALUins->NumElements() > 0; j+
      +) {
                        outList->Append(rootALUins->Nth(0));
                        outListTemp->Append(rootALUins->Nth(0));
                        if (rootALUins->Nth(0)->getType() == ALU) {
                                rootALUins->Nth(0)->setStatus(execute, cycle, 
      ALU_LATENCY-1); //excute state has no meaning here (just an internal setting)
                        } else if (rootALUins->Nth(0)->getType() == FPU) {
                                rootALUins->Nth(0)->setStatus(execute, cycle, 
      FPU_LATENCY-1); //excute state has no meaning here (just an internal setting)
                        }
                        rootALUins->RemoveAt(0);
                }
                completeIns (cycle,outListTemp,false);
        }
        if (rootALUins->NumElements() > 1000 || rootMEMins->NumElements() > 1000)
      
                return false;
        else
                return true;
}
\end{DoxyCode}
\hypertarget{classvliwScheduler_a6b42ca4f7436dc7dfac2848dabc10416}{
\index{vliwScheduler@{vliwScheduler}!scheduleIns\_\-1FU@{scheduleIns\_\-1FU}}
\index{scheduleIns\_\-1FU@{scheduleIns\_\-1FU}!vliwScheduler@{vliwScheduler}}
\subsubsection[{scheduleIns\_\-1FU}]{\setlength{\rightskip}{0pt plus 5cm}bool vliwScheduler::scheduleIns\_\-1FU (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{inList, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{outList, }
\item[{int}]{cycle, }
\item[{bool}]{UPLDhoisting, }
\item[{long int}]{phraseID}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_a6b42ca4f7436dc7dfac2848dabc10416}

\begin{DoxyCode}
                                                                                 
                                                                 {
        for (int i = 0; i < inList->NumElements(); i++) {
                if (inList->Nth(i)->isReady(cycle) == true) {
                        inList->Nth(i)->findLongestPath(cycle, UPLDhoisting, 
      phraseID);
                }
        }
        quicksortLongestPath(rootALUins,0,rootALUins->NumElements()-1,cycle, UPLD
      hoisting);
        while (inList->NumElements() > 0 || rootALUins->NumElements() > 0 || outL
      istTemp->NumElements() > 0) {
                cycle++;
                for (int i = 0; i < inList->NumElements(); i++) {
                        instruction* ins = inList->Nth(i);
                        if (ins->isReady(cycle) == true) {
                                rootALUins->Append(ins);
                                rootInsIndx->Append(i);
                        }
                }
                for (int j = rootInsIndx->NumElements()-1; j >= 0; j--) {
                        int indx = rootInsIndx->Nth(j);
                        inList->RemoveAt(indx);
                        rootInsIndx->RemoveAt(j);
                }
                Assert(rootInsIndx->NumElements() == 0);
                int j=0;
                for (j = 0; j < 1 && rootALUins->NumElements() > 0; j++) {
                        outList->Append(rootALUins->Nth(0));
                        outListTemp->Append(rootALUins->Nth(0));
                        if (rootALUins->Nth(0)->getType() == MEM) {
                                rootALUins->Nth(0)->setStatus(execute, cycle, 
      cacheLat[0]-1); //excute state has no meaning here (just an internal setting)
                        } else if (rootALUins->Nth(0)->getType() == ALU) {
                                rootALUins->Nth(0)->setStatus(execute, cycle, 
      ALU_LATENCY-1); //excute state has no meaning here (just an internal setting)
                        } else if (rootALUins->Nth(0)->getType() == FPU) {
                                rootALUins->Nth(0)->setStatus(execute, cycle, 
      FPU_LATENCY-1); //excute state has no meaning here (just an internal setting)
                        } else {
                                Assert(rootALUins->Nth(0)->getType() == FPU || 
                                       rootALUins->Nth(0)->getType() == ALU || 
                                       rootALUins->Nth(0)->getType() == MEM);
                        }
                        rootALUins->RemoveAt(0);
                }
                completeIns (cycle,outListTemp, false);
                Assert(outListTemp->NumElements() == 0);
        }
        if (rootALUins->NumElements() > 1000)
                return false;
        else
                return true;
}
\end{DoxyCode}
\hypertarget{classvliwScheduler_a0c1dd56c752aee739de1aa373fc16078}{
\index{vliwScheduler@{vliwScheduler}!scheduleInsStream@{scheduleInsStream}}
\index{scheduleInsStream@{scheduleInsStream}!vliwScheduler@{vliwScheduler}}
\subsubsection[{scheduleInsStream}]{\setlength{\rightskip}{0pt plus 5cm}bool vliwScheduler::scheduleInsStream (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{inList, }
\item[{int}]{cycle, }
\item[{bool}]{UPLDhoisting, }
\item[{FILE $\ast$}]{reScheduleFile, }
\item[{float}]{unpredMemOpThreshold}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_a0c1dd56c752aee739de1aa373fc16078}

\begin{DoxyCode}
                                                                                 
                                                                     {
        bool foundBR = false;
        for (int i = 0; i < inList->NumElements(); i++) {
                instruction* ins = inList->Nth(i);
                if (foundBR == false && ins->getType() == BR) {foundBR = true;}
                if (ins->isReady(cycle) == true) {
                        if (ins->getType() == ALU || ins->getType() == FPU || ins
      ->getType() == BR || ins->getType() == ASSIGN) {
                                rootALUins->Append(ins);
                                rootInsIndx->Append(i);
                                //Inject new instructions
                                //if (foundBR) {
                                //      instruction *newIns = setupNewIns(ins, te
      mpReg, cycle);
                                //      tempReg--;
                                //      inList->InsertAt(newIns, i+1);
                                //}
                        } else if (ins->getType() == MEM) {
                                rootMEMins->Append(ins);
                                rootInsIndx->Append(i);
                                //Inject new instructions
                                //if (foundBR) {
                                //      instruction *newIns = setupNewIns(ins, te
      mpReg, cycle);
                                //      tempReg--;
                                //      inList->InsertAt(newIns, i+1);
                                //}
                        } else {
                                printf("WARNING: THERE IS A PROBLEM2!\n");
                                exit(1);
                        }
                }
        }
        for (int j = rootInsIndx->NumElements()-1; j >= 0; j--) {
                int indx = rootInsIndx->Nth(j);
                inList->RemoveAt(indx);
                rootInsIndx->RemoveAt(j);
        }
        Assert(rootInsIndx->NumElements() == 0);
        sortLists(rootALUins,rootMEMins, cycle, UPLDhoisting, -1);
        int j=0;
        for (j = 0; j < NUM_MEM_UNIT && rootMEMins->NumElements() > 0; j++) {
                rootMEMins->Nth(0)->printToFile(reScheduleFile, UPLDhoisting);//i
      f UPLD hoisting is active, so are missRates
                outListTemp->Append(rootMEMins->Nth(0));
                if (UPLDhoisting == true && rootMEMins->Nth(0)->getMissrate() > 
      unpredMemOpThreshold) {
                        rootMEMins->Nth(0)->setStatus(execute, cycle, cacheLat[2]
      -1); //excute state has no meaning here (just an internal setting)
                } else {
                        rootMEMins->Nth(0)->setStatus(execute, cycle, cacheLat[0]
      -1); //excute state has no meaning here (just an internal setting)
                }
                rootMEMins->RemoveAt(0);
        }
        for (j = 0; j < NUM_ALU_UNIT && rootALUins->NumElements() > 0; j++) {
                rootALUins->Nth(0)->printToFile(reScheduleFile, UPLDhoisting);//i
      f UPLD hoisting is active, so are missRates
                outListTemp->Append(rootALUins->Nth(0));
                if (rootALUins->Nth(0)->getType() == ALU) {
                        rootALUins->Nth(0)->setStatus(execute, cycle, 
      ALU_LATENCY-1); //excute state has no meaning here (just an internal setting)
                } else if (rootALUins->Nth(0)->getType() == FPU) {
                        rootALUins->Nth(0)->setStatus(execute, cycle, 
      FPU_LATENCY-1); //excute state has no meaning here (just an internal setting)
                } else if (rootALUins->Nth(0)->getType() == BR) {
                        rootALUins->Nth(0)->setStatus(execute, cycle, 
      ALU_LATENCY-1); //excute state has no meaning here (just an internal setting)
                } else if (rootALUins->Nth(0)->getType() == ASSIGN) {
                        rootALUins->Nth(0)->setStatus(execute, cycle, 
      ASSIGN_LATENCY-1); //excute state has no meaning here (just an internal setting)
                }
                rootALUins->RemoveAt(0);
        }
        completeIns (cycle,outListTemp, true);
        if (rootALUins->NumElements() > 220 || rootMEMins->NumElements() > 220)
                return false;
        else
                return true;
}
\end{DoxyCode}
\hypertarget{classvliwScheduler_aab01a955d85779eeeddb36cf921e8e80}{
\index{vliwScheduler@{vliwScheduler}!scheduleInsStream\_\-1FU@{scheduleInsStream\_\-1FU}}
\index{scheduleInsStream\_\-1FU@{scheduleInsStream\_\-1FU}!vliwScheduler@{vliwScheduler}}
\subsubsection[{scheduleInsStream\_\-1FU}]{\setlength{\rightskip}{0pt plus 5cm}bool vliwScheduler::scheduleInsStream\_\-1FU (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{inList, }
\item[{int}]{cycle, }
\item[{bool}]{UPLDhoisting, }
\item[{FILE $\ast$}]{reScheduleFile}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_aab01a955d85779eeeddb36cf921e8e80}

\begin{DoxyCode}
                                                                                 
                                             {
        for (int i = 0; i < inList->NumElements(); i++) {
                instruction* ins = inList->Nth(i);
                if (ins->isReady(cycle) == true) {
                        rootALUins->Append(ins);
                        rootInsIndx->Append(i);
                }
        }
        for (int j = rootInsIndx->NumElements()-1; j >= 0; j--) {
                int indx = rootInsIndx->Nth(j);
                inList->RemoveAt(indx);
                rootInsIndx->RemoveAt(j);
        }
        Assert(rootInsIndx->NumElements() == 0);
        findMostCritIns(rootALUins, cycle, UPLDhoisting);
        int j=0;
        for (j = 0; j < 1 && rootALUins->NumElements() > 0; j++) {
                rootALUins->Nth(0)->printToFile(reScheduleFile, UPLDhoisting);//i
      f UPLD hoisting is active, so are missRates
                outListTemp->Append(rootALUins->Nth(0));
                if (rootALUins->Nth(0)->getType() == MEM) {
                        rootALUins->Nth(0)->setStatus(execute, cycle, cacheLat[0]
      -1); //excute state has no meaning here (just an internal setting)
                } else if (rootALUins->Nth(0)->getType() == ALU) {
                        rootALUins->Nth(0)->setStatus(execute, cycle, 
      ALU_LATENCY-1); //excute state has no meaning here (just an internal setting)
                } else if (rootALUins->Nth(0)->getType() == FPU) {
                        rootALUins->Nth(0)->setStatus(execute, cycle, 
      FPU_LATENCY-1); //excute state has no meaning here (just an internal setting)
                } else {
                        Assert(rootALUins->Nth(0)->getType() == FPU || 
                               rootALUins->Nth(0)->getType() == ALU || 
                               rootALUins->Nth(0)->getType() == MEM);
                }
                rootALUins->RemoveAt(0);
        }
        completeIns (cycle,outListTemp,true);
        if (rootALUins->NumElements() > 220)
                return false;
        else
                return true;
}
\end{DoxyCode}
\hypertarget{classvliwScheduler_a5abce2c71dce559d07f8f5de8f04c146}{
\index{vliwScheduler@{vliwScheduler}!schedulePhraseinsStream@{schedulePhraseinsStream}}
\index{schedulePhraseinsStream@{schedulePhraseinsStream}!vliwScheduler@{vliwScheduler}}
\subsubsection[{schedulePhraseinsStream}]{\setlength{\rightskip}{0pt plus 5cm}bool vliwScheduler::schedulePhraseinsStream (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{inList, }
\item[{int}]{cycle, }
\item[{bool}]{UPLDhoisting, }
\item[{FILE $\ast$}]{reScheduleFile, }
\item[{float}]{unpredMemOpThreshold, }
\item[{{\bf List}$<$ {\bf phrase} $\ast$ $>$ $\ast$}]{phList}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_a5abce2c71dce559d07f8f5de8f04c146}

\begin{DoxyCode}
                                                                                 
                                                                                       
                 {
        //bool foundBR = false;
        //static int tempReg = -100;
        if (phID == -1) {
                phID = 1;
                phrase* ph = new phrase(phID);
                phList->Append(ph);
        }
        //for (int i = 0; i < inList->NumElements(); i++) {
        //      instruction* ins = inList->Nth(i);
        //      if (foundBR == false && ins->getType() == BR && ins->isReady(cycl
      e) == false) {foundBR = true;}
        //      if (ins->isReady(cycle) == true) {
        //              if (ins->getType() == ALU || ins->getType() == FPU || ins
      ->getType() == BR || ins->getType() == ASSIGN) {
        //                      rootALUins->Append(ins);
        //                      rootInsIndx->Append(i);
        //                      //Inject new instructions
        //                      if (foundBR == true) {
        //                              instruction *newIns = setupNewIns(ins, te
      mpReg, cycle);
        //                              tempReg--;
        //                              inList->InsertAt(newIns, i+1);
        //                      }
        //              } else if (ins->getType() == MEM) {
        //                      rootMEMins->Append(ins);
        //                      rootInsIndx->Append(i);
        //                      //Inject new instructions
        //                      if (foundBR == true) {
        //                              instruction *newIns = setupNewIns(ins, te
      mpReg, cycle);
        //                              tempReg--;
        //                              inList->InsertAt(newIns, i+1);
        //                      }
        //              } else {
        //                      printf("WARNING: THERE IS A PROBLEM3!\n");
        //                      exit(1);
        //              }
        //      }
        //      //if (ins->getType() == BR) break; //Avoid useless iterations - T
      ODO must use it in different vliw-scheduler funcs
        //}
        //for (int j = rootInsIndx->NumElements()-1; j >= 0; j--) {
        //      int indx = rootInsIndx->Nth(j);
        //      inList->RemoveAt(indx);
        //      rootInsIndx->RemoveAt(j);
        //}
        //Assert(rootInsIndx->NumElements() == 0);
        sortLists(rootALUins,rootMEMins, cycle, UPLDhoisting, -1);
        int j=0;
        for (j = 0; j < NUM_MEM_UNIT && rootMEMins->NumElements() > 0; j++) {
                if (rootMEMins->Nth(0)->getNumMemRdAncestors() > 0) {//check for 
      immediate UPLD ops
                        for (int i = 0; i < rootMEMins->Nth(0)->
      getNumMemRdAncestors(); i++) {
                                if (phID <= rootMEMins->Nth(0)->getNthMemRdAncest
      or(i)->getMyPhraseID()) {
                                        Assert(phID == rootMEMins->Nth(0)->
      getNthMemRdAncestor(i)->getMyPhraseID());
                                        phID++; // = rootMEMins->Nth(0)->getNthMe
      mRdAncestor(i)->getMyPhraseID() + 1;
                                        phrase* ph = new phrase(phID);
                                        phList->Append(ph);
                                }
                        }
                }
                //If ther is an older BR op, inject a new ins
                //if (rootMEMins->Nth(0)->getNumBrAncestors() > 0 && rootMEMins->
      Nth(0)->getType() != BR && rootMEMins->Nth(0)->getMemType() != WRITE && rootMEMin
      s->Nth(0)->getType() != ASSIGN){// && rootMEMins->Nth(0)->getType() != ALU) { //T
      ODO I think this line has the bug!
                if (rootMEMins->Nth(0)->getBrMode() == scheduleBr && rootMEMins->
      Nth(0)->getNumBrAncestors() > 0 && rootMEMins->Nth(0)->getMemType() == READ && ro
      otMEMins->Nth(0)->getMissrate() > unpredMemOpThreshold) { //TODO I think this lin
      e has the bug!
                        injectIns(rootMEMins->Nth(0));
                //} else {
                //      printf("ERROR: Invalid dependency chanin detected. Aborti
      ng...\n");
                //      exit(-1);
                }
                rootMEMins->Nth(0)->setMyPhraseID(phID);
                phList->Nth(phList->NumElements()-1)->addToPhrase_Light(rootMEMin
      s->Nth(0));
                outListTemp->Append(rootMEMins->Nth(0));
                if (UPLDhoisting == true && rootMEMins->Nth(0)->getMissrate() > 
      unpredMemOpThreshold) {
                        rootMEMins->Nth(0)->setStatus(execute, cycle, cacheLat[2]
      -1); //excute state has no meaning here (just an internal setting)
                } else {
                        rootMEMins->Nth(0)->setStatus(execute, cycle, cacheLat[0]
      -1); //excute state has no meaning here (just an internal setting)
                }
                rootMEMins->RemoveAt(0);
                if (phList->NumElements() > 4) {//Keep the three most outstanding
       phrases
                        if (phList->Nth(0)->isPhraseComplete() == true) {
                                phList->Nth(0)->printToFilePhrase(reScheduleFile)
      ;
                                int size = phList->Nth(0)->getPhraseSize_unsort()
      ;
                                for (int k = size-1; k >= 0; k--) {
                                        if (phList->Nth(0)->getInsList_unsort()->
      Nth(k)->getMissrate() > unpredMemOpThreshold) 
                                                phList->Nth(0)->getInsList_unsort
      ()->Nth(k)->notifyDepICommited();
                                        delete phList->Nth(0)->getInsList_unsort(
      )->Nth(k);
                                        phList->Nth(0)->getInsList_unsort()->Remo
      veAt(k);
                                }
                                delete phList->Nth(0);
                                phList->RemoveAt(0);
                        }
                }
        }
        for (j = 0; j < NUM_ALU_UNIT && rootALUins->NumElements() > 0; j++) {
                if (rootALUins->Nth(0)->getNumMemRdAncestors() > 0) {//check for 
      immediate UPLD ops
                        for (int i = 0; i < rootALUins->Nth(0)->
      getNumMemRdAncestors(); i++) {
                                if (phID <= rootALUins->Nth(0)->getNthMemRdAncest
      or(i)->getMyPhraseID()) {
                                        Assert(phID == rootALUins->Nth(0)->
      getNthMemRdAncestor(i)->getMyPhraseID());
                                        phID++; // = rootALUins->Nth(0)->getNthMe
      mRdAncestor(i)->getMyPhraseID() + 1;
                                        phrase* ph = new phrase(phID);
                                        phList->Append(ph);
                                }
                        }
                }
                //If ther is an older BR op, inject a new ins
                //if (rootALUins->Nth(0)->getNumBrAncestors() > 0 && rootALUins->
      Nth(0)->getType() != BR && rootALUins->Nth(0)->getMemType() != WRITE && rootALUin
      s->Nth(0)->getType() != ASSIGN){// && rootALUins->Nth(0)->getType() != ALU) { //T
      ODO I think this line has the bug!
                if (rootALUins->Nth(0)->getBrMode() == scheduleBr && rootALUins->
      Nth(0)->getNumBrAncestors() > 0 && rootALUins->Nth(0)->getMemType() == READ && ro
      otALUins->Nth(0)->getMissrate() > unpredMemOpThreshold) { //TODO I think this lin
      e has the bug!
                        injectIns(rootALUins->Nth(0));
                //} else {
                //      printf("ERROR: Invalid dependency chanin detected. Aborti
      ng...\n");
                //      exit(-1);
                }
                rootALUins->Nth(0)->setMyPhraseID(phID);
                phList->Nth(phList->NumElements()-1)->addToPhrase_Light(rootALUin
      s->Nth(0));
                outListTemp->Append(rootALUins->Nth(0));
                if (rootALUins->Nth(0)->getType() == ALU) {
                        rootALUins->Nth(0)->setStatus(execute, cycle, 
      ALU_LATENCY-1); //excute state has no meaning here (just an internal setting)
                } else if (rootALUins->Nth(0)->getType() == FPU) {
                        rootALUins->Nth(0)->setStatus(execute, cycle, 
      FPU_LATENCY-1); //excute state has no meaning here (just an internal setting)
                } else if (rootALUins->Nth(0)->getType() == BR) {
                        rootALUins->Nth(0)->setStatus(execute, cycle, 
      ALU_LATENCY-1); //excute state has no meaning here (just an internal setting)
                } else if (rootALUins->Nth(0)->getType() == ASSIGN) {
                        rootALUins->Nth(0)->setStatus(execute, cycle, 
      ASSIGN_LATENCY-1); //excute state has no meaning here (just an internal setting)
                }
                rootALUins->RemoveAt(0);
                if (phList->NumElements() > 4) {
                        if (phList->Nth(0)->isPhraseComplete() == true) {
                                phList->Nth(0)->printToFilePhrase(reScheduleFile)
      ;
                                int size = phList->Nth(0)->getPhraseSize_unsort()
      ;
                                for (int k = size-1; k >= 0; k--) {
                                        if (phList->Nth(0)->getInsList_unsort()->
      Nth(k)->getMissrate() > unpredMemOpThreshold) 
                                                phList->Nth(0)->getInsList_unsort
      ()->Nth(k)->notifyDepICommited();
                                        delete phList->Nth(0)->getInsList_unsort(
      )->Nth(k);
                                        phList->Nth(0)->getInsList_unsort()->Remo
      veAt(k);
                                }
                                delete phList->Nth(0);
                                phList->RemoveAt(0);
                        }
                }
        }
        completeIns (cycle,outListTemp, false);
        if (rootALUins->NumElements() > 220 || rootMEMins->NumElements() > 220)
                return false;
        else
                return true;
}
\end{DoxyCode}
\hypertarget{classvliwScheduler_afd1ec0df4e12e892ef2e1d6cd5a1ad3c}{
\index{vliwScheduler@{vliwScheduler}!setupNewIns@{setupNewIns}}
\index{setupNewIns@{setupNewIns}!vliwScheduler@{vliwScheduler}}
\subsubsection[{setupNewIns}]{\setlength{\rightskip}{0pt plus 5cm}{\bf instruction} $\ast$ vliwScheduler::setupNewIns (
\begin{DoxyParamCaption}
\item[{{\bf instruction} $\ast$}]{ins, }
\item[{int}]{cycle}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_afd1ec0df4e12e892ef2e1d6cd5a1ad3c}

\begin{DoxyCode}
                                                                   {
        instruction* newIns = new instruction;
        newIns->setType(ASSIGN);
        newIns->setInsID(ins->getInsID());
        newIns->setInsAddr(ins->getInsAddr());
        newIns->setPiepelineLat(ASSIGN_LATENCY);
        newIns->setStatus(FETCH, cycle, -1);
        newIns->setStatus(FETCH, cycle, -1);
        newIns->setBrMode(scheduleBr);
        newIns->setReadyLists(rootALUins, rootMEMins);
        newIns->setVliwScheduler(this);
        //Setup Registers
        ins->updateDepTableEntris(depTables, coreType, newIns);
        for (int i = ins->getNumReg()-1; i >= 0; i--) {
                //Transfer write registers
                if (ins->getNthRegType(i) == WRITE) {
                        long int temp1 = ins->getNthReg(i);
                        int temp2 = ins->getNthRegType(i);
                        newIns->setRegister(&temp1, &temp2);
                        ins->removeNthRegister(i);
                }
                //Create register dependency link between ins & newIns 
                int type = WRITE;
                ins->setRegister(&tempReg, &type);
                type = READ;
                newIns->setRegister(&tempReg, &type);
        }
        //Setup Dependencies
        while(ins->getNumBrAncestors() > 0) {
                newIns->setAsAncestor(ins->getNthBrAncestor(0));
                newIns->setAsBrAncestor(ins->getNthBrAncestor(0));
                newIns->addDep();
                ins->getNthBrAncestor(0)->setAsDependent(newIns);
                ins->getNthBrAncestor(0)->delBrDependent(ins);
                ins->getNthBrAncestor(0)->setAsBrDependent(newIns);
                ins->delNthBrAncestor(0);
        }
        ins->notifyDepICommited();
        ins->notifyAllDepICompleted_light();
        while(ins->getDependents()->NumElements() > 0) {
                newIns->setAsDependent(ins->getDependents()->Nth(0));
                ins->getDependents()->Nth(0)->setAsAncestor(newIns);
                ins->getDependents()->Nth(0)->addDep();
                ins->getDependents()->RemoveAt(0);
        }
        if (newIns->isRepeated(ins, newIns->_ancestors) == false) {
                newIns->setAsAncestor(ins);
                newIns->addDep();
        }
        ins->setAsDependent(newIns);
        newIns->findPhraseAncestors();
        newIns->setCmdStr("T, "); //TODO incomplete
        if (newIns->isReady(cycle) == true) newIns->goToReadyList(); //Catch root
       instructions
        tempReg--;
        return newIns;
}
\end{DoxyCode}
\hypertarget{classvliwScheduler_aa7078d3900e7edcb82304e988339d33a}{
\index{vliwScheduler@{vliwScheduler}!sortLists@{sortLists}}
\index{sortLists@{sortLists}!vliwScheduler@{vliwScheduler}}
\subsubsection[{sortLists}]{\setlength{\rightskip}{0pt plus 5cm}void vliwScheduler::sortLists (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{rootALUins, }
\item[{{\bf List}$<$ {\bf instruction} $\ast$ $>$ $\ast$}]{rootMEMins, }
\item[{int}]{cycle, }
\item[{bool}]{UPLDhoisting, }
\item[{long int}]{phraseID}
\end{DoxyParamCaption}
)}}
\label{classvliwScheduler_aa7078d3900e7edcb82304e988339d33a}

\begin{DoxyCode}
                                                                                 
                                                                  {
        quicksortLongestPathDyanmic(rootALUins,0,rootALUins->NumElements()-1,
      cycle, UPLDhoisting);
        //findMostCritIns(rootALUins, cycle, UPLDhoisting); //TODO this line must
       be replaced wth the line above when the 1ALU unit process is done
        findMostCritIns(rootMEMins, cycle, UPLDhoisting);
        //rootSize += rootMEMins->NumElements();

        //printf("\n");
        //for (int i = 0; i < rootALUins->NumElements(); i++)
        //      printf("%d, ",rootALUins->Nth(i)->findLongestPath(rootALUins->Nth
      (i)->getInsID()), UPLDhoisting);
}
\end{DoxyCode}


The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
/home/milad/esc\_\-project/svn/PARS/src/backend/\hyperlink{vliwScheduler_8h}{vliwScheduler.h}\item 
/home/milad/esc\_\-project/svn/PARS/src/backend/\hyperlink{vliwScheduler_8cpp}{vliwScheduler.cpp}\end{DoxyCompactItemize}
