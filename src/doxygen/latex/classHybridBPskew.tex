\hypertarget{classHybridBPskew}{
\section{HybridBPskew Class Reference}
\label{classHybridBPskew}\index{HybridBPskew@{HybridBPskew}}
}


{\ttfamily \#include $<$hybrid\_\-skew.h$>$}

\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct {\bfseries BPHistory}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classHybridBPskew_a039896cdd3566d98247bf7b871766cc9}{HybridBPskew} (unsigned localPredictorSize, unsigned localCtrBits, unsigned globalPredictorSize, unsigned globalHistoryBits, unsigned globalCtrBits, unsigned choicePredictorSize, unsigned choiceCtrBits, unsigned instShiftAmt, unsigned fetchWidth)
\item 
unsigned \hyperlink{classHybridBPskew_ae8b356ac60f229ce92086836420a1d11}{computeLocalIndex} (Addr branch\_\-addr, unsigned positionInFetchGroup)
\item 
unsigned \hyperlink{classHybridBPskew_a2d3c53348902a29d3315dcec78e12a99}{computeGlobalIndex0} (Addr branch\_\-addr, unsigned positionInFetchGroup)
\item 
unsigned \hyperlink{classHybridBPskew_a4009eae987557a103d5846cd32e30333}{computeGlobalIndex1} (Addr branch\_\-addr, unsigned positionInFetchGroup)
\item 
unsigned \hyperlink{classHybridBPskew_a70b7b53463dd2cd4a6394266ea3c2ee3}{computeChoiceIndex} (Addr branch\_\-addr, unsigned positionInFetchGroup)
\item 
bool \hyperlink{classHybridBPskew_a582ad543f9fc90c933eb2c740de572ec}{lookup} (Addr \&branch\_\-addr, void $\ast$\&bp\_\-history, unsigned positionInFetchGroup, bool onDemand, bool \&choice)
\item 
void \hyperlink{classHybridBPskew_a1dbffb30d1d0f0c4c8e6a8f1084e68e4}{uncondBr} (void $\ast$\&bp\_\-history)
\item 
void \hyperlink{classHybridBPskew_ab10e5603326fd6eae8d8cdd106a625ef}{onDemandBr} (Addr \&branch\_\-addr, void $\ast$\&bp\_\-history, unsigned positionInFetchGroup)
\item 
void \hyperlink{classHybridBPskew_a5ceeff1b2e0cc39822346b1cd8fbab80}{BTBUpdate} (Addr \&branch\_\-addr, void $\ast$\&bp\_\-history)
\item 
void \hyperlink{classHybridBPskew_a4fb73465bf70ab821401f3d47e44fc91}{update} (Addr \&branch\_\-addr, bool taken, void $\ast$bp\_\-history, bool squashed)
\item 
void \hyperlink{classHybridBPskew_a5e73e9324e87d820712789f33100e5f4}{histUpdate} (Addr \&branch\_\-addr, bool taken, void $\ast$bp\_\-history, bool squashed)
\item 
void \hyperlink{classHybridBPskew_a4c3aa89615af200ad553461f20de8315}{histGarbageCollect} (void $\ast$bp\_\-history)
\item 
void \hyperlink{classHybridBPskew_a44db53115e8b3ccff2d9b7785c96f380}{squash} (void $\ast$bp\_\-history)
\item 
unsigned \hyperlink{classHybridBPskew_aa00b0494fe8fc804dd6ef9c1abf89c9d}{readGlobalHist} ()
\item 
void \hyperlink{classHybridBPskew_a9c1a201e37cbba10055ff63b9e072a69}{updateGlobalHistTaken} ()
\item 
void \hyperlink{classHybridBPskew_a07095043813d5f59978c0708efa58bd4}{updateGlobalHistNotTaken} ()
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Implements a tournament branch predictor, hopefully identical to the one used in the 21264. It has a local predictor, which uses a local history table to index into a table of counters, and a global predictor, which uses a global history to index into a table of counters. A choice predictor chooses between the two. Only the global history register is speculatively updated, the rest are updated upon branches committing or misspeculating. 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classHybridBPskew_a039896cdd3566d98247bf7b871766cc9}{
\index{HybridBPskew@{HybridBPskew}!HybridBPskew@{HybridBPskew}}
\index{HybridBPskew@{HybridBPskew}!HybridBPskew@{HybridBPskew}}
\subsubsection[{HybridBPskew}]{\setlength{\rightskip}{0pt plus 5cm}HybridBPskew::HybridBPskew (
\begin{DoxyParamCaption}
\item[{unsigned}]{localPredictorSize, }
\item[{unsigned}]{localCtrBits, }
\item[{unsigned}]{globalPredictorSize, }
\item[{unsigned}]{globalHistoryBits, }
\item[{unsigned}]{globalCtrBits, }
\item[{unsigned}]{choicePredictorSize, }
\item[{unsigned}]{choiceCtrBits, }
\item[{unsigned}]{instShiftAmt, }
\item[{unsigned}]{fetchWidth}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_a039896cdd3566d98247bf7b871766cc9}
Default branch predictor constructor. 
\begin{DoxyCode}
    : localPredictorSize(_localPredictorSize),
      localCtrBits(_localCtrBits),
      globalPredictorSize(_globalPredictorSize),
      globalCtrBits(_globalCtrBits),
      globalHistoryBits(_globalHistoryBits),
      choicePredictorSize(_globalPredictorSize),
      choiceCtrBits(_choiceCtrBits),
      instShiftAmt(_instShiftAmt),
      fetchWidth(_fetchWidth)
{
    if (!isPowerOf2(localPredictorSize)) {
        fatal("Invalid local predictor size!\n");
    }

    //Setup the array of counters for the local predictor
    localCtrs.resize(localPredictorSize);

    for (int i = 0; i < localPredictorSize; ++i)
        localCtrs[i].setBits(localCtrBits);

    //localPredictorMask = floorPow2(localPredictorSize) - 1;

    if (!isPowerOf2(globalPredictorSize)) {
        fatal("Invalid global predictor size!\n");
    }

    //Setup the array of counters for the global predictor
    globalCtrs0.resize(globalPredictorSize);
    globalCtrs1.resize(globalPredictorSize);

    for (int i = 0; i < globalPredictorSize; ++i) {
        globalCtrs0[i].setBits(globalCtrBits);
        globalCtrs1[i].setBits(globalCtrBits);
        }

    //Clear the global history
    globalHistory = 0;
    // Setup the global history mask
    globalHistoryMask = (1 << globalHistoryBits) - 1;

    if (!isPowerOf2(choicePredictorSize)) {
        fatal("Invalid choice predictor size!\n");
    }

    //Setup the array of counters for the choice predictor
    choiceCtrs.resize(choicePredictorSize);

    for (int i = 0; i < choicePredictorSize; ++i)
        choiceCtrs[i].setBits(choiceCtrBits);

    // @todo: Allow for different thresholds between the predictors.
    threshold = (1 << (localCtrBits - 1)) - 1;

        //Shift amount is dependent on the fetch width and the instruction size i
      n bytes
        totalInstShiftAmt = instShiftAmt + (unsigned)log2(fetchWidth);

        assert(HIST_SHFT_1 > HIST_SHFT_0);
        assert((unsigned)pow(2,HIST_SHFT_1) < globalPredictorSize);
}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{classHybridBPskew_a5ceeff1b2e0cc39822346b1cd8fbab80}{
\index{HybridBPskew@{HybridBPskew}!BTBUpdate@{BTBUpdate}}
\index{BTBUpdate@{BTBUpdate}!HybridBPskew@{HybridBPskew}}
\subsubsection[{BTBUpdate}]{\setlength{\rightskip}{0pt plus 5cm}void HybridBPskew::BTBUpdate (
\begin{DoxyParamCaption}
\item[{Addr \&}]{branch\_\-addr, }
\item[{void $\ast$\&}]{bp\_\-history}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_a5ceeff1b2e0cc39822346b1cd8fbab80}
Updates the branch predictor to Not Taken if a BTB entry is invalid or not found. 
\begin{DoxyParams}{Parameters}
{\em branch\_\-addr} & The address of the branch to look up. \\
\hline
{\em bp\_\-history} & Pointer to any bp history state. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether or not the branch is taken. 
\end{DoxyReturn}

\begin{DoxyCode}
{
    //Update Global History to Not Taken
    globalHistory = globalHistory & (globalHistoryMask - 1);
}
\end{DoxyCode}
\hypertarget{classHybridBPskew_a70b7b53463dd2cd4a6394266ea3c2ee3}{
\index{HybridBPskew@{HybridBPskew}!computeChoiceIndex@{computeChoiceIndex}}
\index{computeChoiceIndex@{computeChoiceIndex}!HybridBPskew@{HybridBPskew}}
\subsubsection[{computeChoiceIndex}]{\setlength{\rightskip}{0pt plus 5cm}unsigned HybridBPskew::computeChoiceIndex (
\begin{DoxyParamCaption}
\item[{Addr}]{branch\_\-addr, }
\item[{unsigned}]{positionInFetchGroup}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_a70b7b53463dd2cd4a6394266ea3c2ee3}
this unit computes the address index to the BP based on the EV8 predictor Milad 
\begin{DoxyCode}
{
        unsigned indx = ((((branch_addr>>totalInstShiftAmt)^globalHistory)<<instS
      hiftAmt)+(Addr)positionInFetchGroup) 
                                        & (choicePredictorSize-1);
        assert(indx < choicePredictorSize);
        return indx;
}
\end{DoxyCode}
\hypertarget{classHybridBPskew_a2d3c53348902a29d3315dcec78e12a99}{
\index{HybridBPskew@{HybridBPskew}!computeGlobalIndex0@{computeGlobalIndex0}}
\index{computeGlobalIndex0@{computeGlobalIndex0}!HybridBPskew@{HybridBPskew}}
\subsubsection[{computeGlobalIndex0}]{\setlength{\rightskip}{0pt plus 5cm}unsigned HybridBPskew::computeGlobalIndex0 (
\begin{DoxyParamCaption}
\item[{Addr}]{branch\_\-addr, }
\item[{unsigned}]{positionInFetchGroup}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_a2d3c53348902a29d3315dcec78e12a99}
this unit computes the address index to the BP based on the EV8 predictor Milad 
\begin{DoxyCode}
{
        unsigned mask = (0x1 << HIST_SHFT_0) - 1;
        unsigned globalHistory_loBits = (globalHistory & mask) << (globalHistoryB
      its - HIST_SHFT_0);
        unsigned globalHistory_hiBits = globalHistory >> HIST_SHFT_0;
        unsigned globalHistory_shifted = globalHistory_loBits | globalHistory_hiB
      its;
        unsigned indx = ((((branch_addr>>totalInstShiftAmt)^globalHistory_shifted
      )<<instShiftAmt)+(Addr)positionInFetchGroup) 
                                        & (globalPredictorSize-1);
        assert(indx < globalPredictorSize);
        return indx;
}
\end{DoxyCode}
\hypertarget{classHybridBPskew_a4009eae987557a103d5846cd32e30333}{
\index{HybridBPskew@{HybridBPskew}!computeGlobalIndex1@{computeGlobalIndex1}}
\index{computeGlobalIndex1@{computeGlobalIndex1}!HybridBPskew@{HybridBPskew}}
\subsubsection[{computeGlobalIndex1}]{\setlength{\rightskip}{0pt plus 5cm}unsigned HybridBPskew::computeGlobalIndex1 (
\begin{DoxyParamCaption}
\item[{Addr}]{branch\_\-addr, }
\item[{unsigned}]{positionInFetchGroup}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_a4009eae987557a103d5846cd32e30333}

\begin{DoxyCode}
{
        unsigned mask = (0x1 << HIST_SHFT_1) - 1;
        unsigned globalHistory_loBits = (globalHistory & mask) << (globalHistoryB
      its - HIST_SHFT_1);
        unsigned globalHistory_hiBits = globalHistory >> HIST_SHFT_1;
        unsigned globalHistory_shifted = globalHistory_loBits | globalHistory_hiB
      its;
        unsigned indx = ((((branch_addr>>totalInstShiftAmt)^globalHistory_shifted
      )<<instShiftAmt)+(Addr)positionInFetchGroup) 
                                        & (globalPredictorSize-1);
        assert(indx < globalPredictorSize);
        return indx;
}
\end{DoxyCode}
\hypertarget{classHybridBPskew_ae8b356ac60f229ce92086836420a1d11}{
\index{HybridBPskew@{HybridBPskew}!computeLocalIndex@{computeLocalIndex}}
\index{computeLocalIndex@{computeLocalIndex}!HybridBPskew@{HybridBPskew}}
\subsubsection[{computeLocalIndex}]{\setlength{\rightskip}{0pt plus 5cm}unsigned HybridBPskew::computeLocalIndex (
\begin{DoxyParamCaption}
\item[{Addr}]{branch\_\-addr, }
\item[{unsigned}]{positionInFetchGroup}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_ae8b356ac60f229ce92086836420a1d11}
this unit computes the address index to the BP based on the EV8 predictor Milad 
\begin{DoxyCode}
{
        unsigned indx = (((branch_addr>>totalInstShiftAmt)<<instShiftAmt)+(Addr)p
      ositionInFetchGroup) 
                                        & (localPredictorSize-1);
        assert(indx < localPredictorSize);
        return indx;
}
\end{DoxyCode}
\hypertarget{classHybridBPskew_a4c3aa89615af200ad553461f20de8315}{
\index{HybridBPskew@{HybridBPskew}!histGarbageCollect@{histGarbageCollect}}
\index{histGarbageCollect@{histGarbageCollect}!HybridBPskew@{HybridBPskew}}
\subsubsection[{histGarbageCollect}]{\setlength{\rightskip}{0pt plus 5cm}void HybridBPskew::histGarbageCollect (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{bp\_\-history}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_a4c3aa89615af200ad553461f20de8315}

\begin{DoxyCode}
{
    if (bp_history) {
       BPHistory *history = static_cast<BPHistory *>(bp_history);
       // We're done with this history, now delete it.
       delete history;
    }
}
\end{DoxyCode}
\hypertarget{classHybridBPskew_a5e73e9324e87d820712789f33100e5f4}{
\index{HybridBPskew@{HybridBPskew}!histUpdate@{histUpdate}}
\index{histUpdate@{histUpdate}!HybridBPskew@{HybridBPskew}}
\subsubsection[{histUpdate}]{\setlength{\rightskip}{0pt plus 5cm}void HybridBPskew::histUpdate (
\begin{DoxyParamCaption}
\item[{Addr \&}]{branch\_\-addr, }
\item[{bool}]{taken, }
\item[{void $\ast$}]{bp\_\-history, }
\item[{bool}]{squashed}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_a5e73e9324e87d820712789f33100e5f4}

\begin{DoxyCode}
{
    if (bp_history) {
       BPHistory *history = static_cast<BPHistory *>(bp_history);
                if (squashed) {
                        if (taken) {
                                globalHistory = (history->globalHistory << 1) | 1
      ;
                                globalHistory = globalHistory & globalHistoryMask
      ;
                        } else {
                                globalHistory = (history->globalHistory << 1);
                                globalHistory = globalHistory & globalHistoryMask
      ;
                        }
                }
       // We're done with this history, now delete it.
       delete history;
    }
}
\end{DoxyCode}
\hypertarget{classHybridBPskew_a582ad543f9fc90c933eb2c740de572ec}{
\index{HybridBPskew@{HybridBPskew}!lookup@{lookup}}
\index{lookup@{lookup}!HybridBPskew@{HybridBPskew}}
\subsubsection[{lookup}]{\setlength{\rightskip}{0pt plus 5cm}bool HybridBPskew::lookup (
\begin{DoxyParamCaption}
\item[{Addr \&}]{branch\_\-addr, }
\item[{void $\ast$\&}]{bp\_\-history, }
\item[{unsigned}]{positionInFetchGroup, }
\item[{bool}]{onDemand, }
\item[{bool \&}]{choice}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_a582ad543f9fc90c933eb2c740de572ec}
Looks up the given address in the branch predictor and returns a true/false value as to whether it is taken. Also creates a BPHistory object to store any state it will need on squash/update. 
\begin{DoxyParams}{Parameters}
{\em branch\_\-addr} & The address of the branch to look up. \\
\hline
{\em bp\_\-history} & Pointer that will be set to the BPHistory object. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether or not the branch is taken. 
\end{DoxyReturn}

\begin{DoxyCode}
{
    unsigned local_predictor_idx;
    unsigned choice_predictor_idx;

    bool local_prediction;
    bool global_prediction;
    bool choice_prediction;

    BPHistory *history = new BPHistory;

    //Lookup in the local predictor to get its branch prediction
    local_predictor_idx = computeLocalIndex(branch_addr, positionInFetchGroup);
    local_prediction = localCtrs[local_predictor_idx].read() > threshold;

    //Lookup in the global predictor to get its branch prediction
    global_prediction = gSkewPredict(branch_addr, bp_history, positionInFetchGrou
      p, onDemand, choice, history);

    //Lookup in the choice predictor to see which one to use
    choice_predictor_idx = computeChoiceIndex(branch_addr, positionInFetchGroup);
      
    choice_prediction = choiceCtrs[choice_predictor_idx].read() > threshold;

    // Create BPHistory and pass it back to be recorded.
    history->choicePredictorIdx = choice_predictor_idx;
    history->localPredictorIdx  = local_predictor_idx;
    history->globalHistory = globalHistory;
    history->localPredTaken = local_prediction;
    history->globalPredTaken = global_prediction;
    history->globalUsed = choice_prediction;
    bp_history = (void *)history;

    assert(globalHistory < globalPredictorSize);
    assert(positionInFetchGroup >= 0);
    assert(positionInFetchGroup < fetchWidth);
    assert(local_predictor_idx < localPredictorSize);

    // Commented code is for doing speculative update of counters and
    // all histories.
        bool prediction;
    if (choice_prediction) {
        if (global_prediction) {
                        updateGlobalHistTaken();
                        prediction = true;
        } else {
                        updateGlobalHistNotTaken();
                        prediction = false;
        }
    } else {
        if (local_prediction) {
                        updateGlobalHistTaken();
                        prediction = true;
        } else {
                        updateGlobalHistNotTaken();
                        prediction = false;
        }
    }
  //Addr tempPC = ((branch_addr>>totalInstShiftAmt)<<totalInstShiftAmt)+((Addr)po
      w(instShiftAmt,2))*(fetchWidth-1); //Create the addr of last ins in cacheline
  //if (prediction == true) { //TAKEN
  //    updateGlobalHistTaken();
  //} else if (branch_addr == tempPC && prediction == false) {
  //    updateGlobalHistNotTaken();
  //}
    /* testing if local predictor functions right */
        choice = choice_prediction;
    return prediction;
}
\end{DoxyCode}
\hypertarget{classHybridBPskew_ab10e5603326fd6eae8d8cdd106a625ef}{
\index{HybridBPskew@{HybridBPskew}!onDemandBr@{onDemandBr}}
\index{onDemandBr@{onDemandBr}!HybridBPskew@{HybridBPskew}}
\subsubsection[{onDemandBr}]{\setlength{\rightskip}{0pt plus 5cm}void HybridBPskew::onDemandBr (
\begin{DoxyParamCaption}
\item[{Addr \&}]{branch\_\-addr, }
\item[{void $\ast$\&}]{bp\_\-history, }
\item[{unsigned}]{positionInFetchGroup}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_ab10e5603326fd6eae8d8cdd106a625ef}

\begin{DoxyCode}
{
  // Create BPHistory and pass it back to be recorded.
  BPHistory *history = new BPHistory;
  history->globalHistory = globalHistory;
  history->choicePredictorIdx = invalidPredictorIndex; //computeChoiceIndex(branc
      h_addr, positionInFetchGroup);
  history->globalPredictorIdx0 = invalidPredictorIndex; //computeGlobalIndex0(bra
      nch_addr, positionInFetchGroup);
  history->globalPredictorIdx1 = invalidPredictorIndex; //computeGlobalIndex1(bra
      nch_addr, positionInFetchGroup);
  history->localPredictorIdx  = invalidPredictorIndex; //computeLocalIndex(branch
      _addr, positionInFetchGroup);
  bp_history = static_cast<void *>(history);
}
\end{DoxyCode}
\hypertarget{classHybridBPskew_aa00b0494fe8fc804dd6ef9c1abf89c9d}{
\index{HybridBPskew@{HybridBPskew}!readGlobalHist@{readGlobalHist}}
\index{readGlobalHist@{readGlobalHist}!HybridBPskew@{HybridBPskew}}
\subsubsection[{readGlobalHist}]{\setlength{\rightskip}{0pt plus 5cm}unsigned HybridBPskew::readGlobalHist (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{classHybridBPskew_aa00b0494fe8fc804dd6ef9c1abf89c9d}
Returns the global history. 
\begin{DoxyCode}
{ return globalHistory; }
\end{DoxyCode}
\hypertarget{classHybridBPskew_a44db53115e8b3ccff2d9b7785c96f380}{
\index{HybridBPskew@{HybridBPskew}!squash@{squash}}
\index{squash@{squash}!HybridBPskew@{HybridBPskew}}
\subsubsection[{squash}]{\setlength{\rightskip}{0pt plus 5cm}void HybridBPskew::squash (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{bp\_\-history}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_a44db53115e8b3ccff2d9b7785c96f380}
Restores the global branch history on a squash. 
\begin{DoxyParams}{Parameters}
{\em bp\_\-history} & Pointer to the BPHistory object that has the previous global branch history in it. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
{
    BPHistory *history = static_cast<BPHistory *>(bp_history);

    // Restore global history to state prior to this branch.
    globalHistory = history->globalHistory;

    // Delete this BPHistory now that we're done with it.
    delete history;
}
\end{DoxyCode}
\hypertarget{classHybridBPskew_a1dbffb30d1d0f0c4c8e6a8f1084e68e4}{
\index{HybridBPskew@{HybridBPskew}!uncondBr@{uncondBr}}
\index{uncondBr@{uncondBr}!HybridBPskew@{HybridBPskew}}
\subsubsection[{uncondBr}]{\setlength{\rightskip}{0pt plus 5cm}void HybridBPskew::uncondBr (
\begin{DoxyParamCaption}
\item[{void $\ast$\&}]{bp\_\-history}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_a1dbffb30d1d0f0c4c8e6a8f1084e68e4}
Records that there was an unconditional branch, and modifies the bp history to point to an object that has the previous global history stored in it. 
\begin{DoxyParams}{Parameters}
{\em bp\_\-history} & Pointer that will be set to the BPHistory object. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
{
    // Create BPHistory and pass it back to be recorded.
    BPHistory *history = new BPHistory;
    history->globalHistory = globalHistory;
    history->localPredTaken = true;
    history->globalPredTaken = true;
    history->globalUsed = true;
    history->choicePredictorIdx = invalidPredictorIndex; //computeChoiceIndex(bra
      nch_addr, positionInFetchGroup);
    history->globalPredictorIdx0 = invalidPredictorIndex; //computeGlobalIndex0(b
      ranch_addr, positionInFetchGroup);
    history->globalPredictorIdx1 = invalidPredictorIndex; //computeGlobalIndex1(b
      ranch_addr, positionInFetchGroup);
    history->localPredictorIdx  = invalidPredictorIndex; //computeLocalIndex(bran
      ch_addr, positionInFetchGroup);
    bp_history = static_cast<void *>(history);

    updateGlobalHistTaken();
}
\end{DoxyCode}
\hypertarget{classHybridBPskew_a4fb73465bf70ab821401f3d47e44fc91}{
\index{HybridBPskew@{HybridBPskew}!update@{update}}
\index{update@{update}!HybridBPskew@{HybridBPskew}}
\subsubsection[{update}]{\setlength{\rightskip}{0pt plus 5cm}void HybridBPskew::update (
\begin{DoxyParamCaption}
\item[{Addr \&}]{branch\_\-addr, }
\item[{bool}]{taken, }
\item[{void $\ast$}]{bp\_\-history, }
\item[{bool}]{squashed}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_a4fb73465bf70ab821401f3d47e44fc91}
Updates the branch predictor with the actual result of a branch. 
\begin{DoxyParams}{Parameters}
{\em branch\_\-addr} & The address of the branch to update. \\
\hline
{\em taken} & Whether or not the branch was taken. \\
\hline
{\em bp\_\-history} & Pointer to the BPHistory object that was created when the branch was predicted. \\
\hline
{\em squashed} & is set when this function is called during a squash operation. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
{
    // Update the choice predictor to tell it which one was correct if
    // there was a prediction.
    if (bp_history) {
        BPHistory *history = static_cast<BPHistory *>(bp_history);
        bool historyPred = false;
        if (history->globalUsed) {
           historyPred = history->globalPredTaken;
        } else {
           historyPred = history->localPredTaken;
        }
                // Update BP upon commit
                if (!squashed) {
                        // Update the choice predictor to tell it which one was c
      orrect if
                        // there was a prediction.
                        if (history->localPredTaken != history->globalPredTaken) 
      {
                            // If the local prediction matches the actual outcome
      ,
                            // decerement the counter.  Otherwise increment the c
      ounter
                            if (!history->globalUsed && history->choicePredictorI
      dx != invalidPredictorIndex) {
                                choiceCtrs[history->choicePredictorIdx].decrement
      ();
                            } else if (history->globalUsed && history->choicePred
      ictorIdx != invalidPredictorIndex) {
                                choiceCtrs[history->choicePredictorIdx].increment
      ();
                            }
                        }
                        if (!history->globalUsed) {
                           //Strengthen bimodal
                                if (taken) {
                                        if (history->localPredictorIdx != invalid
      PredictorIndex)
                                                localCtrs[history->localPredictor
      Idx].increment();
                                } else {
                                        if (history->localPredictorIdx != invalid
      PredictorIndex)
                                           localCtrs[history->localPredictorIdx].
      decrement();
                                }
                        } else {
                           //Strengthen gskew
                                if (taken) {
                                        if (history->globalPredictorIdx0 != inval
      idPredictorIndex && history->global0used)
                                                globalCtrs0[history->globalPredic
      torIdx0].increment();
                                        if (history->globalPredictorIdx1 != inval
      idPredictorIndex && history->global1used)
                                                globalCtrs1[history->globalPredic
      torIdx1].increment();
                                        if (history->localPredictorIdx != invalid
      PredictorIndex && history->localused)
                                                localCtrs[history->localPredictor
      Idx].increment();
                                } else {
                                        if (history->globalPredictorIdx0 != inval
      idPredictorIndex && history->global0used)
                                                globalCtrs0[history->globalPredic
      torIdx0].decrement();
                                        if (history->globalPredictorIdx1 != inval
      idPredictorIndex && history->global1used)
                                                globalCtrs1[history->globalPredic
      torIdx1].decrement();
                                        if (history->localPredictorIdx != invalid
      PredictorIndex && history->localused)
                                                localCtrs[history->localPredictor
      Idx].decrement();
                                }
                        }
                } else if (squashed && historyPred != taken) { //upon a branch lo
      okup mis-pred - not btb mis-pred
                        if (history->localPredTaken == history->globalPredTaken) 
      {
                                //strengthen all predictors
                                if (taken) {
                                        if (history->globalPredictorIdx0 != inval
      idPredictorIndex)
                                                globalCtrs0[history->globalPredic
      torIdx0].increment();
                                        if (history->globalPredictorIdx1 != inval
      idPredictorIndex)
                                                globalCtrs1[history->globalPredic
      torIdx1].increment();
                                        if (history->localPredictorIdx != invalid
      PredictorIndex)
                                                localCtrs[history->localPredictor
      Idx].increment();
                                } else {
                                        if (history->globalPredictorIdx0 != inval
      idPredictorIndex)
                                                globalCtrs0[history->globalPredic
      torIdx0].decrement();
                                        if (history->globalPredictorIdx1 != inval
      idPredictorIndex)
                                                globalCtrs1[history->globalPredic
      torIdx1].decrement();
                                        if (history->localPredictorIdx != invalid
      PredictorIndex)
                                                localCtrs[history->localPredictor
      Idx].decrement();
                                }
                        } else {
                                // Meta predictor update:
                                // If the local prediction matches the actual out
      come,
                                // decerement the counter.  Otherwise increment t
      he counter
                                if (!history->globalUsed && history->choicePredic
      torIdx != invalidPredictorIndex) {
                                    choiceCtrs[history->choicePredictorIdx].incre
      ment();
                                } else if (history->globalUsed && history->choice
      PredictorIdx != invalidPredictorIndex) {
                                    choiceCtrs[history->choicePredictorIdx].decre
      ment();
                                }
                                if (history->globalUsed) {
                                   //Strengthen bimodal when gskew fails
                                        if (taken) {
                                                if (history->localPredictorIdx !=
       invalidPredictorIndex)
                                                        localCtrs[history->localP
      redictorIdx].increment();
                                        } else {
                                                if (history->localPredictorIdx !=
       invalidPredictorIndex)
                                                   localCtrs[history->localPredic
      torIdx].decrement();
                                        }
                                } else {
                                   //Strengthen gskew when bimodal fails
                                        if (taken) {
                                                if (history->globalPredictorIdx0 
      != invalidPredictorIndex && history->global0used)
                                                        globalCtrs0[history->glob
      alPredictorIdx0].increment();
                                                if (history->globalPredictorIdx1 
      != invalidPredictorIndex && history->global1used)
                                                        globalCtrs1[history->glob
      alPredictorIdx1].increment();
                                                if (history->localPredictorIdx !=
       invalidPredictorIndex && history->localused)
                                                        localCtrs[history->localP
      redictorIdx].increment();
                                        } else {
                                                if (history->globalPredictorIdx0 
      != invalidPredictorIndex && history->global0used)
                                                        globalCtrs0[history->glob
      alPredictorIdx0].decrement();
                                                if (history->globalPredictorIdx1 
      != invalidPredictorIndex && history->global1used)
                                                        globalCtrs1[history->glob
      alPredictorIdx1].decrement();
                                                if (history->localPredictorIdx !=
       invalidPredictorIndex && history->localused)
                                                        localCtrs[history->localP
      redictorIdx].decrement();
                                        }
                                }
                        }
                }
                assert(history->globalPredictorIdx0 < globalPredictorSize &&
                           history->globalPredictorIdx1 < globalPredictorSize &&
                       history->localPredictorIdx < localPredictorSize);
    }
}
\end{DoxyCode}
\hypertarget{classHybridBPskew_a07095043813d5f59978c0708efa58bd4}{
\index{HybridBPskew@{HybridBPskew}!updateGlobalHistNotTaken@{updateGlobalHistNotTaken}}
\index{updateGlobalHistNotTaken@{updateGlobalHistNotTaken}!HybridBPskew@{HybridBPskew}}
\subsubsection[{updateGlobalHistNotTaken}]{\setlength{\rightskip}{0pt plus 5cm}void HybridBPskew::updateGlobalHistNotTaken (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_a07095043813d5f59978c0708efa58bd4}
Updates global history as not taken. 
\begin{DoxyCode}
{
    globalHistory = (globalHistory << 1);
    globalHistory = globalHistory & globalHistoryMask;
}
\end{DoxyCode}
\hypertarget{classHybridBPskew_a9c1a201e37cbba10055ff63b9e072a69}{
\index{HybridBPskew@{HybridBPskew}!updateGlobalHistTaken@{updateGlobalHistTaken}}
\index{updateGlobalHistTaken@{updateGlobalHistTaken}!HybridBPskew@{HybridBPskew}}
\subsubsection[{updateGlobalHistTaken}]{\setlength{\rightskip}{0pt plus 5cm}void HybridBPskew::updateGlobalHistTaken (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classHybridBPskew_a9c1a201e37cbba10055ff63b9e072a69}
Updates global history as taken. 
\begin{DoxyCode}
{
    globalHistory = (globalHistory << 1) | 1;
    globalHistory = globalHistory & globalHistoryMask;
}
\end{DoxyCode}


The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
/home/milad/esc\_\-project/svn/PARS/src/forLater/pred/\hyperlink{hybrid__skew_8h}{hybrid\_\-skew.h}\item 
/home/milad/esc\_\-project/svn/PARS/src/forLater/pred/\hyperlink{hybrid__skew_8cpp}{hybrid\_\-skew.cpp}\end{DoxyCompactItemize}
