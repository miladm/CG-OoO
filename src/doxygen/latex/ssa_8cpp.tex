\hypertarget{ssa_8cpp}{
\section{/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/ssa.cpp File Reference}
\label{ssa_8cpp}\index{/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/ssa.cpp@{/home/milad/esc\_\-project/svn/PARS/src/binaryTranslator/ssa.cpp}}
}
{\ttfamily \#include \char`\"{}ssa.h\char`\"{}}\par
Include dependency graph for ssa.cpp:
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{ssa_8cpp_a27946f3e650b0cd16c36dd3ce519fc1d}{ZERO\_\-ITER}~0
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{ssa_8cpp_a2407eaf38be9d17167c4361072082608}{buildDefUseSets} (\hyperlink{classList}{List}$<$ \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$bbList)
\item 
void \hyperlink{ssa_8cpp_adb27c228bf508415dafc026ebbc822d3}{buildVarList} (\hyperlink{classList}{List}$<$ \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$bbList, map$<$ int, \hyperlink{classvariable}{variable} $\ast$ $>$ \&varList)
\item 
void \hyperlink{ssa_8cpp_a64b325828ea51414e2809f54af3302a2}{phi\_\-func\_\-placement} (\hyperlink{classList}{List}$<$ \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$bbList, map$<$ int, \hyperlink{classvariable}{variable} $\ast$ $>$ \&varList)
\item 
int \hyperlink{ssa_8cpp_ad51f0106de926496f1a6b24bfd21bc32}{whichPred} (\hyperlink{classbasicblock}{basicblock} $\ast$Y, \hyperlink{classbasicblock}{basicblock} $\ast$X)
\item 
void \hyperlink{ssa_8cpp_af9593c92c3c4713e11388054c46aa5e9}{search} (\hyperlink{classbasicblock}{basicblock} $\ast$bb, map$<$ int, \hyperlink{classvariable}{variable} $\ast$ $>$ \&varList)
\item 
void \hyperlink{ssa_8cpp_a804de8f00b7ea9e5487315dc9ff01d77}{ssa\_\-renaming} (\hyperlink{classList}{List}$<$ \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$bbList, map$<$ int, \hyperlink{classvariable}{variable} $\ast$ $>$ \&varList)
\item 
void \hyperlink{ssa_8cpp_a99d7839751286ac78c627aabd383cb51}{build\_\-ssa\_\-form} (\hyperlink{classList}{List}$<$ \hyperlink{classbasicblock}{basicblock} $\ast$ $>$ $\ast$bbList, map$<$ int, \hyperlink{classvariable}{variable} $\ast$ $>$ \&varList)
\end{DoxyCompactItemize}


\subsection{Define Documentation}
\hypertarget{ssa_8cpp_a27946f3e650b0cd16c36dd3ce519fc1d}{
\index{ssa.cpp@{ssa.cpp}!ZERO\_\-ITER@{ZERO\_\-ITER}}
\index{ZERO\_\-ITER@{ZERO\_\-ITER}!ssa.cpp@{ssa.cpp}}
\subsubsection[{ZERO\_\-ITER}]{\setlength{\rightskip}{0pt plus 5cm}\#define ZERO\_\-ITER~0}}
\label{ssa_8cpp_a27946f3e650b0cd16c36dd3ce519fc1d}


\subsection{Function Documentation}
\hypertarget{ssa_8cpp_a99d7839751286ac78c627aabd383cb51}{
\index{ssa.cpp@{ssa.cpp}!build\_\-ssa\_\-form@{build\_\-ssa\_\-form}}
\index{build\_\-ssa\_\-form@{build\_\-ssa\_\-form}!ssa.cpp@{ssa.cpp}}
\subsubsection[{build\_\-ssa\_\-form}]{\setlength{\rightskip}{0pt plus 5cm}void build\_\-ssa\_\-form (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf basicblock} $\ast$ $>$ $\ast$}]{bbList, }
\item[{map$<$ int, {\bf variable} $\ast$ $>$ \&}]{varList}
\end{DoxyParamCaption}
)}}
\label{ssa_8cpp_a99d7839751286ac78c627aabd383cb51}

\begin{DoxyCode}
                                                                             {
        printf ("\tBuild Def-Use Sets\n");
        buildDefUseSets (bbList);
        printf ("\tBuild Variable Def Lists From DefSets\n");
        buildVarList (bbList,varList);
        printf ("\tBuild Phi-Funcations\n");
        phi_func_placement (bbList, varList);
        printf ("\tRun SSA Renaming\n");
        ssa_renaming (bbList, varList);
        printf ("\tDistroy VarList\n");
        for (map<int,variable*>::iterator it = varList.begin (); it != varList.en
      d (); it++) {
                delete it->second;
        }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{ssa_8cpp_a2407eaf38be9d17167c4361072082608}{
\index{ssa.cpp@{ssa.cpp}!buildDefUseSets@{buildDefUseSets}}
\index{buildDefUseSets@{buildDefUseSets}!ssa.cpp@{ssa.cpp}}
\subsubsection[{buildDefUseSets}]{\setlength{\rightskip}{0pt plus 5cm}void buildDefUseSets (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf basicblock} $\ast$ $>$ $\ast$}]{bbList}
\end{DoxyParamCaption}
)}}
\label{ssa_8cpp_a2407eaf38be9d17167c4361072082608}

\begin{DoxyCode}
                                                 {
        for (int i =0 ; i < bbList->NumElements (); i++)
                bbList->Nth (i)->setupDefUseSets ();
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{ssa_8cpp_adb27c228bf508415dafc026ebbc822d3}{
\index{ssa.cpp@{ssa.cpp}!buildVarList@{buildVarList}}
\index{buildVarList@{buildVarList}!ssa.cpp@{ssa.cpp}}
\subsubsection[{buildVarList}]{\setlength{\rightskip}{0pt plus 5cm}void buildVarList (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf basicblock} $\ast$ $>$ $\ast$}]{bbList, }
\item[{map$<$ int, {\bf variable} $\ast$ $>$ \&}]{varList}
\end{DoxyParamCaption}
)}}
\label{ssa_8cpp_adb27c228bf508415dafc026ebbc822d3}

\begin{DoxyCode}
                                                                           {
        /* BUILD THE VARIABLES LIST FOR X86 REGISTERS */
        for (long int i = X86_REG_LO; i <= X86_REG_HI; i++) {
                variable *var = new variable (i);
                varList.insert (pair<int,variable*> (i,var));
        }
        for (int i = 0; i < bbList->NumElements (); i++) {
                basicblock* bb = bbList->Nth (i);
                set<long int> defSet = bb->getDefSet (); //NOTE: some variables a
      re "somehow" never defined in x86!
        set<long int>::iterator it;
                for (it = defSet.begin (); it != defSet.end (); it++) {
                        Assert ((*it) >= X86_REG_LO && (*it) <= X86_REG_HI && "In
      valid x86 variable.");
                        int varIndx = *it;
                        varList[varIndx]->addBB (bb);
                }
                #ifdef DEBUG_SSA
                printf ("def set: %d\n",defSet.size ());
                #endif
        }
        // Stat on x86 reg definitions in a program.
        // for (map<int,variable*>::iterator it = varList.begin (); it != varList
      .end (); it++) {
                // printf ("%d\n", it->second->getNumAssignedBB ());
        // }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{ssa_8cpp_a64b325828ea51414e2809f54af3302a2}{
\index{ssa.cpp@{ssa.cpp}!phi\_\-func\_\-placement@{phi\_\-func\_\-placement}}
\index{phi\_\-func\_\-placement@{phi\_\-func\_\-placement}!ssa.cpp@{ssa.cpp}}
\subsubsection[{phi\_\-func\_\-placement}]{\setlength{\rightskip}{0pt plus 5cm}void phi\_\-func\_\-placement (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf basicblock} $\ast$ $>$ $\ast$}]{bbList, }
\item[{map$<$ int, {\bf variable} $\ast$ $>$ \&}]{varList}
\end{DoxyParamCaption}
)}}
\label{ssa_8cpp_a64b325828ea51414e2809f54af3302a2}

\begin{DoxyCode}
                                                                                 
      {
        map<ADDR,int> hasAlready, work;
        map<ADDR,basicblock*> W;
        for (int i = 0; i < bbList->NumElements (); i++) {
                basicblock *bb = bbList->Nth (i);
                hasAlready.insert (pair<ADDR,int> (bb->getID (),ZERO_ITER));
                work.insert (pair<ADDR,int> (bb->getID (),ZERO_ITER));
        }
        int iterCount = 0;
    map<int,variable*>::iterator it;
        for (it = varList.begin (); it != varList.end (); it++) {
                iterCount++;
                variable *var = it->second;
                for (int j = 0; j < var->getNumAssignedBB (); j++) {
                        basicblock *bb = var->getNthAssignedBB (j);
                        work[bb->getID ()] = iterCount;
                        W.insert (pair<ADDR,basicblock*> (bb->getID (),bb));
                }
                while (W.size () != 0) {
                        basicblock* X = (W.begin ())->second;
                        W.erase (W.begin ());
                        map<ADDR,basicblock*> xDF = X->getDF ();
            map<ADDR,basicblock*>::iterator Y;
                        for (Y = xDF.begin (); Y != xDF.end (); Y++) {
                                if (hasAlready[Y->first] < iterCount) {
                                        (Y->second)->insertPhiFunc (var->getID ()
      );
                                        hasAlready[Y->first] = iterCount;
                                        if (work[Y->first] < iterCount) {
                                                work[Y->first] = iterCount;
                                                W.insert (pair<ADDR,basicblock*> 
      ((Y->second)->getID (),Y->second));
                                        }
                                }
                        }
                }
        }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{ssa_8cpp_af9593c92c3c4713e11388054c46aa5e9}{
\index{ssa.cpp@{ssa.cpp}!search@{search}}
\index{search@{search}!ssa.cpp@{ssa.cpp}}
\subsubsection[{search}]{\setlength{\rightskip}{0pt plus 5cm}void search (
\begin{DoxyParamCaption}
\item[{{\bf basicblock} $\ast$}]{bb, }
\item[{map$<$ int, {\bf variable} $\ast$ $>$ \&}]{varList}
\end{DoxyParamCaption}
)}}
\label{ssa_8cpp_af9593c92c3c4713e11388054c46aa5e9}

\begin{DoxyCode}
                                                          {
    Assert (!bb->isVisited () && "An attempt to revisit a block in SSA");
    bb->setAsVisited ();

    List<instruction*> *insList = bb->getInsList ();
    map<int, int> hackPushes;
    map<long int, vector<long int> > phiFuncs = bb->getPhiFuncs ();

    /* ASSIGN DESTINATION SSA REGISTER TO PHI-FUNCTIONS */
    map<long int, vector<long int> >::iterator phiFunc;
    for (phiFunc = phiFuncs.begin (); phiFunc != phiFuncs.end (); phiFunc++) {
        int var = phiFunc->first;
        Assert (var <= X86_REG_HI && var >= X86_REG_LO && "Invalid register value
      ");
        int k = varList[var]->getC ();
        bb->setPhiWriteVar (var, k);
        varList[var]->pushToStack (k);
        varList[var]->setC (k + 1);
    }

    /* ASSIGN SSA REGISTERS TO REGULAR INSTRUCTIONS */
    for (int i = 0; i < insList->NumElements (); i++) {
        instruction *ins = insList->Nth (i);
        for (int j = 0; j < ins->getNumReg (); j++) {
            if (ins->getNthRegType (j) == READ) {
                int var = ins->getNthReg (j);
                Assert (var <= X86_REG_HI && var >= X86_REG_LO && "Invalid regist
      er value");
                int v1 = varList[var]->_hackPushCount;
                int subscript = varList[var]->getTopStack ();
                if (varList[var]->_hackPushCount - v1 == 1) {
                    if (hackPushes.find (var) == hackPushes.end ()) 
                        hackPushes.insert(pair<int, int> (var, 1));
                    else 
                        hackPushes[var]++;
                }
                ins->setReadVar (var, subscript);
            }
        }
        for (int j = 0; j < ins->getNumReg (); j++) {
            if (ins->getNthRegType (j) == WRITE) {
                int var = ins->getNthReg (j);
                Assert (var <= X86_REG_HI && var >= X86_REG_LO && "Invalid regist
      er value");
                int k = varList[var]->getC ();
                ins->setWriteVar (var, k);
                varList[var]->pushToStack (k);
                varList[var]->setC (k + 1);
            }
        }
    }

    /*--
     * SET SSA VALUES OF EACH VARIABLE FROM this BB TO EACH OF ITS
     * DESCENDENTS (RHS of PHI-FUNCTION). WE WANT TO HAVE AS MANY ELEMENET
     * IN TEH PHI-VECTOR AS THE NUMBER OF ANCESTORS OF THE BB. THEN EVERY
     * ANCESTOR MUST COME AND FILL IN THE HOLE
     --*/
    for (int i = 0; i < bb->getNumDescendents (); i++) {
        basicblock* Y = bb->getNthDescendent (i);
        int j = whichPred (Y, bb);
        map<long int, vector<long int> > phiFuncs = Y->getPhiFuncs ();
        for (phiFunc = phiFuncs.begin (); phiFunc != phiFuncs.end (); phiFunc++) 
      {
            int var = phiFunc->first;
            Assert (var <= X86_REG_HI && var >= X86_REG_LO && "Invalid register v
      alue");
            int v1 = varList[var]->_hackPushCount;
            int subscript = varList[var]->getTopStack ();
            if (varList[var]->_hackPushCount - v1 == 1) {
                if (hackPushes.find (var) == hackPushes.end ()) 
                    hackPushes.insert(pair<int, int> (var, 1));
                else 
                    hackPushes[var]++;
            }
            Y->replaceNthPhiOperand (var, j, subscript); //TODO correct?
        }
    }

    /* SEARCH EVERY CHILD OF this BB IN THE DOMINATOR TREE */
    map<ADDR,basicblock*> children = bb->getChildren ();
    map<ADDR,basicblock*>::iterator child;
    for (child = children.begin (); child != children.end (); child++) {
        basicblock* Y = child->second;
        search (Y, varList);
    }

    /* CLEAN THE STACKES THAT HAD A DEFINITION DONE BY this BB */
    for (int i = 0; i < insList->NumElements (); i++) {
        instruction *ins = insList->Nth (i);
        for (int j = 0; j < ins->getNumReg (); j++) {
            if (ins->getNthRegType (j) == WRITE) {
                int var = ins->getNthReg (j);
                Assert (var <= X86_REG_HI && var >= X86_REG_LO && "Invalid regist
      er value");
                varList[var]->popFromStack ();
            }
        }
        /* THIS IS ANOTHER PART OF THE STACK HACK */
        for (int j = 0; j < ins->getNumReg (); j++) {
            if (ins->getNthRegType (j) == READ) {
                int var = ins->getNthReg (j);
                Assert (varList.find (var) != varList.end ());
                if (hackPushes.find (var) != hackPushes.end ()) {
                    varList[var]->popHackPushes (hackPushes[var]);
                    hackPushes.erase (var);
                }
            }
        }
    }
    for (phiFunc = phiFuncs.begin (); phiFunc != phiFuncs.end (); phiFunc++) {
        int var = phiFunc->first;
        Assert (var <= X86_REG_HI && var >= X86_REG_LO && "Invalid register value
      ");
        varList[var]->popFromStack ();
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{ssa_8cpp_a804de8f00b7ea9e5487315dc9ff01d77}{
\index{ssa.cpp@{ssa.cpp}!ssa\_\-renaming@{ssa\_\-renaming}}
\index{ssa\_\-renaming@{ssa\_\-renaming}!ssa.cpp@{ssa.cpp}}
\subsubsection[{ssa\_\-renaming}]{\setlength{\rightskip}{0pt plus 5cm}void ssa\_\-renaming (
\begin{DoxyParamCaption}
\item[{{\bf List}$<$ {\bf basicblock} $\ast$ $>$ $\ast$}]{bbList, }
\item[{map$<$ int, {\bf variable} $\ast$ $>$ \&}]{varList}
\end{DoxyParamCaption}
)}}
\label{ssa_8cpp_a804de8f00b7ea9e5487315dc9ff01d77}

\begin{DoxyCode}
                                                                           {
        List<basicblock*> *interiorBB = new List<basicblock*>;
        findDomEntryPoints (bbList, interiorBB);
        for (int i = 0; i < bbList->NumElements (); i++)
                bbList->Nth (i)->setAsUnvisited ();
        for (int i = 0; i < interiorBB->NumElements (); i++) {
                basicblock* bbHead = interiorBB->Nth (i);
                search (bbHead, varList);
        }
        for (int i = 0; i < bbList->NumElements (); i++) {
                if (!bbList->Nth (i)->isVisited ()) 
            printf ("Unvisited BB ID: %llx,%d,%d\n", bbList->Nth (i)->getID (), 
                                                     bbList->Nth (i)->getNumAnces
      tors (), 
                                                     bbList->Nth (i)->numNonBackE
      dgeAncestors ());
                bbList->Nth (i)->setAsUnvisited ();
        }
    delete interiorBB;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{ssa_8cpp_ad51f0106de926496f1a6b24bfd21bc32}{
\index{ssa.cpp@{ssa.cpp}!whichPred@{whichPred}}
\index{whichPred@{whichPred}!ssa.cpp@{ssa.cpp}}
\subsubsection[{whichPred}]{\setlength{\rightskip}{0pt plus 5cm}int whichPred (
\begin{DoxyParamCaption}
\item[{{\bf basicblock} $\ast$}]{Y, }
\item[{{\bf basicblock} $\ast$}]{X}
\end{DoxyParamCaption}
)}}
\label{ssa_8cpp_ad51f0106de926496f1a6b24bfd21bc32}

\begin{DoxyCode}
                                             {
        ADDR bbID = X->getID ();
        for (int i = 0; i < Y->getNumAncestors (); i++) {
                if (Y->getNthAncestor (i)->getID () == bbID)
                        return i;
        }
        Assert (0 && "CFG Fault. The BB ancesor was not found.");
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


