\hypertarget{cacheCtrl_8h}{
\section{/home/milad/esc\_\-project/svn/PARS/src/backend/cacheCtrl.h File Reference}
\label{cacheCtrl_8h}\index{/home/milad/esc\_\-project/svn/PARS/src/backend/cacheCtrl.h@{/home/milad/esc\_\-project/svn/PARS/src/backend/cacheCtrl.h}}
}
{\ttfamily \#include $<$stdint.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include \char`\"{}cache.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}latency.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}instruction.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}../global/global.h\char`\"{}}\par
Include dependency graph for cacheCtrl.h:
This graph shows which files directly or indirectly include this file:
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{cacheCtrl_8h_a7c2452ed16a72831698606002127800d}{getLatency} (int memCode)
\item 
void \hyperlink{cacheCtrl_8h_a9d3abaa15043f5ead167e4d73bfcfb8b}{writeUp} (int memCode1, int memCode2, \hyperlink{global_2global_8h_a7ea74bb9ffd2e4d41550ae2383dd25bc}{ADDRS} addr, int $\ast$\&latency, int8\_\-t $\ast$\&data, char \hyperlink{binaryTranslator_2global_8h_a7aead736a07eaf25623ad7bfa1f0ee2d}{type}, \hyperlink{binaryTranslator_2global_8h_a94b8423a23b95a7adac22848b81e7c0c}{memType} rORw)
\item 
void \hyperlink{cacheCtrl_8h_a3c95fb18f45bc2704ececadb8e7a3200}{writeBack} (int memCode1, int memCode2, \hyperlink{global_2global_8h_a7ea74bb9ffd2e4d41550ae2383dd25bc}{ADDRS} addr, int $\ast$\&latency, \hyperlink{binaryTranslator_2global_8h_a94b8423a23b95a7adac22848b81e7c0c}{memType} rORw)
\item 
int \hyperlink{cacheCtrl_8h_aca22aa31c1e2231d94dea96de677955a}{doRead} (\hyperlink{classcache}{cache} $\ast$L, \hyperlink{global_2global_8h_a7ea74bb9ffd2e4d41550ae2383dd25bc}{ADDRS} addr, int8\_\-t $\ast$\&data, int $\ast$\&latency, int memCode, char \hyperlink{binaryTranslator_2global_8h_a7aead736a07eaf25623ad7bfa1f0ee2d}{type}, \hyperlink{binaryTranslator_2global_8h_a94b8423a23b95a7adac22848b81e7c0c}{memType} rORw)
\item 
int \hyperlink{cacheCtrl_8h_a940d1bcbe86e71d64bd1eede69d55324}{doWrite} (\hyperlink{classcache}{cache} $\ast$L, \hyperlink{global_2global_8h_a7ea74bb9ffd2e4d41550ae2383dd25bc}{ADDRS} addr, int8\_\-t $\ast$\&data, int $\ast$\&latency, int memCode, \hyperlink{binaryTranslator_2global_8h_a94b8423a23b95a7adac22848b81e7c0c}{memType} rORw)
\item 
void \hyperlink{cacheCtrl_8h_ad486f7e0df47675ca2833eff41afcff5}{report} (\hyperlink{global_2global_8h_a7ea74bb9ffd2e4d41550ae2383dd25bc}{ADDRS} addr, int8\_\-t $\ast$\&data, int $\ast$\&latency, \hyperlink{binaryTranslator_2global_8h_a94b8423a23b95a7adac22848b81e7c0c}{memType} rORw)
\item 
int \hyperlink{cacheCtrl_8h_a647b95d4a9cb0f09d95d2adfaf25e1d7}{cacheCtrl} (\hyperlink{binaryTranslator_2global_8h_a94b8423a23b95a7adac22848b81e7c0c}{memType} rORw, \hyperlink{global_2global_8h_a7ea74bb9ffd2e4d41550ae2383dd25bc}{ADDRS} addr, \hyperlink{global_2global_8h_a430d9e51ff815ddfce06905ae7392e83}{BYTES} memAxesSize, \hyperlink{classcache}{cache} $\ast$\hyperlink{bkEnd_8cpp_aff6a511d0f79b17fa32081abfd2b5bc6}{\_\-L1}, \hyperlink{classcache}{cache} $\ast$\hyperlink{bkEnd_8cpp_a36621f4e017586bf3fd070b443755da2}{\_\-L2}, \hyperlink{classcache}{cache} $\ast$\hyperlink{bkEnd_8cpp_ad3c630a534ba16b1ffdc565033ad36ee}{\_\-L3})
\item 
void \hyperlink{cacheCtrl_8h_aec17348ba267b0d7d1034650bd6b3d15}{initCaches} ()
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{cacheCtrl_8h_a647b95d4a9cb0f09d95d2adfaf25e1d7}{
\index{cacheCtrl.h@{cacheCtrl.h}!cacheCtrl@{cacheCtrl}}
\index{cacheCtrl@{cacheCtrl}!cacheCtrl.h@{cacheCtrl.h}}
\subsubsection[{cacheCtrl}]{\setlength{\rightskip}{0pt plus 5cm}int cacheCtrl (
\begin{DoxyParamCaption}
\item[{{\bf memType}}]{rORw, }
\item[{{\bf ADDRS}}]{addr, }
\item[{{\bf BYTES}}]{memAxesSize, }
\item[{{\bf cache} $\ast$}]{\_\-L1, }
\item[{{\bf cache} $\ast$}]{\_\-L2, }
\item[{{\bf cache} $\ast$}]{\_\-L3}
\end{DoxyParamCaption}
)}}
\label{cacheCtrl_8h_a647b95d4a9cb0f09d95d2adfaf25e1d7}

\begin{DoxyCode}
{
    int* latency = new int;
        L1 = _L1;
        L2 = _L2;
        L3 = _L3;
        // initialize random seed
        srand ( time(NULL) );

        //Generate Random Data (TODO: this should be removed)
        int8_t *data = (int8_t *) malloc(sizeof(int8_t)*8);
        int8_t *inData = (int8_t *) malloc(sizeof(int8_t)*8);
        //for (int i = 0; i < 8; i++) {inData[i] = 0;}
        
        //printf("cache address = %x\n", &L2);

        /*----Handle READS & WRITES----*/
        if (rORw == READ) { //Handle READ
            //printf("----READ: addr = %x\n", addr);
            hitLevel = 1;
            doRead(L1, addr, data, latency, 1, 'R', rORw);
            //return getLatency(hitLevel);
            //if (lineNum >= 71272839)
            //    fprintf(outFile, "%d,%lx\n", getLatency(hitLevel), addr);
        } else if (rORw == WRITE) { //Handle WRITE
            //printf("----WRITE: addr = %x\n", addr);
            hitLevel = 1;
            doWrite(L1, addr, inData, latency, 1, rORw);
            hitLevel = 1;//Hack to make write always a hit!
            //return getLatency(hitLevel);
            //if (lineNum >= 71272839)
            //    fprintf(outFile, "%d,%lx\n", getLatency(hitLevel), addr);
        } else {
            printf("WARNING: the memory access type is not specified\n");
            return -1;
        }

        delete [] data;
        delete [] inData;
    delete latency;
        if(hitLevel == 0) printf("ERROR: hit level is 0\n");
        Assert (hitLevel != 0);
        if (debug1) printf("***********DONE MEM OP****************\n");
        return  getLatency(hitLevel, 0);
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{cacheCtrl_8h_aca22aa31c1e2231d94dea96de677955a}{
\index{cacheCtrl.h@{cacheCtrl.h}!doRead@{doRead}}
\index{doRead@{doRead}!cacheCtrl.h@{cacheCtrl.h}}
\subsubsection[{doRead}]{\setlength{\rightskip}{0pt plus 5cm}int doRead (
\begin{DoxyParamCaption}
\item[{{\bf cache} $\ast$}]{L, }
\item[{{\bf ADDRS}}]{addr, }
\item[{int8\_\-t $\ast$\&}]{data, }
\item[{int $\ast$\&}]{latency, }
\item[{int}]{memCode, }
\item[{char}]{type, }
\item[{{\bf memType}}]{rORw}
\end{DoxyParamCaption}
)}}
\label{cacheCtrl_8h_aca22aa31c1e2231d94dea96de677955a}

\begin{DoxyCode}
{
        //if(memCode > hitLevel) hitLevel = memCode;
        if(debug1) printf("Onto Reading L%d - ADDRS=%llx\n", memCode,addr); 
        if (memCode <= 3) {
                if (L->isValid(addr)) {
                        if (L->isHit(addr)) {
                                if(debug1) printf("   R, V, H\n");
                                if(memCode > hitLevel && rORw == READ) hitLevel =
       memCode;
                                L->readCache(addr, data);
                                return 0; //Cache Hit
                        } else {
                                if(L->isDirty(addr)) {
                                        if(debug1) printf("   R, V, M, D\n");
                                        //if(debug1) printf("   ** why dirty: %x\
      n", L->getTag(addr)); //TODO getTag must go back to being provate...
                                        if (type == 'W') printf("      ADDRESSSSS
      SSS %llx\n", addr);
                                        writeBack(memCode, memCode+1, addr, laten
      cy, rORw);
                                        if (type == 'R') {writeUp(memCode, memCod
      e+1, addr, latency, data, rORw);}
                                } else {
                                        if(debug1) printf("   R, V, M, C\n");
                                        writeUp(memCode, memCode+1, addr, latency
      , data, rORw);
                                }
                                L->readCache(addr, data);
                                return 0; //Cache miss (conflict) - check for dir
      tiness
                        }
                } else {
                        if(debug1) printf("   R, I\n");
                        writeUp(memCode, memCode+1, addr, latency, data, rORw);
                        if (memCode == 1) L->readCache(addr, data);
                        return 0; //Cache miss (compulsary) (fetch-> read)
                }
        } else {
                if(memCode > hitLevel && rORw == READ) hitLevel = memCode; //TODO
       can a write ever make it here?
                //We don't care about the number from DRAM. So gen a rand val
                if(debug1) printf("   R, L4\n");
                if(debug1) printf("   Data to Write: ");
                //for (int i = 0; i < 8; i++)
                //{
                //    data[i] = rand() % 100 + 1;
                //    if(debug1) printf("%d ", data[i]);
                //}
                if(debug1) printf("\n");
        }
        return 0;
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{cacheCtrl_8h_a940d1bcbe86e71d64bd1eede69d55324}{
\index{cacheCtrl.h@{cacheCtrl.h}!doWrite@{doWrite}}
\index{doWrite@{doWrite}!cacheCtrl.h@{cacheCtrl.h}}
\subsubsection[{doWrite}]{\setlength{\rightskip}{0pt plus 5cm}int doWrite (
\begin{DoxyParamCaption}
\item[{{\bf cache} $\ast$}]{L, }
\item[{{\bf ADDRS}}]{addr, }
\item[{int8\_\-t $\ast$\&}]{data, }
\item[{int $\ast$\&}]{latency, }
\item[{int}]{memCode, }
\item[{{\bf memType}}]{rORw}
\end{DoxyParamCaption}
)}}
\label{cacheCtrl_8h_a940d1bcbe86e71d64bd1eede69d55324}

\begin{DoxyCode}
{
        //if(memCode > hitLevel) hitLevel = memCode;
        if(debug1) printf("Onto Writing L%d - ADDRS=%llx\n", memCode, addr); 
        if (memCode <= 3) {
                if (L->isValid(addr)) {
                        if (L->isHit(addr)) {
                                if(debug1) printf("   W, V, H\n");
                                L->writeCache(addr, data);
                                return 0; //Cache Hit (no care for dirty flag)
                        } else {
                                //int8_t *inData = (int8_t *) malloc(sizeof(int8_
      t)*8);
                                //for (int i = 0; i < 8; i++) {inData[i] = data[i
      ];}
                                if (L->isDirty(addr)) {
                                        if(debug1) printf("   W, V, M, D\n");
                                        if(debug1) printf("   ** why dirty: %llx\
      n", L->getTag(addr));
                                        writeBack(memCode, memCode+1, addr, laten
      cy, rORw);
                                        writeUp(memCode, memCode+1, addr, latency
      , data, rORw); //TODO fix? need it?
                                        //Cache Miss (writeback -> fetch -> write
      )
                                        L->writeCache(addr, data);
                                } else {
                                        if(debug1) printf("   W, V, M, C\n");
                                        if (L->getExpectData(addr) == false) {
                                                L->setExpectData(addr,true);
                                                writeUp(memCode, memCode+1, addr,
       latency, data, rORw);
                                                L->setExpectData(addr,false);
                                                L->writeCache(addr, data);
                                        } else {
                                                L->writeCache(addr, data);
                                        }
                                        //Cache Miss (fetch -> write)
                                }
                                return 0;
                        }
                } else {
                        if(debug1) printf("   W, I\n");
                                        //writeUp(memCode, memCode+1, addr, laten
      cy, data, rORw); //TODO: should not need it
                        if (L->getExpectData(addr) == false) {
                                L->setExpectData(addr,true);
                                writeUp(memCode, memCode+1, addr, latency, data, 
      rORw);
                                L->setExpectData(addr,false);
                                L->writeCache(addr, data);
                        } else {
                                L->writeCache(addr, data);
                        }
                        return 0; //Cache Miss (fetch -> write)
                }
        } else {
                if(debug1) printf("   W, L4\n");
                return 0;
        }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{cacheCtrl_8h_a7c2452ed16a72831698606002127800d}{
\index{cacheCtrl.h@{cacheCtrl.h}!getLatency@{getLatency}}
\index{getLatency@{getLatency}!cacheCtrl.h@{cacheCtrl.h}}
\subsubsection[{getLatency}]{\setlength{\rightskip}{0pt plus 5cm}int getLatency (
\begin{DoxyParamCaption}
\item[{int}]{memCode}
\end{DoxyParamCaption}
)}}
\label{cacheCtrl_8h_a7c2452ed16a72831698606002127800d}


Here is the caller graph for this function:


\hypertarget{cacheCtrl_8h_aec17348ba267b0d7d1034650bd6b3d15}{
\index{cacheCtrl.h@{cacheCtrl.h}!initCaches@{initCaches}}
\index{initCaches@{initCaches}!cacheCtrl.h@{cacheCtrl.h}}
\subsubsection[{initCaches}]{\setlength{\rightskip}{0pt plus 5cm}void initCaches (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{cacheCtrl_8h_aec17348ba267b0d7d1034650bd6b3d15}
\hypertarget{cacheCtrl_8h_ad486f7e0df47675ca2833eff41afcff5}{
\index{cacheCtrl.h@{cacheCtrl.h}!report@{report}}
\index{report@{report}!cacheCtrl.h@{cacheCtrl.h}}
\subsubsection[{report}]{\setlength{\rightskip}{0pt plus 5cm}void report (
\begin{DoxyParamCaption}
\item[{{\bf ADDRS}}]{addr, }
\item[{int8\_\-t $\ast$\&}]{data, }
\item[{int $\ast$\&}]{latency, }
\item[{{\bf memType}}]{rORw}
\end{DoxyParamCaption}
)}}
\label{cacheCtrl_8h_ad486f7e0df47675ca2833eff41afcff5}

\begin{DoxyCode}
{}
\end{DoxyCode}
\hypertarget{cacheCtrl_8h_a3c95fb18f45bc2704ececadb8e7a3200}{
\index{cacheCtrl.h@{cacheCtrl.h}!writeBack@{writeBack}}
\index{writeBack@{writeBack}!cacheCtrl.h@{cacheCtrl.h}}
\subsubsection[{writeBack}]{\setlength{\rightskip}{0pt plus 5cm}void writeBack (
\begin{DoxyParamCaption}
\item[{int}]{memCode1, }
\item[{int}]{memCode2, }
\item[{{\bf ADDRS}}]{addr, }
\item[{int $\ast$\&}]{latency, }
\item[{{\bf memType}}]{rORw}
\end{DoxyParamCaption}
)}}
\label{cacheCtrl_8h_a3c95fb18f45bc2704ececadb8e7a3200}

\begin{DoxyCode}
                                                                                 
         {
        int8_t *tempData = (int8_t *) malloc(sizeof(int8_t)*8);

        if (memCode1 == 1 && memCode2 == 2) {
                ADDRS tempAddr = L1->getWBAddr(addr);
                if(debug1) printf("   WB, memcCode:%d - ADDRS:%llx\n", memCode1, 
      addr);
                doRead (L1, tempAddr, tempData, latency, 1, 'W', rORw);
                doWrite (L2, tempAddr, tempData, latency, 2, rORw);
                L1->setClean(addr); //reset the dirty flag
                delete [] tempData;
        } else if (memCode1 == 2 && memCode2 == 3) {
                ADDRS tempAddr = L2->getWBAddr(addr);
                if(debug1) printf("   WB, memcCode:%d\n", memCode1);
                doRead (L2, tempAddr, tempData, latency, 2, 'W', rORw);
                doWrite (L3, tempAddr, tempData, latency, 3, rORw);
                L2->setClean(addr); //reset the dirty flag
                delete [] tempData;
        } else if (memCode1 == 3 && memCode2 == 4) {
                //ADDRS tempAddr = L3->getWBAddr(addr);
                if(debug1) printf("   WB, memcCode:%d\n", memCode1);
                //Skip actually writing into the memory (to avoid crazy mem. cons
      umption)
                //doRead (L2, tempAddr, tempData, latency, 2, 'W', rORw);
                //doWrite (L3, tempAddr, tempData, latency, 3, rORw);
                L3->setClean(addr); //reset the dirty flag
                delete [] tempData;
        }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{cacheCtrl_8h_a9d3abaa15043f5ead167e4d73bfcfb8b}{
\index{cacheCtrl.h@{cacheCtrl.h}!writeUp@{writeUp}}
\index{writeUp@{writeUp}!cacheCtrl.h@{cacheCtrl.h}}
\subsubsection[{writeUp}]{\setlength{\rightskip}{0pt plus 5cm}void writeUp (
\begin{DoxyParamCaption}
\item[{int}]{memCode1, }
\item[{int}]{memCode2, }
\item[{{\bf ADDRS}}]{addr, }
\item[{int $\ast$\&}]{latency, }
\item[{int8\_\-t $\ast$\&}]{data, }
\item[{char}]{type, }
\item[{{\bf memType}}]{rORw}
\end{DoxyParamCaption}
)}}
\label{cacheCtrl_8h_a9d3abaa15043f5ead167e4d73bfcfb8b}
