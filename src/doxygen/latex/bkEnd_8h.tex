\hypertarget{bkEnd_8h}{
\section{/home/milad/esc\_\-project/svn/PARS/src/backend/bkEnd.h File Reference}
\label{bkEnd_8h}\index{/home/milad/esc\_\-project/svn/PARS/src/backend/bkEnd.h@{/home/milad/esc\_\-project/svn/PARS/src/backend/bkEnd.h}}
}
{\ttfamily \#include \char`\"{}../global/g\_\-variable.h\char`\"{}}\par
{\ttfamily \#include $<$stdint.h$>$}\par
Include dependency graph for bkEnd.h:
This graph shows which files directly or indirectly include this file:
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{bkEnd_8h_a82b271e081de4cfb35eb87b0c13dddba}{BP}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{bkEnd_8h_a2610cc7850729dad55450e26627d78ae}{bkEnd\_\-init} (int argc, char const $\ast$argv\mbox{[}$\,$\mbox{]}, \hyperlink{structg__variable}{g\_\-variable} \&\hyperlink{g__variable_8h_adfd3dddc03cc8a61d5ba0f266d7caeaa}{g\_\-var})
\item 
void \hyperlink{bkEnd_8h_aa41656fd1e95e4bdc43191b18dfd8102}{bkEnd\_\-heading} (int argc, char const $\ast$argv\mbox{[}$\,$\mbox{]})
\item 
void \hyperlink{bkEnd_8h_a0de885ce07273f37e162ecb0e63ec95d}{bkEnd\_\-run} ()
\item 
void \hyperlink{bkEnd_8h_af34e8aea898d89ab4f271696b1c9ab8b}{bkEnd\_\-finish} ()
\item 
bool \hyperlink{bkEnd_8h_a5627ce0f84690d974b96ebb091e67d6e}{PredictAndUpdate} (uint64\_\-t \_\-\_\-pc, int \_\-\_\-taken)
\end{DoxyCompactItemize}


\subsection{Define Documentation}
\hypertarget{bkEnd_8h_a82b271e081de4cfb35eb87b0c13dddba}{
\index{bkEnd.h@{bkEnd.h}!BP@{BP}}
\index{BP@{BP}!bkEnd.h@{bkEnd.h}}
\subsubsection[{BP}]{\setlength{\rightskip}{0pt plus 5cm}\#define BP}}
\label{bkEnd_8h_a82b271e081de4cfb35eb87b0c13dddba}


\subsection{Function Documentation}
\hypertarget{bkEnd_8h_af34e8aea898d89ab4f271696b1c9ab8b}{
\index{bkEnd.h@{bkEnd.h}!bkEnd\_\-finish@{bkEnd\_\-finish}}
\index{bkEnd\_\-finish@{bkEnd\_\-finish}!bkEnd.h@{bkEnd.h}}
\subsubsection[{bkEnd\_\-finish}]{\setlength{\rightskip}{0pt plus 5cm}void bkEnd\_\-finish (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8h_af34e8aea898d89ab4f271696b1c9ab8b}

\begin{DoxyCode}
                     {
        //Print Stats on screen
        //printf("line Number = %ld\n", lineNum);
        printf("------------------------------------------\n");
        printf("COMMENT           = %s\n", comment);
        printf("CORE TYPE         = %d\n", coreType);
        printf("Perf Reg Renaming = %d (Size: %d)\n", perfectRegRen, GRRF_SIZE);
        printf("LSQ Model         = %d (LQ: %d, SQ %d)\n", memoryModel, LQ_SIZE, 
      SQ_SIZE);
        if (coreType == PHRASEBLOCK) printf("Num Ins Buff = %d\n", 
      NUM_PHRASEBLKS);
        printf("ROB Size                  = %d\n", ROBsize);
        printf("1 LD Lat Lvl      = %ld\n", oneLevDeepLatLevel);
        printf("Frame Buffer Size         = %ld\n", SBlength);
        printf("Num Side Buffs            = %ld\n", numSideBuffs);
        printf("IN FILE                   = %s\n", inFileName.c_str());
        printf("OUT FILE                  = %s\n", outFileName1.c_str());
        if (reschedule == true) printf("VLIW TRACE FILE = %s\n", 
      reScheduleFileName.c_str());
        if (makePhrase == true) printf("PHRASE TRACE FILE = %s\n", 
      phrasingFileName.c_str());
        if (reportTraceAndHitMiss == true) 
                printf("UNPRED MEM TRACE FILE = %s\n", reScheduleFileName.c_str()
      );
        printf("IPC                       = %f\n", ipc);
        printf("Corrupt Instruction Conut = %ld\n", corruptInsCount);
        printf("Miss  Count            = %ld\n", missCount(cacheLat[0]));
        printf("Hit   Count            = %ld\n", hitCount(0));
        printf("Miss  Latency          = %ld\n", missLatency(cacheLat[0]));
        printf("Hit   Latency          = %ld\n", hitLatency(0));
        printf("TOTAL Latency          = %ld\n", cycle);
        printf("TOTAL MEM Latency      = %ld\n", totalLatency(0));
        printf("FU  Utilization Count  = %ld, %ld, %ld, %ld\n\n",aluStat[0],
      aluStat[1],aluStat[2],aluStat[3]);
        printf("STALL Event Rate = %ld (%f)\n",fetchStallCycle,(float)
      fetchStallCycle/(float)cycle);

        printf("Miss  Rate             = %f\n", (float)missCount(cacheLat[0])/(fl
      oat)(hitCount(0)+missCount(cacheLat[0])));
        printf("Hit   Rate             = %f\n", (float)hitCount(0)/(float)(
      hitCount(0)+missCount(cacheLat[0])));
        printf("Miss  Avg Latency      = %f\n", (float)missLatency(cacheLat[0])/(
      float)totalLatency(0));
        printf("Hit   Avg Latency      = %f\n", (float)hitLatency(0)/(float)
      totalLatency(0));
        printf("FU  Utilization Rate   = %f, %f, %f, %f\n\n",(float)aluStat[0]/(f
      loat)cycle,
                                                             (float)aluStat[1]/(f
      loat)cycle,
                                                             (float)aluStat[2]/(f
      loat)cycle,
                                                             (float)aluStat[3]/(f
      loat)cycle);

        printf("L1  Hit Rate           = %f\n", (float)L1hitCount()/(float)(
      hitCount(0)+missCount(cacheLat[0])));
        printf("L2  Hit Rate           = %f\n", (float)L2hitCount()/(float)(
      hitCount(0)+missCount(cacheLat[0])));
        printf("L3  Hit Rate           = %f\n", (float)L3hitCount()/(float)(
      hitCount(0)+missCount(cacheLat[0])));
        printf("MEM Hit Rate           = %f\n\n", (float)MEMhitCount()/(float)(
      hitCount(0)+missCount(cacheLat[0])));

        printf("Ins ROB   Utilization  = %f\n", (float)iROBSize/(float)cycle);
        printf("Ins Win   Utilization  = %f\n", (float)iWinSize/(float)cycle);
        printf("Res Stn   Utilization  = %f\n", (float)iResStnSize/(float)cycle);
      
        printf("Ins LQ    Utilization  = %f\n", (float)lqSize/(float)cycle);
        printf("Ins SQ    Utilization  = %f\n", (float)sqSize/(float)cycle);
        printf("Ins RR    Utilization  = %f\n", (float)rrSize/(float)cycle);
        printf("Ins LRF   Utilization  = %lld (%f)\n",lrfCount,(double)lrfCount/(
      double)insCount);
        printf("Ins GRF   Utilization  = %lld (%f)\n",grfCount,(double)grfCount/(
      double)insCount);
        printf("LRF WR    Utilization  = %lld (%f)\n",lrfWrCountPerIns,(double)
      lrfWrCountPerIns/(double)insCount);
        printf("LRF RD    Utilization  = %lld (%f)\n",lrfRdCountPerIns,(double)
      lrfRdCountPerIns/(double)insCount);
        printf("GRF WR    Utilization  = %lld (%f)\n",grfWrCountPerIns,(double)
      grfWrCountPerIns/(double)insCount);
        printf("GRF RD    Utilization  = %lld (%f)\n",grfRdCountPerIns,(double)
      grfRdCountPerIns/(double)insCount);
        printf("Mem Buf   Utilization  = %f\n", (float)iMemBuffSize/(float)cycle)
      ;
        printf("Side Buf  Utilization  = %f\n", (float)iSideBufSize/(float)cycle)
      ;
        printf("In Flight Utilization  = %f\n\n",(float)inFlightLDopsSize/(float)
      cycle);

        printf("Tot Num Squash Events   = %d,   Ratio: (%f)\n",squashCount, (floa
      t)squashCount/(float)cycle);
        printf("Tot Num Squash Ins      = %lld, Ratio: (%f)\n",squashInsCount, (f
      loat)squashInsCount/(float)insCount);
        printf("Tot Num Squash BR Ins   = %lld, Ratio: (%f)\n",squashBRinsCount, 
      (float)squashBRinsCount/(float)insCount);
        printf("Tot Num Squash LD Ins   = %lld, Ratio: (%f)\n",squashLQinsCount, 
      (float)squashLQinsCount/(float)insCount);
        printf("Tot Num Squash ST Ins   = %lld, Ratio: (%f)\n",squashSQinsCount, 
      (float)squashSQinsCount/(float)insCount);
        printf("Tot Num Squash RS Ins   = %lld, Ratio: (%f)\n",squashRSinsCount, 
      (float)squashRSinsCount/(float)insCount);
        printf("Tot Num Squash iWin Ins = %lld, Ratio: (%f)\n",squashWinInsCount,
       (float)squashWinInsCount/(float)insCount);
        printf("Tot Num Squash iPhr Ins = %lld, Ratio: (%f)\n",squashPhrInsCount,
       (float)squashPhrInsCount/(float)insCount);
        printf("Tot Num Squash GRF Reg = %lld, Ratio: (%f)\n",squashRegRenCount, 
      (float)squashRegRenCount/(float)insCount);
        printf("Tot Num Squash LRF Reg = %lld, Ratio: (%f)\n",squashLRFcount, (fl
      oat)squashLRFcount/(float)insCount);
        printf("Tot Num Squash GRF WR Reg (ALL)   = %lld\n",
      num_squashed_grf_wr_reg);
        printf("Tot Num Squash GRF RD Reg (ALL)   = %lld\n",
      num_squashed_grf_rd_reg);
        printf("Tot Num Squash LRF WR Reg (ALL)   = %lld\n",
      num_squashed_lrf_wr_reg);
        printf("Tot Num Squash LRF RD Reg (ALL)   = %lld\n",
      num_squashed_lrf_rd_reg);
        printf("Tot Num Squash LRF WR Reg (FETCH) = %lld\n",
      num_squashed_lrf_wr_fetch_reg);
        printf("Tot Num Squash LRF RD Reg (FETCH) = %lld\n",
      num_squashed_lrf_rd_fetch_reg);
        printf("Tot Num Squash LRF WR Reg (READY) = %lld\n",
      num_squashed_lrf_wr_ready_reg);
        printf("Tot Num Squash LRF RD Reg (READY) = %lld\n",
      num_squashed_lrf_rd_ready_reg);
        printf("Tot Num Squash LRF WR Reg (EXECT) = %lld\n",
      num_squashed_lrf_wr_execute_reg);
        printf("Tot Num Squash LRF RD Reg (EXECT) = %lld\n",
      num_squashed_lrf_rd_execute_reg);
        printf("Tot Num Squash LRF WR Reg (COMPL) = %lld\n",
      num_squashed_lrf_wr_complete_reg);
        printf("Tot Num Squash LRF RD Reg (COMPL) = %lld\n",
      num_squashed_lrf_rd_complete_reg);
        printf("Tot Num Squash GRF WR Reg (FETCH) = %lld\n",
      num_squashed_grf_wr_fetch_reg);
        printf("Tot Num Squash GRF RD Reg (FETCH) = %lld\n",
      num_squashed_grf_rd_fetch_reg);
        printf("Tot Num Squash GRF WR Reg (READY) = %lld\n",
      num_squashed_grf_wr_ready_reg);
        printf("Tot Num Squash GRF RD Reg (READY) = %lld\n",
      num_squashed_grf_rd_ready_reg);
        printf("Tot Num Squash GRF WR Reg (EXECT) = %lld\n",
      num_squashed_grf_wr_execute_reg);
        printf("Tot Num Squash GRF RD Reg (EXECT) = %lld\n",
      num_squashed_grf_rd_execute_reg);
        printf("Tot Num Squash GRF WR Reg (COMPL) = %lld\n",
      num_squashed_grf_wr_complete_reg);
        printf("Tot Num Squash GRF RD Reg (COMPL) = %lld\n",
      num_squashed_grf_rd_complete_reg);
        printf("Tot Num SB Activations            = %ld\n",totNumSBactivations);
        printf("Tot Num SB ReActivations          = %ld\n",totNumSBreactivations)
      ;
        printf("Tot SB Reactivation Rate          = %f\n",(float)
      totNumSBreactivations/(float)totNumSBactivations);
        printf("Total SB Size                     = %lu\n",totalSBsize);
        printf("Tot Avg SB Size                   = %f\n",(float)totalSBsize/(flo
      at)totNumSBactivations);
        printf("Max SB Size                           = %ld\n",maxSBsize);
        printf("Min SB Size                           = %ld\n",minSBsize);
        printf("Total Number of Execute  Ins      = %ld\n",executeInsCount);
        printf("Total Number of Complete Ins      = %ld\n",completeInsCount);
        printf("Total Number of Commit Ins        = %ld\n",insCount);
        printf("Total Num Ins Visit SB            = %ld\n",totInsVisitingSBcount)
      ;
        printf("Total Rate of Ins Visiting SB     = %f\n",(float)
      totInsVisitingSBcount/(float)insCount);
        printf("Tot Ins Exe When SB ON            = %ld\n",totInsCountWhenSBon);
        printf("Tot Ins Exe When SB ON IPC        = %f\n",(float)
      totInsCountWhenSBon/(float)totSBactiveCycles);
        printf("Tot SB ON Avg. Time               = %f\n\n",(float)(cycle-
      totSBoffCycles)/(float)cycle);
        printf("Tot Num of Off SB Dep. Ins/Active Win = %f\n",(float)
      numDepInOtherSBs/(float)totNumSBactivations);
        printf("Num Empty Res Stn Cycles          = %ld\n", emptyResStation);
        printf("Num Empty Res Stn Cycles/All Cycl = %f\n\n", (float)
      emptyResStation/(float)cycle);

        if (reportTraceAndHitMiss) {
                printf("Unpredictability Threshold        = %f\n", (double)
      unpredMemOpThreshold/(double)COEFF);
                printf("Num Unpred. Ins:                  = %ld\n", 
      unpredMemInsCnt);
                printf("Num Unpred. Ops:                  = %ld\n", 
      unpredMemOpCnt);
                printf("Unpred. Ins Rate:                 = %f\n\n", (float)
      unpredMemOpCnt/(float)insCount);
        }
        if (makePhrase) {
                printf("Max Phrases Size                  = %d\n", 
      phraseSizeBound);
                printf("Unpredictable Ins Threshold       = %f\n", (double)
      unpredMemOpThreshold/(double)COEFF);
                printf("Num Phrases                       = %ld\n", totNumPhrase)
      ;
                printf("Avg. Num Ins/Phrase               = %f\n", (float)
      insCount/(float)totNumPhrase);
                printf("Tot Num SoftBound Partitions      = %ld\n", 
      totNumSoftBound);
                printf("Avg. Num SoftBound/Phrase         = %f\n", (float)
      totNumSoftBound/(float)totNumPhrase);
                printf("Tot Num Unpred. Ins               = %ld\n", 
      totNumPhUnpredMemOp);
                printf("Num Unpred. Ins/Phrase            = %f\n", (float)
      totNumPhUnpredMemOp/(float)totNumPhrase);
                printf("Num Unpred. Ins/Total Ins         = %f\n", (float)
      totNumPhUnpredMemOp/(float)insCount);
                printf("Tot Num Root Ins                  = %ld\n", 
      totNumRootIns);
                printf("Num Root Ins/Phrase               = %f\n", (float)
      totNumRootIns/(float)totNumPhrase);
                printf("Tot Num Phrase Ancestors          = %ld\n", 
      totNumPhraseAncestors);
                printf("NumPhrase Ancestors/Phrase        = %f\n", (float)
      totNumPhraseAncestors/(float)totNumPhrase);
                printf("Num of Resetting Times            = %ld\n\n", 
      totNumPhGenResets);
                printf("Num Fragment                      = %ld\n", totNumFrag);
                printf("Num Root Phrases                  = %ld\n", totNumRootPh)
      ;
                printf("Root Phrases Rate                 = %f\n", (double)
      totNumRootPh/(double)totNumPhrase);
                printf("Num Critical Path Violations      = %ld\n", 
      totNumCritPathViol);
                printf("Critical Path Violations Rate     = %f\n", (double)
      totNumCritPathViol/(double)totNumPhrase);
                printf("Avg. Num Ins/Fragment             = %f\n", (float)
      insCount/(float)totNumFrag);
                printf("Avg. Num Fragment/Phrase          = %f\n", (float)
      totNumFrag/(float)totNumPhrase);
        }
        if (coreType == PHRASE || coreType == FRAGMENT) {
                printf("Num Phrases                       = %ld\n", totNumPhrase)
      ;
                printf("Avg. Num Ins/Fragment             = %f\n", (float)
      insCount/(float)totNumFrag);
                printf("Avg. Num Fragment/Phrase          = %f\n", (float)
      totNumFrag/(float)totNumPhrase);
                printf("Avg. Num Ins/Phrase               = %f\n", (float)
      insCount/(float)totNumPhrase);
                printf("Latency/Phrase                    = %f\n", (float)
      totalLatency(0)/(float)totNumPhrase);
                printf("Tot Phrase Stall Time             = %ld\n", totPhStall);
                printf("Avg. Phrase Stall Time            = %f\n", (float)
      totPhStall/(float)totNumPhrase);
                printf("Unexpected Miss Count             = %ld\n", 
      unexpectedMiss);
                printf("Unexpected Miss Rate              = %f\n", (float)
      unexpectedMiss/(float)missCount(cacheLat[0]));
                printf("Unexpected Miss Latency           = %ld\n", 
      unexpecteedLat);
                printf("Unexpected Avg. Miss Lat          = %f\n", (float)
      unexpecteedLat/(float)unexpectedMiss);
                printf("Unexpected Miss Lat Rate          = %f\n", (float)
      unexpecteedLat/(float)missLatency(0));
        }
        if (coreType == FRAGMENT) {
                printf("Num Fragment                      = %ld\n", totNumFrag);
                printf("Tot Fragment Stall Time           = %ld\n", totFrStall);
                printf("Avg. Fragment  Stall Time         = %f\n", (float)
      totFrStall/(float)totNumFrag);
                printf("Num Real Fragment                 = %ld\n", 
      totNumRealFrag);
                printf("Real Frag/Tot Frag                = %f\n", (float)
      totNumRealFrag/(float)totNumFrag);
                printf("Avg. Num Ins/Real Frag            = %f\n", (float)
      totSizRealFrag/(float)totNumRealFrag);
                printf("Num of Single Frag Wavefront      = %ld\n", 
      totNumOfSigleFragPhrases);
                printf("Avg. Num Real Frag/Phrase         = %f\n", (double)
      totNumRealFrag/(double)(totNumPhrase-totNumOfSigleFragPhrases));
                printf("Avg. Num Ready Frags              = %f\n", (double)
      numReadyFrags/(double)totNumFrag);
                printf("Inter-Fragment Stall Time         = %ld\n", 
      interFragStallCycle);
                printf("Inter-Fragment Stall Rate         = %f\n\n", (double)
      interFragStallCycle/(double)cycle);
        }



        printf("---    ---    ---    ---    ---    ----   \n");
        for (int  i = 0; i < numSideBuffs; i++) {
                printf("SB INDEX                = %d\n",i);
                printf("Num SB Activations      = %ld\n",numSBactivations[i]);
                printf("Num SB ReActivations    = %ld\n",numSBreactivations[i]);
                printf("SB Reactivation Rate    = %f\n",(float)
      numSBreactivations[i]/(float)numSBactivations[i]);
                printf("SB Size                 = %lu\n",SBsize[i]);
                printf("Avg SB Size             = %f\n",(float)SBsize[i]/(float)
      numSBactivations[i]);
                printf("Num Ins Visit SB        = %ld\n",insVisitingSBcount[i]);
                printf("Rate of Ins Visiting SB = %f\n",(float)
      insVisitingSBcount[i]/(float)insCount);
                printf("Ins Exe When SB ON      = %ld\n",InsCountWhenSBon[i]);
                printf("Ins Exe When SB ON IPC  = %f\n",(float)InsCountWhenSBon[i
      ]/(float)SBactiveCycles[i]);
                printf("SB ON Avg. Time         = %f\n\n",(float)(cycle-
      SBoffCycles[i])/(float)cycle);
                printf("Frame Win Avg. Size    = %f\n",(float)(totFrameSize)/(flo
      at)numSBactivations[i]);
                printf("Frame NonSB Ins Avg Cnt= %f\n",(float)(
      totMainStreamBound)/(float)numSBactivations[i]);
                printf("Frame Window Sat Rate  = %f\n",(float)(windowSatration)/(
      float)numSBactivations[i]);  //TODO THIS IS NOT A VECTOR ELEMENT, fix
                printf("Frame ON longLat op Rate  = %f\n",(float)(
      longLatOpWhenSPisON)/(float)numSBactivations[i]);  //TODO THIS IS NOT A VECTOR EL
      EMENT, fix
                printf("Frame ON-Drain longLat Rat= %f\n",(float)(
      longLatOpWhenSPisDraining)/(float)numSBactivations[i]);  //TODO THIS IS NOT A VEC
      TOR ELEMENT, fix
                printf("Frame ON-Wait longLat Rate= %f\n",(float)(
      longLatOpWhenSPisWaiting)/(float)numSBactivations[i]);  //TODO THIS IS NOT A VECT
      OR ELEMENT, fix
                printf("---    ---    ---    ---    ---    ----   \n");
        }

        printf("\nNumber of MEM Ops       = %ld\n",numMemOps);
        printf("Number of ALU Ops         = %ld\n",numALUOps);
        printf("Number of FPU Ops         = %ld\n",numFPUOps);
        printf("Number of BR  Ops         = %ld\n",numBROps);
        printf("Number of ASSIGN  Ops     = %ld\n",numAssignOps);
        printf("Number of READ Ops        = %ld\n",numReadOps);
        printf("Number of WRITE Op        = %ld\n",numWriteOps);
        printf("Number Mis-Pred BR Ops (Fetch)     = %ld, Rate: %f\n",
      missPredBROps_fetch, (float)missPredBROps_fetch/(float)numBROps);
        printf("Number Mis-Pred BR Ops (Commit)    = %ld, Rate: %f\n",
      missPredBROps, (float)missPredBROps/(float)numBROps);
        printf("Number Mis-Pred_NT BR Ops (Fetch)  = %ld, Rate: %f\n",
      missPredBROps_NT_fetch, (float)missPredBROps_NT_fetch/(float)numBROps);
        printf("Number Mis-Pred_NT BR Ops (Commit) = %ld, Rate: %f\n",
      missPredBROps_NT, (float)missPredBROps_NT/(float)numBROps);
        printf("Number Pred_NT R Ops (Fetch)       = %ld, Rate: %f\n",
      numBrOps_predT_fetch, (float)numBrOps_predT_fetch/(float)numBROps);
        printf("Number Pred_T BR Ops (Commit)      = %ld, Rate: %f\n",
      numBrOps_predT, (float)numBrOps_predT/(float)numBROps);
        printf("Store FWD READ Ops        = %ld\n",stFwdMemOp);
        printf("Store FWD READ/All READ   = %f\n",(float)stFwdMemOp/(float)
      numReadOps);
        printf("Non-blocking READ Ops     = %ld\n",nonBlockingMemOp);
        printf("Non-blck READ/All READ    = %f\n",(float)nonBlockingMemOp/(float)
      numReadOps);
        printf("Cache Axes READ Ops       = %ld\n",maxSBsize);
        printf("Cache Axes READ/All READ  = %f\n",(float)maxSBsize/(float)
      numReadOps);
        printf("MEM Ops Rate            = %f\n",(float)numMemOps/(float)insCount)
      ;
        printf("ALU Ops Rate            = %f\n",(float)numALUOps/(float)insCount)
      ;
        printf("FPU Ops Rate            = %f\n",(float)numFPUOps/(float)insCount)
      ;
        printf("BR  Ops Rate            = %f\n",(float)numBROps/(float)insCount);
      
        printf("ASSIGN  Ops     Rate    = %f\n",(float)numAssignOps/(float)
      insCount);
        printf("READ Ops Rate           = %f\n",(float)numReadOps/(float)
      insCount);
        printf("WRITE Ops Rate          = %f\n",(float)numWriteOps/(float)
      insCount);
        printf("READ/MEM  Ops Rate      = %f\n",(float)numReadOps/(float)
      numMemOps);
        printf("WRITE/MEM Ops Rate      = %f\n\n",(float)numWriteOps/(float)
      numMemOps);
        printf("------------------------------------------\n");

        /* STRAND EXE STAT */
        if (coreType == STRAND || coreType == PHRASEBLOCK) {
                printf("STRAND COUNT: %lld\n", dyn_num_strands);
                printf("TOT NUM INS IN STRAND: %lld\n", total_num_strand_ins);
                printf("AVG. STRAND SIZE: %f\n", (double)total_num_strand_ins/(do
      uble)dyn_num_strands);
                printf("Percent of Ins in Strands: %f\n", (double)
      total_num_strand_ins/(double)insCount*100.0);
        } 
        /* PHRASEBLOCK EXE STAT */
        else if (coreType == PHRASEBLOCK) {
                printf("Total Num PB/BB Ran: %ld\n", bbCount);
                printf("AVG. Active BB/PB Ratio: %f\n", (double)activeBuffCnt/(do
      uble)cycle);
                printf("Average # of Cycles b/w BP Lookup & Update: %f\n", (doubl
      e)br_pred_update_dist/(double)brInsCount);
        }
        for (int i = 0; i < NUM_FUNC_UNIT; i++)
                printf("Res Stn %d Utilization  = %f\n", i, (float)iResStnsSize[i
      ]/(float)cycle);
        for (int i = 0; i < NUM_PHRASEBLKS; i++)
                printf("Phraseblock %d Utilization  = %f\n", i, (float)
      pbListsSize[i]/(float)cycle);

        /* Report the branches whose accuracy was not recorded: */
        if (branchProfileFlag) {
                set<long int>::iterator it;
                printf("Report the branches whose accuracy was not recorded:\n");
      
                for (it = missingAccuracyBranches.begin(); it != 
      missingAccuracyBranches.end(); it++) {
                        printf("%ld, ", *it);
                }
                printf("\n");
        }

        //Print Stats into file
        //for (int i = 0; i < 1; i++) {
        //      if (i == 0) outFile = outFile1;
        //      else        outFile = outFile2;
        outFile = outFile1;

                fprintf(outFile, "------------------------------------------\n");
      
                fprintf(outFile,"COMMENT                    = %s\n", comment);
                fprintf(outFile, "CORE TYPE         = %d\n", coreType);
                fprintf(outFile, "Perf Reg Renaming = %d (Size: %d)\n", 
      perfectRegRen, GRRF_SIZE);
                fprintf(outFile, "LSQ Model         = %d (LQ: %d, SQ %d)\n", 
      memoryModel, LQ_SIZE, SQ_SIZE);
                if (coreType == PHRASEBLOCK) fprintf(outFile, "Num Ins Buff = %d\
      n", NUM_PHRASEBLKS);
                fprintf(outFile, "ROB Size                  = %d\n", ROBsize);
                fprintf(outFile, "1 LD Lat Lvl              = %ld\n", 
      oneLevDeepLatLevel);
                fprintf(outFile, "Frame Buffer Size       = %ld\n", SBlength);
                fprintf(outFile, "Num Side Buffs            = %ld\n", numSideBuff
      s);
                fprintf(outFile, "IN FILE                   = %s\n", inFileName.c
      _str());
                fprintf(outFile, "OUT FILE                  = %s\n", 
      outFileName1.c_str());
                if (reschedule == true) fprintf(outFile,"VLIW TRACE FILE = %s\n",
       reScheduleFileName.c_str());
                if (makePhrase == true) fprintf(outFile,"PHRASE TRACE FILE = %s\n
      ", phrasingFileName.c_str());
                if (reportTraceAndHitMiss == true) 
                                        fprintf(outFile,"UNPRED MEM TRACE FILE = 
      %s\n", reScheduleFileName.c_str());
                fprintf(outFile, "IPC                       = %f\n", ipc);
                fprintf(outFile, "Corrupt Instruction Conut = %ld\n", 
      corruptInsCount);
                fprintf(outFile, "Miss  Count               = %ld\n", missCount(
      cacheLat[0]));
                fprintf(outFile, "Hit   Count               = %ld\n", hitCount(0)
      );
                fprintf(outFile, "Miss  Latency             = %ld\n", 
      missLatency(0));
                fprintf(outFile, "Hit   Latency             = %ld\n", hitLatency(
      0));
                fprintf(outFile, "TOTAL Latency             = %ld\n", cycle);
                fprintf(outFile, "TOTAL MEM Latency         = %ld\n", 
      totalLatency(0));
                fprintf(outFile, "FU  Utilization Count = %ld, %ld, %ld, %ld\n\n"
      ,aluStat[0],aluStat[1],aluStat[2],aluStat[3]);
                fprintf(outFile, "STALL Event Rate = %ld (%f)\n",fetchStallCycle,
      (float)fetchStallCycle/(float)cycle);
                
                fprintf(outFile, "Miss  Rate             = %f\n", (float)
      missCount(cacheLat[0])/(float)(hitCount(0)+missCount(cacheLat[0])));
                fprintf(outFile, "Hit   Rate             = %f\n", (float)
      hitCount(0)/(float)(hitCount(0)+missCount(cacheLat[0])));
                fprintf(outFile, "Miss  Avg Latency      = %f\n", (float)
      missLatency(cacheLat[0])/(float)totalLatency(0));
                fprintf(outFile, "Hit   Avg Latency      = %f\n", (float)
      hitLatency(0)/(float)totalLatency(0));
                fprintf(outFile, "FU  Utilization Rate   = %f, %f, %f, %f\n\n", (
      float)aluStat[0]/(float)cycle,
                                                                                (
      float)aluStat[1]/(float)cycle,
                                                                                (
      float)aluStat[2]/(float)cycle,
                                                                                (
      float)aluStat[3]/(float)cycle);
                
                fprintf(outFile, "L1  Hit Rate           = %f\n",   (float)
      L1hitCount()/(float)(hitCount(0)+missCount(cacheLat[0])));
                fprintf(outFile, "L2  Hit Rate           = %f\n",   (float)
      L2hitCount()/(float)(hitCount(0)+missCount(cacheLat[0])));
                fprintf(outFile, "L3  Hit Rate           = %f\n",   (float)
      L3hitCount()/(float)(hitCount(0)+missCount(cacheLat[0])));
                fprintf(outFile, "MEM Hit Rate           = %f\n\n", (float)
      MEMhitCount()/(float)(hitCount(0)+missCount(cacheLat[0])));
                
                fprintf(outFile, "Ins ROB   Utilization  = %f\n", (float)
      iROBSize/(float)cycle);
                fprintf(outFile, "Ins Win   Utilization  = %f\n", (float)
      iWinSize/(float)cycle);
                fprintf(outFile, "Res Stn   Utilization  = %f\n", (float)
      iResStnSize/(float)cycle);
                fprintf(outFile, "Ins LQ    Utilization  = %f\n", (float)lqSize/(
      float)cycle);
                fprintf(outFile, "Ins SQ    Utilization  = %f\n", (float)sqSize/(
      float)cycle);
                fprintf(outFile, "Ins RR    Utilization  = %f\n", (float)rrSize/(
      float)cycle);
                fprintf(outFile, "Ins LRF   Utilization  = %lld (%f)\n",lrfCount,
      (double)lrfCount/(double)insCount);
                fprintf(outFile, "Ins GRF   Utilization  = %lld (%f)\n",grfCount,
      (double)grfCount/(double)insCount);
                fprintf(outFile, "LRF WR    Utilization  = %lld (%f)\n",
      lrfWrCountPerIns,(double)lrfWrCountPerIns/(double)insCount);
                fprintf(outFile, "LRF RD    Utilization  = %lld (%f)\n",
      lrfRdCountPerIns,(double)lrfRdCountPerIns/(double)insCount);
                fprintf(outFile, "GRF WR    Utilization  = %lld (%f)\n",
      grfWrCountPerIns,(double)grfWrCountPerIns/(double)insCount);
                fprintf(outFile, "GRF RD    Utilization  = %lld (%f)\n",
      grfRdCountPerIns,(double)grfRdCountPerIns/(double)insCount);
                fprintf(outFile, "Mem Buf   Utilization  = %f\n", (float)
      iMemBuffSize/(float)cycle);
                fprintf(outFile, "Side Buf  Utilization  = %f\n", (float)
      iSideBufSize/(float)cycle);
                fprintf(outFile, "In Flight Utilization  = %f\n", (float)
      inFlightLDopsSize/(float)cycle);

                fprintf(outFile, "Tot Num Squash Events = %d, Ratio: (%f)\n",
      squashCount, (float)squashCount/(float)cycle);
                fprintf(outFile, "Tot Num Squash Ins    = %lld, Ratio: (%f)\n",
      squashInsCount, (float)squashInsCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash BR Ins   = %lld, Ratio: (%f)\n",
      squashBRinsCount, (float)squashBRinsCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash LD Ins = %lld, Ratio: (%f)\n",
      squashLQinsCount, (float)squashLQinsCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash ST Ins = %lld, Ratio: (%f)\n",
      squashSQinsCount, (float)squashSQinsCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash RS Ins = %lld, Ratio: (%f)\n",
      squashRSinsCount, (float)squashRSinsCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash iWin Ins = %lld, Ratio: (%f)\n",
      squashWinInsCount, (float)squashWinInsCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash iPhr Ins = %lld, Ratio: (%f)\n",
      squashPhrInsCount, (float)squashPhrInsCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash GRF Reg = %lld, Ratio: (%f)\n",
      squashRegRenCount, (float)squashRegRenCount/(float)insCount);
                fprintf(outFile, "Tot Num Squash LRF Reg = %lld, Ratio: (%f)\n",
      squashLRFcount, (float)squashLRFcount/(float)insCount);
                fprintf(outFile, "Tot Num Squash GRF WR Reg (ALL)   = %lld\n",
      num_squashed_grf_wr_reg);
                fprintf(outFile, "Tot Num Squash GRF RD Reg (ALL)   = %lld\n",
      num_squashed_grf_rd_reg);
                fprintf(outFile, "Tot Num Squash LRF WR Reg (ALL)   = %lld\n",
      num_squashed_lrf_wr_reg);
                fprintf(outFile, "Tot Num Squash LRF RD Reg (ALL)   = %lld\n",
      num_squashed_lrf_rd_reg);
                fprintf(outFile, "Tot Num Squash LRF WR Reg (FETCH) = %lld\n",
      num_squashed_lrf_wr_fetch_reg);
                fprintf(outFile, "Tot Num Squash LRF RD Reg (FETCH) = %lld\n",
      num_squashed_lrf_rd_fetch_reg);
                fprintf(outFile, "Tot Num Squash LRF WR Reg (READY) = %lld\n",
      num_squashed_lrf_wr_ready_reg);
                fprintf(outFile, "Tot Num Squash LRF RD Reg (READY) = %lld\n",
      num_squashed_lrf_rd_ready_reg);
                fprintf(outFile, "Tot Num Squash LRF WR Reg (EXECT) = %lld\n",
      num_squashed_lrf_wr_execute_reg);
                fprintf(outFile, "Tot Num Squash LRF RD Reg (EXECT) = %lld\n",
      num_squashed_lrf_rd_execute_reg);
                fprintf(outFile, "Tot Num Squash LRF WR Reg (COMPL) = %lld\n",
      num_squashed_lrf_wr_complete_reg);
                fprintf(outFile, "Tot Num Squash LRF RD Reg (COMPL) = %lld\n",
      num_squashed_lrf_rd_complete_reg);
                fprintf(outFile, "Tot Num Squash GRF WR Reg (FETCH) = %lld\n",
      num_squashed_grf_wr_fetch_reg);
                fprintf(outFile, "Tot Num Squash GRF RD Reg (FETCH) = %lld\n",
      num_squashed_grf_rd_fetch_reg);
                fprintf(outFile, "Tot Num Squash GRF WR Reg (READY) = %lld\n",
      num_squashed_grf_wr_ready_reg);
                fprintf(outFile, "Tot Num Squash GRF RD Reg (READY) = %lld\n",
      num_squashed_grf_rd_ready_reg);
                fprintf(outFile, "Tot Num Squash GRF WR Reg (EXECT) = %lld\n",
      num_squashed_grf_wr_execute_reg);
                fprintf(outFile, "Tot Num Squash GRF RD Reg (EXECT) = %lld\n",
      num_squashed_grf_rd_execute_reg);
                fprintf(outFile, "Tot Num Squash GRF WR Reg (COMPL) = %lld\n",
      num_squashed_grf_wr_complete_reg);
                fprintf(outFile, "Tot Num Squash GRF RD Reg (COMPL) = %lld\n",
      num_squashed_grf_rd_complete_reg);
                fprintf(outFile, "Tot Num SB Activations            = %ld\n",
      totNumSBactivations);
                fprintf(outFile, "Tot Num SB ReActivations          = %ld\n",
      totNumSBreactivations);
                fprintf(outFile, "Tot SB Reactivation Rate          = %f\n",(floa
      t)totNumSBreactivations/(float)totNumSBactivations);
                fprintf(outFile, "Total SB Size                     = %lu\n",
      totalSBsize);
                fprintf(outFile, "Tot Avg SB Size                   = %f\n",(floa
      t)totalSBsize/(float)totNumSBactivations);
                fprintf(outFile, "Max SB Size                       = %ld\n",
      maxSBsize);
                fprintf(outFile, "Min SB Size                       = %ld\n",
      minSBsize);
                fprintf(outFile, "Total Number of Execute  Ins      = %ld\n",
      executeInsCount);
                fprintf(outFile, "Total Number of Complete Ins      = %ld\n",
      completeInsCount);
                fprintf(outFile, "Total Number of Commit Ins        = %ld\n",
      insCount);
                fprintf(outFile, "Total Num Ins Visit SB            = %ld\n",
      totInsVisitingSBcount);
                fprintf(outFile, "Total Rate of Ins Visiting SB     = %f\n",(floa
      t)totInsVisitingSBcount/(float)insCount);
                fprintf(outFile, "Tot Ins Exe When SB ON            = %ld\n",
      totInsCountWhenSBon);
                fprintf(outFile, "Tot Ins Exe When SB ON IPC        = %f\n",(floa
      t)totInsCountWhenSBon/(float)totSBactiveCycles);
                fprintf(outFile, "SB ON Avg. Time                   = %f\n\n",(fl
      oat)(cycle-totSBoffCycles)/(float)cycle);
                fprintf(outFile, "Tot Num of Off SB Dep. Ins/Active Win = %f\n",(
      float)numDepInOtherSBs/(float)totNumSBactivations);
                fprintf(outFile, "Num Empty Res Stn Cycles          = %ld\n", 
      emptyResStation);
                fprintf(outFile, "Num Empty Res Stn Cycles/All Cycl = %f\n\n", (f
      loat)emptyResStation/(float)cycle);

                if (reportTraceAndHitMiss) {
                        fprintf(outFile, "Unpredictability Threshold= %f\n", (dou
      ble)unpredMemOpThreshold/(double)COEFF);
                        fprintf(outFile, "Num Unpred. Ins:          = %ld\n", 
      unpredMemInsCnt);
                        fprintf(outFile, "Num Unpred. Ops:          = %ld\n", 
      unpredMemOpCnt);
                        fprintf(outFile, "Unpred. Ins Rate:         = %f\n", (flo
      at)unpredMemOpCnt/(float)insCount);
                }
                if (makePhrase) {
                        fprintf(outFile, "Max Phrases Size                = %d\n"
      , phraseSizeBound);
                        fprintf(outFile, "Unpredictable Ins Threshold     = %f\n"
      , (double)unpredMemOpThreshold/(double)COEFF);
                        fprintf(outFile, "Num Phrases                     = %ld\n
      ", totNumPhrase);
                        fprintf(outFile, "Avg. Num Ins/Phrase             = %f\n"
      , (float)insCount/(float)totNumPhrase);
                        fprintf(outFile, "Tot Num SoftBound Partitions    = %ld\n
      ", totNumSoftBound);
                        fprintf(outFile, "Avg. Num SoftBound/Phrase       = %f\n"
      , (float)totNumSoftBound/(float)totNumPhrase);
                        fprintf(outFile, "Tot Num Unpred. Ins             = %ld\n
      ", totNumPhUnpredMemOp);
                        fprintf(outFile, "Num Unpred. Ins/Phrase          = %f\n"
      , (float)totNumPhUnpredMemOp/(float)totNumPhrase);
                        fprintf(outFile, "Num Unpred. Ins/Total Ins       = %f\n"
      , (float)totNumPhUnpredMemOp/(float)insCount);
                        fprintf(outFile, "Tot Num Root Ins                = %ld\n
      ", totNumRootIns);
                        fprintf(outFile, "Num Root Ins/Phrase             = %f\n"
      , (float)totNumRootIns/(float)totNumPhrase);
                        fprintf(outFile, "Tot Num Phrase Ancestors        = %ld\n
      ", totNumPhraseAncestors);
                        fprintf(outFile, "NumPhrase Ancestors/Phrase      = %f\n"
      , (float)totNumPhraseAncestors/(float)totNumPhrase);
                        fprintf(outFile, "Num of Resetting Times          = %ld\n
      \n", totNumPhGenResets);
                        fprintf(outFile, "Num Fragment                    = %ld\n
      ", totNumFrag);
                        fprintf(outFile, "Num Root Phrases                = %ld\n
      ", totNumRootPh);
                        fprintf(outFile, "Root Phrases Rate               = %f\n"
      , (double)totNumRootPh/(double)totNumPhrase);
                        fprintf(outFile, "Num Critical Path Violations    = %ld\n
      ", totNumCritPathViol);
                        fprintf(outFile, "Critical Path Violations Rate   = %f\n"
      , (double)totNumCritPathViol/(double)totNumPhrase);
                        fprintf(outFile, "Avg. Num Ins/Fragment           = %f\n"
      , (float)insCount/(float)totNumFrag);
                        fprintf(outFile, "Avg. Num Fragment/Phrase        = %f\n"
      , (float)totNumFrag/(float)totNumPhrase);
                }
                if (coreType == PHRASE || coreType == FRAGMENT) {
                        fprintf(outFile, "Num Phrases                     = %ld\n
      ", totNumPhrase);
                        fprintf(outFile, "Avg. Num Ins/Fragment           = %f\n"
      , (float)insCount/(float)totNumFrag);
                        fprintf(outFile, "Avg. Num Fragment/Phrase        = %f\n"
      , (float)totNumFrag/(float)totNumPhrase);
                        fprintf(outFile, "Avg. Num Ins/Phrase             = %f\n"
      , (float)insCount/(float)totNumPhrase);
                        fprintf(outFile, "Latency/Phrase                  = %f\n"
      , (float)totalLatency(0)/(float)totNumPhrase);
                        fprintf(outFile, "Tot Phrase Stall Time           = %ld\n
      ", totPhStall);
                        fprintf(outFile, "Avg. Phrase Stall Time          = %f\n"
      , (float)totPhStall/(float)totNumPhrase);
                        fprintf(outFile, "Unexpected Miss Count           = %ld\n
      ", unexpectedMiss);
                        fprintf(outFile, "Unexpected Miss Rate            = %f\n"
      , (float)unexpectedMiss/(float)missCount(cacheLat[0]));
                        fprintf(outFile, "Unexpected Miss Latency         = %ld\n
      ", unexpecteedLat);
                        fprintf(outFile, "Unexpected Avg. Miss Lat        = %f\n"
      , (float)unexpecteedLat/(float)unexpectedMiss);
                        fprintf(outFile, "Unexpected Miss Lat Rate        = %f\n"
      , (float)unexpecteedLat/(float)missLatency(0));
                }
                if (coreType == FRAGMENT) {
                        fprintf(outFile, "Num Fragment                    = %ld\n
      ", totNumFrag);
                        fprintf(outFile, "Tot Fragment Stall Time         = %ld\n
      ", totFrStall);
                        fprintf(outFile, "Avg. Fragment  Stall Time       = %f\n"
      , (float)totFrStall/(float)totNumFrag);
                        fprintf(outFile, "Num Real Fragment               = %ld\n
      ", totNumRealFrag);
                        fprintf(outFile, "Real Frag/Tot Frag              = %f\n"
      , (float)totNumRealFrag/(float)totNumFrag);
                        fprintf(outFile, "Avg. Num Ins/Real Frag          = %f\n"
      , (float)totSizRealFrag/(float)totNumRealFrag);
                        fprintf(outFile, "Num of Single Frag Wavefront    = %ld\n
      ", totNumOfSigleFragPhrases);
                        fprintf(outFile, "Avg. Num Real Frag/Phrase       = %f\n"
      , (double)totNumRealFrag/(double)(totNumPhrase-totNumOfSigleFragPhrases));
                        fprintf(outFile, "Avg. Num Ready Frags            = %f\n"
      , (double)numReadyFrags/(double)totNumFrag);
                        fprintf(outFile, "Inter-Fragment Stall Time       = %ld\n
      ", interFragStallCycle);
                        fprintf(outFile, "Inter-Fragment Stall Rate       = %f\n\
      n", (double)interFragStallCycle/(double)cycle);

                }


                fprintf(outFile, "---    ---    ---    ---    ---    ----   \n");
      
                for (int  i = 0; i < numSideBuffs; i++) {
                        fprintf(outFile, "SB INDEX                = %d\n",i);
                        fprintf(outFile, "Num SB Activations      = %ld\n",
      numSBactivations[i]);
                        fprintf(outFile, "Num SB ReActivations    = %ld\n",
      numSBreactivations[i]);
                        fprintf(outFile, "SB Reactivation Rate    = %f\n",(float)
      numSBreactivations[i]/(float)numSBactivations[i]);
                        fprintf(outFile, "SB Size                 = %lu\n",
      SBsize[i]);
                        fprintf(outFile, "Avg SB Size             = %f\n",(float)
      SBsize[i]/(float)numSBactivations[i]);
                        fprintf(outFile, "Num Ins Visit SB        = %ld\n",
      insVisitingSBcount[i]);
                        fprintf(outFile, "Rate of Ins Visiting SB = %f\n",(float)
      insVisitingSBcount[i]/(float)insCount);
                        fprintf(outFile, "Ins Exe When SB ON      = %ld\n",
      InsCountWhenSBon[i]);
                        fprintf(outFile, "Ins Exe When SB ON IPC  = %f\n",(float)
      InsCountWhenSBon[i]/(float)SBactiveCycles[i]);
                        fprintf(outFile, "SB ON Avg. Time         = %f\n\n",(floa
      t)(cycle-SBoffCycles[i])/(float)cycle);
                        fprintf(outFile, "Frame Win Avg. Size    = %f\n",(float)(
      totFrameSize)/(float)numSBactivations[i]);
                        fprintf(outFile, "Frame NonSB Ins Avg Cnt= %f\n",(float)(
      totMainStreamBound)/(float)numSBactivations[i]);
                        fprintf(outFile, "Frame Window Sat Rate  = %f\n",(float)(
      windowSatration)/(float)numSBactivations[i]);  //TODO THIS IS NOT A VECTOR ELEMEN
      T, fix
                        fprintf(outFile, "Frame ON longLat op Rate  = %f\n",(floa
      t)(longLatOpWhenSPisON)/(float)numSBactivations[i]);  //TODO THIS IS NOT A VECTOR
       ELEMENT, fix
                        fprintf(outFile, "Frame ON-Drain longLat Rat= %f\n",(floa
      t)(longLatOpWhenSPisDraining)/(float)numSBactivations[i]);  //TODO THIS IS NOT A 
      VECTOR ELEMENT, fix
                        fprintf(outFile, "Frame ON-Wait longLat Rate= %f\n",(floa
      t)(longLatOpWhenSPisWaiting)/(float)numSBactivations[i]);  //TODO THIS IS NOT A V
      ECTOR ELEMENT, fix
                        fprintf(outFile, "---    ---    ---    ---    ---    ----
         \n");
                }


                fprintf(outFile, "\nNumber of MEM Ops       = %ld\n",numMemOps);
                fprintf(outFile, "Number of ALU Ops         = %ld\n",numALUOps);
                fprintf(outFile, "Number of FPU Ops         = %ld\n",numFPUOps);
                fprintf(outFile, "Number of BR  Ops         = %ld\n",numBROps);
                fprintf(outFile, "Number of ASSIGN  Ops     = %ld\n",
      numAssignOps);
                fprintf(outFile, "Number of READ Ops        = %ld\n",numReadOps);
      
                fprintf(outFile, "Number of WRITE Ops       = %ld\n",numWriteOps)
      ;
                fprintf(outFile, "Number Mis-Pred BR Ops (Fetch)     = %ld, Rate:
       %f\n",missPredBROps_fetch, (float)missPredBROps_fetch/(float)numBROps);
                fprintf(outFile, "Number Mis-Pred BR Ops (Commit)    = %ld, Rate:
       %f\n",missPredBROps, (float)missPredBROps/(float)numBROps);
                fprintf(outFile, "Number Mis-Pred_NT BR Ops (Fetch)  = %ld, Rate:
       %f\n",missPredBROps_NT_fetch, (float)missPredBROps_NT_fetch/(float)numBROps);
                fprintf(outFile, "Number Mis-Pred_NT BR Ops (Commit) = %ld, Rate:
       %f\n",missPredBROps_NT, (float)missPredBROps_NT/(float)numBROps);
                fprintf(outFile, "Number Pred_NT R Ops (Fetch)       = %ld, Rate:
       %f\n",numBrOps_predT_fetch, (float)numBrOps_predT_fetch/(float)numBROps);
                fprintf(outFile, "Number Pred_T BR Ops (Commit)      = %ld, Rate:
       %f\n",numBrOps_predT, (float)numBrOps_predT/(float)numBROps);
                fprintf(outFile, "Store FWD READ Ops        = %ld\n",stFwdMemOp);
      
                fprintf(outFile, "Store FWD READ/All READ   = %f\n",(float)
      stFwdMemOp/(float)numReadOps);
                fprintf(outFile, "Non-blocking READ Ops     = %ld\n",
      nonBlockingMemOp);
                fprintf(outFile, "Non-blck READ/All READ    = %f\n",(float)
      nonBlockingMemOp/(float)numReadOps);
                fprintf(outFile, "Cache Axes READ Ops       = %ld\n",maxSBsize);
                fprintf(outFile, "Cache Axes READ/All READ  = %f\n",(float)
      maxSBsize/(float)numReadOps);
                fprintf(outFile, "MEM Ops Rate          = %f\n",(float)numMemOps/
      (float)insCount);
                fprintf(outFile, "ALU Ops Rate          = %f\n",(float)numALUOps/
      (float)insCount);
                fprintf(outFile, "FPU Ops Rate          = %f\n",(float)numFPUOps/
      (float)insCount);
                fprintf(outFile, "BR  Ops Rate          = %f\n",(float)numBROps/(
      float)insCount);
                fprintf(outFile, "ASSIGN  Ops Rate      = %f\n",(float)
      numAssignOps/(float)insCount);
                fprintf(outFile, "READ Ops Rate         = %f\n",(float)
      numReadOps/(float)insCount);
                fprintf(outFile, "WRITE Ops Rate        = %f\n",(float)
      numWriteOps/(float)insCount);
                fprintf(outFile, "READ/MEM  Ops Rate    = %f\n",(float)
      numReadOps/(float)numMemOps);
                fprintf(outFile, "WRITE/MEM Ops Rate    = %f\n\n",(float)
      numWriteOps/(float)numMemOps);
                fprintf(outFile, "------------------------------------------\n");
      
        //}
        //fprintf(outFile, "SB Sizes:\n");
        //for (int x = 0; x < SBsizeList->NumElements(); x++)
        //      fprintf(outFile, "%d\n", SBsizeList->Nth(x));
        //fprintf(outFile, "------------------------------------------\n");
        //fprintf(outFile, "SB Sizes (SORTED):\n");
        //quicksort(SBsizeList,0,SBsizeList->NumElements()-1,cycle);
        //for (int x = 0; x < SBsizeList->NumElements(); x++)
        //      fprintf(outFile, "%d\n", SBsizeList->Nth(x));

        if (coreType == FRAGMENT || coreType == FRAGMENT2) {
                frSizeHist->report(outFile, "Frag Size Hist");
                frLatHist->report(outFile, "Frag Latency Hist");
        } 
        else if (coreType == PHRASE) {
                //phCritPathHist->report(outFile, "Phrase Critical Path Hist");
                //phSizeHist->report(outFile, "Phrase Size Hist");
        }
        if (coreType == STRAND || coreType == PHRASEBLOCK) {
                fprintf(outFile, "STRAND COUNT: %lld\n", dyn_num_strands);
                fprintf(outFile, "TOT NUM INS IN STRAND: %lld\n", 
      total_num_strand_ins);
                fprintf(outFile, "AVG. STRAND SIZE: %f\n", (double)
      total_num_strand_ins/(double)dyn_num_strands);
                fprintf(outFile, "Percent of Ins in Strands: %f\n", (double)
      total_num_strand_ins/(double)insCount*100.0);
        } 
        /* PHRASEBLOCK EXE STAT */
        else if (coreType == PHRASEBLOCK) {
                fprintf(outFile, "Total Num PB/BB Ran: %ld\n", bbCount);
                fprintf(outFile, "AVG. Active BB/PB Ratio: %f\n", (double)
      activeBuffCnt/(double)cycle);
                fprintf(outFile, "Average # of Cycles b/w BP Lookup & Update: %f\
      n", (double)br_pred_update_dist/(double)brInsCount);
        }
        for (int i = 0; i < NUM_FUNC_UNIT; i++)
                fprintf(outFile, "Res Stn %d Utilization  = %f\n", i, (float)
      iResStnsSize[i]/(float)cycle);
        for (int i = 0; i < NUM_PHRASEBLKS; i++)
                fprintf(outFile, "Phraseblock %d Utilization  = %f\n", i, (float)
      pbListsSize[i]/(float)cycle);
        if (reportTraceAndHitMiss == true) {
                correlationHist->report(outFile, "Miss Rate Correlation between I
      NO Schedule and the 'new' schedule");
        }
        numParentsHist->report(outFile, "Num of Ancestors Hist");
        numChildrenHist->report(outFile, "Num of Dependents Hist");
        numParentsHist->report();
        numChildrenHist->report();

        map<long int, int>::iterator wbb_it;
        for (wbb_it = num_ins_exe_cnt.end(); wbb_it != num_ins_exe_cnt.begin(); w
      bb_it--) {
                long int insAddr = wbb_it->first;
                fprintf(wbbSkipCountFile, "%ld, %d, %d, %f\n",  insAddr,
                                                                                                                
      num_ins_exe_cnt[insAddr],
                                                                                                                
      num_bypassed_wbb[insAddr],
                                                                                                                f
      loat(num_bypassed_wbb[insAddr])/float(num_ins_exe_cnt[insAddr]));
        }
        map<long int, int>::iterator br_it;
        for (br_it = num_ins_exe_cnt.end(); br_it != num_ins_exe_cnt.begin(); br_
      it--) {
                long int insAddr = br_it->first;
                fprintf(brSkipAccuracyFile, "%ld, %d, %f, %f\n",insAddr,
                                                                                                                
      num_ins_exe_cnt[insAddr],
                                                                                                                
      ins_exe_hoist_accuracy[insAddr],
                                                                                                                f
      loat(ins_exe_hoist_accuracy[insAddr])/float(num_ins_exe_cnt[insAddr]));
        }
        fclose(wbbSkipCountFile);
        fclose(brSkipAccuracyFile);
        fclose (pinFile);
        fclose (outFile);
        if (reschedule == true) fclose (reScheduleFile);
        if (makePhrase == true) fclose (phraseFile);
        printf("DONE TRACING!\n");

        delete iResStation;
        delete iMemBuf;
        delete iWindow;
        delete iROB;
        //delete iSideBuff[0];
        delete _L1;
        delete _L2;
        delete _L3;
        delete [] iSideBuff;

        delete [] numSBreactivations;
        delete [] insVisitingSBcount;
        delete [] numSBactivations;
        delete [] InsCountWhenSBon;
        delete [] SBactiveCycles;
        delete [] SBoffCycles;
        delete [] SBsize;
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{bkEnd_8h_aa41656fd1e95e4bdc43191b18dfd8102}{
\index{bkEnd.h@{bkEnd.h}!bkEnd\_\-heading@{bkEnd\_\-heading}}
\index{bkEnd\_\-heading@{bkEnd\_\-heading}!bkEnd.h@{bkEnd.h}}
\subsubsection[{bkEnd\_\-heading}]{\setlength{\rightskip}{0pt plus 5cm}void bkEnd\_\-heading (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char const $\ast$}]{argv\mbox{[}$\,$\mbox{]}}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8h_aa41656fd1e95e4bdc43191b18dfd8102}

\begin{DoxyCode}
                                                  {
        printf("-----------------------------------------\n");
        printf("COMMAND:          ");
        for (int i = 0; i < argc; i++) {
                printf("%s ", argv[i]);
        }
        printf("\n");
        printf("CACHE LAT:       = ");
        for (int i = 0; i < MEM_HIGHERARCHY; i++) {
                printf("%d, ", cacheLat[i]);
        }
        printf("\n");
        printf("CORE TYPE         = %d\n", coreType);
        printf("Perf Reg Renaming = %d (Size: %d)\n", perfectRegRen, GRRF_SIZE);
        printf("LSQ Model         = %d (LQ: %d, SQ %d)\n", memoryModel, LQ_SIZE, 
      SQ_SIZE);
        printf("ROB Size              = %d\n", ROBsize);
        printf("1 LD Lat Lvl      = %ld\n", oneLevDeepLatLevel);
        printf("Frame Buffer Size = %ld\n", SBlength);
        printf("Num Side Buffs    = %ld\n", numSideBuffs);
        printf("IN FILE               = %s\n", inFileName.c_str());
        printf("OUT FILE          = %s\n", outFileName1.c_str());
        if (reschedule == true) printf("VLIW TRACE FILE = %s\n", 
      reScheduleFileName.c_str());
        if (makePhrase == true) printf("PHRASE TRACE FILE = %s\n", 
      phrasingFileName.c_str());
        if (reportTraceAndHitMiss == true) 
                                printf("UNPRED MEM TRACE FILE = %s\n", 
      reScheduleFileName.c_str());
        printf("COMMENT          = %s\n", comment);
        printf("-----------------------------------------\n");

        outFile = outFile1;
        fprintf(outFile, "-----------------------------------------\n");
        fprintf(outFile, "COMMAND:          ");
        for (int i = 0; i < argc; i++) {
                fprintf(outFile, "%s ", argv[i]);
        }
        fprintf(outFile, "\n");
        fprintf(outFile, "CACHE LAT:       = ");
        for (int i = 0; i < MEM_HIGHERARCHY; i++) {
                fprintf(outFile, "%d, ", cacheLat[i]);
        }
        fprintf(outFile, "\n");
        fprintf(outFile, "CORE TYPE        = %d\n", coreType);
        fprintf(outFile, "ROB Size                 = %d\n", ROBsize);
        fprintf(outFile, "1 LD Lat Lvl     = %ld\n", oneLevDeepLatLevel);
        fprintf(outFile, "Frame Buffer Size= %ld\n", SBlength);
        fprintf(outFile, "Num Side Buffs   = %ld\n", numSideBuffs);
        fprintf(outFile, "IN FILE          = %s\n", inFileName.c_str());
        fprintf(outFile, "OUT FILE         = %s\n", outFileName1.c_str());
        if (reschedule == true) fprintf(outFile,"VLIW TRACE FILE = %s\n", 
      reScheduleFileName.c_str());
        if (makePhrase == true) fprintf(outFile,"PHRASE TRACE FILE = %s\n", 
      phrasingFileName.c_str());
        if (reportTraceAndHitMiss == true) 
                                fprintf(outFile,"UNPRED MEM TRACE FILE = %s\n", 
      reScheduleFileName.c_str());
        fprintf(outFile,"COMMENT                 = %s\n", comment);
        fprintf(outFile, "-----------------------------------------\n");
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{bkEnd_8h_a2610cc7850729dad55450e26627d78ae}{
\index{bkEnd.h@{bkEnd.h}!bkEnd\_\-init@{bkEnd\_\-init}}
\index{bkEnd\_\-init@{bkEnd\_\-init}!bkEnd.h@{bkEnd.h}}
\subsubsection[{bkEnd\_\-init}]{\setlength{\rightskip}{0pt plus 5cm}void bkEnd\_\-init (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char const $\ast$}]{argv\mbox{[}$\,$\mbox{]}, }
\item[{{\bf g\_\-variable} \&}]{g\_\-var}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8h_a2610cc7850729dad55450e26627d78ae}

\begin{DoxyCode}
                                                                   {
        junk=fopen("junk_bzip.txt", "w");
        for (int i = 0; i < numSideBuffs; i++) {
                numSBreactivations[i] = 0;
                insVisitingSBcount[i] = 0;
                numSBactivations[i] = 0;
                InsCountWhenSBon[i] = 0;
                SBactiveCycles[i] = 0;
                SBoffCycles[i] = 0;
                SBsize[i] = 0;
        }
        //Initialize Branch Predictor
    predictor = new TournamentBP(2048, 2, 2048, 11, 8192, 13, 2, 8192, 2, 0);

        //Set cache level latencies
        cacheLat[0] = L1_LATENCY;
        cacheLat[1] = L2_LATENCY;
        cacheLat[2] = L3_LATENCY;
        cacheLat[3] = MEM_LATENCY;

        oneLevDeepLatLevel = cacheLat[0];
        xLevDeepLatLevel   = cacheLat[0];

        //Set core type
        coreType =IN_ORDER ; //;OUT_OF_ORDER;ONE_LEVEL_DEEP_DYN 
        ROBsize = ROB_SIZE;
        pbROBsize = PB_ROB_SIZE;
        
        //Comment
        comment = new char[500];

        //Parse inputs
        int c;
        int temp = -1;
        while ((c = getopt (argc, (char **)argv, "l:o:i:u:f:c:w:s:b:t:m:p:r:h:a:1
      :2:3:4:n:d:e:v:g:j:k:x:y:z:")) != -1) 
        {   
                switch(c)
                {   
                case 'l':
                        xLevDeepLatLevel = atoi(optarg);
                        break;
                case 'o':
                        outFileName1.assign(optarg);
                        break;
                case 'i':
                        inFileName.assign(optarg);
                        break;
                case 'u':
                        reScheduleFileName.assign(optarg);
                        break;
                case 'f':
                        phrasingFileName.assign(optarg);
                        break;
                case 'c':
                        coreType = (core) atoi(optarg);
                        break;
                case 'w':
                        ROBsize = atoi(optarg);
                        break;
                case 's':
                        numSideBuffs = atoi(optarg);
                        break;
                case 'b':
                        SBlength = atoi(optarg);
                        break;
                case 't':
                        temp = atoi(optarg);
                        if (temp == 0)  reportTrace = false;
                        else            reportTrace = true;
                        Assert(temp == 1 || temp == 0);
                        break;
                case 'm':
                        temp = atoi(optarg);
                        if (temp == 0)  reportTraceAndHitMiss = false;
                        else            reportTraceAndHitMiss = true;
                        Assert(temp == 1 || temp == 0);
                        break;
                case 'p':
                        temp = atoi(optarg);
                        if (temp == 0)  makePhrase = false;
                        else            makePhrase = true;
                        Assert(temp == 1 || temp == 0);
                        break;
                case 'r':
                        temp = atoi(optarg);
                        if (temp == 0)  reschedule = false;
                        else            reschedule = true;
                        Assert(temp == 1 || temp == 0);
                        break;
                case 'h':
                        unpredMemOpThreshold = atof(optarg);
                        break;
                case 'a':
                        phraseSizeBound = atoi(optarg);
                        break;
                case '1':
                        cacheLat[0] = atoi(optarg);
                        break;
                case '2':
                        cacheLat[1] = atoi(optarg);
                        break;
                case '3':
                        cacheLat[2] = atoi(optarg);
                        break;
                case '4':
                        cacheLat[3] = atoi(optarg);
                        break;
                case 'n': //NOTE: incomplete - only implemented for single issue 
      INO and OOO
                        numFU = atoi(optarg);
                        break;
                case 'd':
                        parseHitMiss = atoi(optarg);
                        break;
                case 'e':
                        comment = optarg;
                        break;
                case 'v':
                        evaltMissRtCorrel = atoi(optarg);
                        break;
                case 'g':
                        temp = atoi(optarg);
                        if (temp == 0)  UPLDhoist = false;
                        else            UPLDhoist = true;
                        break;
                case 'j':
                        branchMode = (brMode) atoi(optarg);
                        break;
                case 'k':
                        insParseCap = atoi(optarg);
                        Assert(insParseCap > 0);
                        break;
                case 'x':
                        wbb_skip_count.assign(optarg);
                        break;
                case 'y':
                        temp = atoi(optarg);
                        if (temp == 0)  branchProfileFlag = false;
                        else                    branchProfileFlag = true;
                        break;
                case 'z':
                        branchProfileFileName.assign(optarg);
                        break;
                default:
                        //Unrecognized input. Terminate the run
                        exit(-1);
                };
        }
        //Assert(branchMode >= noBr && branchMode <= scheduleBr);

        //Build the cache
        _L1 = new cache(1, 64, 32768  ); //32KB
        _L2 = new cache(1, 64, 2097152); //2MB
        _L3 = new cache(1, 64, 8388608); //8MB

        //Build functional units status
        for (int i = 0; i < NUM_FUNC_UNIT; i++) {
                aluAvail   [i] = true;
                aluFreeTime[i] = 0;
                aluStat    [i] = 0;
                if (i == 0) {
                        aluKind[i] = MEM;
                } else {
                        aluKind[i] = ALU;
                }
        }
        
        //Build instruction window (empty right now)
        iROB           = new List<instruction*>;
        pbROB          = new List<basicblock*>;
        ICQ            = new List<char*>;
        iWindow        = new List<instruction*>;
        iMemBuf        = new List<instruction*>;
        iResStation    = new List<instruction*>;
        SBpriorityList = new List<int>;
        iSideBuff   = new sideBuff* [NUM_SIDE_BUFFERS];
        for (int i = 0; i < NUM_FUNC_UNIT; i++)
                iResStations[i] = new List<instruction*>;
        for (int i = 0; i < NUM_SIDE_BUFFERS; i++)
                iSideBuff[i] = new sideBuff;
        for (int i = 0; i < NUM_FUNC_UNIT; i++)
                iResStnsSize[i] = 0;
        for (int i = 0; i < NUM_PHRASEBLKS; i++)
                pbListsSize[i] = 0;

        //Open files
        sprintf(outFileName2,"%sSum",outFileName1.c_str());
        if((pinFile=fopen(inFileName.c_str(), "r")) == NULL || 
           (outFile1=fopen(outFileName1.c_str(), "w+")) == NULL) {// ||
           //(outFile2=fopen(outFileName2, "w+")) == NULL) {
            printf("1-ERROR: Cannot open file(s).\n");
            exit(1);
        }
        if(//reschedule == true &&
           (reScheduleFile=fopen(reScheduleFileName.c_str(), "w")) == NULL) {
            printf("2-ERROR: Cannot open file(s).\n");
            exit(1);
        }
        if (makePhrase == true &&
           (phraseFile=fopen(phrasingFileName.c_str(), "w")) == NULL) {
            printf("3-ERROR: Cannot open file(s).\n");
            exit(1);
        }

        if (branchProfileFlag == true &&
            ((branchProfile=fopen(branchProfileFileName.c_str(), "r")) == NULL ||
      
             (branchAccuracy=fopen(branchAccuracyFileName.c_str(), "r")) == NULL)
      ) {
            printf("4-ERROR: Cannot open file(s).\n");
            exit(1);
        } else if (branchProfileFlag == true) {
                int total_count, taken_count, bbl_size;
                long int ins_addr, dst_addr;
                float taken_rate;
                while(fscanf(branchProfile, "%ld, %d, %d, %d, %f, %ld\n", &ins_ad
      dr, &bbl_size, &total_count, &taken_count, &taken_rate, &dst_addr) != EOF) {
                //while(fscanf(branchProfile, "%ld, %d, %d, %f\n", &ins_addr, &to
      tal_count, &taken_count, &taken_rate) != EOF) {
                        branchBiasProfileMap[ins_addr] = taken_rate;
                }
                while(fscanf(branchAccuracy, "%ld, %f\n", &ins_addr, &taken_rate)
       != EOF) {
                        branchAccuracyMap[ins_addr] = taken_rate;
                }
        }


        if (upldProfileFlag == true &&
           (upldProfile=fopen(upldProfileFileName.c_str(), "r")) == NULL) {
            printf("4-ERROR: Cannot open file(s).\n");
            exit(1);
        } else if (upldProfileFlag == true) {
                long int ins_addr;
                float miss_rate;
                while(fscanf(upldProfile, "(%ld, %f)\n", &ins_addr, &miss_rate) !
      = EOF) {
                        upldMissRateProfileMap[ins_addr] = miss_rate;
                }
        }
        
        if ((wbbSkipCountFile=fopen(wbb_skip_count.c_str(), "w")) == NULL) {
            printf("3-ERROR: Cannot open file(s).\n");
            exit(1);
        }
        if ((brSkipAccuracyFile=fopen(br_skip_accuracy.c_str(), "w")) == NULL) {
            printf("3-ERROR: Cannot open file(s).\n");
            exit(1);
        }

        //Debug
        debug = false;

        //Invalid instruction counter
        invalidInsCount = 0;

        //EOC/EOF flags
        eoc = false;
        eof = false;

        corruptInsCount = 0;

        //generates the instruction Id
        insID = 0;
        cycle = 0;
        insCount = 0;
        completeInsCount = 0;
        executeInsCount = 0;

        //Histogram
        if (coreType == FRAGMENT || coreType == FRAGMENT2) {
                frSizeHist = new hist(phraseSizeBound+1, 0, phraseSizeBound+1);
                frLatHist = new hist(750, 0, 750);
        } else if (coreType == PHRASE) {
                //phCritPathHist = new hist(cacheLat[0]*phraseSizeBound, 0, cache
      Lat[0]*phraseSizeBound);
                //phSizeHist = new hist(phraseSizeBound+1, 0, phraseSizeBound+1);
      
        }
        numChildrenHist = new hist(ROBsize, 0, ROBsize);
        numParentsHist  = new hist(ROBsize, 0, ROBsize);

        //Parser
        parse = new parser;

        //Register Configuration
        if (perfectRegRen == true) {
                //Build x86 register file
                RF = new regFile;
                //Setup Dependency Table Obj for REG, MRM & BR
                depTables = new dependencyTable;
        } else { //Build an actual RF system
                switch (coreType) {
                        case IN_ORDER:
                                //Setup Dependency Table Obj for REG, MRM & BR
                                depTables = new dependencyTable;
                                break;
                        case OUT_OF_ORDER:
                                //Setup RR Obj for all reg
                                GRF = new registerRename(LARF_LO,GARF_HI);
                                //Setup Dependency Table Obj for MRM & BR
                                depTables = new dependencyTable;
                                break;
                        case PHRASEBLOCK:
                                //Setup RR Obj for global reg
                                GRF = new registerRename;
                                //GRF = new registerRename(LARF_LO,GARF_HI); /* f
      or no LRF */
                                //Setup Dependency Table Obj for local reg
                                for (int i = 0; i < NUM_PHRASEBLKS; i++) {
                                        LRFTables[i] = new dependencyTable;
                                }
                                //Setup Dependency Table Obj for MRM & BR
                                depTables = new dependencyTable;
                                break;
                        default: 
                                Assert(true == false && "Register allocation regu
      laion is not defined for this core.");
                };
        }
        
        //LSQ Configuration
        if (memoryModel == PERFECT) {
                ;//nothing to be done
        } else if (memoryModel == TOTAL_ORDER || memoryModel == NAIVE_SPECUL) {
                loadStoreQue = new lsq;
        }

        //INO is only valid when perfectRegRen is disabled
        if (coreType == IN_ORDER)
                Assert(perfectRegRen == false && "INO and perfectRegRen produce m
      eaningless results");
        
        //Initialize the frontend variables
        __g_var = &g_var;

        //phraseblock initialization
        if (coreType == PHRASEBLOCK) {
                _pbLists = new List<instruction*>* [NUM_PHRASEBLKS];
                for (int i = 0; i < NUM_PHRASEBLKS; i++) {
                        _pbLists[i] = new List<instruction*>;
                }
        }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{bkEnd_8h_a0de885ce07273f37e162ecb0e63ec95d}{
\index{bkEnd.h@{bkEnd.h}!bkEnd\_\-run@{bkEnd\_\-run}}
\index{bkEnd\_\-run@{bkEnd\_\-run}!bkEnd.h@{bkEnd.h}}
\subsubsection[{bkEnd\_\-run}]{\setlength{\rightskip}{0pt plus 5cm}void bkEnd\_\-run (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8h_a0de885ce07273f37e162ecb0e63ec95d}

\begin{DoxyCode}
                  {
        //VLIW Scheduler
        if (reschedule == true) {
                bool addMoreIns = true;
                vliwScheduler* schedule = new vliwScheduler;
                while (true) {
                        cycle++;
                        if (eoc == false && addMoreIns == true) addIns(cycle);
                        else if (eoc == true && iROB->NumElements() == 0) break; 
      //TODO double check this line
                        if (numFU == 1) { //VLIW scheduling (normal) for 1FU
                                addMoreIns = schedule->scheduleInsStream_1FU(
      iROB,cycle,false,reScheduleFile);
                        } else { //VLIW scheduling (normal) for multiple FU's
                                addMoreIns = schedule->scheduleInsStream(iROB,
      cycle,UPLDhoist,reScheduleFile,unpredMemOpThreshold);
                        }
                        //Runtime Stat
                        if (cycle%100000==0) {
                                printf ("Cycle %ld\n", cycle);
                                //printf("Ins Count = %d\n", insCount); //TODO ad
      d this line later
                        }
                }
                delete schedule;
        }

        // Phrase Maker
        else if (makePhrase == true) {
                bool addMoreIns = true;
                vliwScheduler* schedule = new vliwScheduler;
                List<phrase*>* phList = new List<phrase*>;
                while (true) {
                        cycle++;
                        if (eoc == false && addMoreIns == true) schedule->
      parseIns(ROBsize, parse, cycle);
                        else if (eoc == true) break; //TODO double check this lin
      e
                        //while (iWindow->NumElements() > 0) {iWindow->RemoveAt(0
      );}//Drain it to avoid core dump (TODO optimize it out later)
                        addMoreIns = schedule->schedulePhraseinsStream(iROB,
      cycle,UPLDhoist,reScheduleFile,unpredMemOpThreshold,phList);
                        //Runtime Stat
                        if (cycle%10000==0) {
                                printf ("Cycle %ld\n", cycle);
                                printf("Ins Count = %ld\n", insCount);
                        }
                }
                delete schedule;
        }
        //----
        //else if (makePhrase == true) {
        //      printf("\n---WARNING: SET THE CORRECT unpredMemOpThreshold VALUE!
      !!---\n\n");
        //      int numPhrases = -1;
        //      phraseGen* phGen = new phraseGen;
        //      while (true) {
        //              cycle++;
        //              if (iROB->NumElements() == 0) printf("***********ROB DONE
      \n");
        //              if (iWindow->NumElements() == 0) printf("***********iWIN 
      DONE\n");
        //              if (eoc == true) printf("END OF FILE\n");
        //              //if (numPhrases == 0) printf("PHRASES DONE\n");
        //              //else printf("num phrases = %d\n", numPhrases);
        //
        //              if (eoc == false) addIns(cycle);
        //              else if (eoc == true &&
        //                       numPhrases == 0 &&
        //                       iROB->NumElements() == 0) break;
        //              numPhrases = phGen->runPhraseGen(iROB, iWindow, phraseFil
      e, depTables, eoc, ROBsize);
        //              if (cycle%300000==0) {
        //                      printf ("Instruction: %d\n", iWindow->Nth(0)->get
      InsID());
        //              }
        //      }
        //      /*-----STAT-----*/
        //      totNumPhrase = phGen->getTotNumPhrases();
        //      totNumSoftBound = phGen->getTotNumSoftBound();
        //      totNumPhUnpredMemOp = phGen->getTotNumPhraseUPLD();
        //      totNumRootIns = phGen->getTotNumRootIns();
        //      totNumPhraseAncestors = phGen->getTotNumPhraseAncestors();
        //      totNumPhGenResets = phGen->getNumPhGenReset();
        //      insCount = phGen->getTotNumIns();
        //      totNumFrag = phGen->getTotNumFrags();
        //      totNumRootPh = phGen->getTotNumRootPh();
        //      totNumCritPathViol = phGen->getTotNumCritPathViolations();
        //      /*-----STAT-----*/
        //      //delete phGen;
        //}

        // Phrase Core
        else if (coreType == PHRASE) {
                List<phrase*> *iPh = new List<phrase*>;
                dot *d = new dot(0);
                long int phIndx = 0;
                long int phIdealLat;
                bool phStart = true;
                int phSize;
                int numInFlightPh = 0;
                if (eoc == false) addPhrase(iPh, cycle, d); //TODO temperary loca
      tion
                phSize = iPh->Nth(0)->getPhraseSize_unsort();
                //long int critPath = iPh->Nth(0)->findCriticalPath();
                //phCritPathHist->addElem(critPath);
                for (int i = 0; i < phSize; i++) {
                        iWindow->Append(iPh->Nth(0)->getNthIns_unsort(i));
                }
                numInFlightPh++;
                /*-----STAT-----*/
                phIdealLat = iPh->Nth(0)->getPhIdealLat();
                /*-----STAT-----*/
                while (true) {
                        cycle++;
                        if (phStart == true) phCycle++;
                        //Free the busy ALU's
                        freeALUs(cycle);
                        //Complete executed phrases
                        for (int i = 0; i < numInFlightPh; i++) {
                                completeIns(cycle,iPh->Nth(i)->getInsList_unsort(
      ));
                                commitIns(cycle,iPh->Nth(i)->getInsList_unsort())
      ;
                                //Complete executed phrases
                                completeIns(cycle,iPh->Nth(i)->getInsList_unsort(
      ));
                        }
                        //Add instructions to phrase
                        if (eoc == false) addPhrase (iPh, cycle, d);
                        //Check resources status - goto nxt iter if all busy
                        if (!isALUfree()) continue;
                        int temp = numInFlightPh;
                        for (int i = temp-1; i >= 0; i--) {
                                if (iPh->Nth(i)->getPhraseSize_unsort() == 0) {
                                        removePhrase(iPh, i);
                                        numInFlightPh--;
                                        Assert(numInFlightPh >= 0);
                                        //printf("removed:%d\n", numInFlightPh);
                                }
                        }
                        //Go to Next Phrase
                        if (iWindow->NumElements() == 0 && iPh->NumElements() > n
      umInFlightPh) {
                                phStart = false;
                                //removePhrase(iPh, 0);
                                //if (iPh->NumElements() == 0) break;
                                phIndx++;
                                /*-----STAT-----*/
                                //printf("%d, %d\n", phIdealLat/4, phCycle);
                                //Assert((phIdealLat/NUM_FUNC_UNIT-1) <= phCycle)
      ; //TODO this check is broken. fix it
                                totPhStall += phCycle - phIdealLat;
                                phIdealLat = iPh->Nth(0)->getPhIdealLat();
                                /*-----STAT-----*/
                                phCycle = 1;
                                //Assert(iWindow->NumElements() == 0);
                                phSize = iPh->Nth(numInFlightPh)->
      getPhraseSize_unsort();
                                //critPath = iPh->Nth(numInFlightPh)->findCritica
      lPath();
                                //phCritPathHist->addElem(iPh->Nth(numInFlightPh)
      ->findCriticalPath());
                                for (int i = 0; i < phSize; i++) {
                                        iWindow->Append(iPh->Nth(numInFlightPh)->
      getNthIns_unsort(i));
                                }
                                Assert(iWindow->NumElements() == iPh->Nth(numInFl
      ightPh)->getPhraseSize_unsort());
                                numInFlightPh++;
                        }
                        if (iPh->NumElements() == 0 && iWindow->NumElements() == 
      0) break;
                        //Run the core
                        runInOcore(cycle,iWindow);
                        if (iWindow->NumElements() < phSize) phStart = true;
                        //Runtime Stat
                        if (cycle%200000==0) {
                                ipc = (float)(insCount)/(float)(cycle);
                                printf ("Cycle %ld\n", cycle);
                                printf("IPC = %f\n", ipc);
                                //phCritPathHist->report();
                                //phSizeHist->report();
                                //printf("------\n");
                        }
                }
                d->finish();
                delete d;
                /*-----STAT-----*/
                totNumPhrase = phIndx+1;
                /*-----STAT-----*/
        }

        // Fragment Core
        else if (coreType == FRAGMENT) {
                List<fragment*> *iFr_wait  = new List<fragment*>;
                List<fragment*> *iFr_ready = new List<fragment*>;
                long int frIndx = 0;
                long int frIdealLat;
                bool frStart = true;
                int frSize;
                int numInFlightFrags = 0;
                if (eoc == false) addFrag (iFr_wait, cycle); //TODO temperary loc
      ation
                findReadyFrag(iFr_ready, iFr_wait);
                numReadyFrags += iFr_ready->NumElements();
                frSize = iFr_ready->Nth(0)->getFragSize();
                for (int i = 0; i < frSize; i++) {
                        iWindow->Append(iFr_ready->Nth(0)->getNthIns(i));
                }
                numInFlightFrags++;
                /*-----STAT-----*/
                frIdealLat = iFr_ready->Nth(0)->getFrIdealLat();
                /*-----STAT-----*/
                while (true) {
                        cycle++;
                        if (frStart == true) frCycle++;
                        //Free the busy ALU's
                        freeALUs(cycle);
                        for (int i = 0; i < numInFlightFrags; i++) {
                                //Complete executed fragments
                                completeIns(cycle,iFr_ready->Nth(i)->getInsList()
      );
                                commitIns(cycle,iFr_ready->Nth(i)->getInsList());
      
                                //Complete executed fragments
                                completeIns(cycle,iFr_ready->Nth(i)->getInsList()
      );
                        }
                        //Move Fragments from Wait List to Ready List
                        findReadyFrag(iFr_ready, iFr_wait);
                        //Add instructions to fragment
                        if (eoc == false) addFrag (iFr_wait, cycle);
                        //Check resources status - goto nxt iter if all busy
                        if (!isALUfree()) continue;
                        int temp = numInFlightFrags;
                        for (int i = temp-1; i >= 0; i--) {
                                if (iFr_ready->Nth(i)->getFragSize() == 0) {
                                        iFr_ready->Nth(i)->setEnd(cycle);
                                        frLatHist->addElem(iFr_ready->Nth(i)->
      getLat());
                                        removeFrag(iFr_ready, i);
                                        numInFlightFrags--;
                                        Assert(numInFlightFrags >= 0);
                                        //printf("removed:%d\n", numInFlightFrags
      );
                                }
                        }
                        //printf("num: %d,%d,%d,%d\n", iFr_ready->NumElements(), 
      iFr_ready->Nth(0)->getFragSize(), iWindow->NumElements(),numInFlightFrags);
                        //Go to Next Frag
                        if (iWindow->NumElements() == 0 && iFr_ready->
      NumElements() > numInFlightFrags) {
                                //printf("num ready frags=%d\n",iFr_ready->NumEle
      ments());
                                frStart = false;
                                //removeFrag(iFr_ready, 0);
                                frIndx++;
                                /*-----STAT-----*/
                                //printf("%d, %d\n", frIdealLat/4, frCycle);
                                //Assert((frIdealLat/NUM_FUNC_UNIT-1) <= frCycle)
      ; //TODO this check is broken. fix it
                                totFrStall += frCycle - frIdealLat/NUM_FUNC_UNIT;
      
                                //printf("%d\n",frCycle - frIdealLat/4);
                                frIdealLat = iFr_ready->Nth(0)->getFrIdealLat();
                                /*-----STAT-----*/
                                frCycle = 1;
                                //Assert(iWindow->NumElements() == 0);
                                //quicksortFragScore(iFr_ready, numInFlightFrags,
       iFr_ready->NumElements()-1, -1);
                                frSize = iFr_ready->Nth(numInFlightFrags)->
      getFragSize();
                                runningFragNumber = iFr_ready->Nth(numInFlightFra
      gs)->getFragNum();
                                //printf("%d\n", numInFlightFrags);
                                iFr_ready->Nth(numInFlightFrags)->setStart(cycle)
      ;
                                for (int i = 0; i < frSize; i++) {
                                        iWindow->Append(iFr_ready->Nth(numInFligh
      tFrags)->getNthIns(i));
                                }
                                Assert(iWindow->NumElements() == iFr_ready->Nth(n
      umInFlightFrags)->getFragSize());
                                numInFlightFrags++;
                                //printf("added:%d\n", numInFlightFrags);
                                /*-----STAT-----*/
                                if (frSize < phraseSizeBound) {
                                        totNumRealFrag++;
                                        totSizRealFrag += frSize;
                                } else {
                                        totNumOfSigleFragPhrases++;
                                }
                                numReadyFrags += iFr_ready->NumElements();
                                //printf("num ready frags = %d, %d\n", iFr_ready-
      >NumElements(), cycle);
                                /*-----STAT-----*/
                        }
                        if (iFr_wait->NumElements() == 0 && iFr_ready->
      NumElements() == 0 && iWindow->NumElements() == 0) break;
                        /*-----STAT-----*/
                        if (iFr_ready->NumElements()==0) {interFragStallCycle++; 
      printf("empty\n");}
                        /*-----STAT-----*/
                        //Run the core
                        runInOcore(cycle,iWindow);
                        if (iWindow->NumElements() < frSize) frStart = true;
                        //Runtime Stat
                        if (cycle%200000==0) {
                                ipc = (float)(insCount)/(float)(cycle);
                                printf ("Cycle %ld\n", cycle);
                                printf("IPC = %f\n", ipc);
                                //frSizeHist->report();
                                //printf("------\n");
                                //frLatHist->report();
                        }
                }
                delete iFr_wait;
                delete iFr_ready;
                /*-----STAT-----*/
                totNumFrag = frIndx+1;
                /*-----STAT-----*/
        }
        else if (coreType == FRAGMENT2) {
                List<fragment*> *iFr_wait  = new List<fragment*>;
                List<fragment*> *iFr_ready = new List<fragment*>;
                List<instruction*> *iWindow1  = new List<instruction*>;
                List<instruction*> *iWindow2  = new List<instruction*>;
                List<instruction*> *iWindow3  = new List<instruction*>;
                List<instruction*> *iWindow4  = new List<instruction*>;
                long int frIndx = 0;
                //long int frIdealLat;
                bool frStart = true;
                int frSize;
                int numInFlightFrags = 0;
                int arbitrate = -1;
                if (eoc == false) addFrag (iFr_wait, cycle); //TODO temperary loc
      ation
                findReadyFrag(iFr_ready, iFr_wait);
                numReadyFrags += iFr_ready->NumElements();
                frSize = iFr_ready->Nth(0)->getFragSize();
                for (int i = 0; i < frSize; i++) {
                        iWindow1->Append(iFr_ready->Nth(0)->getNthIns(i));
                        arbitrate = 1;
                }
                numInFlightFrags++;
                if (iFr_ready->NumElements() > 1) {
                        frSize = iFr_ready->Nth(1)->getFragSize();
                        for (int i = 0; i < frSize; i++) {
                                iWindow2->Append(iFr_ready->Nth(1)->getNthIns(i))
      ;
                                arbitrate = 1; //TODO is this correect?
                        }
                        numInFlightFrags++;
                }
                /*-----STAT-----*/
                //frIdealLat = iFr_ready->Nth(0)->getFrIdealLat();
                /*-----STAT-----*/
                while (true) {
                        cycle++;
                        if (frStart == true) frCycle++;
                        //Free the busy ALU's
                        freeALUs(cycle);
                        for (int i = 0; i < numInFlightFrags; i++) {
                                //Complete executed fragments
                                completeIns(cycle,iFr_ready->Nth(i)->getInsList()
      );
                                commitIns(cycle,iFr_ready->Nth(i)->getInsList());
      
                                //Complete executed fragments
                                completeIns(cycle,iFr_ready->Nth(i)->getInsList()
      );
                        }
                        //Move Fragments from Wait List to Ready List
                        findReadyFrag(iFr_ready, iFr_wait);
                        //Add instructions to fragment
                        if (eoc == false) addFrag (iFr_wait, cycle);
                        //Check resources status - goto nxt iter if all busy
                        if (!isALUfree()) continue;
                        //if (iFr_ready->NumElements()) {
                        //      printf("num: %d,%d,%d,%d\n", iFr_ready->NumElemen
      ts(), 
                        //                                   iFr_ready->Nth(0)->g
      etFragSize(), 
                        //                                   iWindow1->NumElement
      s(),
                        //                                   numInFlightFrags);
                        //}
                        int temp = numInFlightFrags;
                        for (int i = temp-1; i >= 0; i--) {
                                if (iFr_ready->Nth(i)->getFragSize() == 0) {
                                        removeFrag(iFr_ready, i);
                                        numInFlightFrags--;
                                        Assert(numInFlightFrags >= 0);
                                }
                        }
                        //Go to Next Frag
                        if (iWindow1->NumElements() == 0 && iFr_ready->
      NumElements() > numInFlightFrags) {
                                //printf("******* 1 \n");
                                //int whichWin = -1;
                                //if (iFr_ready->Nth(0)->getFragSize() == 0)
                                //      whichWin = 0;
                                //else if (iFr_ready->Nth(1)->getFragSize() == 0)
      
                                //      whichWin = 1;
                                //else
                                //      Assert(whichWin == 0 || whichWin == 1);
                                //frSize = iFr_ready->Nth(numInFlightFrags)->getF
      ragSize();
                                //removeFrag(iFr_ready, whichWin);
                                //quicksortFragScore(iFr_ready, 0, iFr_ready->Num
      Elements()-1, -1);
                                frSize = iFr_ready->Nth(numInFlightFrags)->
      getFragSize();
                                for (int i = 0; i < frSize; i++) {
                                        iWindow1->Append(iFr_ready->Nth(numInFlig
      htFrags)->getNthIns(i));
                                }
                                Assert(iWindow1->NumElements() == iFr_ready->Nth(
      numInFlightFrags)->getFragSize());
                                numInFlightFrags++;
                                arbitrate = 2;
                        } if (iWindow2->NumElements() == 0 && iFr_ready->
      NumElements() > numInFlightFrags) {
                                //printf("******* 2 \n");
                                //int whichWin = -1;
                                //if (iFr_ready->Nth(0)->getFragSize() == 0)
                                //      whichWin = 0;
                                //else if (iFr_ready->Nth(1)->getFragSize() == 0)
      
                                //      whichWin = 1;
                                //else
                                //      Assert(whichWin == 0 || whichWin == 1);
                                //removeFrag(iFr_ready, whichWin);
                                //quicksortFragScore(iFr_ready, 0, iFr_ready->Num
      Elements()-1, -1);
                                frSize = iFr_ready->Nth(numInFlightFrags)->
      getFragSize();
                                for (int i = 0; i < frSize; i++) {
                                        iWindow2->Append(iFr_ready->Nth(numInFlig
      htFrags)->getNthIns(i));
                                }
                                Assert(iWindow2->NumElements() == iFr_ready->Nth(
      numInFlightFrags)->getFragSize());
                                numInFlightFrags++;
                                arbitrate = 3;
                        } if (iWindow3->NumElements() == 0 && iFr_ready->
      NumElements() > numInFlightFrags) {
                                //printf("******* 2 \n");
                                //int whichWin = -1;
                                //if (iFr_ready->Nth(0)->getFragSize() == 0)
                                //      whichWin = 0;
                                //else if (iFr_ready->Nth(1)->getFragSize() == 0)
      
                                //      whichWin = 1;
                                //else
                                //      Assert(whichWin == 0 || whichWin == 1);
                                //removeFrag(iFr_ready, whichWin);
                                //quicksortFragScore(iFr_ready, 0, iFr_ready->Num
      Elements()-1, -1);
                                frSize = iFr_ready->Nth(numInFlightFrags)->
      getFragSize();
                                for (int i = 0; i < frSize; i++) {
                                        iWindow3->Append(iFr_ready->Nth(numInFlig
      htFrags)->getNthIns(i));
                                }
                                Assert(iWindow3->NumElements() == iFr_ready->Nth(
      numInFlightFrags)->getFragSize());
                                numInFlightFrags++;
                                arbitrate = 4;
                        } if (iWindow4->NumElements() == 0 && iFr_ready->
      NumElements() > numInFlightFrags) {
                                //printf("******* 2 \n");
                                //int whichWin = -1;
                                //if (iFr_ready->Nth(0)->getFragSize() == 0)
                                //      whichWin = 0;
                                //else if (iFr_ready->Nth(1)->getFragSize() == 0)
      
                                //      whichWin = 1;
                                //else
                                //      Assert(whichWin == 0 || whichWin == 1);
                                //removeFrag(iFr_ready, whichWin);
                                //quicksortFragScore(iFr_ready, 0, iFr_ready->Num
      Elements()-1, -1);
                                frSize = iFr_ready->Nth(numInFlightFrags)->
      getFragSize();
                                for (int i = 0; i < frSize; i++) {
                                        iWindow4->Append(iFr_ready->Nth(numInFlig
      htFrags)->getNthIns(i));
                                }
                                Assert(iWindow4->NumElements() == iFr_ready->Nth(
      numInFlightFrags)->getFragSize());
                                numInFlightFrags++;
                                arbitrate = 1;
                        }
                        /*-----STAT-----*/
                        if (iFr_ready->NumElements()== 0 && iFr_wait->
      NumElements()>0) interFragStallCycle++;
                        if (iFr_wait->NumElements() == 0 && 
                            iFr_ready->NumElements()== 0 && 
                            iWindow1->NumElements() == 0 && 
                            iWindow2->NumElements() == 0 &&
                            iWindow3->NumElements() == 0 &&
                            iWindow4->NumElements() == 0) break;
                        /*-----STAT-----*/
                        //Run the core
                        runDueLaneInOcore(cycle,iWindow1,iWindow2,iWindow3,iWindo
      w4,arbitrate); //TODO fix arbitration
                        if (iWindow1->NumElements() < frSize) frStart = true;
                        //Runtime Stat
                        if (cycle%200000==0) {
                                ipc = (float)(insCount)/(float)(cycle);
                                printf ("Cycle %ld\n", cycle);
                                printf("IPC = %f\n", ipc);
                        }
                }
                delete iFr_wait;
                delete iFr_ready;
                delete iWindow1;
                delete iWindow2;
                delete iWindow3;
                delete iWindow4;
                /*-----STAT-----*/
                totNumFrag = frIndx+1;
                /*-----STAT-----*/
        } else if (coreType == PHRASEBLOCK) {
                //long int phIndx = 0;
                //long int phIdealLat;
                //bool phStart = true;
                //int phSize;
                //cout << "addPhraseblock\n";
                addPhraseblock(_pbLists, cycle);
                while (true) {
                        cycle++;
                        //Free the busy ALU's
                        //cout << "freeALUs\n";
                        freeALUs(cycle);
                        //Complete executed phrases
                        //cout << "completePB\n";
                        completePB(cycle);
                        //Commit executed instructions
                        //cout << "commitPB\n";
                        if (commitPB(cycle) == -1 && cycle != 1 && eoc == true) {
      break;}
                        //Complete executed phrases
                        //cout << "completePB\n";
                        completePB(cycle);
                        //LSQ
                        //if (memoryModel == NAIVE_SPECUL) {
                        //      //Run LSQ
                        //      exeMemPipeStage(pbROB, cycle, loadStoreQue);
                        //      //SQ Access Cache for Write
                        //      runStoreQueue(loadStoreQue, cycle);
                        //      getLSQsize(loadStoreQue); /*STAT*/
                        //}
                        if (!perfectRegRen) getRRsize(GRF); /*STAT*/
                        //Add instructions to phrase
                        //cout << "addPhraseblock\n";
                        addPhraseblock (_pbLists, cycle);
                        if (eof) {eof=false; break;}
                        //Check resources status - goto nxt iter if all busy
                        //cout << "isALUfree\n";
                        if (!isALUfree()) continue;
                        //Run the core
                        //cout << "runPhraseblockCore\n";
                        runPhraseblockCore(cycle,_pbLists);
                        //Runtime Stat
                        if (cycle%300000==0) {
                                ipc = (float)(insCount)/(float)(cycle);
                                printf ("Cycle %ld\n", cycle);
                                printf("IPC = %f\n", ipc);
                                printf("Squash Cnt = %d\n", squashCount);
                                printf("EOF: %d EOC: %d\n", eof, eoc);
                        }
                }
                /*-----STAT-----*/
                //totNumPhrase = phIndx+1;
                /*-----STAT-----*/
        } else if (coreType == DOT) {
                printf("hey\n");
                dot *d = new dot(0);
                if (eoc == false) addIns(cycle);
                d->runDot(iWindow,0);
        }
        //core implementations
        else {
                if (debug) {
                        printf("CYCLE IN = %ld\n", cycle);
                        //long int cycle_in = cycle; //TODO cycle_in must be defi
      ned outside this scope
                }
                while (true) {
                        cycle++;
                        //Free the busy ALU's
                        freeALUs(cycle);
                        //Complete executed instructions
                        completeIns(cycle,iROB);
                        //Commit executed instructions
                        if (commitIns(cycle,iROB) == -1 && cycle != 1 && eoc == t
      rue) break;
                        //Complete executed instructions
                        completeIns(cycle,iROB);
                        //LSQ
                        if (memoryModel == NAIVE_SPECUL) {
                                //Run LSQ
                                exeMemPipeStage(iROB, cycle, loadStoreQue);
                                //SQ Access Cache for Write
                                runStoreQueue(loadStoreQue, cycle);
                                getLSQsize(loadStoreQue); /*STAT*/
                        }
                        if (!perfectRegRen && coreType != IN_ORDER) getRRsize(
      GRF); /*STAT*/
                        //Add instructions to iROB
                        if (eoc == false) addIns(cycle);
                        if (eof) {eof=false;break;}
                        //Check resources status - goto nxt iter if all busy
                        if (!isALUfree()) continue;
                        //Run the core
                        if (coreType == OUT_OF_ORDER) {
                                if (numFU == 1) {
                                        runOOOcoreSingleIssue(cycle);
                                } else if (numFU == 4) {
                                        runOOOcore2(cycle);
                                } else {
                                        runOOOcore(cycle);}
                        } else if (coreType == STRAND) {
                                runStrandcore(cycle);
                        } else if (coreType == IN_ORDER) {
                                if (numFU == 4)
                                        runInOcore2(cycle);
                                else
                                        runInOcore(cycle,iWindow);
                        } else if (coreType == X_LEVEL_DEEP_DYN) {
                                runxLDcore_DYN(cycle);
                        } else if (coreType == ONE_LEVE_DEEP_STAT) {
                                run1LD_STAT(cycle);
                        } else if (coreType == X_LEVE_DEEP_STAT) {
                                runxLD_STAT(cycle);
                        }else {
                                printf("ERROR: core name is not set correctly!\n"
      );
                                Assert(coreType >= IN_ORDER && coreType <= 
      X_LEVEL_DEEP_DYN);
                        }
                        //Runtime Stat
                        if (cycle%300000==0) {
                                ipc = (float)(insCount)/(float)(cycle);
                                printf ("Cycle %ld\n", cycle);
                                printf("IPC = %f\n", ipc);
                                printf("Squash Cnt = %d\n", squashCount);
                        }
                }
                //if (debug) printf("CYCLE OUT = %ld (diff = %ld)\n", cycle, cycl
      e-cycle_in);
                if (reportTraceAndHitMiss == true) {
                        printf("STORE Unpredictable Memory Accesses\n");
                        computeMissRates();
                        printMissRatetoFile();
                        fclose (pinFile);
                        //if((pinFile=fopen(inFileName.c_str(), "r")) == NULL) {
                        //      printf("ERROR: Cannot open file(s).\n");
                        //      exit(1);
                        //}
                        //eoc = false;
                        //if (evaltMissRtCorrel == 1) {
                        //      correlationHist = new hist(1001, 0, 1001);
                        //}
                        //while (true) {
                        //      if (eoc == false) addIns(cycle);
                        //      else break;
                        //      while (iWindow->NumElements() > 0) {iWindow->Remo
      veAt(0);}//Drain it to avoid core dump
                        //      while (iROB->NumElements() > 0) {
                        //              instruction *ins = iROB->Nth(0);
                        //              long int insAddr = ins->getInsAddr();
                        //              if (ins->getMemType() == READ &&
                        //                  memRdMissRateTable.count(insAddr) > 0
      ) {
                        //                      float missRate = memRdMissRateTab
      le.find(insAddr)->second;
                        //                      /*-----STAT-----*/
                        //                      if (missRate > unpredMemOpThresho
      ld) {unpredMemOpCnt++;}
                        //                      /*-----STAT-----*/
                        //                      //For measuring UPLD measurement 
      accuracy
                        //                      //if (missRate > unpredMemOpThres
      hold && ins->getMissrate() <= unpredMemOpThreshold)
                        //                      //      printf("1: %f - %f = %f\n
      ",ins->getMissrate(), missRate, ins->getMissrate()-missRate);
                        //                      //else if (missRate <= unpredMemO
      pThreshold && ins->getMissrate() > unpredMemOpThreshold)
                        //                      //      printf("2: %f - %f = %f\n
      ",ins->getMissrate(), missRate, ins->getMissrate()-missRate);

                        //                      if (evaltMissRtCorrel == 0) {
                        //                              ins->setMissRate(missRate
      );
                        //                      } else {
                        //                              float missRateDiff = miss
      Rate - ins->getMissrate();
                        //                              long int temp = (long int
      ) (missRate * 1000.0);
                        //                              if (temp < 0) temp *= -1;
       //take abs
                        //                              correlationHist->addElem(
      temp);
                        //                      }
                        //              } //miss rate is zero by default
                        //              if (evaltMissRtCorrel == 0) {
                        //                      createTraceAndHitMiss(0);
                        //              }
                        //              iROB->Nth(0)->notifyAllDepICompleted();
                        //              iROB->Nth(0)->delDepTableEntris(depTables
      , coreType);
                        //              delete iROB->Nth(0);
                        //              iROB->RemoveAt(0);
                        //      }
                        //}
                        //if (evaltMissRtCorrel == 1) {
                        //      correlationHist->report();
                        //}
                }
        }
        //Final IPC computation
        ipc = (float)(insCount)/(float)(cycle);
}
\end{DoxyCode}
\hypertarget{bkEnd_8h_a5627ce0f84690d974b96ebb091e67d6e}{
\index{bkEnd.h@{bkEnd.h}!PredictAndUpdate@{PredictAndUpdate}}
\index{PredictAndUpdate@{PredictAndUpdate}!bkEnd.h@{bkEnd.h}}
\subsubsection[{PredictAndUpdate}]{\setlength{\rightskip}{0pt plus 5cm}bool PredictAndUpdate (
\begin{DoxyParamCaption}
\item[{uint64\_\-t}]{\_\-\_\-pc, }
\item[{int}]{\_\-\_\-taken}
\end{DoxyParamCaption}
)}}
\label{bkEnd_8h_a5627ce0f84690d974b96ebb091e67d6e}

\begin{DoxyCode}
                                                  {
    bool taken = __taken;
    uint64_t pc = __pc;
    void *bp_hist = NULL;
    bool prediction = predictor->lookup(pc, bp_hist);
    //outfile << hex << "0x" << pc << ": ";
    if(prediction != taken) {
        //outfile << "wrong prediction\n";
                //if (brExeCount.find(pc) != brExeCount.end())  brExeCount[pc] +=
       1;
                //else                                                                                  b
      rExeCount[pc] = 1;
        predictor->update(pc, taken, bp_hist, true);
                return true; //mis-prediction
    } else {
        //outfile << "correct prediction\n";
                //if (correctPred.find(pc) != correctPred.end())        correctPr
      ed[pc] += 1;
                //else                                                                                  c
      orrectPred[pc] = 1;
                //if (brExeCount.find(pc) != brExeCount.end())  brExeCount[pc] +=
       1;
                //else                                                                                  b
      rExeCount[pc] = 1;
        predictor->update(pc, taken, bp_hist, false);
                return false; //correct-prediction
    }
        //return prediction;
}
\end{DoxyCode}


Here is the call graph for this function:


