\hypertarget{uop__gen_8cpp}{
\section{/home/milad/esc\_\-project/svn/PARS/src/frontend/uop\_\-gen.cpp File Reference}
\label{uop__gen_8cpp}\index{/home/milad/esc\_\-project/svn/PARS/src/frontend/uop\_\-gen.cpp@{/home/milad/esc\_\-project/svn/PARS/src/frontend/uop\_\-gen.cpp}}
}
{\ttfamily \#include \char`\"{}uop\_\-gen.h\char`\"{}}\par
Include dependency graph for uop\_\-gen.cpp:
\subsection*{Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{uop__gen_8cpp_a830df59572c1d3acabddb3bea8dd34ab}{ENABLE\_\-MICRO}~0
\item 
\#define \hyperlink{uop__gen_8cpp_a68c6e9679073f1041a4a1351270fedb8}{MICRO0}~\char`\"{}TEMP0\char`\"{}
\item 
\#define \hyperlink{uop__gen_8cpp_a5b4c5283e2d7ddad8441a8b68c1959ef}{MICRO1}~\char`\"{}TEMP1\char`\"{}
\item 
\#define \hyperlink{uop__gen_8cpp_adf16e393a301584c9d9381c4eb563e2b}{MICRO2}~\char`\"{}TEMP2\char`\"{}
\item 
\#define \hyperlink{uop__gen_8cpp_a52fc56c4d67c82a71784fbcbd4ae20b0}{MICRO3}~\char`\"{}TEMP3\char`\"{}
\item 
\#define \hyperlink{uop__gen_8cpp_a55a2058bb871a131f4d246bc08d4dac8}{MICRO4}~\char`\"{}TEMP4\char`\"{}
\item 
\#define \hyperlink{uop__gen_8cpp_a9cfa33052d8a586f3b510b7cf3ed5e92}{MICRO5}~\char`\"{}TEMP5\char`\"{}
\item 
\#define \hyperlink{uop__gen_8cpp_a19f877718310c2ff11e3904f391fee74}{MICRO6}~\char`\"{}TEMP6\char`\"{}
\item 
\#define \hyperlink{uop__gen_8cpp_abf70ff14304e69be332ea69e9863a8b5}{MICRO7}~\char`\"{}TEMP7\char`\"{}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{uop__gen_8cpp_a217fa2dd3b2403988eef55b4356904cf}{isFloat} (INS)
\item 
bool \hyperlink{uop__gen_8cpp_aab56ab18527221c529ee447fd64d6dd2}{isFDiv} (INS)
\item 
VOID \hyperlink{uop__gen_8cpp_a74d38cfa65092c53e78f25070e6b2d81}{dosAsmMEMWS} (ADDRINT ip, ADDRINT instAddr, VOID $\ast$addr, int regCount, UINT32 isFloat, UINT32 isFDiv, UINT32 MAXR, UINT32 MAXW, REG R1, REG R2, REG R3, REG R4, REG R5, REG R6, REG R7, REG R8, REG W1, REG W2, REG W3, REG W4, REG W5, REG W6, REG W7, REG W8)
\item 
VOID \hyperlink{uop__gen_8cpp_a36cb4a3ea0b90875c3f3f7db368660d4}{dosAsmMEMW} (ADDRINT ip, ADDRINT instAddr, VOID $\ast$addr, int regCount, UINT32 isFloat, UINT32 isFDiv)
\item 
VOID \hyperlink{uop__gen_8cpp_a22215f9778fee32ff3167a47ef3717c3}{dosAsmMEMW1} (ADDRINT ip, ADDRINT instAddr, VOID $\ast$addr, int regCount, UINT32 isFloat, UINT32 isFDiv)
\item 
VOID \hyperlink{uop__gen_8cpp_a96927d71a1f34c22c9cf0e61e98ca89b}{dosAsmMEMR} (ADDRINT ip, ADDRINT instAddr, VOID $\ast$addr, int regCount, UINT32 isFloat, UINT32 isFDiv)
\item 
VOID \hyperlink{uop__gen_8cpp_aea089ccd09fa855564240ca58f42f7fb}{dosAsmMEMR1} (ADDRINT ip, ADDRINT instAddr, VOID $\ast$addr, int regCount, UINT32 isFloat, UINT32 isFDiv)
\item 
VOID \hyperlink{uop__gen_8cpp_ae58115ce5a3f6d5d32f3e19af69aca01}{dosAsmMEMRS} (ADDRINT ip, ADDRINT instAddr, VOID $\ast$addr, int regCount, UINT32 isFloat, UINT32 isFDiv, UINT32 MAXR, UINT32 MAXW, REG R1, REG R2, REG R3, REG R4, REG R5, REG R6, REG R7, REG R8)
\item 
ADDRINT \hyperlink{uop__gen_8cpp_a905d2f264f56a1569cc7fd7d374c759f}{disAsmALU} (ADDRINT ip, ADDRINT instAddr, UINT32 regCount, UINT32 isFloat, UINT32 isFDiv, UINT32 isBranch, ADDRINT brTarget, BOOL brTaken)
\item 
ADDRINT \hyperlink{uop__gen_8cpp_a2f63fe95045d33d08845eafac3a74467}{operands} (ADDRINT ip, REG reg, int i, int regType)
\item 
ADDRINT \hyperlink{uop__gen_8cpp_a0172f442f10ebe82e79266223149e815}{operands1} (ADDRINT ip, REG reg, int i, int regType)
\item 
VOID \hyperlink{uop__gen_8cpp_a4901d0bf289e797f3edec7dc81a72de9}{reset} ()
\item 
VOID \hyperlink{uop__gen_8cpp_a81d412f8480d48d0e150906d993936c5}{findInSfile} (ADDRINT ip, ADDRINT insAddr)
\item 
VOID \hyperlink{uop__gen_8cpp_a494cc3b7e8096971d0edd424c59eb639}{EmulateLoad} (INS ins, VOID $\ast$v)
\item 
VOID \hyperlink{uop__gen_8cpp_a1dd8dfe7a85c108588cc1616ac4080fd}{doImpCount} ()
\item 
VOID \hyperlink{uop__gen_8cpp_a22699730f95b03cca69984cb665c271c}{doImpCallCount} (BOOL isCall)
\item 
VOID \hyperlink{uop__gen_8cpp_aff141cad0976d515ec0807de6a29c607}{doImpMemCount} (UINT32 isMem)
\item 
VOID \hyperlink{uop__gen_8cpp_adb2db14a73cb9e821f3b42ee61403c82}{instr} (INS ins, VOID $\ast$v)
\item 
VOID \hyperlink{uop__gen_8cpp_a4e877db47eeb14a04e3154561e237bcd}{SI\_\-Img} (IMG img, VOID $\ast$v)
\item 
void \hyperlink{uop__gen_8cpp_a6e258f8f019fd3f67349d3288677d2b3}{uop\_\-gen} (FILE $\ast$\_\-outFile, \hyperlink{classstaticCodeParser}{staticCodeParser} \&\hyperlink{pars_8cpp_ae1f49acdc02bc860091a9c0826042e9a}{g\_\-staticCode})
\item 
VOID \hyperlink{uop__gen_8cpp_aa9b459ce84a7d93d13a3f1f3bf82088a}{getBrIns} (ADDRINT insAddr, BOOL hasFT, ADDRINT tgAddr, ADDRINT ftAddr, BOOL isTaken, BOOL isCall, BOOL isRet, BOOL isJump, BOOL isDirBrOrCallOrJmp)
\item 
VOID \hyperlink{uop__gen_8cpp_a2dca73fb6683b99910bcad66c0cdf726}{getMemIns} (ADDRINT insAddr, ADDRINT memAccessSize, ADDRINT memAddr, BOOL isStackRd, BOOL isStackWr, BOOL isMemRead)
\item 
VOID \hyperlink{uop__gen_8cpp_a0ec88bd53fecf7e7ba1cb862d34db82d}{getIns} (ADDRINT insAddr)
\item 
VOID \hyperlink{uop__gen_8cpp_abd93f7dec3bc70a2e12dabcb528b00c5}{getNopIns} (ADDRINT insAddr)
\item 
void \hyperlink{uop__gen_8cpp_a6b129244e191a3f59375a31842557abd}{get\_\-uop} (INS ins)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
FILE $\ast$ \hyperlink{uop__gen_8cpp_a1277960b5f2b37137fe9b0b5a1ea0beb}{out} = 0
\item 
FILE $\ast$ \hyperlink{uop__gen_8cpp_a09e9742c01c4ea54fe6ad7a118d27c05}{out1} = 0
\item 
std::stringstream \hyperlink{uop__gen_8cpp_a8fc3524f4e679a41dcc8d0f302d637ed}{ss}
\item 
\hyperlink{classstaticCodeParser}{staticCodeParser} $\ast$ \hyperlink{uop__gen_8cpp_abfe2730122561da64ab5e1dec976a2fc}{\_\-g\_\-staticCode}
\item 
map$<$ ADDRINT, string $>$ \hyperlink{uop__gen_8cpp_a5425dff34ae281a9d2ed5836922ae793}{insMap}
\item 
unsigned \hyperlink{uop__gen_8cpp_ab4f6b3aed51d8a9b2ada1ad5390fb569}{j}
\item 
int \hyperlink{uop__gen_8cpp_aa546155cf4ec601e43e20ead17e983d1}{memOp}
\item 
int \hyperlink{uop__gen_8cpp_a721a0e615d2b640fe60ecb8366ddb7a8}{aluOp}
\item 
int \hyperlink{uop__gen_8cpp_a0f07fe0363b6134cf1849fe46bb48227}{fpOp}
\item 
int \hyperlink{uop__gen_8cpp_adbd842db51089bacd184458de788ef57}{brOp}
\item 
int \hyperlink{uop__gen_8cpp_a87ab2c83ace6e8169a1ea7419f20360e}{strt} = 0
\item 
int \hyperlink{uop__gen_8cpp_a8674f1654f805920ac2f393ad449702c}{fin} = 0
\item 
int \hyperlink{uop__gen_8cpp_a4cf81ffad0a875cffd527876156689aa}{warmUp} = 0
\item 
int \hyperlink{uop__gen_8cpp_ad6a2043678ae90c7936423209ffbe50f}{runAllProgram} = true
\item 
bool \hyperlink{uop__gen_8cpp_ad3131e139bdf973dba3caa8efa9914bb}{logEnable} = false
\item 
long unsigned \hyperlink{uop__gen_8cpp_a49f12f6edbb46c1021b8845a9efe5a69}{imgInsCount} = 0
\item 
long unsigned \hyperlink{uop__gen_8cpp_af95d5076519fb14463e7dd6b5e2d4f8e}{imgInsCallCount} = 0
\item 
long unsigned \hyperlink{uop__gen_8cpp_ad50bc042fba06693e68c94a89b0d753f}{imgInsMemCount} = 0
\end{DoxyCompactItemize}


\subsection{Define Documentation}
\hypertarget{uop__gen_8cpp_a830df59572c1d3acabddb3bea8dd34ab}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!ENABLE\_\-MICRO@{ENABLE\_\-MICRO}}
\index{ENABLE\_\-MICRO@{ENABLE\_\-MICRO}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{ENABLE\_\-MICRO}]{\setlength{\rightskip}{0pt plus 5cm}\#define ENABLE\_\-MICRO~0}}
\label{uop__gen_8cpp_a830df59572c1d3acabddb3bea8dd34ab}
\hypertarget{uop__gen_8cpp_a68c6e9679073f1041a4a1351270fedb8}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!MICRO0@{MICRO0}}
\index{MICRO0@{MICRO0}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{MICRO0}]{\setlength{\rightskip}{0pt plus 5cm}\#define MICRO0~\char`\"{}TEMP0\char`\"{}}}
\label{uop__gen_8cpp_a68c6e9679073f1041a4a1351270fedb8}
\hypertarget{uop__gen_8cpp_a5b4c5283e2d7ddad8441a8b68c1959ef}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!MICRO1@{MICRO1}}
\index{MICRO1@{MICRO1}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{MICRO1}]{\setlength{\rightskip}{0pt plus 5cm}\#define MICRO1~\char`\"{}TEMP1\char`\"{}}}
\label{uop__gen_8cpp_a5b4c5283e2d7ddad8441a8b68c1959ef}
\hypertarget{uop__gen_8cpp_adf16e393a301584c9d9381c4eb563e2b}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!MICRO2@{MICRO2}}
\index{MICRO2@{MICRO2}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{MICRO2}]{\setlength{\rightskip}{0pt plus 5cm}\#define MICRO2~\char`\"{}TEMP2\char`\"{}}}
\label{uop__gen_8cpp_adf16e393a301584c9d9381c4eb563e2b}
\hypertarget{uop__gen_8cpp_a52fc56c4d67c82a71784fbcbd4ae20b0}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!MICRO3@{MICRO3}}
\index{MICRO3@{MICRO3}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{MICRO3}]{\setlength{\rightskip}{0pt plus 5cm}\#define MICRO3~\char`\"{}TEMP3\char`\"{}}}
\label{uop__gen_8cpp_a52fc56c4d67c82a71784fbcbd4ae20b0}
\hypertarget{uop__gen_8cpp_a55a2058bb871a131f4d246bc08d4dac8}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!MICRO4@{MICRO4}}
\index{MICRO4@{MICRO4}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{MICRO4}]{\setlength{\rightskip}{0pt plus 5cm}\#define MICRO4~\char`\"{}TEMP4\char`\"{}}}
\label{uop__gen_8cpp_a55a2058bb871a131f4d246bc08d4dac8}
\hypertarget{uop__gen_8cpp_a9cfa33052d8a586f3b510b7cf3ed5e92}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!MICRO5@{MICRO5}}
\index{MICRO5@{MICRO5}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{MICRO5}]{\setlength{\rightskip}{0pt plus 5cm}\#define MICRO5~\char`\"{}TEMP5\char`\"{}}}
\label{uop__gen_8cpp_a9cfa33052d8a586f3b510b7cf3ed5e92}
\hypertarget{uop__gen_8cpp_a19f877718310c2ff11e3904f391fee74}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!MICRO6@{MICRO6}}
\index{MICRO6@{MICRO6}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{MICRO6}]{\setlength{\rightskip}{0pt plus 5cm}\#define MICRO6~\char`\"{}TEMP6\char`\"{}}}
\label{uop__gen_8cpp_a19f877718310c2ff11e3904f391fee74}
\hypertarget{uop__gen_8cpp_abf70ff14304e69be332ea69e9863a8b5}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!MICRO7@{MICRO7}}
\index{MICRO7@{MICRO7}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{MICRO7}]{\setlength{\rightskip}{0pt plus 5cm}\#define MICRO7~\char`\"{}TEMP7\char`\"{}}}
\label{uop__gen_8cpp_abf70ff14304e69be332ea69e9863a8b5}


\subsection{Function Documentation}
\hypertarget{uop__gen_8cpp_a905d2f264f56a1569cc7fd7d374c759f}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!disAsmALU@{disAsmALU}}
\index{disAsmALU@{disAsmALU}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{disAsmALU}]{\setlength{\rightskip}{0pt plus 5cm}ADDRINT disAsmALU (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{ip, }
\item[{ADDRINT}]{instAddr, }
\item[{UINT32}]{regCount, }
\item[{UINT32}]{isFloat, }
\item[{UINT32}]{isFDiv, }
\item[{UINT32}]{isBranch, }
\item[{ADDRINT}]{brTarget, }
\item[{BOOL}]{brTaken}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a905d2f264f56a1569cc7fd7d374c759f}

\begin{DoxyCode}
{
    if ( ( (warmUp == 1 || strt == 1) && fin == 0) || runAllProgram == true) {
        if (isFloat) {
            fpOp++;
            if (isFDiv) {
                if (logEnable) fprintf (out, "\n--- D, %d, IP:%ld, ASM: (%s)\n", 
      regCount, ip, insMap[ip].c_str ());
                if (logEnable) fprintf (out, "\n>> ");
                fprintf (out1,"\nD,%llu,", (long long unsigned int)instAddr);
                ss << "\nD," << (long long unsigned int)instAddr << ",";
                g_var.g_ins = ss.str ();
                //ss.str (std::string ());
            } else {
                if (logEnable) fprintf (out, "\n--- F, %d, IP:%ld, ASM: (%s)\n", 
      regCount, ip, insMap[ip].c_str ());
                if (logEnable) fprintf (out, "\n>> ");
                fprintf (out1,"\nF,%llu,", (long long unsigned int)instAddr);
                ss << "\nF," << (long long unsigned int)instAddr << ",";
                g_var.g_ins = ss.str ();
                //ss.str (std::string ());
            }
        } else if (isBranch) {
            brOp++;
            if (logEnable) fprintf (out, "\n--- B, %d, IP:%ld, ASM: (%s)\n", regC
      ount, ip, insMap[ip].c_str ());
            if (logEnable) fprintf (out, "\n>> ");
            fprintf (out1,"\nB,%llu,%d,%llu,", (long long unsigned int)instAddr,b
      rTaken, (long long unsigned int)brTarget);
            ss << "\nB," << (long long unsigned int)instAddr << "," << brTaken <<
       "," << (long long unsigned int)brTarget << ",";
            g_var.g_ins = ss.str ();
            //ss.str (std::string ());
        } else {
            if (logEnable) fprintf (out, "\n--- A, %d, IP:%ld, ASM: (%s)\n", regC
      ount, ip, insMap[ip].c_str ());
            if (logEnable) fprintf (out, "\n>> ");
            fprintf (out1,"\nA,%llu,", (long long unsigned int)instAddr);
            ss << "\nA," << (long long unsigned int)instAddr << ",";
            g_var.g_ins = ss.str ();
            //ss.str (std::string ());
        }
        aluOp++;
    }
    //long int temp = instAddr-target;
    //if (isBranch==1 && temp < 0 && temp > -2000) printf ("%d, %lu, %lu, %lu, %l
      d\n", brOp, brTarget, brTaken, instAddr, temp);
    ADDRINT value=0;//dummy return
    return value;
}
\end{DoxyCode}
\hypertarget{uop__gen_8cpp_a22699730f95b03cca69984cb665c271c}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!doImpCallCount@{doImpCallCount}}
\index{doImpCallCount@{doImpCallCount}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{doImpCallCount}]{\setlength{\rightskip}{0pt plus 5cm}VOID doImpCallCount (
\begin{DoxyParamCaption}
\item[{BOOL}]{isCall}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a22699730f95b03cca69984cb665c271c}

\begin{DoxyCode}
{
    if (isCall)
        imgInsCallCount++;
    unsigned long countRem = imgInsCount%BILLION;
    if (countRem == 0) {
        cout << " (CALL) :" << imgInsCallCount << "\n";
    }
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{uop__gen_8cpp_a1dd8dfe7a85c108588cc1616ac4080fd}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!doImpCount@{doImpCount}}
\index{doImpCount@{doImpCount}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{doImpCount}]{\setlength{\rightskip}{0pt plus 5cm}VOID doImpCount (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a1dd8dfe7a85c108588cc1616ac4080fd}

\begin{DoxyCode}
{
    imgInsCount++;
    unsigned long countRem = imgInsCount%BILLION;
    if (countRem == 0) {
        cout << " (IMG) :" << imgInsCount << "\n";
    }
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{uop__gen_8cpp_aff141cad0976d515ec0807de6a29c607}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!doImpMemCount@{doImpMemCount}}
\index{doImpMemCount@{doImpMemCount}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{doImpMemCount}]{\setlength{\rightskip}{0pt plus 5cm}VOID doImpMemCount (
\begin{DoxyParamCaption}
\item[{UINT32}]{isMem}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_aff141cad0976d515ec0807de6a29c607}

\begin{DoxyCode}
{
    if (isMem > 0)
        imgInsMemCount++;
    unsigned long countRem = imgInsCount%BILLION;
    if (countRem == 0) {
        cout << " (MEM) :" << imgInsMemCount << "\n";
    }
}
\end{DoxyCode}


Here is the caller graph for this function:


\hypertarget{uop__gen_8cpp_a96927d71a1f34c22c9cf0e61e98ca89b}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!dosAsmMEMR@{dosAsmMEMR}}
\index{dosAsmMEMR@{dosAsmMEMR}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{dosAsmMEMR}]{\setlength{\rightskip}{0pt plus 5cm}VOID dosAsmMEMR (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{ip, }
\item[{ADDRINT}]{instAddr, }
\item[{VOID $\ast$}]{addr, }
\item[{int}]{regCount, }
\item[{UINT32}]{isFloat, }
\item[{UINT32}]{isFDiv}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a96927d71a1f34c22c9cf0e61e98ca89b}

\begin{DoxyCode}
{
    if ( ( (warmUp == 1 || strt == 1) && fin == 0) || runAllProgram == true) {
        if (isFloat) {
            fpOp++;
            if (isFDiv) {
                if (logEnable) fprintf (out, "\n--- D, %d, IP:%ld, ADDR:%llu, ASM
      : (%s)\n", regCount, ip, (long long unsigned int)addr, insMap[ip].c_str ());
                if (logEnable) fprintf (out, "\n>> ");
                fprintf (out1,"\nD,%llu,", (long long unsigned int)instAddr);
                ss << "\nD," << (long long unsigned int)instAddr << ",";
                g_var.g_ins = ss.str ();
                //ss.str (std::string ());
            } else {
                if (logEnable) fprintf (out, "\n--- F, %d, IP:%ld, ADDR:%llu, ASM
      : (%s)\n", regCount, ip, (long long unsigned int)addr, insMap[ip].c_str ());
                if (logEnable) fprintf (out, "\n>> ");
                fprintf (out1,"\nF,%llu,", (long long unsigned int)instAddr);
                ss << "\nF," << (long long unsigned int)instAddr << ",";
                g_var.g_ins = ss.str ();
                //ss.str (std::string ());
            }
        } else {
            if (logEnable) fprintf (out, "\n--- R, %d, IP:%ld, ADDR:%llu, ASM: (%
      s)\n", regCount, ip, (long long unsigned int)addr, insMap[ip].c_str ());
            if (logEnable) fprintf (out, "\n>> ");
            fprintf (out1,"\nR,%llu,%llu,", (long long unsigned int)addr, (long l
      ong unsigned int)instAddr);
            ss << "\nR," << (long long unsigned int)addr << "," << (long long uns
      igned int)instAddr << ",";
            g_var.g_ins = ss.str ();
            //ss.str (std::string ());
        }
        memOp++;
    }
}
\end{DoxyCode}
\hypertarget{uop__gen_8cpp_aea089ccd09fa855564240ca58f42f7fb}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!dosAsmMEMR1@{dosAsmMEMR1}}
\index{dosAsmMEMR1@{dosAsmMEMR1}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{dosAsmMEMR1}]{\setlength{\rightskip}{0pt plus 5cm}VOID dosAsmMEMR1 (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{ip, }
\item[{ADDRINT}]{instAddr, }
\item[{VOID $\ast$}]{addr, }
\item[{int}]{regCount, }
\item[{UINT32}]{isFloat, }
\item[{UINT32}]{isFDiv}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_aea089ccd09fa855564240ca58f42f7fb}

\begin{DoxyCode}
{
    if ( ( (warmUp == 1 || strt == 1) && fin == 0) || runAllProgram == true) {
        if (isFloat) {
            fpOp++;
            if (isFDiv) {
                if (logEnable) fprintf (out, "\n--- D, %d, IP:%ld, ADDR:%llu, ASM
      : (%s)\n", regCount, ip, (long long unsigned int)addr, insMap[ip].c_str ());
                if (logEnable) fprintf (out, "\n>> ");
            } else {
                if (logEnable) fprintf (out, "\n--- F, %d, IP:%ld, ADDR:%llu, ASM
      : (%s)\n", regCount, ip, (long long unsigned int)addr, insMap[ip].c_str ());
                if (logEnable) fprintf (out, "\n>> ");
            }
        } else { 
            if (logEnable) fprintf (out, "\n--- R, %d, IP:%ld, ADDR:%llu, ASM: (%
      s)\n", regCount, ip, (long long unsigned int)addr, insMap[ip].c_str ());
            if (logEnable) fprintf (out, "\n>> ");
        }
        memOp++;}
}
\end{DoxyCode}
\hypertarget{uop__gen_8cpp_ae58115ce5a3f6d5d32f3e19af69aca01}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!dosAsmMEMRS@{dosAsmMEMRS}}
\index{dosAsmMEMRS@{dosAsmMEMRS}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{dosAsmMEMRS}]{\setlength{\rightskip}{0pt plus 5cm}VOID dosAsmMEMRS (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{ip, }
\item[{ADDRINT}]{instAddr, }
\item[{VOID $\ast$}]{addr, }
\item[{int}]{regCount, }
\item[{UINT32}]{isFloat, }
\item[{UINT32}]{isFDiv, }
\item[{UINT32}]{MAXR, }
\item[{UINT32}]{MAXW, }
\item[{REG}]{R1, }
\item[{REG}]{R2, }
\item[{REG}]{R3, }
\item[{REG}]{R4, }
\item[{REG}]{R5, }
\item[{REG}]{R6, }
\item[{REG}]{R7, }
\item[{REG}]{R8}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_ae58115ce5a3f6d5d32f3e19af69aca01}

\begin{DoxyCode}
{
    if ( ( (warmUp == 1 || strt == 1) && fin == 0) || runAllProgram == true) {
        int subAddr = 0;
        string original = insMap[ip].c_str ();
        string RRegs[8];
        string TRegs[8];
        string MORegs[8];
        MORegs[0] = MICRO0;
        MORegs[1] = MICRO1;
        MORegs[2] = MICRO2;
        MORegs[3] = MICRO3;
        MORegs[4] = MICRO4;
        MORegs[5] = MICRO5;
        MORegs[6] = MICRO6;
        MORegs[7] = MICRO7;
        int TRegPtr = 0;
        int RMask = 0x0;
        for (UINT32 i = 0; i < MAXR; i++) {
            if (i == 0) {
                RRegs[i] = REG_StringShort (R1);
                RMask |= 0x1;
            } else if (i == 1) {
                RRegs[i] = REG_StringShort (R2); 
                RMask |= 0x2;
            } else if (i == 2) {
                RRegs[i] = REG_StringShort (R3); 
                RMask |= 0x4;
            } else if (i == 3) {
                RRegs[i] = REG_StringShort (R4); 
                RMask |= 0x8;
            } else if (i == 4) {
                RRegs[i] = REG_StringShort (R5); 
                RMask |= 0x10;
            } else if (i == 5) {
                RRegs[i] = REG_StringShort (R6); 
                RMask |= 0x20;
            } else if (i == 6) {
                RRegs[i] = REG_StringShort (R7); 
                RMask |= 0x40;
            } else if (i == 7) {
                RRegs[i] = REG_StringShort (R8); 
                RMask |= 0x80;
            }
        }
        int MPointers = 0;
        int addrOps = 0;
        for (UINT32 i = 0; i < original.length (); i++) {
            if (original[i] == '[') {
                for (UINT32 k = i; k < original.length (); k++) {
                    if (original[k] == ']') {
                        break;
                    } else if ( (original[k] == '+') || (original[k] == '-') || (
      original[k] == '*')) {
                        addrOps++;
                    }
                }
                MPointers++;
                int RLength = 0;
                for (UINT32 ii = i; ii < original.length (); ii++) {
                    if ( (original[ii] == ']') || (original[ii] == ' ') || (origi
      nal[ii] == '+') || (original[ii] == '-') || (original[ii] == '*')) {
                        RLength = ii-i-1;
                        break;
                    }
                }
                for (UINT32 j = 0; j < MAXR; j++) {
                    if (RRegs[j].compare (original.substr (i+1, RLength)) == 0) {
      
                        RMask &= ~ (0x1 << j);
                        TRegs[TRegPtr] = RRegs[j].c_str ();
                        TRegPtr++;
                        break;
                    }
                }
            }
        }
        TRegPtr = 0;
        int MORegPtr = 0;
        for (int i = 0; i < addrOps; i++) {
            fprintf (out1,"\nA,%llu-%i,", (long long unsigned int)instAddr, subAd
      dr);    
            fprintf (out1,"%s#%d,",MORegs[0].c_str (), 2);
            ss << "\nA," << (long long unsigned int)instAddr << "-" <<  subAddr <
      < ",";
            ss << MORegs[0].c_str () << "#2,";
            g_var.g_ins = ss.str ();
            //ss.str (std::string ());
            aluOp++;
            subAddr++;
        }       
        for (int i = 0; i < MPointers; i++) {
            fprintf (out1,"\nR,%llu,%llu-%i,", (long long unsigned int)addr, (lon
      g long unsigned int)instAddr, subAddr); 
            fprintf (out1,"%s#%d,",TRegs[TRegPtr].c_str (), 1);
            fprintf (out1,"%s#%d,",MORegs[TRegPtr].c_str (), 2);
            ss << "\nR," << (long long unsigned int)addr << "," << (long long uns
      igned int)instAddr << "-" << subAddr << ",";    
            ss << TRegs[TRegPtr].c_str () << "#1,";
            ss << MORegs[TRegPtr].c_str () << "#2,";
            g_var.g_ins = ss.str ();
            //ss.str (std::string ());
            TRegPtr++;
            memOp++;
            subAddr++;
        }
        ss << "\n";
        if (isFDiv) {
            fprintf (out1,"\nD,%llu-%i,", (long long unsigned int)instAddr, subAd
      dr);
            ss << "\nD," << (long long unsigned int)instAddr << "-" << subAddr <<
       ",";
            g_var.g_ins = ss.str ();
            //ss.str (std::string ());
            fpOp++;
        } else if (isFloat) {
            fprintf (out1,"\nF,%llu-%i,", (long long unsigned int)instAddr, subAd
      dr);
            ss << "\nF," << (long long unsigned int)instAddr << "-" << subAddr <<
       ",";
            g_var.g_ins = ss.str ();
            //ss.str (std::string ());
            fpOp++;
        } else {
            fprintf (out1,"\nA,%llu-%i,", (long long unsigned int)instAddr, subAd
      dr);
            ss << "\nA," << (long long unsigned int)instAddr << "-" << subAddr <<
       ",";
            g_var.g_ins = ss.str ();
            //ss.str (std::string ());
            aluOp++;
        }
        subAddr++;
        for (UINT32 i = 0; i < MAXR; i++) {
            if (RMask & (0x1 << i)) {
                fprintf (out1,"%s#%d,", RRegs[i].c_str (), 1);
                ss << RRegs[i].c_str () << "#1,";
                g_var.g_ins = ss.str ();
                //ss.str (std::string ());
            } else {
                fprintf (out1,"%s#%d,", MORegs[MORegPtr].c_str (), 1);
                ss << MORegs[MORegPtr].c_str () << "#1,";
                g_var.g_ins = ss.str ();
                //ss.str (std::string ());
                MORegPtr++;
            }
        }
    }
    //ss.str (std::string ());
}
\end{DoxyCode}
\hypertarget{uop__gen_8cpp_a36cb4a3ea0b90875c3f3f7db368660d4}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!dosAsmMEMW@{dosAsmMEMW}}
\index{dosAsmMEMW@{dosAsmMEMW}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{dosAsmMEMW}]{\setlength{\rightskip}{0pt plus 5cm}VOID dosAsmMEMW (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{ip, }
\item[{ADDRINT}]{instAddr, }
\item[{VOID $\ast$}]{addr, }
\item[{int}]{regCount, }
\item[{UINT32}]{isFloat, }
\item[{UINT32}]{isFDiv}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a36cb4a3ea0b90875c3f3f7db368660d4}

\begin{DoxyCode}
{
    if ( ( (warmUp == 1 || strt == 1) && fin == 0) || runAllProgram == true) {
        if (isFloat) {
            fpOp++;
            if (isFDiv) {
                if (logEnable) fprintf (out, "\n--- D, %d, IP:%ld, ADDR:%llu, ASM
      : (%s)\n", regCount, ip, (long long unsigned int)addr, insMap[ip].c_str ());
                if (logEnable) fprintf (out, "\n>> ");
                fprintf (out1,"\nD,%llu,", (long long unsigned int)instAddr);
                ss << "\nD," << (long long unsigned int)instAddr << ",";
                g_var.g_ins = ss.str ();
                //ss.str (std::string ());
            } else {
                if (logEnable) fprintf (out, "\n--- F, %d, IP:%ld, ADDR:%llu, ASM
      : (%s)\n", regCount, ip, (long long unsigned int)addr, insMap[ip].c_str ());
                if (logEnable) fprintf (out, "\n>> ");
                fprintf (out1,"\nF,%llu,", (long long unsigned int)instAddr);
                ss << "\nF," << (long long unsigned int)instAddr << ",";
                g_var.g_ins = ss.str ();
                //ss.str (std::string ());
            }
        } else {
            if (logEnable) fprintf (out, "\n--- W, %d, IP:%ld, ADDR:%llu, ASM: (%
      s)\n", regCount, ip, (long long unsigned int)addr, insMap[ip].c_str ());
            if (logEnable) fprintf (out, "\n>> ");
            fprintf (out1,"\nW,%llu,%llu,", (long long unsigned)addr, (long long 
      unsigned)instAddr);
            ss << "\nW," << (long long unsigned)addr << "," << (long long unsigne
      d)instAddr << ",";
            g_var.g_ins = ss.str ();
            //ss.str (std::string ());
        }
        memOp++;
    }
}
\end{DoxyCode}
\hypertarget{uop__gen_8cpp_a22215f9778fee32ff3167a47ef3717c3}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!dosAsmMEMW1@{dosAsmMEMW1}}
\index{dosAsmMEMW1@{dosAsmMEMW1}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{dosAsmMEMW1}]{\setlength{\rightskip}{0pt plus 5cm}VOID dosAsmMEMW1 (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{ip, }
\item[{ADDRINT}]{instAddr, }
\item[{VOID $\ast$}]{addr, }
\item[{int}]{regCount, }
\item[{UINT32}]{isFloat, }
\item[{UINT32}]{isFDiv}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a22215f9778fee32ff3167a47ef3717c3}

\begin{DoxyCode}
{
    if ( ( (warmUp == 1 || strt == 1) && fin == 0) || runAllProgram == true) {
        if (isFloat) {
            fpOp++;
            if (isFDiv) {
                if (logEnable) fprintf (out, "\n--- D, %d, IP:%ld, ADDR:%llu, ASM
      : (%s)\n", regCount, ip, (long long unsigned int)addr, insMap[ip].c_str ());
                if (logEnable) fprintf (out, "\n>> ");
            } else {
                if (logEnable) fprintf (out, "\n--- F, %d, IP:%ld, ADDR:%llu, ASM
      : (%s)\n", regCount, ip, (long long unsigned int)addr, insMap[ip].c_str ());
                if (logEnable) fprintf (out, "\n>> ");
            }
        } else {
            if (logEnable) fprintf (out, "\n--- W, %d, IP:%ld, ADDR:%llu, ASM: (%
      s)\n", regCount, ip, (long long unsigned int)addr, insMap[ip].c_str ());
            if (logEnable) fprintf (out, "\n>> ");
        } 
        memOp++;
    }
}
\end{DoxyCode}
\hypertarget{uop__gen_8cpp_a74d38cfa65092c53e78f25070e6b2d81}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!dosAsmMEMWS@{dosAsmMEMWS}}
\index{dosAsmMEMWS@{dosAsmMEMWS}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{dosAsmMEMWS}]{\setlength{\rightskip}{0pt plus 5cm}VOID dosAsmMEMWS (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{ip, }
\item[{ADDRINT}]{instAddr, }
\item[{VOID $\ast$}]{addr, }
\item[{int}]{regCount, }
\item[{UINT32}]{isFloat, }
\item[{UINT32}]{isFDiv, }
\item[{UINT32}]{MAXR, }
\item[{UINT32}]{MAXW, }
\item[{REG}]{R1, }
\item[{REG}]{R2, }
\item[{REG}]{R3, }
\item[{REG}]{R4, }
\item[{REG}]{R5, }
\item[{REG}]{R6, }
\item[{REG}]{R7, }
\item[{REG}]{R8, }
\item[{REG}]{W1, }
\item[{REG}]{W2, }
\item[{REG}]{W3, }
\item[{REG}]{W4, }
\item[{REG}]{W5, }
\item[{REG}]{W6, }
\item[{REG}]{W7, }
\item[{REG}]{W8}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a74d38cfa65092c53e78f25070e6b2d81}

\begin{DoxyCode}
{
    if ( ( (warmUp == 1 || strt == 1) && fin == 0) || runAllProgram == true) {
        int subAddr = 0;
        string original = insMap[ip].c_str ();
        string RRegs[8];
        string WRegs[8];
        string TRegs[8];
        string MORegs[8];
        MORegs[0] = MICRO0;
        MORegs[1] = MICRO1;
        MORegs[2] = MICRO2;
        MORegs[3] = MICRO3;
        MORegs[4] = MICRO4;
        MORegs[5] = MICRO5;
        MORegs[6] = MICRO6;
        MORegs[7] = MICRO7;
        int TRegPtr = 0;
        int RMask = 0x0;
        for (UINT32 i = 0; i < MAXR; i++) {
            if (i == 0) {
                RRegs[i] = REG_StringShort (R1);
                RMask |= 0x1;
            } else if (i == 1) {
                RRegs[i] = REG_StringShort (R2); 
                RMask |= 0x2;
            } else if (i == 2) {
                RRegs[i] = REG_StringShort (R3); 
                RMask |= 0x4;
            } else if (i == 3) {
                RRegs[i] = REG_StringShort (R4); 
                RMask |= 0x8;
            } else if (i == 4) {
                RRegs[i] = REG_StringShort (R5); 
                RMask |= 0x10;
            } else if (i == 5) {
                RRegs[i] = REG_StringShort (R6); 
                RMask |= 0x20;
            } else if (i == 6) {
                RRegs[i] = REG_StringShort (R7); 
                RMask |= 0x40;
            } else if (i == 7) {
                RRegs[i] = REG_StringShort (R8); 
                RMask |= 0x80;
            }
        }
        for (UINT32 i = 0; i < MAXW; i++) {
            if (i == 0) {
                WRegs[i] = REG_StringShort (W1);
            } else if (i == 1) {
                WRegs[i] = REG_StringShort (W2); 
            } else if (i == 2) {
                WRegs[i] = REG_StringShort (W3); 
            } else if (i == 3) {
                WRegs[i] = REG_StringShort (W4); 
            } else if (i == 4) {
                WRegs[i] = REG_StringShort (W5); 
            } else if (i == 5) {
                WRegs[i] = REG_StringShort (W6); 
            } else if (i == 6) {
                WRegs[i] = REG_StringShort (W7); 
            } else if (i == 7) {
                WRegs[i] = REG_StringShort (W8); 
            }
        }
        int MPointers = 0;
        int addrOps = 0;
        for (UINT32 i = 0; i < original.length (); i++) {
            if (original[i] == '[') {
                for (UINT32 k = i; k < original.length (); k++) {
                    if (original[k] == ']') {
                        break;
                    } else if ( (original[k] == '+') || (original[k] == '-') || (
      original[k] == '*')) {
                        addrOps++;
                    }
                }
                MPointers++;
                int RLength = 0;
                for (UINT32 ii = i; ii < original.length (); ii++) {
                    if ( (original[ii] == ']') || (original[ii] == ' ') || (origi
      nal[ii] == '+') || (original[ii] == '-') || (original[ii] == '*')) {
                        RLength = ii-i-1;
                        break;
                    }
                }
                for (UINT32 j = 0; j < MAXR; j++) {
                    if (RRegs[j].compare (original.substr (i+1, RLength)) == 0) {
      
                        RMask &= ~ (0x1 << j);
                        TRegs[TRegPtr] = RRegs[j].c_str ();
                        TRegPtr++;
                        break;
                    }
                }
            }
        }
        TRegPtr = 0;
        int MORegPtr = 0;
        for (int i = 0; i < addrOps; i++) {
            fprintf (out1,"\nA,%llu-%i,", (long long unsigned int)instAddr, subAd
      dr);    
            fprintf (out1,"%s#%d,",MORegs[0].c_str (), 2);
            ss << "\nA," << (long long unsigned int)instAddr << "-" << subAddr <<
       ",";   
            ss << MORegs[0].c_str () << "#2,";
            g_var.g_ins = ss.str ();
            //ss.str (std::string ());
            aluOp++;
            subAddr++;
        }       
        for (int i = 0; i < MPointers; i++) {
            fprintf (out1,"\nR,%llu,%llu-%i,", (long long unsigned int)addr, (lon
      g long unsigned int)instAddr, subAddr); 
            fprintf (out1,"%s#%d,",TRegs[TRegPtr].c_str (), 1);
            fprintf (out1,"%s#%d,",MORegs[TRegPtr].c_str (), 2);
            ss << "\nR," << (long long unsigned int)addr << "," << (long long uns
      igned int)instAddr << "-" << subAddr << ",";    
            ss << TRegs[TRegPtr].c_str () << "#1,";
            ss << MORegs[TRegPtr].c_str () << "#2,";
            g_var.g_ins = ss.str ();
            //ss.str (std::string ());
            TRegPtr++;
            memOp++;
            subAddr++;
        }
        ss << "\n";
        if (isFDiv) {
            fprintf (out1,"\nD,%llu-%i,", (long long unsigned int)instAddr, subAd
      dr);
            ss << "\nD," << (long long unsigned int)instAddr << "-" << subAddr <<
       ",";
            g_var.g_ins = ss.str ();
            //ss.str (std::string ());
            fpOp++;
        } else if (isFloat) {
            fprintf (out1,"\nF,%llu-%i,", (long long unsigned int)instAddr, subAd
      dr);
            ss << "\nF," << (long long unsigned int)instAddr << "-" << subAddr <<
       ",";
            g_var.g_ins = ss.str ();
            //ss.str (std::string ());
            fpOp++;
        } else {
            fprintf (out1,"\nA,%llu-%i,", (long long unsigned int)instAddr, subAd
      dr);
            ss << "\nA," << (long long unsigned int)instAddr << "-" << subAddr <<
       ",";
            g_var.g_ins = ss.str ();
            //ss.str (std::string ());
            aluOp++;
        }
        subAddr++;
        for (UINT32 i = 0; i < MAXR; i++) {
            if (RMask & (0x1 << i)) {
                fprintf (out1,"%s#%d,", RRegs[i].c_str (), 1);
                ss << RRegs[i].c_str () << "#1,";
                g_var.g_ins = ss.str ();
                //ss.str (std::string ());
            } else {
                fprintf (out1,"%s#%d,", MORegs[MORegPtr].c_str (), 1);
                ss << MORegs[MORegPtr].c_str () << "#1,";
                g_var.g_ins = ss.str ();
                //ss.str (std::string ());
                MORegPtr++;
            }
        }
        int MORegSPtr = MORegPtr;
        int WMask = 0;
        for (UINT32 i = 0; i < MAXW; i++) {
            bool flags = WRegs[i].compare ("rflags");
            if (flags == 0) {
                fprintf (out1,"%s#%d,", WRegs[i].c_str (), 2); 
                ss << WRegs[i].c_str () << "#2,"; 
                g_var.g_ins = ss.str ();
                //ss.str (std::string ());
            } else {
                fprintf (out1,"%s#%d,", MORegs[MORegPtr].c_str (), 2);
                ss << MORegs[MORegPtr].c_str () << "#2,";
                g_var.g_ins = ss.str ();
                //ss.str (std::string ());
                MORegPtr++;
                WMask |= (0x1 << i);
            }
        }
        fprintf (out1,"\nW,%llu,%llu-%i,", (long long unsigned)addr, (long long u
      nsigned)instAddr, subAddr);
        ss << "\nW," << (long long unsigned)addr << "," << (long long unsigned)in
      stAddr << "-" << subAddr << ",";
        g_var.g_ins = ss.str ();
        //ss.str (std::string ());
        memOp++;
        subAddr++;
        for (UINT32 i = 0; i < MAXW; i++) {
            if (WMask & (0x1 << i)) {
                fprintf (out1,"%s#%d,", MORegs[MORegSPtr].c_str (), 1);
                ss << MORegs[MORegSPtr].c_str () << "#1,";
                g_var.g_ins = ss.str ();
                //ss.str (std::string ());
                MORegSPtr++;
            }
        }           
        for (UINT32 i = 0; i < MAXR; i++) {
            if (! (RMask & (0x1 << i))) {
                fprintf (out1,"%s#%d,", RRegs[i].c_str (), 1);
                ss << RRegs[i].c_str () << "#1,";
                g_var.g_ins = ss.str ();
                //ss.str (std::string ());
            }
        }
    }
    //ss.str (std::string ());
}
\end{DoxyCode}
\hypertarget{uop__gen_8cpp_a494cc3b7e8096971d0edd424c59eb639}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!EmulateLoad@{EmulateLoad}}
\index{EmulateLoad@{EmulateLoad}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{EmulateLoad}]{\setlength{\rightskip}{0pt plus 5cm}VOID EmulateLoad (
\begin{DoxyParamCaption}
\item[{INS}]{ins, }
\item[{VOID $\ast$}]{v}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a494cc3b7e8096971d0edd424c59eb639}


$\ast$MEMORY OPERATIONS$\ast$/

$\ast$NON-\/MEMORY OPERATIONS$\ast$/ /if (memOperands==0 \&\& INS\_\-OperandCount (ins) $>$ 0 \&\& INS\_\-Valid (ins)) \{ 


\begin{DoxyCode}
{
    INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) findInSfile,
            IARG_INST_PTR,
            IARG_ADDRINT, INS_Address (ins),
            IARG_END);
    //INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) reset,
    //  IARG_END);
    //pair<map<ADDRINT,string>::iterator,bool> ret;
    //UINT32 memOperands = INS_MemoryOperandCount (ins);
    //for (UINT32 memOp = 0; memOp < memOperands; memOp++)
    //{
    //    //printf ("%lx\t\t%s\tINS_COUNT=%d\n", INS_Opcode (ins), INS_Disassembl
      e (ins).c_str (),INS_OperandCount (ins));
    //    if (INS_MemoryOperandIsRead (ins, memOp) && INS_Valid (ins))
    //    {
    //          bool split = (INS_Category (ins) == XED_CATEGORY_BINARY) ||
    //                       (INS_Category (ins) == XED_CATEGORY_LOGICAL) ||
    //                       (INS_Category (ins) == XED_CATEGORY_STRINGOP);
    //
    //          ADDRINT insAddr = INS_Address (ins);
    //          string temp = INS_Disassemble (ins);
    //          ret=insMap.insert (pair<ADDRINT,string> (insAddr,temp));
    //
    //          bool isFloatIns;
    //          isFloatIns = isFloat (ins);
    //
    //          bool isFDivIns;
    //          isFDivIns = isFDiv (ins);
    //
    //          UINT32 operandCount = INS_MaxNumRRegs (ins)+INS_MaxNumWRegs (ins)
      ; //INS_OperandCount (ins);
    //          
    //          if (split && ENABLE_MICRO) {
    //                  INS_InsertPredicatedCall (
    //                      ins, IPOINT_BEFORE, AFUNPTR (dosAsmMEMRS),
    //                      IARG_INST_PTR,
    //                          IARG_ADDRINT, insAddr,
    //                          IARG_MEMORYOP_EA, memOp,
    //                      IARG_UINT32, operandCount,
    //                          IARG_UINT32, isFloatIns,
    //                          IARG_UINT32, isFDivIns,
    //                          IARG_UINT32, INS_MaxNumRRegs (ins),
    //                          IARG_UINT32, INS_MaxNumWRegs (ins),
    //                          IARG_UINT32, INS_RegR (ins, 0),
    //                          IARG_UINT32, INS_RegR (ins, 1),
    //                          IARG_UINT32, INS_RegR (ins, 2),
    //                          IARG_UINT32, INS_RegR (ins, 3),
    //                          IARG_UINT32, INS_RegR (ins, 4),
    //                          IARG_UINT32, INS_RegR (ins, 5),
    //                          IARG_UINT32, INS_RegR (ins, 6),
    //                          IARG_UINT32, INS_RegR (ins, 7),
    //                          IARG_END);
    //
    //                  INS_InsertPredicatedCall ( ins, IPOINT_BEFORE, AFUNPTR (d
      osAsmMEMR1),
    //                      IARG_INST_PTR,
    //                          IARG_ADDRINT, insAddr,
    //                          IARG_MEMORYOP_EA, memOp,
    //                      IARG_UINT32, operandCount,
    //                          IARG_UINT32, isFloatIns,
    //                          IARG_UINT32, isFDivIns,
    //                          IARG_END);
    //                  for (j = 0; j < INS_MaxNumRRegs (ins); j+=1) {
    //                          int regType=1; //READ
    //                          INS_InsertPredicatedCall (ins,
    //                                  IPOINT_BEFORE,
    //                                  AFUNPTR (operands1),
    //                                  IARG_INST_PTR,
    //                                  IARG_UINT32, INS_RegR (ins, j),
    //                                  IARG_UINT32, j,
    //                                  IARG_UINT32, regType,
    //                              IARG_END);
    //                                  printf ("Regggg (%d)%d: %d - %s\n",j,INS_
      OperandCount (ins),regType, 
    //                                                                 REG_String
      Short (INS_RegR (ins, j)).c_str ()); //INS_Disassemble (ins).c_str ());
    //                  }
    //                  for (j = 0; j < INS_MaxNumWRegs (ins); j+=1) {
    //                          int regType=2; //WRITE
    //                          INS_InsertPredicatedCall (ins,
    //                                  IPOINT_BEFORE,
    //                                  AFUNPTR (operands),
    //                                  IARG_INST_PTR,
    //                                  IARG_UINT32, INS_RegW (ins, j),
    //                                  IARG_UINT32, j,
    //                                  IARG_UINT32, regType,
    //                              IARG_END);
    //                                  printf ("Regggg (%d)%d: %d - %s\n",j,INS_
      OperandCount (ins),regType, 
    //                                                                 REG_String
      Short (INS_RegW (ins, j)).c_str ()); //INS_Disassemble (ins).c_str ());
    //                  }
    //          } else {
    //                  INS_InsertPredicatedCall (
    //                      ins, IPOINT_BEFORE, AFUNPTR (dosAsmMEMR),
    //                      IARG_INST_PTR,
    //                          IARG_ADDRINT, insAddr,
    //                          IARG_MEMORYOP_EA, memOp,
    //                      IARG_UINT32, operandCount,
    //                          IARG_UINT32, isFloatIns,
    //                          IARG_UINT32, isFDivIns,
    //                          IARG_END);
    //                  for (j = 0; j < INS_MaxNumRRegs (ins); j+=1) {
    //                      int regType=1; //READ
    //                      INS_InsertPredicatedCall (ins,
    //                          IPOINT_BEFORE,
    //                          AFUNPTR (operands),
    //                          IARG_INST_PTR,
    //                          IARG_UINT32, INS_RegR (ins, j),
    //                          IARG_UINT32, j,
    //                          IARG_UINT32, regType,
    //                          IARG_END);
    //                              printf ("Regggg (%d)%d: %d - %s\n",j,INS_Oper
      andCount (ins),regType, 
    //                                  REG_StringShort (INS_RegR (ins, j)).c_str
       ()); //INS_Disassemble (ins).c_str ());
    //                  }
    //                  for (j = 0; j < INS_MaxNumWRegs (ins); j+=1) {
    //                          int regType=2; //WRITE
    //                          INS_InsertPredicatedCall (ins,
    //                                  IPOINT_BEFORE,
    //                                  AFUNPTR (operands),
    //                                  IARG_INST_PTR,
    //                                  IARG_UINT32, INS_RegW (ins, j),
    //                                  IARG_UINT32, j,
    //                                  IARG_UINT32, regType,
    //                              IARG_END);
    //                                  printf ("Regggg (%d)%d: %d - %s\n",j,INS_
      OperandCount (ins),regType, 
    //                                  REG_StringShort (INS_RegW (ins, j)).c_str
       ()); //INS_Disassemble (ins).c_str ());
    //                  }
    //          }
    //  }
    //    if (INS_MemoryOperandIsWritten (ins, memOp) && INS_Valid (ins))
    //    {
    //
    //          bool split = (INS_Category (ins) == XED_CATEGORY_BINARY) ||
    //                       (INS_Category (ins) == XED_CATEGORY_LOGICAL) ||
    //                       (INS_Category (ins) == XED_CATEGORY_STRINGOP);
    //
    //          ADDRINT insAddr = INS_Address (ins);
    //          string temp = INS_Disassemble (ins);
    //          ret=insMap.insert (pair<ADDRINT,string> (insAddr,temp));
    //          
    //          bool isFloatIns;
    //          isFloatIns = isFloat (ins);
    //
    //          bool isFDivIns;
    //          isFDivIns = isFDiv (ins);
    //
    //          UINT32 operandCount = INS_MaxNumRRegs (ins)+INS_MaxNumWRegs (ins)
      ; //INS_OperandCount (ins);
    //          
    //          if (split && ENABLE_MICRO) {
    //                  INS_InsertPredicatedCall (
    //                      ins, IPOINT_BEFORE, AFUNPTR (dosAsmMEMWS),
    //                      IARG_INST_PTR,
    //                          IARG_ADDRINT, insAddr,
    //                          IARG_MEMORYOP_EA, memOp,
    //                      IARG_UINT32, operandCount,
    //                          IARG_UINT32, isFloatIns,
    //                          IARG_UINT32, isFDivIns,
    //                          IARG_UINT32, INS_MaxNumRRegs (ins),
    //                          IARG_UINT32, INS_MaxNumWRegs (ins),
    //                          IARG_UINT32, INS_RegR (ins, 0),
    //                          IARG_UINT32, INS_RegR (ins, 1),
    //                          IARG_UINT32, INS_RegR (ins, 2),
    //                          IARG_UINT32, INS_RegR (ins, 3),
    //                          IARG_UINT32, INS_RegR (ins, 4),
    //                          IARG_UINT32, INS_RegR (ins, 5),
    //                          IARG_UINT32, INS_RegR (ins, 6),
    //                          IARG_UINT32, INS_RegR (ins, 7),
    //                          IARG_UINT32, INS_RegW (ins, 0),
    //                          IARG_UINT32, INS_RegW (ins, 1),
    //                          IARG_UINT32, INS_RegW (ins, 2),
    //                          IARG_UINT32, INS_RegW (ins, 3),
    //                          IARG_UINT32, INS_RegW (ins, 4),
    //                          IARG_UINT32, INS_RegW (ins, 5),
    //                          IARG_UINT32, INS_RegW (ins, 6),
    //                          IARG_UINT32, INS_RegW (ins, 7),
    //                          IARG_END);
    //                  INS_InsertPredicatedCall (
    //                      ins, IPOINT_BEFORE, AFUNPTR (dosAsmMEMW1),
    //                      IARG_INST_PTR,
    //                          IARG_ADDRINT, insAddr,
    //                          IARG_MEMORYOP_EA, memOp,
    //                      IARG_UINT32, operandCount,
    //                          IARG_UINT32, isFloatIns,
    //                          IARG_UINT32, isFDivIns,
    //                          IARG_END);
    //                  for (j = 0; j < INS_MaxNumWRegs (ins); j+=1) {
    //                          int regType=2; //WRITE
    //                          INS_InsertPredicatedCall (ins,
    //                                  IPOINT_BEFORE,
    //                                  AFUNPTR (operands1),
    //                                  IARG_INST_PTR,
    //                                  IARG_UINT32, INS_RegW (ins, j),
    //                                  IARG_UINT32, j,
    //                                  IARG_UINT32, regType,
    //                              IARG_END);
    //                                  printf ("Regggg (%d)%d: %d - %s\n",j,INS_
      OperandCount (ins),regType, 
    //                                                  REG_StringShort (INS_RegR
       (ins, j)).c_str ()); //INS_Disassemble (ins).c_str ());
    //                  }
    //                  for (j = 0; j < INS_MaxNumRRegs (ins); j+=1) {
    //                      int regType=1; //READ
    //                      INS_InsertPredicatedCall (ins,
    //                          IPOINT_BEFORE,
    //                          AFUNPTR (operands1),
    //                          IARG_INST_PTR,
    //                          IARG_UINT32, INS_RegR (ins, j),
    //                          IARG_UINT32, j,
    //                          IARG_UINT32, regType,
    //                          IARG_END);
    //                              printf ("Regggg (%d)%d: %d - %s\n",j,INS_Oper
      andCount (ins),regType, 
    //                                                  REG_StringShort (INS_RegW
       (ins, j)).c_str ()); //INS_Disassemble (ins).c_str ());
    //                  }
    //          } else {
    //                  INS_InsertPredicatedCall (
    //                      ins, IPOINT_BEFORE, AFUNPTR (dosAsmMEMW),
    //                      IARG_INST_PTR,
    //                          IARG_ADDRINT, insAddr,
    //                          IARG_MEMORYOP_EA, memOp,
    //                      IARG_UINT32, operandCount,
    //                          IARG_UINT32, isFloatIns,
    //                      IARG_UINT32, isFDivIns,
    //                          IARG_END);
    //                  for (j = 0; j < INS_MaxNumWRegs (ins); j+=1) {
    //                          int regType=2; //WRITE
    //                          INS_InsertPredicatedCall (ins,
    //                                  IPOINT_BEFORE,
    //                                  AFUNPTR (operands),
    //                                  IARG_INST_PTR,
    //                                  IARG_UINT32, INS_RegW (ins, j),
    //                                  IARG_UINT32, j,
    //                                  IARG_UINT32, regType,
    //                              IARG_END);
    //                                  printf ("Regggg (%d)%d: %d - %s\n",j,INS_
      OperandCount (ins),regType,
    //                                                  REG_StringShort (INS_RegW
       (ins, j)).c_str ()); //INS_Disassemble (ins).c_str ());
    //printf ("Regggg (%d)%d: %d - %s\n",j,INS_OperandCount (ins),regType, INS_Di
      sassemble (ins).c_str ());
    //                  }
    //                  for (j = 0; j < INS_MaxNumRRegs (ins); j+=1) {
    //                          int regType=1; //READ
    //                          INS_InsertPredicatedCall (ins,
    //                                  IPOINT_BEFORE,
    //                                  AFUNPTR (operands),
    //                                  IARG_INST_PTR,
    //                                  IARG_UINT32, INS_RegR (ins, j),
    //                                  IARG_UINT32, j,
    //                                  IARG_UINT32, regType,
    //                              IARG_END);
    //                              printf ("Regggg (%d)%d: %d - %s\n",j,INS_Oper
      andCount (ins),regType,
    //                                                  REG_StringShort (INS_RegR
       (ins, j)).c_str ()); //INS_Disassemble (ins).c_str ());
    //printf ("Regggg (%d)%d: %d - %s\n",j,INS_OperandCount (ins),regType, INS_Di
      sassemble (ins).c_str ());
    // Count!
    //INS_InsertPredicatedCall (ins, IPOINT_BEFORE,
    //   (AFUNPTR)memCount, IARG_END);
    //fprintf (trace1, "\t%lx\t\t%s\n", INS_Opcode (ins), INS_Disassemble (ins));
      
    //                  }
    //          }
    //    }
    //}
    //if (memOperands==0 || INS_Category (ins) == XED_CATEGORY_BINARY ||
    //  INS_Category (ins) == XED_CATEGORY_LOGICAL ||
    //  INS_Category (ins) == XED_CATEGORY_STRINGOP) {
    //    ADDRINT insAddr = INS_Address (ins);
    //    string temp = INS_Disassemble (ins);
    //    ret=insMap.insert (pair<ADDRINT,string> (insAddr,temp));
    //    
    //    bool isFloatIns;
    //    isFloatIns = isFloat (ins);
    //    bool isFDivIns;
    //    isFDivIns = isFDiv (ins);
    //    bool isBranchIns;
    //    if (INS_Category (ins) == XED_CATEGORY_COND_BR) {
    //        isBranchIns = true;
    //          //printf ("%lx\t\t%s\tINS_COUNT=%d\n", INS_Opcode (ins), INS_Disa
      ssemble (ins).c_str (),INS_OperandCount (ins));
    //    } else {
    //        isBranchIns = false;
    //    }
    //
    //    UINT32 operandCount = INS_MaxNumRRegs (ins)+INS_MaxNumWRegs (ins); //IN
      S_OperandCount (ins);
    //      INS_InsertPredicatedCall (ins,
    //          IPOINT_BEFORE,
    //          AFUNPTR (disAsmALU),
    //          IARG_INST_PTR,
    //          IARG_ADDRINT, insAddr,
    //                  IARG_UINT32, operandCount,
    //                  IARG_UINT32, isFloatIns,
    //          IARG_UINT32, isFDivIns,
    //          IARG_UINT32, isBranchIns,
    //                  IARG_BRANCH_TARGET_ADDR,
    //                  IARG_BRANCH_TAKEN,
    //                  IARG_END);
    //    for (j = 0; j < INS_MaxNumRRegs (ins); j+=1) {
    //            int regType=1;//READ
    //            INS_InsertPredicatedCall (ins,
    //                  IPOINT_BEFORE,
    //                  AFUNPTR (operands),
    //                  IARG_INST_PTR,
    //                  IARG_UINT32, INS_RegR (ins, j),
    //                  IARG_UINT32, j,
    //                  IARG_UINT32, regType,
    //                IARG_END);
    //              printf ("Regggg (%d)%d: %d - %s\n",j,INS_OperandCount (ins),r
      egType, 
    //                                          REG_StringShort (INS_RegR (ins, j
      )).c_str ()); //INS_Disassemble (ins).c_str ());
    //printf ("Regggg (%d)%d: %d - %s\n",j,INS_OperandCount (ins),regType, INS_Di
      sassemble (ins).c_str ());
    //    }
    //    for (j = 0; j < INS_MaxNumWRegs (ins); j+=1) {
    //          int regType=2;//WRITE
    //          INS_InsertPredicatedCall (ins,
    //                  IPOINT_BEFORE,
    //                  AFUNPTR (operands),
    //                  IARG_INST_PTR,
    //                  IARG_UINT32, INS_RegW (ins, j),
    //                  IARG_UINT32, j,
    //                  IARG_UINT32, regType,
    //              IARG_END);
    //                  printf ("Regggg (%d)%d: %d - %s\n",j,INS_OperandCount (in
      s),regType, 
    //                                  REG_StringShort (INS_RegW (ins, j)).c_str
       ()); //INS_Disassemble (ins).c_str ());
    //          //printf ("Regggg (%d)%d: %d - %s\n",j,INS_OperandCount (ins),reg
      Type, INS_Disassemble (ins).c_str ());
    //    }
    //}
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{uop__gen_8cpp_a81d412f8480d48d0e150906d993936c5}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!findInSfile@{findInSfile}}
\index{findInSfile@{findInSfile}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{findInSfile}]{\setlength{\rightskip}{0pt plus 5cm}VOID findInSfile (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{ip, }
\item[{ADDRINT}]{insAddr}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a81d412f8480d48d0e150906d993936c5}

\begin{DoxyCode}
                                               {
    if (!_g_staticCode->isInsIn_insMap (insAddr)) {
        g_var.stat.noMatchIns++;
        //if (g_var.missingInsList.find (insAddr) == g_var.missingInsList.end ())
      
        //      printf ("-- INS: %ld %lx\n", insAddr, insAddr);
        g_var.stat.missingInsList.insert (insAddr);
    } else {
        g_var.stat.matchIns++;
        g_var.g_ins = _g_staticCode->getIns (insAddr);
        //printf ("%s\n", _g_staticCode->getIns (insAddr, 1, 1, false).c_str ());
      
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{uop__gen_8cpp_a6b129244e191a3f59375a31842557abd}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!get\_\-uop@{get\_\-uop}}
\index{get\_\-uop@{get\_\-uop}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{get\_\-uop}]{\setlength{\rightskip}{0pt plus 5cm}void get\_\-uop (
\begin{DoxyParamCaption}
\item[{INS}]{ins}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a6b129244e191a3f59375a31842557abd}

\begin{DoxyCode}
                       {
    if (INS_IsBranchOrCall (ins) || INS_IsFarRet (ins) || INS_IsRet (ins)) {
        INS_InsertCall (ins, IPOINT_TAKEN_BRANCH, (AFUNPTR) getBrIns,
                IARG_ADDRINT, INS_Address (ins),
                IARG_BOOL, INS_HasFallThrough (ins),
                IARG_BRANCH_TARGET_ADDR, 
                IARG_FALLTHROUGH_ADDR,
                IARG_BRANCH_TAKEN,
                IARG_BOOL, INS_IsCall (ins) || INS_IsFarCall (ins),
                IARG_BOOL, INS_IsRet (ins) || INS_IsFarRet (ins),
                IARG_BOOL, INS_IsDirectFarJump (ins) || INS_IsFarJump (ins) || (I
      NS_IsBranch (ins) && INS_HasFallThrough (ins)),
                IARG_BOOL, INS_IsDirectFarJump (ins) || INS_IsDirectBranchOrCall 
      (ins),
                IARG_END);
        /*
        //capture mem u-op
        if (INS_IsMemoryWrite (ins) || INS_IsMemoryRead (ins)) {
        INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) getMemIns,
        IARG_ADDRINT, INS_Address (ins),
        IARG_MEMORYWRITE_SIZE,
        IARG_MEMORYWRITE_EA,
        IARG_END);
        }
        */
    } else if (INS_IsMemoryWrite (ins)) {
        BOOL isMemRead;
        isMemRead = false;
        INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) getMemIns,
                IARG_ADDRINT, INS_Address (ins),
                IARG_MEMORYWRITE_SIZE,
                IARG_MEMORYWRITE_EA,
                IARG_BOOL, INS_IsStackRead (ins),
                IARG_BOOL, INS_IsStackWrite (ins),
                IARG_BOOL, isMemRead,
                IARG_END);
    } else if (INS_IsMemoryRead (ins)) {
        bool isMemRead;
        isMemRead = true;
        INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) getMemIns,
                IARG_ADDRINT, INS_Address (ins),
                IARG_MEMORYREAD_SIZE,
                IARG_MEMORYREAD_EA,
                IARG_BOOL, INS_IsStackRead (ins),
                IARG_BOOL, INS_IsStackWrite (ins),
                IARG_BOOL, isMemRead,
                IARG_END);
    } else if (INS_IsNop (ins)) {
        INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) getNopIns,
                IARG_ADDRINT, INS_Address (ins),
                IARG_END);
    } else {
        INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) getIns,
                IARG_ADDRINT, INS_Address (ins),
                IARG_END);
        /*
        //capture mem u-op
        if (INS_IsMemoryWrite (ins) || INS_IsMemoryRead (ins)) {
        INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) getMemIns,
        IARG_ADDRINT, INS_Address (ins),
        IARG_MEMORYWRITE_SIZE,
        IARG_MEMORYWRITE_EA,
        IARG_END);
        */
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{uop__gen_8cpp_aa9b459ce84a7d93d13a3f1f3bf82088a}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!getBrIns@{getBrIns}}
\index{getBrIns@{getBrIns}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{getBrIns}]{\setlength{\rightskip}{0pt plus 5cm}VOID getBrIns (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{insAddr, }
\item[{BOOL}]{hasFT, }
\item[{ADDRINT}]{tgAddr, }
\item[{ADDRINT}]{ftAddr, }
\item[{BOOL}]{isTaken, }
\item[{BOOL}]{isCall, }
\item[{BOOL}]{isRet, }
\item[{BOOL}]{isJump, }
\item[{BOOL}]{isDirBrOrCallOrJmp}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_aa9b459ce84a7d93d13a3f1f3bf82088a}

\begin{DoxyCode}
                                                                                 
                                                                              {
    if (!_g_staticCode->isInsIn_insMap (insAddr)) {
        g_var.stat.noMatchIns++;
        //if (g_var.missingInsList.find (insAddr) == g_var.missingInsList.end ())
      
        //      printf ("-- INS: %ld %lx\n", insAddr, insAddr);
        g_var.stat.missingInsList.insert (insAddr);
    } else {
        g_var.stat.matchIns++;
        string s;
        //if (!firstBB)
        s = _g_staticCode->getBrIns (insAddr, hasFT, tgAddr, ftAddr, isTaken);
        if (s != "MILAD") {
            g_var.g_ins = s;
            dynInstruction* g_insObj = g_var.getNewCodeCacheIns ();
            dynInstruction* staticIns = _g_staticCode->getInsObj (insAddr);
            staticIns->copyRegsTo (g_insObj);
            g_insObj->setBrAtr (tgAddr, ftAddr, hasFT, isTaken, isCall, isRet, is
      Jump, isDirBrOrCallOrJmp);
            g_insObj->setInsType (BR);
            g_insObj->setInsAddr (insAddr);
            g_insObj->setInsID (g_var.g_seq_num++);
            g_insObj->setWrongPath (g_var.g_wrong_path);
        }
        //printf ("%s\n", _g_staticCode->getIns (insAddr, 1, 1, false).c_str ());
      
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{uop__gen_8cpp_a0ec88bd53fecf7e7ba1cb862d34db82d}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!getIns@{getIns}}
\index{getIns@{getIns}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{getIns}]{\setlength{\rightskip}{0pt plus 5cm}VOID getIns (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{insAddr}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a0ec88bd53fecf7e7ba1cb862d34db82d}

\begin{DoxyCode}
                              {
    if (!_g_staticCode->isInsIn_insMap (insAddr)) {
        g_var.stat.noMatchIns++;
        //if (g_var.missingInsList.find (insAddr) == g_var.missingInsList.end ())
      
        //      printf ("-- INS: %ld %lx\n", insAddr, insAddr);
        g_var.stat.missingInsList.insert (insAddr);
    } else {
        g_var.stat.matchIns++;
        string s;
        //if (!firstBB)
        s = g_var.g_ins = _g_staticCode->getIns (insAddr);
        if (s != "MILAD") {
            dynInstruction* g_insObj = g_var.getNewCodeCacheIns ();
            dynInstruction* staticIns = _g_staticCode->getInsObj (insAddr);
            staticIns->copyRegsTo (g_insObj);
            g_insObj->setInsType (ALU);
            g_insObj->setInsAddr (insAddr);
            g_insObj->setInsID (g_var.g_seq_num++);
            g_insObj->setWrongPath (g_var.g_wrong_path);
            g_var.g_ins = s;
        }
        //printf ("%s\n", _g_staticCode->getIns (insAddr, 1, 1, false).c_str ());
      
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{uop__gen_8cpp_a2dca73fb6683b99910bcad66c0cdf726}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!getMemIns@{getMemIns}}
\index{getMemIns@{getMemIns}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{getMemIns}]{\setlength{\rightskip}{0pt plus 5cm}VOID getMemIns (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{insAddr, }
\item[{ADDRINT}]{memAccessSize, }
\item[{ADDRINT}]{memAddr, }
\item[{BOOL}]{isStackRd, }
\item[{BOOL}]{isStackWr, }
\item[{BOOL}]{isMemRead}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a2dca73fb6683b99910bcad66c0cdf726}

\begin{DoxyCode}
                                                                                 
                                              {
    if (!_g_staticCode->isInsIn_insMap (insAddr)) {
        g_var.stat.noMatchIns++;
        //if (g_var.missingInsList.find (insAddr) == g_var.missingInsList.end ())
      
        //      printf ("-- INS: %ld %lx\n", insAddr, insAddr);
        g_var.stat.missingInsList.insert (insAddr);
    } else {
        g_var.stat.matchIns++;
        string s;
        //if (!firstBB)
        s = _g_staticCode->getMemIns (insAddr, memAccessSize, memAddr);
        if (s != "MILAD") {
            g_var.g_ins = s;
            dynInstruction* g_insObj = g_var.getNewCodeCacheIns ();
            dynInstruction* staticIns = _g_staticCode->getInsObj (insAddr);
            staticIns->copyRegsTo (g_insObj);
            MEM_TYPE mType = (isMemRead == true ? LOAD : STORE);
            g_insObj->setMemAtr (mType, memAddr, memAccessSize, isStackRd, isStac
      kWr);
            g_insObj->setInsType (MEM);
            g_insObj->setInsAddr (insAddr);
            g_insObj->setInsID (g_var.g_seq_num++);
            g_insObj->setWrongPath (g_var.g_wrong_path);
        }
        //printf ("%s\n", _g_staticCode->getIns (insAddr, 1, 1, false).c_str ());
      
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{uop__gen_8cpp_abd93f7dec3bc70a2e12dabcb528b00c5}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!getNopIns@{getNopIns}}
\index{getNopIns@{getNopIns}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{getNopIns}]{\setlength{\rightskip}{0pt plus 5cm}VOID getNopIns (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{insAddr}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_abd93f7dec3bc70a2e12dabcb528b00c5}

\begin{DoxyCode}
                                 {
    if (!_g_staticCode->isInsIn_insMap (insAddr)) {
        g_var.stat.noMatchIns++;
        //if (g_var.missingInsList.find (insAddr) == g_var.missingInsList.end ())
      
        //      printf ("-- INS: %ld %lx\n", insAddr, insAddr);
        g_var.stat.missingInsList.insert (insAddr);
    } else {
        g_var.stat.matchIns++;
        string s;
        //if (!firstBB)
        s = g_var.g_ins = _g_staticCode->getIns (insAddr);
        if (s != "MILAD") {
            dynInstruction* g_insObj = g_var.getNewCodeCacheIns ();
            dynInstruction* staticIns = _g_staticCode->getInsObj (insAddr);
            staticIns->copyRegsTo (g_insObj);
            g_insObj->setInsType (NOP);
            g_insObj->setInsAddr (insAddr);
            g_insObj->setInsID (g_var.g_seq_num++);
            g_insObj->setWrongPath (g_var.g_wrong_path);
            g_var.g_ins = s;
        }
        //printf ("%s\n", _g_staticCode->getIns (insAddr, 1, 1, false).c_str ());
      
    }
}
\end{DoxyCode}


Here is the call graph for this function:




Here is the caller graph for this function:


\hypertarget{uop__gen_8cpp_adb2db14a73cb9e821f3b42ee61403c82}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!instr@{instr}}
\index{instr@{instr}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{instr}]{\setlength{\rightskip}{0pt plus 5cm}VOID instr (
\begin{DoxyParamCaption}
\item[{INS}]{ins, }
\item[{VOID $\ast$}]{v}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_adb2db14a73cb9e821f3b42ee61403c82}

\begin{DoxyCode}
                              {
    INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) doImpCount,
            IARG_END);
    INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) doImpMemCount,
            IARG_UINT32, INS_MemoryOperandCount (ins),
            IARG_END);
    INS_InsertCall (ins, IPOINT_BEFORE, (AFUNPTR) doImpCallCount,
            IARG_BOOL, INS_IsCall (ins),
            IARG_END);
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{uop__gen_8cpp_aab56ab18527221c529ee447fd64d6dd2}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!isFDiv@{isFDiv}}
\index{isFDiv@{isFDiv}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{isFDiv}]{\setlength{\rightskip}{0pt plus 5cm}bool isFDiv (
\begin{DoxyParamCaption}
\item[{INS}]{ins}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_aab56ab18527221c529ee447fd64d6dd2}

\begin{DoxyCode}
{
    bool isFDiv;
    isFDiv = false;

    OPCODE oc = INS_Opcode (ins);

    if (oc == XED_ICLASS_DIVPD) isFDiv = true;
    if (oc == XED_ICLASS_DIVPS) isFDiv = true;
    if (oc == XED_ICLASS_DIVSD) isFDiv = true;
    if (oc == XED_ICLASS_DIVSS) isFDiv = true;
    if (oc == XED_ICLASS_FDIV) isFDiv = true; //Hopfeully not buggy? HA
    if (oc == XED_ICLASS_FDIVP) isFDiv = true;
    if (oc == XED_ICLASS_FDIVR) isFDiv = true;
    if (oc == XED_ICLASS_FDIVRP) isFDiv = true;
    if (oc == XED_ICLASS_FIDIV) isFDiv = true;
    if (oc == XED_ICLASS_FIDIVR) isFDiv = true; //I think this is dividing ints..
      
    if (oc == XED_ICLASS_FDIV) isFDiv = true; //Hopfeully not buggy? HA
    if (oc == XED_ICLASS_FDIVP) isFDiv = true;
    if (oc == XED_ICLASS_FDIVR) isFDiv = true;
    if (oc == XED_ICLASS_FDIVRP) isFDiv = true;
    if (oc == XED_ICLASS_FIDIV) isFDiv = true;
    if (oc == XED_ICLASS_FIDIVR) isFDiv = true; //I think this is dividing ints..
      

    return isFDiv;
}
\end{DoxyCode}
\hypertarget{uop__gen_8cpp_a217fa2dd3b2403988eef55b4356904cf}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!isFloat@{isFloat}}
\index{isFloat@{isFloat}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{isFloat}]{\setlength{\rightskip}{0pt plus 5cm}bool isFloat (
\begin{DoxyParamCaption}
\item[{INS}]{ins}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a217fa2dd3b2403988eef55b4356904cf}

\begin{DoxyCode}
{
    bool isFloat;
    isFloat = false;

    OPCODE oc = INS_Opcode (ins); 

    if (oc == XED_ICLASS_MOVSS) isFloat = true;
    if (oc == XED_ICLASS_MOVAPS) isFloat = true;

    if (oc == XED_ICLASS_F2XM1) isFloat = true; //2^x - 1
    if (oc == XED_ICLASS_FABS) isFloat = true;
    if (oc == XED_ICLASS_FADD) isFloat = true;
    if (oc == XED_ICLASS_FADDP) isFloat = true;
    if (oc == XED_ICLASS_FCMOVB) isFloat = true; //conditional moves...
    if (oc == XED_ICLASS_FCMOVBE) isFloat = true;
    if (oc == XED_ICLASS_FCMOVE) isFloat = true;
    if (oc == XED_ICLASS_FCMOVNB) isFloat = true;
    if (oc == XED_ICLASS_FCMOVNBE) isFloat = true;
    if (oc == XED_ICLASS_FCMOVNE) isFloat = true;
    if (oc == XED_ICLASS_FCMOVNU) isFloat = true;
    if (oc == XED_ICLASS_FCMOVU) isFloat = true;
    if (oc == XED_ICLASS_FCOM) isFloat = true; //fpcompares...not counting
    if (oc == XED_ICLASS_FCOMI) isFloat = true;
    if (oc == XED_ICLASS_FCOMIP) isFloat = true;
    if (oc == XED_ICLASS_FCOMP) isFloat = true;
    if (oc == XED_ICLASS_FCOMPP) isFloat = true;
    if (oc == XED_ICLASS_FDIV) isFloat = true; //Hopfeully not buggy? HA
    if (oc == XED_ICLASS_FDIVP) isFloat = true;
    if (oc == XED_ICLASS_FDIVR) isFloat = true;
    if (oc == XED_ICLASS_FDIVRP) isFloat = true;
    if (oc == XED_ICLASS_FFREE) isFloat = true;
    if (oc == XED_ICLASS_FFREEP) isFloat = true;
    if (oc == XED_ICLASS_FIADD) isFloat = true;
    if (oc == XED_ICLASS_FICOM) isFloat = true;
    if (oc == XED_ICLASS_FICOMP) isFloat = true;
    if (oc == XED_ICLASS_FIDIV) isFloat = true;
    if (oc == XED_ICLASS_FIDIVR) isFloat = true; //I think this is dividing ints.
      .
    if (oc == XED_ICLASS_FIMUL) isFloat = true;
    if (oc == XED_ICLASS_FISUB) isFloat = true;
    if (oc == XED_ICLASS_FISUBR) isFloat = true;
    if (oc == XED_ICLASS_FMUL) isFloat = true;
    if (oc == XED_ICLASS_FMULP) isFloat = true;
    if (oc == XED_ICLASS_FNINIT) isFloat = true;
    if (oc == XED_ICLASS_FNSAVE) isFloat = true; //These seem like adds...
    if (oc == XED_ICLASS_FNSTCW) isFloat = true;
    if (oc == XED_ICLASS_FNSTENV) isFloat = true;
    if (oc == XED_ICLASS_FNSTSW) isFloat = true;
    if (oc == XED_ICLASS_FPREM) isFloat = true; //Partial remainder..
    if (oc == XED_ICLASS_FPREM1) isFloat = true;
    if (oc == XED_ICLASS_FRNDINT) isFloat = true;  //round to integer
    if (oc == XED_ICLASS_FSCALE) isFloat = true; //some sort of rounding operatio
      n  
    if (oc == XED_ICLASS_FSQRT) isFloat = true; //
    if (oc == XED_ICLASS_FST) isFloat = true; //floating point store
    if (oc == XED_ICLASS_FSTP) isFloat = true; //floating point store & pop
    if (oc == XED_ICLASS_FSUB) isFloat = true;  //various types of subtracts
    if (oc == XED_ICLASS_FSUBP) isFloat = true;
    if (oc == XED_ICLASS_FSUBR) isFloat = true; //reverse subtract
    if (oc == XED_ICLASS_FSUBRP) isFloat = true;
    if (oc == XED_ICLASS_FTST) isFloat = true; //compare (test) 
    if (oc == XED_ICLASS_FUCOM) isFloat = true; //unordered compare floating poin
      t values
    if (oc == XED_ICLASS_FUCOMI) isFloat = true;
    if (oc == XED_ICLASS_FUCOMIP) isFloat = true;
    if (oc == XED_ICLASS_FUCOMP) isFloat = true;
    if (oc == XED_ICLASS_FUCOMPP) isFloat = true;
    if (oc == XED_ICLASS_FXSAVE) isFloat = true;
    if (oc == XED_ICLASS_FXTRACT) isFloat = true; //split exp and mant
    if (oc == XED_ICLASS_FYL2X) isFloat = true; //y*log_2 (x)
    if (oc == XED_ICLASS_FYL2XP1) isFloat = true; //y*log_2 (x+1)
    if (oc == XED_ICLASS_PFACC) isFloat = true;
    if (oc == XED_ICLASS_PFADD) isFloat = true;
    if (oc == XED_ICLASS_PFCMPEQ) isFloat = true;
    if (oc == XED_ICLASS_PFCMPGE) isFloat = true;
    if (oc == XED_ICLASS_PFCMPGT) isFloat = true;
    if (oc == XED_ICLASS_PFCPIT1) isFloat = true;
    if (oc == XED_ICLASS_PFMAX) isFloat = true;
    if (oc == XED_ICLASS_PFMIN) isFloat = true;
    if (oc == XED_ICLASS_PFMUL) isFloat = true;
    if (oc == XED_ICLASS_PFNACC) isFloat = true;
    if (oc == XED_ICLASS_PFPNACC) isFloat = true;
    if (oc == XED_ICLASS_PFRCP) isFloat = true;
    if (oc == XED_ICLASS_PFRCPIT2) isFloat = true;
    if (oc == XED_ICLASS_PFRSQIT1) isFloat = true;
    if (oc == XED_ICLASS_PFSQRT) isFloat = true;
    if (oc == XED_ICLASS_PFSUB) isFloat = true;
    if (oc == XED_ICLASS_PFSUBR) isFloat = true;
    if (oc == XED_ICLASS_PI2FD) isFloat = true;
    if (oc == XED_ICLASS_PI2FW) isFloat = true;
    if (oc == XED_ICLASS_PINSRB) isFloat = true;
    if (oc == XED_ICLASS_PINSRD) isFloat = true;
    if (oc == XED_ICLASS_PINSRQ) isFloat = true;
    if (oc == XED_ICLASS_PINSRW) isFloat = true;
    if (oc == XED_ICLASS_SHLD) isFloat = true;//double precision shift left
    if (oc == XED_ICLASS_SHRD) isFloat = true;
    if (oc == XED_ICLASS_ADDPD) isFloat = true;
    if (oc == XED_ICLASS_ADDPS) isFloat = true;
    if (oc == XED_ICLASS_ADDSD) isFloat = true;
    if (oc == XED_ICLASS_ADDSS) isFloat = true;
    if (oc == XED_ICLASS_ADDSUBPD) isFloat = true;
    if (oc == XED_ICLASS_ADDSUBPS) isFloat = true;
    if (oc == XED_ICLASS_DIVPD) isFloat = true;
    if (oc == XED_ICLASS_DIVPS) isFloat = true;
    if (oc == XED_ICLASS_DIVSD) isFloat = true;
    if (oc == XED_ICLASS_DIVSS) isFloat = true;
    if (oc == XED_ICLASS_DPPD) isFloat = true;
    if (oc == XED_ICLASS_DPPS) isFloat = true;
    if (oc == XED_ICLASS_F2XM1) isFloat = true; //2^x - 1
    if (oc == XED_ICLASS_FABS) isFloat = true;
    if (oc == XED_ICLASS_FADD) isFloat = true;
    if (oc == XED_ICLASS_FADDP) isFloat = true;
    if (oc == XED_ICLASS_FCOS) isFloat = true; //I feel bad only counting for 1
    if (oc == XED_ICLASS_FDIV) isFloat = true; //Hopfeully not buggy? HA
    if (oc == XED_ICLASS_FDIVP) isFloat = true;
    if (oc == XED_ICLASS_FDIVR) isFloat = true;
    if (oc == XED_ICLASS_FDIVRP) isFloat = true;
    if (oc == XED_ICLASS_FIDIV) isFloat = true;
    if (oc == XED_ICLASS_FIDIVR) isFloat = true; //I think this is dividing ints.
      .
    if (oc == XED_ICLASS_FIMUL) isFloat = true;
    if (oc == XED_ICLASS_FISUB) isFloat = true;
    if (oc == XED_ICLASS_FISUBR) isFloat = true;
    if (oc == XED_ICLASS_FMUL) isFloat = true;
    if (oc == XED_ICLASS_FMULP) isFloat = true;
    if (oc == XED_ICLASS_FPATAN) isFloat = true;  //Compute the arctan and divide
      
    if (oc == XED_ICLASS_FPREM) isFloat = true; //Partial remainder..
    if (oc == XED_ICLASS_FPREM1) isFloat = true;
    if (oc == XED_ICLASS_FPTAN) isFloat = true;
    if (oc == XED_ICLASS_FRNDINT) isFloat = true;  //round to integer
    if (oc == XED_ICLASS_FSCALE) isFloat = true; //some sort of rounding operatio
      n  
    if (oc == XED_ICLASS_FSIN) isFloat = true; //sin
    if (oc == XED_ICLASS_FSINCOS) isFloat = true; //compute both the sin and cos 
      
    if (oc == XED_ICLASS_FSQRT) isFloat = true; //
    if (oc == XED_ICLASS_FSUB) isFloat = true;  //various types of subtracts
    if (oc == XED_ICLASS_FSUBP) isFloat = true;
    if (oc == XED_ICLASS_FSUBR) isFloat = true; //reverse subtract
    if (oc == XED_ICLASS_FSUBRP) isFloat = true;
    if (oc == XED_ICLASS_FYL2X) isFloat = true; //y*log_2 (x)
    if (oc == XED_ICLASS_FYL2XP1) isFloat = true; //y*log_2 (x+1)
    if (oc == XED_ICLASS_HADDPD) isFloat = true; 
    if (oc == XED_ICLASS_HADDPS) isFloat = true;
    if (oc == XED_ICLASS_HSUBPD) isFloat = true;
    if (oc == XED_ICLASS_HSUBPS) isFloat = true; 
    if (oc == XED_ICLASS_MULPD) isFloat = true;
    if (oc == XED_ICLASS_MULPS) isFloat = true;
    if (oc == XED_ICLASS_MULSD) isFloat = true;
    if (oc == XED_ICLASS_MULSS) isFloat = true;
    if (oc == XED_ICLASS_RCPPS) isFloat = true; //reciprocal
    if (oc == XED_ICLASS_RCPSS) isFloat = true;
    if (oc == XED_ICLASS_ROUNDPD) isFloat = true;  //packed round to ints
    if (oc == XED_ICLASS_ROUNDPS) isFloat = true;
    if (oc == XED_ICLASS_ROUNDSD) isFloat = true;
    if (oc == XED_ICLASS_ROUNDSS) isFloat = true;
    if (oc == XED_ICLASS_RSQRTPS) isFloat = true; //recip square root
    if (oc == XED_ICLASS_RSQRTSS) isFloat = true;
    if (oc == XED_ICLASS_SQRTPD) isFloat = true; //float square roots
    if (oc == XED_ICLASS_SQRTPS) isFloat = true;
    if (oc == XED_ICLASS_SQRTSD) isFloat = true;
    if (oc == XED_ICLASS_SQRTSS) isFloat = true;
    if (oc == XED_ICLASS_SUBPD) isFloat = true;
    if (oc == XED_ICLASS_SUBPS) isFloat = true;
    if (oc == XED_ICLASS_SUBSD) isFloat = true; 
    if (oc == XED_ICLASS_SUBSS) isFloat = true; //substract

    return isFloat;
}
\end{DoxyCode}
\hypertarget{uop__gen_8cpp_a2f63fe95045d33d08845eafac3a74467}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!operands@{operands}}
\index{operands@{operands}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{operands}]{\setlength{\rightskip}{0pt plus 5cm}ADDRINT operands (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{ip, }
\item[{REG}]{reg, }
\item[{int}]{i, }
\item[{int}]{regType}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a2f63fe95045d33d08845eafac3a74467}

\begin{DoxyCode}
{
    if ( ( (warmUp == 1 || strt == 1) && fin == 0) || runAllProgram == true) {
        if (logEnable) fprintf (out, "%s#%d, ", REG_StringShort (reg).c_str (), r
      egType);
        fprintf (out1,"%s#%d,",  REG_StringShort (reg).c_str (), regType);
        ss << REG_StringShort (reg).c_str () << "#" << regType << ",";
        g_var.g_ins = ss.str ();
        //ss.str (std::string ());
    }
    ADDRINT value=0;//dummy return
    return value;
}
\end{DoxyCode}
\hypertarget{uop__gen_8cpp_a0172f442f10ebe82e79266223149e815}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!operands1@{operands1}}
\index{operands1@{operands1}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{operands1}]{\setlength{\rightskip}{0pt plus 5cm}ADDRINT operands1 (
\begin{DoxyParamCaption}
\item[{ADDRINT}]{ip, }
\item[{REG}]{reg, }
\item[{int}]{i, }
\item[{int}]{regType}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a0172f442f10ebe82e79266223149e815}

\begin{DoxyCode}
{
    if ( ( (warmUp == 1 || strt == 1) && fin == 0) || runAllProgram == true) {
        if (logEnable) fprintf (out, "%s#%d, ", REG_StringShort (reg).c_str (), r
      egType);
    }
    ADDRINT value=0;//dummy return
    return value;
}
\end{DoxyCode}
\hypertarget{uop__gen_8cpp_a4901d0bf289e797f3edec7dc81a72de9}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!reset@{reset}}
\index{reset@{reset}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{reset}]{\setlength{\rightskip}{0pt plus 5cm}VOID reset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a4901d0bf289e797f3edec7dc81a72de9}

\begin{DoxyCode}
              {
    ss.str (std::string ());
}
\end{DoxyCode}
\hypertarget{uop__gen_8cpp_a4e877db47eeb14a04e3154561e237bcd}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!SI\_\-Img@{SI\_\-Img}}
\index{SI\_\-Img@{SI\_\-Img}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{SI\_\-Img}]{\setlength{\rightskip}{0pt plus 5cm}VOID SI\_\-Img (
\begin{DoxyParamCaption}
\item[{IMG}]{img, }
\item[{VOID $\ast$}]{v}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a4e877db47eeb14a04e3154561e237bcd}

\begin{DoxyCode}
                                {
    for (SEC sec = IMG_SecHead (img); SEC_Valid (sec); sec = SEC_Next (sec)){
        for (RTN rtn = SEC_RtnHead (sec); RTN_Valid (rtn); rtn = RTN_Next (rtn)){
      

            RTN_Open (rtn);
            for (INS ins = RTN_InsHead (rtn); INS_Valid (ins); ins = INS_Next (in
      s))
            {
                EmulateLoad (ins, v);
                //instr (ins,v);
            }
            RTN_Close (rtn);
        }
    }
}
\end{DoxyCode}


Here is the call graph for this function:


\hypertarget{uop__gen_8cpp_a6e258f8f019fd3f67349d3288677d2b3}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!uop\_\-gen@{uop\_\-gen}}
\index{uop\_\-gen@{uop\_\-gen}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{uop\_\-gen}]{\setlength{\rightskip}{0pt plus 5cm}void uop\_\-gen (
\begin{DoxyParamCaption}
\item[{FILE $\ast$}]{\_\-outFile, }
\item[{{\bf staticCodeParser} \&}]{g\_\-staticCode}
\end{DoxyParamCaption}
)}}
\label{uop__gen_8cpp_a6e258f8f019fd3f67349d3288677d2b3}

\begin{DoxyCode}
{
    // Write to a file since cout and cerr maybe closed by the application
    memOp = 0;
    aluOp = 0;
    fpOp = 0;
    //if (logEnable) out = fopen ("trace_nbody.out", "w");
    out1 = _outFile;
    _g_staticCode = &g_staticCode;

    // Initialize pin & symbol manager
    // Register EmulateLoad to be called to instrument instructions
    //IMG_AddInstrumentFunction (SI_Img, 0);
    //PIN_AddFiniFunction (Fini, 0);
}
\end{DoxyCode}


Here is the caller graph for this function:




\subsection{Variable Documentation}
\hypertarget{uop__gen_8cpp_abfe2730122561da64ab5e1dec976a2fc}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!\_\-g\_\-staticCode@{\_\-g\_\-staticCode}}
\index{\_\-g\_\-staticCode@{\_\-g\_\-staticCode}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{\_\-g\_\-staticCode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf staticCodeParser}$\ast$ {\bf \_\-g\_\-staticCode}}}
\label{uop__gen_8cpp_abfe2730122561da64ab5e1dec976a2fc}
\hypertarget{uop__gen_8cpp_a721a0e615d2b640fe60ecb8366ddb7a8}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!aluOp@{aluOp}}
\index{aluOp@{aluOp}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{aluOp}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf aluOp}}}
\label{uop__gen_8cpp_a721a0e615d2b640fe60ecb8366ddb7a8}
\hypertarget{uop__gen_8cpp_adbd842db51089bacd184458de788ef57}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!brOp@{brOp}}
\index{brOp@{brOp}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{brOp}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf brOp}}}
\label{uop__gen_8cpp_adbd842db51089bacd184458de788ef57}
\hypertarget{uop__gen_8cpp_a8674f1654f805920ac2f393ad449702c}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!fin@{fin}}
\index{fin@{fin}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{fin}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf fin} = 0}}
\label{uop__gen_8cpp_a8674f1654f805920ac2f393ad449702c}
\hypertarget{uop__gen_8cpp_a0f07fe0363b6134cf1849fe46bb48227}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!fpOp@{fpOp}}
\index{fpOp@{fpOp}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{fpOp}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf fpOp}}}
\label{uop__gen_8cpp_a0f07fe0363b6134cf1849fe46bb48227}
\hypertarget{uop__gen_8cpp_af95d5076519fb14463e7dd6b5e2d4f8e}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!imgInsCallCount@{imgInsCallCount}}
\index{imgInsCallCount@{imgInsCallCount}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{imgInsCallCount}]{\setlength{\rightskip}{0pt plus 5cm}long unsigned {\bf imgInsCallCount} = 0}}
\label{uop__gen_8cpp_af95d5076519fb14463e7dd6b5e2d4f8e}
\hypertarget{uop__gen_8cpp_a49f12f6edbb46c1021b8845a9efe5a69}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!imgInsCount@{imgInsCount}}
\index{imgInsCount@{imgInsCount}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{imgInsCount}]{\setlength{\rightskip}{0pt plus 5cm}long unsigned {\bf imgInsCount} = 0}}
\label{uop__gen_8cpp_a49f12f6edbb46c1021b8845a9efe5a69}
\hypertarget{uop__gen_8cpp_ad50bc042fba06693e68c94a89b0d753f}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!imgInsMemCount@{imgInsMemCount}}
\index{imgInsMemCount@{imgInsMemCount}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{imgInsMemCount}]{\setlength{\rightskip}{0pt plus 5cm}long unsigned {\bf imgInsMemCount} = 0}}
\label{uop__gen_8cpp_ad50bc042fba06693e68c94a89b0d753f}
\hypertarget{uop__gen_8cpp_a5425dff34ae281a9d2ed5836922ae793}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!insMap@{insMap}}
\index{insMap@{insMap}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{insMap}]{\setlength{\rightskip}{0pt plus 5cm}map$<$ADDRINT,string$>$ {\bf insMap}}}
\label{uop__gen_8cpp_a5425dff34ae281a9d2ed5836922ae793}
\hypertarget{uop__gen_8cpp_ab4f6b3aed51d8a9b2ada1ad5390fb569}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!j@{j}}
\index{j@{j}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{j}]{\setlength{\rightskip}{0pt plus 5cm}unsigned {\bf j}}}
\label{uop__gen_8cpp_ab4f6b3aed51d8a9b2ada1ad5390fb569}
\hypertarget{uop__gen_8cpp_ad3131e139bdf973dba3caa8efa9914bb}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!logEnable@{logEnable}}
\index{logEnable@{logEnable}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{logEnable}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf logEnable} = false}}
\label{uop__gen_8cpp_ad3131e139bdf973dba3caa8efa9914bb}
\hypertarget{uop__gen_8cpp_aa546155cf4ec601e43e20ead17e983d1}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!memOp@{memOp}}
\index{memOp@{memOp}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{memOp}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf memOp}}}
\label{uop__gen_8cpp_aa546155cf4ec601e43e20ead17e983d1}
\hypertarget{uop__gen_8cpp_a1277960b5f2b37137fe9b0b5a1ea0beb}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!out@{out}}
\index{out@{out}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{out}]{\setlength{\rightskip}{0pt plus 5cm}FILE$\ast$ {\bf out} = 0}}
\label{uop__gen_8cpp_a1277960b5f2b37137fe9b0b5a1ea0beb}
\hypertarget{uop__gen_8cpp_a09e9742c01c4ea54fe6ad7a118d27c05}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!out1@{out1}}
\index{out1@{out1}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{out1}]{\setlength{\rightskip}{0pt plus 5cm}FILE$\ast$ {\bf out1} = 0}}
\label{uop__gen_8cpp_a09e9742c01c4ea54fe6ad7a118d27c05}
\hypertarget{uop__gen_8cpp_ad6a2043678ae90c7936423209ffbe50f}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!runAllProgram@{runAllProgram}}
\index{runAllProgram@{runAllProgram}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{runAllProgram}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf runAllProgram} = true}}
\label{uop__gen_8cpp_ad6a2043678ae90c7936423209ffbe50f}
\hypertarget{uop__gen_8cpp_a8fc3524f4e679a41dcc8d0f302d637ed}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!ss@{ss}}
\index{ss@{ss}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{ss}]{\setlength{\rightskip}{0pt plus 5cm}std::stringstream {\bf ss}}}
\label{uop__gen_8cpp_a8fc3524f4e679a41dcc8d0f302d637ed}
\hypertarget{uop__gen_8cpp_a87ab2c83ace6e8169a1ea7419f20360e}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!strt@{strt}}
\index{strt@{strt}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{strt}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf strt} = 0}}
\label{uop__gen_8cpp_a87ab2c83ace6e8169a1ea7419f20360e}
\hypertarget{uop__gen_8cpp_a4cf81ffad0a875cffd527876156689aa}{
\index{uop\_\-gen.cpp@{uop\_\-gen.cpp}!warmUp@{warmUp}}
\index{warmUp@{warmUp}!uop_gen.cpp@{uop\_\-gen.cpp}}
\subsubsection[{warmUp}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf warmUp} = 0}}
\label{uop__gen_8cpp_a4cf81ffad0a875cffd527876156689aa}
