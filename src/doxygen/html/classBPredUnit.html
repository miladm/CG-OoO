<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PhArS: BPredUnit&lt; Impl &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PhArS&#160;<span id="projectnumber">1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">BPredUnit&lt; Impl &gt; Class Template Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="BPredUnit" -->
<p><code>#include &lt;<a class="el" href="backend_2bp_2bpred__unit_8h_source.html">bpred_unit.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for BPredUnit&lt; Impl &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit__coll__graph.png" border="0" usemap="#BPredUnit_3_01Impl_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="BPredUnit_3_01Impl_01_4_coll__map" id="BPredUnit_3_01Impl_01_4_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classBPredUnit-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>PredictorHistory</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a4d632a2a34745803315809aedf2ce9b1">BPredUnit</a> (DerivO3CPUParams *params)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#aeaaeb15f110f0ed58cc3161d6f6ace22">name</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a0cffcea165538b2e7fd554a92b8d9b85">regStats</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#ac33c3d29c7b6aca9578fc416eb34e60e">switchOut</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a9011bcc9143d2396dfec49828484a645">takeOverFrom</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#ad37b550622b7ed76b55d80cc28700699">predict</a> (DynInstPtr &amp;inst, TheISA::PCState &amp;pc, ThreadID tid, bool odbpStatic, bool predTaken, int positionInFetchGroup, int positionInLine, bool &amp;allPredStatic, int oracleBP, bool onlyLP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a89690e897bb5661ee868f659a06515c9">increase_BP_lookup</a> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a471a1acb994d07a6d57b2f39ce56e6a4">increase_BP_lookup_and_update</a> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a41ecb08c99f45538eaf1de4e184905b4">increase_BTB_lookup</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a24bfe00e5e8c2a318930a6474ed60173">BPUncond</a> (void *&amp;bp_history)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a282f0c689c4cedfb52221c1ce96b4084">BP_onDemand</a> (void *&amp;bp_history, bool taken)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#aa154b29fbf52ad49d89a046e94b53ac9">update</a> (const InstSeqNum &amp;done_sn, ThreadID tid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a94a04b4bdf8f6b9b3cf33882bc16067b">squash</a> (const InstSeqNum &amp;squashed_sn, ThreadID tid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a78e6f48f8a11db90daab850527d48aa7">squash</a> (const InstSeqNum &amp;squashed_sn, const TheISA::PCState &amp;corr_target, bool actually_taken, ThreadID tid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a14a43c5f5bc8c64c07a075ce1608f9c3">BPSquash</a> (void *bp_history)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#af381979dadd608af5d4d5a235050f335">BPLookup</a> (Addr instPC, void *&amp;bp_history, int positionInFetchGroup, bool onDemand, bool &amp;choicePred, bool onlyLP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#af5b3e6db0cf1f00dee290e16765f28f8">noBPLookup</a> (Addr instPC, void *&amp;bp_history, int positionInLine)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a55a6608f958c4e70360c34bd48c57032">BPBTBUpdate</a> (Addr instPC, void *&amp;bp_history)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a66a1f6f9cdd28b38b005a666a9976ed7">BTBValid</a> (Addr instPC)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TheISA::PCState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a31024f2d92bfd7e778a790f4c6f61498">BTBLookup</a> (Addr instPC)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a35c57ae0661f1d5dd2169e919741d47b">BPUpdate</a> (Addr instPC, bool taken, void *bp_history, bool squashed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a16de9793a28ee07dcf26d89c03328555">BPHistUpdate</a> (Addr instPC, bool taken, void *bp_history, bool squashed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a9268abcbddfdfd6e6a076ecd343a3de5">BPHistGarbageCollect</a> (void *bp_history)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a5afe025cde23c608d745e8daca63e8a6">BTBUpdate</a> (Addr instPC, const TheISA::PCState &amp;target)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a6b7b489094d02552a2e1a81aab1ed280">dump</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#aeaaeb15f110f0ed58cc3161d6f6ace22">name</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a0cffcea165538b2e7fd554a92b8d9b85">regStats</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#ac33c3d29c7b6aca9578fc416eb34e60e">switchOut</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a9011bcc9143d2396dfec49828484a645">takeOverFrom</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#add836c4a521ed2bd12eca4d1dee13620">predict</a> (DynInstPtr &amp;inst, TheISA::PCState &amp;pc, ThreadID tid, bool odbpStatic, bool predTaken, int positionInFetchGroup, int positionInLine, bool &amp;allPredStatic, int oracleBP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a89690e897bb5661ee868f659a06515c9">increase_BP_lookup</a> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a471a1acb994d07a6d57b2f39ce56e6a4">increase_BP_lookup_and_update</a> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a41ecb08c99f45538eaf1de4e184905b4">increase_BTB_lookup</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a24bfe00e5e8c2a318930a6474ed60173">BPUncond</a> (void *&amp;bp_history)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a282f0c689c4cedfb52221c1ce96b4084">BP_onDemand</a> (void *&amp;bp_history, bool taken)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#aa154b29fbf52ad49d89a046e94b53ac9">update</a> (const InstSeqNum &amp;done_sn, ThreadID tid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a94a04b4bdf8f6b9b3cf33882bc16067b">squash</a> (const InstSeqNum &amp;squashed_sn, ThreadID tid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a78e6f48f8a11db90daab850527d48aa7">squash</a> (const InstSeqNum &amp;squashed_sn, const TheISA::PCState &amp;corr_target, bool actually_taken, ThreadID tid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a14a43c5f5bc8c64c07a075ce1608f9c3">BPSquash</a> (void *bp_history)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#aafefe8c8d85f49d118e825fa0c1c0176">BPLookup</a> (Addr instPC, void *&amp;bp_history, int positionInFetchGroup, bool onDemand, bool &amp;choicePred)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#af5b3e6db0cf1f00dee290e16765f28f8">noBPLookup</a> (Addr instPC, void *&amp;bp_history, int positionInLine)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a55a6608f958c4e70360c34bd48c57032">BPBTBUpdate</a> (Addr instPC, void *&amp;bp_history)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a66a1f6f9cdd28b38b005a666a9976ed7">BTBValid</a> (Addr instPC)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TheISA::PCState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a31024f2d92bfd7e778a790f4c6f61498">BTBLookup</a> (Addr instPC)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a35c57ae0661f1d5dd2169e919741d47b">BPUpdate</a> (Addr instPC, bool taken, void *bp_history, bool squashed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a16de9793a28ee07dcf26d89c03328555">BPHistUpdate</a> (Addr instPC, bool taken, void *bp_history, bool squashed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a9268abcbddfdfd6e6a076ecd343a3de5">BPHistGarbageCollect</a> (void *bp_history)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBPredUnit.html#a5afe025cde23c608d745e8daca63e8a6">BTBUpdate</a> (Addr instPC, const TheISA::PCState &amp;target)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Impl&gt;<br/>
class BPredUnit&lt; Impl &gt;</h3>

<p>BASICALLY A WRAPPER CLASS TO HOLD BOTH THE BRANCH PREDICTOR AND THE <a class="el" href="classBTB.html">BTB</a>.</p>
<p>Basically a wrapper class to hold both the branch predictor and the <a class="el" href="classBTB.html">BTB</a>. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4d632a2a34745803315809aedf2ce9b1"></a><!-- doxytag: member="BPredUnit::BPredUnit" ref="a4d632a2a34745803315809aedf2ce9b1" args="(DerivO3CPUParams *params)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::<a class="el" href="classBPredUnit.html">BPredUnit</a> </td>
          <td>(</td>
          <td class="paramtype">DerivO3CPUParams *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>The params object, that has the size of the BP and <a class="el" href="classBTB.html">BTB</a>. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">    : _name (params-&gt;name + <span class="stringliteral">&quot;.BPredUnit&quot;</span>),
      <a class="code" href="classBTB.html">BTB</a> (params-&gt;BTBEntries,
          params-&gt;BTBTagSize,
          params-&gt;instShiftAmt)
{
    <span class="comment">// Setup the selected predictor.</span>
    <span class="keywordflow">if</span> (params-&gt;predType == <span class="stringliteral">&quot;local&quot;</span>) {
        localBP = <span class="keyword">new</span> <a class="code" href="classLocalBP.html">LocalBP</a> (params-&gt;localPredictorSize,
                              params-&gt;localCtrBits,
                              params-&gt;instShiftAmt);
        predictor = Local;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (params-&gt;predType == <span class="stringliteral">&quot;hybrid&quot;</span>) {
        hybridbp = <span class="keyword">new</span> <a class="code" href="classHybridBP.html">HybridBP</a> (params-&gt;localPredictorSize,
                                        params-&gt;localCtrBits,
                                        params-&gt;globalPredictorSize,
                                        params-&gt;globalHistoryBits,
                                        params-&gt;globalCtrBits,
                                        params-&gt;choicePredictorSize,
                                        params-&gt;choiceCtrBits,
                                        params-&gt;instShiftAmt,
                                                                                params-&gt;fetchWidth);
        predictor = Hybrid;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (params-&gt;predType == <span class="stringliteral">&quot;hybrid_skew&quot;</span>) {
        hybridSkewbp = <span class="keyword">new</span> <a class="code" href="classHybridBPskew.html">HybridBPskew</a> (params-&gt;localPredictorSize,
                                        params-&gt;localCtrBits,
                                        params-&gt;globalPredictorSize,
                                        params-&gt;globalHistoryBits,
                                        params-&gt;globalCtrBits,
                                        params-&gt;choicePredictorSize,
                                        params-&gt;choiceCtrBits,
                                        params-&gt;instShiftAmt,
                                                                                params-&gt;fetchWidth);
        predictor = HybridSkew;
    } <span class="keywordflow">else</span> {
        <a class="code" href="util_8c.html#a0f652fc98ffe05ea6bf52ced076a02aa">fatal</a> (<span class="stringliteral">&quot;Invalid BP selected!&quot;</span>);
    }

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; Impl::MaxThreads; i++)
        RAS[i].<a class="code" href="main_8cpp.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a> (params-&gt;RASSize);
        
        fetchWidth = params-&gt;fetchWidth;
        instShiftAmt = params-&gt;instShiftAmt;
        totalInstShiftAmt = instShiftAmt + (unsigned)<a class="code" href="namespacearray.html#a4da2c69671f9dc2be88b1b8fdf0bf3b8">log2</a> (fetchWidth);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a4d632a2a34745803315809aedf2ce9b1_cgraph.png" border="0" usemap="#classBPredUnit_a4d632a2a34745803315809aedf2ce9b1_cgraph" alt=""/></div>
<map name="classBPredUnit_a4d632a2a34745803315809aedf2ce9b1_cgraph" id="classBPredUnit_a4d632a2a34745803315809aedf2ce9b1_cgraph">
</map>
</div>
</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a282f0c689c4cedfb52221c1ce96b4084"></a><!-- doxytag: member="BPredUnit::BP_onDemand" ref="a282f0c689c4cedfb52221c1ce96b4084" args="(void *&amp;bp_history, bool taken)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BP_onDemand </td>
          <td>(</td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>bp_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a282f0c689c4cedfb52221c1ce96b4084"></a><!-- doxytag: member="BPredUnit::BP_onDemand" ref="a282f0c689c4cedfb52221c1ce96b4084" args="(void *&amp;bp_history, bool taken)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BP_onDemand </td>
          <td>(</td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>bp_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>taken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a55a6608f958c4e70360c34bd48c57032"></a><!-- doxytag: member="BPredUnit::BPBTBUpdate" ref="a55a6608f958c4e70360c34bd48c57032" args="(Addr instPC, void *&amp;bp_history)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BPBTBUpdate </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>bp_history</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If a branch is not taken, because the <a class="el" href="classBTB.html">BTB</a> address is invalid or missing, this function sets the appropriate counter in the global and local predictors to not taken. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst_PC</td><td>The PC to look up the local predictor. </td></tr>
    <tr><td class="paramname">bp_history</td><td>Pointer that will be set to an object that has the branch predictor state associated with the lookup. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (predictor == Local) {
        <span class="keywordflow">return</span> localBP-&gt;<a class="code" href="classLocalBP.html#a6efe84f10a9141f20a9abeeaa1a76de1">BTBUpdate</a> (instPC, bp_history);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == Hybrid) {
        <span class="keywordflow">return</span> hybridbp-&gt;<a class="code" href="classHybridBP.html#a89edda03644e8f68ff703b4452569186">BTBUpdate</a> (instPC, bp_history);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == HybridSkew) {
        <span class="keywordflow">return</span> hybridSkewbp-&gt;<a class="code" href="classHybridBPskew.html#a5ceeff1b2e0cc39822346b1cd8fbab80">BTBUpdate</a> (instPC, bp_history);
    } <span class="keywordflow">else</span> {
        panic (<span class="stringliteral">&quot;Predictor type is unexpected value!&quot;</span>);
    }
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a55a6608f958c4e70360c34bd48c57032_cgraph.png" border="0" usemap="#classBPredUnit_a55a6608f958c4e70360c34bd48c57032_cgraph" alt=""/></div>
<map name="classBPredUnit_a55a6608f958c4e70360c34bd48c57032_cgraph" id="classBPredUnit_a55a6608f958c4e70360c34bd48c57032_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a55a6608f958c4e70360c34bd48c57032"></a><!-- doxytag: member="BPredUnit::BPBTBUpdate" ref="a55a6608f958c4e70360c34bd48c57032" args="(Addr instPC, void *&amp;bp_history)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BPBTBUpdate </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>bp_history</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If a branch is not taken, because the <a class="el" href="classBTB.html">BTB</a> address is invalid or missing, this function sets the appropriate counter in the global and local predictors to not taken. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst_PC</td><td>The PC to look up the local predictor. </td></tr>
    <tr><td class="paramname">bp_history</td><td>Pointer that will be set to an object that has the branch predictor state associated with the lookup. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9268abcbddfdfd6e6a076ecd343a3de5"></a><!-- doxytag: member="BPredUnit::BPHistGarbageCollect" ref="a9268abcbddfdfd6e6a076ecd343a3de5" args="(void *bp_history)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BPHistGarbageCollect </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>bp_history</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (predictor == Local) {
        assert (<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;this function is not supported for loacl prediction - (see Milad!)&quot;</span>);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == Hybrid) {
        hybridbp-&gt;<a class="code" href="classHybridBP.html#a42988126b43e89e1ec5fb5a1985a0a36">histGarbageCollect</a> (bp_history);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == HybridSkew) {
        hybridSkewbp-&gt;<a class="code" href="classHybridBPskew.html#a4c3aa89615af200ad553461f20de8315">histGarbageCollect</a> (bp_history);
    } <span class="keywordflow">else</span> {
        panic (<span class="stringliteral">&quot;Predictor type is unexpected value!&quot;</span>);
    }
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a9268abcbddfdfd6e6a076ecd343a3de5_cgraph.png" border="0" usemap="#classBPredUnit_a9268abcbddfdfd6e6a076ecd343a3de5_cgraph" alt=""/></div>
<map name="classBPredUnit_a9268abcbddfdfd6e6a076ecd343a3de5_cgraph" id="classBPredUnit_a9268abcbddfdfd6e6a076ecd343a3de5_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9268abcbddfdfd6e6a076ecd343a3de5"></a><!-- doxytag: member="BPredUnit::BPHistGarbageCollect" ref="a9268abcbddfdfd6e6a076ecd343a3de5" args="(void *bp_history)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BPHistGarbageCollect </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>bp_history</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a16de9793a28ee07dcf26d89c03328555"></a><!-- doxytag: member="BPredUnit::BPHistUpdate" ref="a16de9793a28ee07dcf26d89c03328555" args="(Addr instPC, bool taken, void *bp_history, bool squashed)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BPHistUpdate </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>bp_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>squashed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a16de9793a28ee07dcf26d89c03328555"></a><!-- doxytag: member="BPredUnit::BPHistUpdate" ref="a16de9793a28ee07dcf26d89c03328555" args="(Addr instPC, bool taken, void *bp_history, bool squashed)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BPHistUpdate </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>bp_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>squashed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (predictor == Local) {
        assert (<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;this function is not supported for loacl prediction - (see Milad!)&quot;</span>);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == Hybrid) {
        hybridbp-&gt;<a class="code" href="classHybridBP.html#a057bdd611cf2f46e8465df5376a72efb">histUpdate</a> (instPC, taken, bp_history, squashed);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == HybridSkew) {
        hybridSkewbp-&gt;<a class="code" href="classHybridBPskew.html#a5e73e9324e87d820712789f33100e5f4">histUpdate</a> (instPC, taken, bp_history, squashed);
    } <span class="keywordflow">else</span> {
        panic (<span class="stringliteral">&quot;Predictor type is unexpected value!&quot;</span>);
    }
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a16de9793a28ee07dcf26d89c03328555_cgraph.png" border="0" usemap="#classBPredUnit_a16de9793a28ee07dcf26d89c03328555_cgraph" alt=""/></div>
<map name="classBPredUnit_a16de9793a28ee07dcf26d89c03328555_cgraph" id="classBPredUnit_a16de9793a28ee07dcf26d89c03328555_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aafefe8c8d85f49d118e825fa0c1c0176"></a><!-- doxytag: member="BPredUnit::BPLookup" ref="aafefe8c8d85f49d118e825fa0c1c0176" args="(Addr instPC, void *&amp;bp_history, int positionInFetchGroup, bool onDemand, bool &amp;choicePred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BPLookup </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>bp_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>positionInFetchGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onDemand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>choicePred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up a given PC in the BP to see if it is taken or not taken. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst_PC</td><td>The PC to look up. </td></tr>
    <tr><td class="paramname">bp_history</td><td>Pointer that will be set to an object that has the branch predictor state associated with the lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the branch is taken or not taken. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (predictor == Local) {
        <span class="keywordflow">return</span> localBP-&gt;<a class="code" href="classLocalBP.html#ab884d4daf328f3284fe92c0ef3f5a37b">lookup</a>(instPC, bp_history);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == Hybrid) {
        <span class="keywordtype">bool</span> prediction = hybridbp-&gt;<a class="code" href="classHybridBP.html#a6aef367656e0d8c3b964bfb4e69858fa">lookup</a>(instPC, bp_history, (<span class="keywordtype">unsigned</span>)positionInLine, onDemand, choicePred);
        <span class="keywordflow">return</span> prediction;
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == HybridSkew) {
        <span class="keywordtype">bool</span> prediction = hybridSkewbp-&gt;<a class="code" href="classHybridBPskew.html#a27e2268df7da826fefe75f1a490bce11">lookup</a>(instPC, bp_history, (<span class="keywordtype">unsigned</span>)positionInLine, onDemand, choicePred);
        <span class="keywordflow">return</span> prediction;
    } <span class="keywordflow">else</span> {
        panic(<span class="stringliteral">&quot;Predictor type is unexpected value!&quot;</span>);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="af381979dadd608af5d4d5a235050f335"></a><!-- doxytag: member="BPredUnit::BPLookup" ref="af381979dadd608af5d4d5a235050f335" args="(Addr instPC, void *&amp;bp_history, int positionInFetchGroup, bool onDemand, bool &amp;choicePred, bool onlyLP)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BPLookup </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>bp_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>positionInFetchGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onDemand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>choicePred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyLP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up a given PC in the BP to see if it is taken or not taken. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst_PC</td><td>The PC to look up. </td></tr>
    <tr><td class="paramname">bp_history</td><td>Pointer that will be set to an object that has the branch predictor state associated with the lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the branch is taken or not taken. </dd></dl>

</div>
</div>
<a class="anchor" id="a14a43c5f5bc8c64c07a075ce1608f9c3"></a><!-- doxytag: member="BPredUnit::BPSquash" ref="a14a43c5f5bc8c64c07a075ce1608f9c3" args="(void *bp_history)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BPSquash </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>bp_history</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bp_history</td><td>Pointer to the history object. The predictor will need to update any state and delete the object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14a43c5f5bc8c64c07a075ce1608f9c3"></a><!-- doxytag: member="BPredUnit::BPSquash" ref="a14a43c5f5bc8c64c07a075ce1608f9c3" args="(void *bp_history)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BPSquash </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>bp_history</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bp_history</td><td>Pointer to the history object. The predictor will need to update any state and delete the object. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (predictor == Local) {
        localBP-&gt;<a class="code" href="classLocalBP.html#a19ff947a742878b0a27e23b72b867ff7">squash</a> (bp_history);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == Hybrid) {
        hybridbp-&gt;<a class="code" href="classHybridBP.html#aa69f90a513749a5ef74eb9e1bc2582a5">squash</a> (bp_history);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == HybridSkew) {
        hybridSkewbp-&gt;<a class="code" href="classHybridBPskew.html#a44db53115e8b3ccff2d9b7785c96f380">squash</a> (bp_history);
    } <span class="keywordflow">else</span> {
        panic (<span class="stringliteral">&quot;Predictor type is unexpected value!&quot;</span>);
    }
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a14a43c5f5bc8c64c07a075ce1608f9c3_cgraph.png" border="0" usemap="#classBPredUnit_a14a43c5f5bc8c64c07a075ce1608f9c3_cgraph" alt=""/></div>
<map name="classBPredUnit_a14a43c5f5bc8c64c07a075ce1608f9c3_cgraph" id="classBPredUnit_a14a43c5f5bc8c64c07a075ce1608f9c3_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a24bfe00e5e8c2a318930a6474ed60173"></a><!-- doxytag: member="BPredUnit::BPUncond" ref="a24bfe00e5e8c2a318930a6474ed60173" args="(void *&amp;bp_history)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BPUncond </td>
          <td>(</td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>bp_history</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="comment">// Only the hybrid predictor cares about unconditional branches.</span>
    <span class="keywordflow">if</span> (predictor == Hybrid) {
        hybridbp-&gt;<a class="code" href="classHybridBP.html#a298bbbcf380b81292e158a5d880073d4">uncondBr</a> (bp_history);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == HybridSkew) {
        hybridSkewbp-&gt;<a class="code" href="classHybridBPskew.html#a1dbffb30d1d0f0c4c8e6a8f1084e68e4">uncondBr</a> (bp_history);
    }
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a24bfe00e5e8c2a318930a6474ed60173_cgraph.png" border="0" usemap="#classBPredUnit_a24bfe00e5e8c2a318930a6474ed60173_cgraph" alt=""/></div>
<map name="classBPredUnit_a24bfe00e5e8c2a318930a6474ed60173_cgraph" id="classBPredUnit_a24bfe00e5e8c2a318930a6474ed60173_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a24bfe00e5e8c2a318930a6474ed60173"></a><!-- doxytag: member="BPredUnit::BPUncond" ref="a24bfe00e5e8c2a318930a6474ed60173" args="(void *&amp;bp_history)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BPUncond </td>
          <td>(</td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>bp_history</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a35c57ae0661f1d5dd2169e919741d47b"></a><!-- doxytag: member="BPredUnit::BPUpdate" ref="a35c57ae0661f1d5dd2169e919741d47b" args="(Addr instPC, bool taken, void *bp_history, bool squashed)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BPUpdate </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>bp_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>squashed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Updates the BP with taken/not taken information. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst_PC</td><td>The branch's PC that will be updated. </td></tr>
    <tr><td class="paramname">taken</td><td>Whether the branch was taken or not taken. </td></tr>
    <tr><td class="paramname">bp_history</td><td>Pointer to the branch predictor state that is associated with the branch lookup that is being updated. </td></tr>
    <tr><td class="paramname">squashed</td><td>Set to true when this function is called during a squash operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Make this update flexible enough to handle a global predictor. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (predictor == Local) {
        localBP-&gt;<a class="code" href="classLocalBP.html#a4d29b367b9ab3f0ab7250d1cce4b032b">update</a> (instPC, taken, bp_history);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == Hybrid) {
        hybridbp-&gt;<a class="code" href="classHybridBP.html#a61c2bdd85d221b11539524613e2f4ca5">update</a> (instPC, taken, bp_history, squashed);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == HybridSkew) {
        hybridSkewbp-&gt;<a class="code" href="classHybridBPskew.html#a4fb73465bf70ab821401f3d47e44fc91">update</a> (instPC, taken, bp_history, squashed);
    } <span class="keywordflow">else</span> {
        panic (<span class="stringliteral">&quot;Predictor type is unexpected value!&quot;</span>);
    }
        <a class="code" href="classBPredUnit.html#a471a1acb994d07a6d57b2f39ce56e6a4">increase_BP_lookup_and_update</a> (1);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a35c57ae0661f1d5dd2169e919741d47b_cgraph.png" border="0" usemap="#classBPredUnit_a35c57ae0661f1d5dd2169e919741d47b_cgraph" alt=""/></div>
<map name="classBPredUnit_a35c57ae0661f1d5dd2169e919741d47b_cgraph" id="classBPredUnit_a35c57ae0661f1d5dd2169e919741d47b_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a35c57ae0661f1d5dd2169e919741d47b"></a><!-- doxytag: member="BPredUnit::BPUpdate" ref="a35c57ae0661f1d5dd2169e919741d47b" args="(Addr instPC, bool taken, void *bp_history, bool squashed)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BPUpdate </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>bp_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>squashed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Updates the BP with taken/not taken information. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst_PC</td><td>The branch's PC that will be updated. </td></tr>
    <tr><td class="paramname">taken</td><td>Whether the branch was taken or not taken. </td></tr>
    <tr><td class="paramname">bp_history</td><td>Pointer to the branch predictor state that is associated with the branch lookup that is being updated. </td></tr>
    <tr><td class="paramname">squashed</td><td>Set to true when this function is called during a squash operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Make this update flexible enough to handle a global predictor. </dd></dl>

</div>
</div>
<a class="anchor" id="a31024f2d92bfd7e778a790f4c6f61498"></a><!-- doxytag: member="BPredUnit::BTBLookup" ref="a31024f2d92bfd7e778a790f4c6f61498" args="(Addr instPC)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TheISA::PCState <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BTBLookup </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up a given PC in the <a class="el" href="classBTB.html">BTB</a> to get the predicted target. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst_PC</td><td>The PC to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address of the target of the branch. </dd></dl>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classBTB.html">BTB</a>.<a class="code" href="classBTB.html#adada120072dd6a1a33fcc9dcab69ebad">lookup</a>(instPC, 0); }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a31024f2d92bfd7e778a790f4c6f61498_cgraph.png" border="0" usemap="#classBPredUnit_a31024f2d92bfd7e778a790f4c6f61498_cgraph" alt=""/></div>
<map name="classBPredUnit_a31024f2d92bfd7e778a790f4c6f61498_cgraph" id="classBPredUnit_a31024f2d92bfd7e778a790f4c6f61498_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a31024f2d92bfd7e778a790f4c6f61498"></a><!-- doxytag: member="BPredUnit::BTBLookup" ref="a31024f2d92bfd7e778a790f4c6f61498" args="(Addr instPC)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TheISA::PCState <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BTBLookup </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up a given PC in the <a class="el" href="classBTB.html">BTB</a> to get the predicted target. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst_PC</td><td>The PC to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address of the target of the branch. </dd></dl>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classBTB.html">BTB</a>.<a class="code" href="classBTB.html#adada120072dd6a1a33fcc9dcab69ebad">lookup</a>(instPC, 0); }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a31024f2d92bfd7e778a790f4c6f61498_cgraph.png" border="0" usemap="#classBPredUnit_a31024f2d92bfd7e778a790f4c6f61498_cgraph" alt=""/></div>
<map name="classBPredUnit_a31024f2d92bfd7e778a790f4c6f61498_cgraph" id="classBPredUnit_a31024f2d92bfd7e778a790f4c6f61498_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5afe025cde23c608d745e8daca63e8a6"></a><!-- doxytag: member="BPredUnit::BTBUpdate" ref="a5afe025cde23c608d745e8daca63e8a6" args="(Addr instPC, const TheISA::PCState &amp;target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BTBUpdate </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TheISA::PCState &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Updates the <a class="el" href="classBTB.html">BTB</a> with the target of a branch. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst_PC</td><td>The branch's PC that will be updated. </td></tr>
    <tr><td class="paramname">target_PC</td><td>The branch's target that will be added to the <a class="el" href="classBTB.html">BTB</a>. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">    { <a class="code" href="classBTB.html">BTB</a>.<a class="code" href="classBTB.html#a3b219a528353ed5cc381b783d40a72fd">update</a>(instPC, target, 0); }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a5afe025cde23c608d745e8daca63e8a6_cgraph.png" border="0" usemap="#classBPredUnit_a5afe025cde23c608d745e8daca63e8a6_cgraph" alt=""/></div>
<map name="classBPredUnit_a5afe025cde23c608d745e8daca63e8a6_cgraph" id="classBPredUnit_a5afe025cde23c608d745e8daca63e8a6_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5afe025cde23c608d745e8daca63e8a6"></a><!-- doxytag: member="BPredUnit::BTBUpdate" ref="a5afe025cde23c608d745e8daca63e8a6" args="(Addr instPC, const TheISA::PCState &amp;target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BTBUpdate </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TheISA::PCState &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Updates the <a class="el" href="classBTB.html">BTB</a> with the target of a branch. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst_PC</td><td>The branch's PC that will be updated. </td></tr>
    <tr><td class="paramname">target_PC</td><td>The branch's target that will be added to the <a class="el" href="classBTB.html">BTB</a>. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">    { <a class="code" href="classBTB.html">BTB</a>.<a class="code" href="classBTB.html#a3b219a528353ed5cc381b783d40a72fd">update</a>(instPC, target, 0); }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a5afe025cde23c608d745e8daca63e8a6_cgraph.png" border="0" usemap="#classBPredUnit_a5afe025cde23c608d745e8daca63e8a6_cgraph" alt=""/></div>
<map name="classBPredUnit_a5afe025cde23c608d745e8daca63e8a6_cgraph" id="classBPredUnit_a5afe025cde23c608d745e8daca63e8a6_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a66a1f6f9cdd28b38b005a666a9976ed7"></a><!-- doxytag: member="BPredUnit::BTBValid" ref="a66a1f6f9cdd28b38b005a666a9976ed7" args="(Addr instPC)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BTBValid </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up a given PC in the <a class="el" href="classBTB.html">BTB</a> to see if a matching entry exists. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst_PC</td><td>The PC to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the <a class="el" href="classBTB.html">BTB</a> contains the given PC. </dd></dl>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classBTB.html">BTB</a>.<a class="code" href="classBTB.html#a9675b08c643f69fdc9a7b4527c135d72">valid</a>(instPC, 0); }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a66a1f6f9cdd28b38b005a666a9976ed7_cgraph.png" border="0" usemap="#classBPredUnit_a66a1f6f9cdd28b38b005a666a9976ed7_cgraph" alt=""/></div>
<map name="classBPredUnit_a66a1f6f9cdd28b38b005a666a9976ed7_cgraph" id="classBPredUnit_a66a1f6f9cdd28b38b005a666a9976ed7_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a66a1f6f9cdd28b38b005a666a9976ed7"></a><!-- doxytag: member="BPredUnit::BTBValid" ref="a66a1f6f9cdd28b38b005a666a9976ed7" args="(Addr instPC)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::BTBValid </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up a given PC in the <a class="el" href="classBTB.html">BTB</a> to see if a matching entry exists. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst_PC</td><td>The PC to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the <a class="el" href="classBTB.html">BTB</a> contains the given PC. </dd></dl>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classBTB.html">BTB</a>.<a class="code" href="classBTB.html#a9675b08c643f69fdc9a7b4527c135d72">valid</a>(instPC, 0); }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a66a1f6f9cdd28b38b005a666a9976ed7_cgraph.png" border="0" usemap="#classBPredUnit_a66a1f6f9cdd28b38b005a666a9976ed7_cgraph" alt=""/></div>
<map name="classBPredUnit_a66a1f6f9cdd28b38b005a666a9976ed7_cgraph" id="classBPredUnit_a66a1f6f9cdd28b38b005a666a9976ed7_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6b7b489094d02552a2e1a81aab1ed280"></a><!-- doxytag: member="BPredUnit::dump" ref="a6b7b489094d02552a2e1a81aab1ed280" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    HistoryIt pred_hist_it;

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; Impl::MaxThreads; ++i) {
        <span class="keywordflow">if</span> (!predHist[i].empty ()) {
            pred_hist_it = predHist[i].begin ();

            cprintf (<span class="stringliteral">&quot;predHist[%i].size (): %i\n&quot;</span>, i, predHist[i].size ());

            <span class="keywordflow">while</span> (pred_hist_it != predHist[i].end ()) {
                cprintf (<span class="stringliteral">&quot;[sn:%lli], PC:%#x, tid:%i, predTaken:%i, &quot;</span>
                        <span class="stringliteral">&quot;bpHistory:%#x\n&quot;</span>,
                        pred_hist_it-&gt;seqNum, pred_hist_it-&gt;pc,
                        pred_hist_it-&gt;pred_hist_it-&gt;predTaken,
                        pred_hist_it-&gt;bpHistory);
                pred_hist_it++;
            }
            cprintf (<span class="stringliteral">&quot;\n&quot;</span>);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a89690e897bb5661ee868f659a06515c9"></a><!-- doxytag: member="BPredUnit::increase_BP_lookup" ref="a89690e897bb5661ee868f659a06515c9" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::increase_BP_lookup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lookupCnt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
  lookups += lookupCnt;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a89690e897bb5661ee868f659a06515c9"></a><!-- doxytag: member="BPredUnit::increase_BP_lookup" ref="a89690e897bb5661ee868f659a06515c9" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::increase_BP_lookup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a471a1acb994d07a6d57b2f39ce56e6a4"></a><!-- doxytag: member="BPredUnit::increase_BP_lookup_and_update" ref="a471a1acb994d07a6d57b2f39ce56e6a4" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::increase_BP_lookup_and_update </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a471a1acb994d07a6d57b2f39ce56e6a4"></a><!-- doxytag: member="BPredUnit::increase_BP_lookup_and_update" ref="a471a1acb994d07a6d57b2f39ce56e6a4" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::increase_BP_lookup_and_update </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lookupCnt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
  lookup_and_updates += lookupCnt;
}
</pre></div>
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a471a1acb994d07a6d57b2f39ce56e6a4_icgraph.png" border="0" usemap="#classBPredUnit_a471a1acb994d07a6d57b2f39ce56e6a4_icgraph" alt=""/></div>
<map name="classBPredUnit_a471a1acb994d07a6d57b2f39ce56e6a4_icgraph" id="classBPredUnit_a471a1acb994d07a6d57b2f39ce56e6a4_icgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a41ecb08c99f45538eaf1de4e184905b4"></a><!-- doxytag: member="BPredUnit::increase_BTB_lookup" ref="a41ecb08c99f45538eaf1de4e184905b4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::increase_BTB_lookup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
  BTBLookups++;
  usedRAS++;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a41ecb08c99f45538eaf1de4e184905b4"></a><!-- doxytag: member="BPredUnit::increase_BTB_lookup" ref="a41ecb08c99f45538eaf1de4e184905b4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::increase_BTB_lookup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aeaaeb15f110f0ed58cc3161d6f6ace22"></a><!-- doxytag: member="BPredUnit::name" ref="aeaaeb15f110f0ed58cc3161d6f6ace22" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> _name; }
</pre></div>
</div>
</div>
<a class="anchor" id="aeaaeb15f110f0ed58cc3161d6f6ace22"></a><!-- doxytag: member="BPredUnit::name" ref="aeaaeb15f110f0ed58cc3161d6f6ace22" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> _name; }
</pre></div>
</div>
</div>
<a class="anchor" id="af5b3e6db0cf1f00dee290e16765f28f8"></a><!-- doxytag: member="BPredUnit::noBPLookup" ref="af5b3e6db0cf1f00dee290e16765f28f8" args="(Addr instPC, void *&amp;bp_history, int positionInLine)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::noBPLookup </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>bp_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>positionInLine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
        assert(onDemand);
    <span class="keywordflow">if</span> (predictor == Local) {
        assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;this function is not supported for loacl prediction - (see Milad!)&quot;</span>);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == Hybrid) {
        <span class="keywordflow">return</span> hybridbp-&gt;<a class="code" href="classHybridBP.html#aa54c3620546c026eb4d593007adc5baf">onDemandBr</a>(instPC, bp_history, (<span class="keywordtype">unsigned</span>)positionInLine);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (predictor == HybridSkew) {
        <span class="keywordflow">return</span> hybridSkewbp-&gt;<a class="code" href="classHybridBPskew.html#ab10e5603326fd6eae8d8cdd106a625ef">onDemandBr</a>(instPC, bp_history, (<span class="keywordtype">unsigned</span>)positionInLine);
    } <span class="keywordflow">else</span> {
        panic(<span class="stringliteral">&quot;Predictor type is unexpected value!&quot;</span>);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="af5b3e6db0cf1f00dee290e16765f28f8"></a><!-- doxytag: member="BPredUnit::noBPLookup" ref="af5b3e6db0cf1f00dee290e16765f28f8" args="(Addr instPC, void *&amp;bp_history, int positionInLine)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::noBPLookup </td>
          <td>(</td>
          <td class="paramtype">Addr&#160;</td>
          <td class="paramname"><em>instPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>bp_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>positionInLine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="add836c4a521ed2bd12eca4d1dee13620"></a><!-- doxytag: member="BPredUnit::predict" ref="add836c4a521ed2bd12eca4d1dee13620" args="(DynInstPtr &amp;inst, TheISA::PCState &amp;pc, ThreadID tid, bool odbpStatic, bool predTaken, int positionInFetchGroup, int positionInLine, bool &amp;allPredStatic, int oracleBP)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::predict </td>
          <td>(</td>
          <td class="paramtype">DynInstPtr &amp;&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TheISA::PCState &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ThreadID&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>odbpStatic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>predTaken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>positionInFetchGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>positionInLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>allPredStatic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oracleBP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Predicts whether or not the instruction is a taken branch, and the target of the branch if it is taken. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>The branch instruction. </td></tr>
    <tr><td class="paramname">PC</td><td>The predicted PC is passed back through this parameter. </td></tr>
    <tr><td class="paramname">tid</td><td>The thread id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns if the branch is taken or not. </dd></dl>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// See if branch predictor predicts taken.</span>
    <span class="comment">// If so, get its target addr either from the BTB or the RAS.</span>
    <span class="comment">// Save off record of branch stuff so the RAS can be fixed</span>
    <span class="comment">// up once it&#39;s done.</span>

    <span class="keywordtype">bool</span> pred_taken = <span class="keyword">false</span>;
    TheISA::PCState target = pc;

    <span class="keywordtype">void</span> *bp_history = NULL;
        <span class="keyword">static</span> <span class="keywordtype">bool</span> firstDY = <span class="keyword">true</span>;
        <span class="keywordflow">if</span> (onDemand &amp;&amp; positionInFetchGroup == 0)
                firstDY = <span class="keyword">true</span>;

    <span class="comment">//if (inst-&gt;isUncondCtrl())</span>
    <span class="comment">//{</span>
    <span class="comment">//    DPRINTF(Fetch, &quot;BranchPred: [tid:%i]: Unconditional control.\n&quot;, tid);</span>
    <span class="comment">//    pred_taken = true;</span>
    <span class="comment">//    // Tell the BP there was an unconditional branch.</span>
    <span class="comment">//    BPUncond(bp_history);</span>
    <span class="comment">//}</span>
    <span class="comment">//else</span>
    <span class="comment">//{</span>
      ++condPredicted;
                <span class="keywordtype">bool</span> choicePred;
        <span class="keywordflow">if</span> (!onDemand) { <span class="comment">//BASEBP</span>
                        <span class="comment">//Addr indx = ((pc.instAddr()&gt;&gt;4)&lt;&lt;2)+positionInLine;</span>
                        <span class="comment">//if (bpIndxHist.find(indx) != bpIndxHist.end()) { bpIndxHist[indx]++;</span>
                        <span class="comment">//} else { bpIndxHist[indx] = 1; }</span>
                        pred_taken = <a class="code" href="classBPredUnit.html#af381979dadd608af5d4d5a235050f335">BPLookup</a>(pc.instAddr(), bp_history, positionInLine, onDemand, choicePred);
                        DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: Branch predictor predicted %i for PC %s\n&quot;</span>, tid, pred_taken, inst-&gt;pcState());
                        <span class="keywordflow">if</span> (positionInFetchGroup == 0) {
                                <a class="code" href="classBPredUnit.html#a89690e897bb5661ee868f659a06515c9">increase_BP_lookup</a>(fetchWidth);
                                <a class="code" href="classBPredUnit.html#a471a1acb994d07a6d57b2f39ce56e6a4">increase_BP_lookup_and_update</a>(fetchWidth);
                                BTBLookups+=fetchWidth;
                        }
                        <span class="comment">//inst-&gt;setWasBPlookup(true); TODO put this back</span>
                        inst-&gt;setDyPredUsed(choicePred);
        } <span class="keywordflow">else</span> { <span class="comment">//ODBP</span>
                        <span class="keywordflow">if</span> (odbpStatic)
                        {
                            pred_taken = predTaken;
                                <span class="keywordflow">if</span> (pred_taken) {
                                        <span class="comment">//hybridbp-&gt;updateGlobalHistTaken();</span>
                                        BTBLookups++;
                                <span class="comment">//} else {</span>
                                        <span class="comment">//Addr tempPC = ((pc.instAddr()&gt;&gt;totalInstShiftAmt)&lt;&lt;totalInstShiftAmt)+((Addr)pow(instShiftAmt,2))*(fetchWidth-1); //Create the addr of last ins in cacheline</span>
                                        <span class="comment">//if (pc.instAddr() == tempPC)</span>
                                        <span class="comment">//hybridbp-&gt;updateGlobalHistNotTaken();</span>
                                }
                                <a class="code" href="classBPredUnit.html#af5b3e6db0cf1f00dee290e16765f28f8">noBPLookup</a>(pc.instAddr(), bp_history, positionInLine);
                                inst-&gt;setWasBPlookup(<span class="keyword">false</span>);
                        }
                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!odbpStatic)
                        {
                                <span class="comment">//Addr indx = ((pc.instAddr()&gt;&gt;4)&lt;&lt;2)+positionInLine;</span>
                                <span class="comment">//if (bpIndxHist.find(indx) != bpIndxHist.end()) { bpIndxHist[indx]++;</span>
                                <span class="comment">//} else { bpIndxHist[indx] = 1; }</span>
                            pred_taken = <a class="code" href="classBPredUnit.html#af381979dadd608af5d4d5a235050f335">BPLookup</a>(pc.instAddr(), bp_history, positionInLine, onDemand, choicePred);
                                allPredStatic = <span class="keyword">false</span>; <span class="comment">//had at least one DY in fetch group</span>
                            DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: Branch predictor predicted %i for PC %s\n&quot;</span>, tid, pred_taken, inst-&gt;pcState());
                                <span class="keywordflow">if</span> (firstDY) {
                                        <a class="code" href="classBPredUnit.html#a89690e897bb5661ee868f659a06515c9">increase_BP_lookup</a>(fetchWidth);
                                        <a class="code" href="classBPredUnit.html#a471a1acb994d07a6d57b2f39ce56e6a4">increase_BP_lookup_and_update</a>(fetchWidth);
                                        firstDY=<span class="keyword">false</span>;
                                }
                                BTBLookups++;
                                inst-&gt;setWasBPlookup(<span class="keyword">true</span>);
                                inst-&gt;setDyPredUsed(choicePred);
                        } <span class="keywordflow">else</span> {
                                assert(<span class="keyword">true</span> &amp;&amp; <span class="stringliteral">&quot;this should have never run&quot;</span>);
                            pred_taken = <span class="keyword">false</span>; <span class="comment">//Turn DY or ST into SN - no update of PHT here</span>
                                <a class="code" href="classBPredUnit.html#af5b3e6db0cf1f00dee290e16765f28f8">noBPLookup</a>(pc.instAddr(), bp_history, positionInLine);
                                <span class="keywordflow">if</span> (odbpStatic &amp;&amp; predTaken)    ST_treated_SN++;
                                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!odbpStatic)                   DY_treated_SN++;
                                inst-&gt;setWasBPlookup(<span class="keyword">false</span>);
                        }
        }
    <span class="comment">//}</span>

    DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: [sn:%i] Creating prediction history &quot;</span>
                <span class="stringliteral">&quot;for PC %s\n&quot;</span>,
            tid, inst-&gt;seqNum, inst-&gt;pcState());

    PredictorHistory predict_record(inst-&gt;seqNum, pc.instAddr(),
                                    pred_taken, bp_history, tid);
        <span class="keywordflow">if</span> (onDemand) {
                predict_record.wasControl = inst-&gt;isControl();
                predict_record.wasStatic = odbpStatic;
                predict_record.wasST = predTaken; <span class="comment">//This is the &quot;original&quot; static prediction</span>
        }

    <span class="comment">// Now lookup in the BTB or RAS.</span>
    <span class="keywordflow">if</span> (pred_taken)
    {
        ++usedRAS; <span class="comment">//RAS read or write</span>
        <span class="keywordflow">if</span> (inst-&gt;isReturn()) <span class="comment">//look up RAS</span>
        {
            predict_record.wasReturn = <span class="keyword">true</span>;
            <span class="comment">// If it&#39;s a function return call, then look up the address</span>
            <span class="comment">// in the RAS.</span>
            TheISA::PCState rasTop = RAS[tid].<a class="code" href="classReturnAddrStack.html#a4fe6450bdc0ff84a60a9331dd88d8507">top</a>();
            target = TheISA::buildRetPC(pc, rasTop);

            <span class="comment">// Record the top entry of the RAS, and its index.</span>
            predict_record.usedRAS = <span class="keyword">true</span>;
            predict_record.RASIndex = RAS[tid].<a class="code" href="classReturnAddrStack.html#a95a293e5b01511ae5363fa9cf69d47f0">topIdx</a>();
            predict_record.RASTarget = rasTop;

            assert(predict_record.RASIndex &lt; 16);

            RAS[tid].<a class="code" href="classReturnAddrStack.html#a9d2396f6b3f90a54b178db4efc002a78">pop</a>();

            DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: Instruction %s is a return, &quot;</span>
                    <span class="stringliteral">&quot;RAS predicted target: %s, RAS index: %i.\n&quot;</span>,
                    tid, inst-&gt;pcState(), target, predict_record.RASIndex);
        }
        <span class="keywordflow">else</span> <span class="comment">//Look up BTB</span>
        {
            <span class="keywordflow">if</span> (inst-&gt;isCall()) {
                RAS[tid].<a class="code" href="classReturnAddrStack.html#ac41dc83da8d0960b57df3e9a97c792c0">push</a>(pc);

                <span class="comment">// Record that it was a call so that the top RAS entry can</span>
                <span class="comment">// be popped off if the speculation is incorrect.</span>
                predict_record.wasCall = <span class="keyword">true</span>;

                DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: Instruction %s was a &quot;</span>
                        <span class="stringliteral">&quot;call, adding %s to the RAS index: %i.\n&quot;</span>,
                        tid, inst-&gt;pcState(), pc, RAS[tid].<a class="code" href="classReturnAddrStack.html#a95a293e5b01511ae5363fa9cf69d47f0">topIdx</a>());
            }

            <span class="keywordflow">if</span> (<a class="code" href="classBTB.html">BTB</a>.<a class="code" href="classBTB.html#a9675b08c643f69fdc9a7b4527c135d72">valid</a>(pc.instAddr(), tid)) {
                ++BTBHits;
                predict_record.validBTB = <span class="keyword">true</span>;

                <span class="comment">// If it&#39;s not a return, use the BTB to get the target addr.</span>
                target = <a class="code" href="classBTB.html">BTB</a>.<a class="code" href="classBTB.html#adada120072dd6a1a33fcc9dcab69ebad">lookup</a>(pc.instAddr(), tid);

                DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: Instruction %s predicted&quot;</span>
                        <span class="stringliteral">&quot; target is %s.\n&quot;</span>, tid, inst-&gt;pcState(), target);

            } <span class="keywordflow">else</span> { <span class="comment">//missed in RAS and BTB</span>
                DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: BTB doesn&#39;t have a &quot;</span>
                        <span class="stringliteral">&quot;valid entry.\n&quot;</span>,tid);
                pred_taken = <span class="keyword">false</span>;
                <span class="comment">// The Direction of the branch predictor is altered because the</span>
                <span class="comment">// BTB did not have an entry</span>
                <span class="comment">// The predictor needs to be updated accordingly</span>
              <span class="comment">//if (!inst-&gt;isCall() &amp;&amp; !inst-&gt;isReturn()) {</span>
                      <a class="code" href="classBPredUnit.html#a55a6608f958c4e70360c34bd48c57032">BPBTBUpdate</a>(pc.instAddr(), bp_history);
                      DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]:[sn:%i] BPBTBUpdate&quot;</span>
                              <span class="stringliteral">&quot; called for %s\n&quot;</span>,
                              tid, inst-&gt;seqNum, inst-&gt;pcState());
              <span class="comment">//} else if (inst-&gt;isCall() &amp;&amp; !inst-&gt;isUncondCtrl()) {</span>
              <span class="comment">//      RAS[tid].pop();</span>
              <span class="comment">//}</span>
                TheISA::advancePC(target, inst-&gt;staticInst);
            }

        }
    } <span class="keywordflow">else</span> { <span class="comment">//predict not taken</span>
        <span class="keywordflow">if</span> (inst-&gt;isReturn()) {
           predict_record.wasReturn = <span class="keyword">true</span>;
        }
        TheISA::advancePC(target, inst-&gt;staticInst);
    }

        predict_record.predTaken = pred_taken;
    pc = target;

    predHist[tid].push_front(predict_record);

    DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: [sn:%i]: History entry added.&quot;</span>
            <span class="stringliteral">&quot;predHist.size(): %i\n&quot;</span>, tid, inst-&gt;seqNum, predHist[tid].size());

    <span class="keywordflow">return</span> pred_taken;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_add836c4a521ed2bd12eca4d1dee13620_cgraph.png" border="0" usemap="#classBPredUnit_add836c4a521ed2bd12eca4d1dee13620_cgraph" alt=""/></div>
<map name="classBPredUnit_add836c4a521ed2bd12eca4d1dee13620_cgraph" id="classBPredUnit_add836c4a521ed2bd12eca4d1dee13620_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad37b550622b7ed76b55d80cc28700699"></a><!-- doxytag: member="BPredUnit::predict" ref="ad37b550622b7ed76b55d80cc28700699" args="(DynInstPtr &amp;inst, TheISA::PCState &amp;pc, ThreadID tid, bool odbpStatic, bool predTaken, int positionInFetchGroup, int positionInLine, bool &amp;allPredStatic, int oracleBP, bool onlyLP)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::predict </td>
          <td>(</td>
          <td class="paramtype">DynInstPtr &amp;&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TheISA::PCState &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ThreadID&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>odbpStatic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>predTaken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>positionInFetchGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>positionInLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>allPredStatic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oracleBP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyLP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Predicts whether or not the instruction is a taken branch, and the target of the branch if it is taken. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>The branch instruction. </td></tr>
    <tr><td class="paramname">PC</td><td>The predicted PC is passed back through this parameter. </td></tr>
    <tr><td class="paramname">tid</td><td>The thread id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns if the branch is taken or not. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cffcea165538b2e7fd554a92b8d9b85"></a><!-- doxytag: member="BPredUnit::regStats" ref="a0cffcea165538b2e7fd554a92b8d9b85" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::regStats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers statistics. </p>
<div class="fragment"><pre class="fragment">{ }
</pre></div>
</div>
</div>
<a class="anchor" id="a0cffcea165538b2e7fd554a92b8d9b85"></a><!-- doxytag: member="BPredUnit::regStats" ref="a0cffcea165538b2e7fd554a92b8d9b85" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::regStats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Registers statistics. </p>

</div>
</div>
<a class="anchor" id="a78e6f48f8a11db90daab850527d48aa7"></a><!-- doxytag: member="BPredUnit::squash" ref="a78e6f48f8a11db90daab850527d48aa7" args="(const InstSeqNum &amp;squashed_sn, const TheISA::PCState &amp;corr_target, bool actually_taken, ThreadID tid)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::squash </td>
          <td>(</td>
          <td class="paramtype">const InstSeqNum &amp;&#160;</td>
          <td class="paramname"><em>squashed_sn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TheISA::PCState &amp;&#160;</td>
          <td class="paramname"><em>corr_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>actually_taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ThreadID&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Squashes all outstanding updates until a given sequence number, and corrects that sn's update with the proper address and taken/not taken. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">squashed_sn</td><td>The sequence number to squash any younger updates up until. </td></tr>
    <tr><td class="paramname">corr_target</td><td>The correct branch target. </td></tr>
    <tr><td class="paramname">actually_taken</td><td>The correct branch direction. </td></tr>
    <tr><td class="paramname">tid</td><td>The thread id. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// Now that we know that a branch was mispredicted, we need to undo</span>
    <span class="comment">// all the branches that have been seen up until this branch and</span>
    <span class="comment">// fix up everything.</span>
    <span class="comment">// NOTE: This should be call conceivably in 2 scenarios:</span>
    <span class="comment">// (1) After an branch is executed, it updates its status in the ROB</span>
    <span class="comment">//     The commit stage then checks the ROB update and sends a signal to</span>
    <span class="comment">//     the fetch stage to squash history after the mispredict</span>
    <span class="comment">// (2) In the decode stage, you can find out early if a unconditional</span>
    <span class="comment">//     PC-relative, branch was predicted incorrectly. If so, a signal</span>
    <span class="comment">//     to the fetch stage is sent to squash history after the mispredict</span>

    History &amp;pred_hist = predHist[tid];

    ++condIncorrect;

    DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: Squashing from sequence number %i, &quot;</span>
            <span class="stringliteral">&quot;setting target to %s.\n&quot;</span>,
            tid, squashed_sn, corrTarget);

    <span class="comment">// Squash All Branches AFTER this mispredicted branch</span>
    <a class="code" href="classBPredUnit.html#a94a04b4bdf8f6b9b3cf33882bc16067b">squash</a>(squashed_sn, tid);

    <span class="comment">// If there&#39;s a squash due to a syscall, there may not be an entry</span>
    <span class="comment">// corresponding to the squash.  In that case, don&#39;t bother trying to</span>
    <span class="comment">// fix up the entry.</span>
    <span class="keywordflow">if</span> (!pred_hist.empty()) {

        HistoryIt hist_it = pred_hist.begin();
        <span class="comment">//HistoryIt hist_it = find(pred_hist.begin(), pred_hist.end(),</span>
        <span class="comment">//                       squashed_sn);</span>

        <span class="comment">//assert(hist_it != pred_hist.end());</span>
        <span class="keywordflow">if</span> (pred_hist.front().seqNum != squashed_sn) {
            DPRINTF(Fetch, <span class="stringliteral">&quot;Front sn %i != Squash sn %i\n&quot;</span>,
                    pred_hist.front().seqNum, squashed_sn);

            assert(pred_hist.front().seqNum == squashed_sn);
        }

        <span class="keywordflow">if</span> ((*hist_it).usedRAS) {
            ++RASIncorrect;
        }

                <span class="keywordflow">if</span> (!onDemand || 
                    (onDemand &amp;&amp; 
                         !pred_hist.front().wasStatic &amp;&amp;
                         pred_hist.front().wasControl)) {
                        <a class="code" href="classBPredUnit.html#a35c57ae0661f1d5dd2169e919741d47b">BPUpdate</a>((*hist_it).pc, actually_taken,
                                 pred_hist.front().bpHistory, <span class="keyword">true</span>);
                }

                <a class="code" href="classBPredUnit.html#a16de9793a28ee07dcf26d89c03328555">BPHistUpdate</a>((*hist_it).pc, actually_taken,
                                        pred_hist.front().bpHistory, <span class="keyword">true</span>);

        <span class="keywordflow">if</span> (actually_taken) {
            <span class="keywordflow">if</span> (hist_it-&gt;wasReturn &amp;&amp; !hist_it-&gt;usedRAS) {
                 DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid: %i] Incorrectly predicted&quot;</span>
                           <span class="stringliteral">&quot;  return [sn:%i] PC: %s\n&quot;</span>, tid, hist_it-&gt;seqNum,
                            hist_it-&gt;pc);
                 RAS[tid].<a class="code" href="classReturnAddrStack.html#a9d2396f6b3f90a54b178db4efc002a78">pop</a>();
            }
        } <span class="keywordflow">else</span> {
           <span class="comment">//Actually not Taken</span>
           <span class="keywordflow">if</span> (hist_it-&gt;usedRAS) {
                DPRINTF(Fetch,<span class="stringliteral">&quot;BranchPred: [tid: %i] Incorrectly predicted&quot;</span>
                           <span class="stringliteral">&quot;  return [sn:%i] PC: %s Restoring RAS\n&quot;</span>, tid,
                           hist_it-&gt;seqNum, hist_it-&gt;pc);
                DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: Restoring top of RAS&quot;</span>
                               <span class="stringliteral">&quot; to: %i, target: %s.\n&quot;</span>, tid,
                              hist_it-&gt;RASIndex, hist_it-&gt;RASTarget);
                RAS[tid].<a class="code" href="classReturnAddrStack.html#a2ceaaf5c1223ef4a262ccf835dee7b08">restore</a>(hist_it-&gt;RASIndex, hist_it-&gt;RASTarget);

           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hist_it-&gt;wasCall &amp;&amp; hist_it-&gt;validBTB) {
                 <span class="comment">//Was a Call but predicated false. Pop RAS here</span>
                 DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid: %i] Incorrectly predicted&quot;</span>
                           <span class="stringliteral">&quot;  Call [sn:%i] PC: %s Popping RAS\n&quot;</span>, tid,
                           hist_it-&gt;seqNum, hist_it-&gt;pc);
                 RAS[tid].<a class="code" href="classReturnAddrStack.html#a9d2396f6b3f90a54b178db4efc002a78">pop</a>();
           }
        }
                <span class="keywordflow">if</span> (onDemand &amp;&amp; 
                    (pred_hist.front().wasST || !pred_hist.front().wasStatic) &amp;&amp; 
                        !pred_hist.front().wasControl) {
                        <a class="code" href="classBTB.html">BTB</a>.<a class="code" href="classBTB.html#aa5c83affce9a681214af9f078d79736f">invalidate</a>((*hist_it).pc);
                } <span class="keywordflow">else</span>  <span class="keywordflow">if</span> (actually_taken) {
                        DPRINTF(Fetch,<span class="stringliteral">&quot;BranchPred: [tid: %i] BTB Update called for [sn:%i]&quot;</span>
                          <span class="stringliteral">&quot; PC: %s\n&quot;</span>, tid,hist_it-&gt;seqNum, hist_it-&gt;pc);
                        <a class="code" href="classBTB.html">BTB</a>.<a class="code" href="classBTB.html#a3b219a528353ed5cc381b783d40a72fd">update</a>((*hist_it).pc, corrTarget, tid);
                        BTBLookups++;
            DPRINTF(Fetch,<span class="stringliteral">&quot;BranchPred: [tid: %i] BTB Update called for [sn:%i]&quot;</span>
                            <span class="stringliteral">&quot; PC: %s\n&quot;</span>, tid,hist_it-&gt;seqNum, hist_it-&gt;pc);
                }

        DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: Removing history for [sn:%i]&quot;</span>
                       <span class="stringliteral">&quot; PC %s  Actually Taken: %i\n&quot;</span>, tid, hist_it-&gt;seqNum,
                       hist_it-&gt;pc, actually_taken);

        pred_hist.erase(hist_it);

        DPRINTF(Fetch, <span class="stringliteral">&quot;[tid:%i]: predHist.size(): %i\n&quot;</span>, tid, predHist[tid].size());
    }
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a78e6f48f8a11db90daab850527d48aa7_cgraph.png" border="0" usemap="#classBPredUnit_a78e6f48f8a11db90daab850527d48aa7_cgraph" alt=""/></div>
<map name="classBPredUnit_a78e6f48f8a11db90daab850527d48aa7_cgraph" id="classBPredUnit_a78e6f48f8a11db90daab850527d48aa7_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a94a04b4bdf8f6b9b3cf33882bc16067b"></a><!-- doxytag: member="BPredUnit::squash" ref="a94a04b4bdf8f6b9b3cf33882bc16067b" args="(const InstSeqNum &amp;squashed_sn, ThreadID tid)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::squash </td>
          <td>(</td>
          <td class="paramtype">const InstSeqNum &amp;&#160;</td>
          <td class="paramname"><em>squashed_sn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ThreadID&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Squashes all outstanding updates until a given sequence number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">squashed_sn</td><td>The sequence number to squash any younger updates up until. </td></tr>
    <tr><td class="paramname">tid</td><td>The thread id. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    History &amp;pred_hist = predHist[tid];

    <span class="keywordflow">while</span> (!pred_hist.empty() &amp;&amp;
           pred_hist.front().seqNum &gt; squashed_sn) {
        <span class="keywordflow">if</span> (pred_hist.front().usedRAS) {
            DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: Restoring top of RAS to: %i,&quot;</span>
                    <span class="stringliteral">&quot; target: %s.\n&quot;</span>, tid,
                    pred_hist.front().RASIndex, pred_hist.front().RASTarget);

            RAS[tid].<a class="code" href="classReturnAddrStack.html#a2ceaaf5c1223ef4a262ccf835dee7b08">restore</a>(pred_hist.front().RASIndex,
                             pred_hist.front().RASTarget);
        } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(pred_hist.front().wasCall &amp;&amp; pred_hist.front().validBTB) {
            <span class="comment">// Was a call but predicated false. Pop RAS here</span>
            DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid: %i] Squashing&quot;</span>
                    <span class="stringliteral">&quot;  Call [sn:%i] PC: %s Popping RAS\n&quot;</span>, tid,
                    pred_hist.front().seqNum, pred_hist.front().pc);
            RAS[tid].<a class="code" href="classReturnAddrStack.html#a9d2396f6b3f90a54b178db4efc002a78">pop</a>();
        }

        <span class="comment">// This call should delete the bpHistory.</span>
        <a class="code" href="classBPredUnit.html#a14a43c5f5bc8c64c07a075ce1608f9c3">BPSquash</a>(pred_hist.front().bpHistory);

        DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: Removing history for [sn:%i] &quot;</span>
                <span class="stringliteral">&quot;PC %s.\n&quot;</span>, tid, pred_hist.front().seqNum,
                pred_hist.front().pc);

        pred_hist.pop_front();

        DPRINTF(Fetch, <span class="stringliteral">&quot;[tid:%i]: predHist.size(): %i\n&quot;</span>,
                tid, predHist[tid].size());
    }

}
</pre></div>
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_a94a04b4bdf8f6b9b3cf33882bc16067b_icgraph.png" border="0" usemap="#classBPredUnit_a94a04b4bdf8f6b9b3cf33882bc16067b_icgraph" alt=""/></div>
<map name="classBPredUnit_a94a04b4bdf8f6b9b3cf33882bc16067b_icgraph" id="classBPredUnit_a94a04b4bdf8f6b9b3cf33882bc16067b_icgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a78e6f48f8a11db90daab850527d48aa7"></a><!-- doxytag: member="BPredUnit::squash" ref="a78e6f48f8a11db90daab850527d48aa7" args="(const InstSeqNum &amp;squashed_sn, const TheISA::PCState &amp;corr_target, bool actually_taken, ThreadID tid)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::squash </td>
          <td>(</td>
          <td class="paramtype">const InstSeqNum &amp;&#160;</td>
          <td class="paramname"><em>squashed_sn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TheISA::PCState &amp;&#160;</td>
          <td class="paramname"><em>corr_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>actually_taken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ThreadID&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Squashes all outstanding updates until a given sequence number, and corrects that sn's update with the proper address and taken/not taken. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">squashed_sn</td><td>The sequence number to squash any younger updates up until. </td></tr>
    <tr><td class="paramname">corr_target</td><td>The correct branch target. </td></tr>
    <tr><td class="paramname">actually_taken</td><td>The correct branch direction. </td></tr>
    <tr><td class="paramname">tid</td><td>The thread id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94a04b4bdf8f6b9b3cf33882bc16067b"></a><!-- doxytag: member="BPredUnit::squash" ref="a94a04b4bdf8f6b9b3cf33882bc16067b" args="(const InstSeqNum &amp;squashed_sn, ThreadID tid)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::squash </td>
          <td>(</td>
          <td class="paramtype">const InstSeqNum &amp;&#160;</td>
          <td class="paramname"><em>squashed_sn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ThreadID&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Squashes all outstanding updates until a given sequence number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">squashed_sn</td><td>The sequence number to squash any younger updates up until. </td></tr>
    <tr><td class="paramname">tid</td><td>The thread id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac33c3d29c7b6aca9578fc416eb34e60e"></a><!-- doxytag: member="BPredUnit::switchOut" ref="ac33c3d29c7b6aca9578fc416eb34e60e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::switchOut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac33c3d29c7b6aca9578fc416eb34e60e"></a><!-- doxytag: member="BPredUnit::switchOut" ref="ac33c3d29c7b6aca9578fc416eb34e60e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::switchOut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="comment">// Clear any state upon switch out.</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; Impl::MaxThreads; ++i) {
        <a class="code" href="classBPredUnit.html#a94a04b4bdf8f6b9b3cf33882bc16067b">squash</a> (0, i);
    }
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classBPredUnit_ac33c3d29c7b6aca9578fc416eb34e60e_cgraph.png" border="0" usemap="#classBPredUnit_ac33c3d29c7b6aca9578fc416eb34e60e_cgraph" alt=""/></div>
<map name="classBPredUnit_ac33c3d29c7b6aca9578fc416eb34e60e_cgraph" id="classBPredUnit_ac33c3d29c7b6aca9578fc416eb34e60e_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9011bcc9143d2396dfec49828484a645"></a><!-- doxytag: member="BPredUnit::takeOverFrom" ref="a9011bcc9143d2396dfec49828484a645" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::takeOverFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9011bcc9143d2396dfec49828484a645"></a><!-- doxytag: member="BPredUnit::takeOverFrom" ref="a9011bcc9143d2396dfec49828484a645" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::takeOverFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="comment">// Can reset all predictor state, but it&#39;s not necessarily better</span>
    <span class="comment">// than leaving it be.</span>
<span class="comment">/*</span>
<span class="comment">    for (int i = 0; i &lt; Impl::MaxThreads; ++i)</span>
<span class="comment">        RAS[i].reset ();</span>
<span class="comment"></span>
<span class="comment">    BP.reset ();</span>
<span class="comment">    BTB.reset ();</span>
<span class="comment">*/</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa154b29fbf52ad49d89a046e94b53ac9"></a><!-- doxytag: member="BPredUnit::update" ref="aa154b29fbf52ad49d89a046e94b53ac9" args="(const InstSeqNum &amp;done_sn, ThreadID tid)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const InstSeqNum &amp;&#160;</td>
          <td class="paramname"><em>done_sn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ThreadID&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tells the branch predictor to commit any updates until the given sequence number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">done_sn</td><td>The sequence number to commit any older updates up until. </td></tr>
    <tr><td class="paramname">tid</td><td>The thread id. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
    DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: Committing branches until &quot;</span>
            <span class="stringliteral">&quot;[sn:%lli].\n&quot;</span>, tid, done_sn);

    <span class="keywordflow">while</span> (!predHist[tid].empty() &amp;&amp;
           predHist[tid].back().seqNum &lt;= done_sn) {
        <span class="comment">// Update the branch predictor with the correct results.</span>
                DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: Committing branch &quot;</span>
                        <span class="stringliteral">&quot;[sn:%lli].\n&quot;</span>, tid, predHist[tid].back().seqNum);
        <span class="keywordflow">if</span> (!onDemand || 
                (onDemand &amp;&amp; 
                 !predHist[tid].back().wasStatic &amp;&amp;
                 predHist[tid].back().wasControl)) {
                <a class="code" href="classBPredUnit.html#a35c57ae0661f1d5dd2169e919741d47b">BPUpdate</a>(predHist[tid].back().pc,
                         predHist[tid].back().predTaken,
                         predHist[tid].back().bpHistory, <span class="keyword">false</span>);
            }
                <a class="code" href="classBPredUnit.html#a16de9793a28ee07dcf26d89c03328555">BPHistUpdate</a>(predHist[tid].back().pc, <span class="comment">//should not do anything</span>
                 predHist[tid].back().predTaken,
                 predHist[tid].back().bpHistory, <span class="keyword">false</span>);

        predHist[tid].pop_back();
    }
    DPRINTF(Fetch, <span class="stringliteral">&quot;BranchPred: [tid:%i]: Done Committing branches\n&quot;</span>, tid);

}
</pre></div>
</div>
</div>
<a class="anchor" id="aa154b29fbf52ad49d89a046e94b53ac9"></a><!-- doxytag: member="BPredUnit::update" ref="aa154b29fbf52ad49d89a046e94b53ac9" args="(const InstSeqNum &amp;done_sn, ThreadID tid)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBPredUnit.html">BPredUnit</a>&lt; Impl &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const InstSeqNum &amp;&#160;</td>
          <td class="paramname"><em>done_sn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ThreadID&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tells the branch predictor to commit any updates until the given sequence number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">done_sn</td><td>The sequence number to commit any older updates up until. </td></tr>
    <tr><td class="paramname">tid</td><td>The thread id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/milad/esc_project/svn/PARS/src/backend/bp/<a class="el" href="backend_2bp_2bpred__unit_8h_source.html">bpred_unit.h</a></li>
<li>/home/milad/esc_project/svn/PARS/src/forLater/<a class="el" href="forLater_2bpred__unit_8h_source.html">bpred_unit.h</a></li>
<li>/home/milad/esc_project/svn/PARS/src/backend/bp/<a class="el" href="backend_2bp_2bpred__unit_8cpp.html">bpred_unit.cpp</a></li>
<li>/home/milad/esc_project/svn/PARS/src/forLater/<a class="el" href="bpred__unit__ctr_8h_source.html">bpred_unit_ctr.h</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon Jul 13 2015 for PhArS by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
