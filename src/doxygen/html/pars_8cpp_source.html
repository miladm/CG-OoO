<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>pars.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">pars.cpp</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*******************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> * pars.cpp</span>
<a name="l00003"></a>00003 <span class="comment"> *******************************************************************************/</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="comment">/*-- INCLUDE --*/</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;set&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;time.h&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;signal.h&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;signal.h&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;setjmp.h&gt;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;pin.H&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;pin_isa.H&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;instlib.H&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;lib/bp_lib/types.hh&quot;</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;tournament.hh&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;lib/bp_lib/types.hh&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;lib/bp_lib/intmath.hh&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;tournament.hh&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;utilities.h&quot;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;pars.h&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;utility.h&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;config.h&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;uop_gen.h&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;global.h&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;memlog.h&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#define G_I_INFO_EN 1</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#include &quot;g_info.h&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;g_variable.h&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;core_backend/bkEnd.h&quot;</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="comment">/* ------------------------------------------------------------------ */</span>
<a name="l00043"></a>00043 <span class="comment">/* Global Variables                                                   */</span>
<a name="l00044"></a>00044 <span class="comment">/* ------------------------------------------------------------------ */</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> g_store_buffer[MAX_MEM_WRITE_LEN];
<a name="l00047"></a>00047 <span class="preprocessor">#ifdef G_I_INFO_EN</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>map&lt;unsigned,i_info&gt; g_i_info;
<a name="l00049"></a>00049 <span class="preprocessor">#endif</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>clock_t start_pars, stop_pars;
<a name="l00051"></a>00051 TournamentBP *g_predictor = NULL;
<a name="l00052"></a>00052 PIN_SEMAPHORE semaphore0, semaphore1; <span class="comment">// semaphore that serializes access to global vars</span>
<a name="l00053"></a>00053 <span class="keywordtype">void</span> * rootThreadArg = (<span class="keywordtype">void</span> *)0xABBA;
<a name="l00054"></a>00054 PIN_THREAD_UID rootThreadUid;
<a name="l00055"></a>00055 <a class="code" href="classconfig.html">config</a>* c_cfg;
<a name="l00056"></a>00056 <a class="code" href="structg__variable.html">g_variable</a> g_var;
<a name="l00057"></a>00057 FILE* __outFile;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="comment">/* ------------------------------------------------------------------ */</span>
<a name="l00060"></a>00060 <span class="comment">/* Class Objects Interface Functions                                  */</span>
<a name="l00061"></a>00061 <span class="comment">/* ------------------------------------------------------------------ */</span>
<a name="l00062"></a>00062 <a class="code" href="classmemory__buffer.html">memory_buffer</a> g_log;
<a name="l00063"></a>00063 <span class="comment">/* ================================================================== */</span>
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="keywordtype">void</span> recover()
<a name="l00066"></a>00066 {
<a name="l00067"></a>00067         g_var.g_wrong_path = <span class="keyword">false</span>;
<a name="l00068"></a>00068         g_var.g_total_wrong_path_count += g_var.g_wrong_path_count;
<a name="l00069"></a>00069         g_var.g_recovery_count++;
<a name="l00070"></a>00070         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) {
<a name="l00071"></a>00071                 std::cout &lt;&lt; <span class="stringliteral">&quot; *** recovering to correct path ***\n&quot;</span>;
<a name="l00072"></a>00072                 std::cout &lt;&lt; <span class="stringliteral">&quot; recovery count = &quot;</span> &lt;&lt; dec &lt;&lt; g_var.g_recovery_count &lt;&lt; std::endl;
<a name="l00073"></a>00073                 std::cout &lt;&lt; <span class="stringliteral">&quot; wrong path ins count = &quot;</span> &lt;&lt; g_var.g_wrong_path_count &lt;&lt; <span class="stringliteral">&quot; instructions (avg: &quot;</span> 
<a name="l00074"></a>00074                           &lt;&lt; (double)g_var.g_total_wrong_path_count/(<span class="keywordtype">double</span>)g_var.g_recovery_count &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;
<a name="l00075"></a>00075         }
<a name="l00076"></a>00076         g_var.g_wrong_path_count = 0;
<a name="l00077"></a>00077         g_var.g_spec_syscall = <span class="keyword">false</span>;
<a name="l00078"></a>00078         g_var.g_context_call_depth=0;
<a name="l00079"></a>00079         g_log.recover();
<a name="l00080"></a>00080         printf(<span class="stringliteral">&quot;\nEND OF WRONG PATH\n&quot;</span>);
<a name="l00081"></a>00081         fprintf(__outFile, <span class="stringliteral">&quot;\nEND OF WRONG PATH\n&quot;</span>);
<a name="l00082"></a>00082 }
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 EXCEPT_HANDLING_RESULT handlePinException(THREADID tid, EXCEPTION_INFO * pExceptInfo, PHYSICAL_CONTEXT * pPhysCtxt, VOID *v)
<a name="l00086"></a>00086 {
<a name="l00087"></a>00087         g_var.g_pin_signal_count++;
<a name="l00088"></a>00088         <span class="keywordflow">if</span>( g_var.g_wrong_path ) {
<a name="l00089"></a>00089                 <span class="comment">//if (PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_NONE || </span>
<a name="l00090"></a>00090                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_ACCESS_INVALID_ADDRESS || </span>
<a name="l00091"></a>00091                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_ACCESS_DENIED ||</span>
<a name="l00092"></a>00092                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_ACCESS_INVALID_PAGE ||</span>
<a name="l00093"></a>00093                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_ACCESS_MISALIGNED ||</span>
<a name="l00094"></a>00094                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_ILLEGAL_INS ||</span>
<a name="l00095"></a>00095                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_INT_DIVIDE_BY_ZERO ||</span>
<a name="l00096"></a>00096                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_INT_OVERFLOW_TRAP ||</span>
<a name="l00097"></a>00097                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_INT_BOUNDS_EXCEEDED ||</span>
<a name="l00098"></a>00098                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_X87_DIVIDE_BY_ZERO ||</span>
<a name="l00099"></a>00099                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_X87_OVERFLOW ||</span>
<a name="l00100"></a>00100                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_X87_UNDERFLOW ||</span>
<a name="l00101"></a>00101                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_X87_INEXACT_RESULT ||</span>
<a name="l00102"></a>00102                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_X87_INVALID_OPERATION ||</span>
<a name="l00103"></a>00103                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_X87_DENORMAL_OPERAND ||</span>
<a name="l00104"></a>00104                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_X87_STACK_ERROR ||</span>
<a name="l00105"></a>00105                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_RECEIVED_UNKNOWN ||</span>
<a name="l00106"></a>00106                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_RECEIVED_ACCESS_FAULT ||</span>
<a name="l00107"></a>00107                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_RECEIVED_AMBIGUOUS_X87 ||</span>
<a name="l00108"></a>00108                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_RECEIVED_AMBIGUOUS_SIMD ||</span>
<a name="l00109"></a>00109                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_SIMD_DIVIDE_BY_ZERO ||</span>
<a name="l00110"></a>00110                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_SIMD_OVERFLOW ||</span>
<a name="l00111"></a>00111                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_SIMD_INEXACT_RESULT ||</span>
<a name="l00112"></a>00112                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_SIMD_UNDERFLOW ||</span>
<a name="l00113"></a>00113                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_SIMD_DENORMAL_OPERAND ||</span>
<a name="l00114"></a>00114                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_DBG_BREAKPOINT_TRAP ||</span>
<a name="l00115"></a>00115                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_ACCESS_WINDOWS_GUARD_PAGE ||</span>
<a name="l00116"></a>00116                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_WINDOWS ||</span>
<a name="l00117"></a>00117                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_ACCESS_WINDOWS_STACK_OVERFLOW ||</span>
<a name="l00118"></a>00118                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_SIMD_INVALID_OPERATION ||</span>
<a name="l00119"></a>00119                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_PRIVILEGED_INS ||</span>
<a name="l00120"></a>00120                 <span class="comment">//    PIN_GetExceptionCode(pExceptInfo) == EXCEPTCODE_DBG_SINGLE_STEP_TRAP)</span>
<a name="l00121"></a>00121                         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; <span class="stringliteral">&quot; caught signal &quot;</span> &lt;&lt; dec &lt;&lt; PIN_GetExceptionCode(pExceptInfo) &lt;&lt; <span class="stringliteral">&quot; on wrong path &quot;</span> &lt;&lt; std::endl;
<a name="l00122"></a>00122                         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; <span class="stringliteral">&quot; execption Info: &quot;</span> &lt;&lt; PIN_ExceptionToString(pExceptInfo) &lt;&lt; endl;
<a name="l00123"></a>00123                         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; <span class="stringliteral">&quot; pin signal count = &quot;</span> &lt;&lt; dec &lt;&lt; g_var.g_pin_signal_count &lt;&lt; std::endl;
<a name="l00124"></a>00124                         recover();
<a name="l00125"></a>00125                         PIN_ExecuteAt(&amp;g_var.g_context);
<a name="l00126"></a>00126         } <span class="keywordflow">else</span> {
<a name="l00127"></a>00127                 std::cout &lt;&lt; <span class="stringliteral">&quot;ERROR for REAL: caught signal &quot;</span> &lt;&lt; dec &lt;&lt; PIN_GetExceptionCode(pExceptInfo) &lt;&lt; <span class="stringliteral">&quot; on correct path &quot;</span> &lt;&lt; std::endl;
<a name="l00128"></a>00128                 std::cout &lt;&lt; <span class="stringliteral">&quot; execption Info: &quot;</span> &lt;&lt; PIN_ExceptionToString(pExceptInfo) &lt;&lt; endl;
<a name="l00129"></a>00129                 std::cout &lt;&lt; <span class="stringliteral">&quot; pin signal count = &quot;</span> &lt;&lt; dec &lt;&lt; g_var.g_pin_signal_count &lt;&lt; std::endl;
<a name="l00130"></a>00130         }
<a name="l00131"></a>00131         <span class="keywordflow">return</span> EHR_UNHANDLED;
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 BOOL signal_handler(THREADID tid, INT32 sig, CONTEXT *ctxt, BOOL hasHandler, <span class="keyword">const</span> EXCEPTION_INFO *pExceptInfo, VOID *v)
<a name="l00135"></a>00135 {
<a name="l00136"></a>00136         <span class="keywordflow">if</span> (sig != 11 &amp;&amp; sig != 4 &amp;&amp; sig != 7) cout &lt;&lt; sig &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; g_var.g_wrong_path &lt;&lt; endl;
<a name="l00137"></a>00137         g_var.g_app_signal_count++;
<a name="l00138"></a>00138         <span class="keywordflow">if</span>( g_var.g_wrong_path ) {
<a name="l00139"></a>00139                 <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; <span class="stringliteral">&quot; caught signal &quot;</span> &lt;&lt; dec &lt;&lt; sig &lt;&lt; <span class="stringliteral">&quot; on wrong path &quot;</span> &lt;&lt; std::endl;
<a name="l00140"></a>00140                 <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; <span class="stringliteral">&quot; application signal count = &quot;</span> &lt;&lt; dec &lt;&lt; g_var.g_app_signal_count &lt;&lt; std::endl;
<a name="l00141"></a>00141 
<a name="l00142"></a>00142                 recover();
<a name="l00143"></a>00143 
<a name="l00144"></a>00144                 PIN_SaveContext(&amp;g_var.g_context,ctxt);
<a name="l00145"></a>00145                 <span class="keywordflow">return</span> FALSE;
<a name="l00146"></a>00146         } <span class="keywordflow">else</span> {
<a name="l00147"></a>00147                 std::cout &lt;&lt; <span class="stringliteral">&quot;ERROR for REAL: caught signal &quot;</span> &lt;&lt; dec &lt;&lt; sig &lt;&lt; <span class="stringliteral">&quot; on correct path &quot;</span> &lt;&lt; std::endl;
<a name="l00148"></a>00148                 std::cout &lt;&lt; <span class="stringliteral">&quot; application signal count = &quot;</span> &lt;&lt; dec &lt;&lt; g_var.g_app_signal_count &lt;&lt; std::endl;
<a name="l00149"></a>00149                 <span class="keywordflow">return</span> TRUE; <span class="comment">// pass exception </span>
<a name="l00150"></a>00150         }
<a name="l00151"></a>00151 }
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 VOID HandleInst( UINT32 uid, BOOL __is_call, BOOL __is_ret, BOOL __is_far_ret)
<a name="l00154"></a>00154 {
<a name="l00155"></a>00155     <span class="keywordflow">if</span>( !g_var.g_enable_wp ) <span class="keywordflow">return</span>;
<a name="l00156"></a>00156 <span class="preprocessor">#ifdef G_I_INFO_EN</span>
<a name="l00157"></a>00157 <span class="preprocessor"></span>        assert(g_i_info.find(uid)!=g_i_info.end());
<a name="l00158"></a>00158         <span class="keyword">const</span> i_info &amp;i = g_i_info[uid];
<a name="l00159"></a>00159 <span class="preprocessor">#endif</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span>
<a name="l00161"></a>00161         g_var.g_seqnum++;
<a name="l00162"></a>00162         <span class="keywordflow">if</span>( !g_var.g_wrong_path ) g_var.g_icount++;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 <span class="preprocessor">#ifdef G_I_INFO_EN</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_EXEC ) std::cout &lt;&lt; <span class="stringliteral">&quot;EXEC i  &quot;</span> &lt;&lt; (g_var.g_wrong_path?<span class="stringliteral">&quot;*&quot;</span>:<span class="stringliteral">&quot; &quot;</span>) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; dec &lt;&lt; g_var.g_seqnum &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; hex &lt;&lt; i.pc &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; i.diss &lt;&lt; <span class="stringliteral">&quot; : &quot;</span>;
<a name="l00166"></a>00166 #endif
<a name="l00167"></a>00167 
<a name="l00168"></a>00168         <span class="keywordflow">if</span>( g_var.g_wrong_path ) {
<a name="l00169"></a>00169                 g_var.g_wrong_path_count++;
<a name="l00170"></a>00170                 <span class="keywordflow">if</span>( __is_call ) g_var.g_context_call_depth++;
<a name="l00171"></a>00171             <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; <span class="stringliteral">&quot; *** wrong path *** count = &quot;</span> &lt;&lt; dec &lt;&lt; g_var.g_wrong_path_count &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00172"></a>00172                 <span class="keywordflow">if</span>( (g_var.g_wrong_path_count &gt;= g_var.g_branch_mispredict_delay) ||
<a name="l00173"></a>00173                         ((g_var.g_context_call_depth==0) &amp;&amp; __is_ret) ||
<a name="l00174"></a>00174                         g_var.g_invalid_size || g_var.g_invalid_addr || g_var.g_spec_syscall || __is_far_ret || __is_call || __is_ret) {
<a name="l00175"></a>00175 
<a name="l00176"></a>00176                         recover();
<a name="l00177"></a>00177                         <span class="keywordflow">if</span>( g_var.g_enable_wp ) {
<a name="l00178"></a>00178                                 PIN_ExecuteAt( &amp;g_var.g_context );
<a name="l00179"></a>00179                         }
<a name="l00180"></a>00180                 }
<a name="l00181"></a>00181         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_EXEC ) std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00182"></a>00182         <span class="keywordflow">return</span>;
<a name="l00183"></a>00183 }
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 VOID countTrace(TRACE trace, VOID * v)
<a name="l00186"></a>00186 {
<a name="l00187"></a>00187         g_var.g_traceCount++;
<a name="l00188"></a>00188         g_var.g_codeCacheSize +=  TRACE_CodeCacheSize(trace);
<a name="l00189"></a>00189     <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_CC ) std::cout &lt;&lt; <span class="stringliteral">&quot;--Code Cache Size Limit: &quot;</span> &lt;&lt; CODECACHE_CacheSizeLimit()/(1024*1024) &lt;&lt; <span class="stringliteral">&quot;MB.\n&quot;</span>;
<a name="l00190"></a>00190     <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_CC ) std::cout &lt;&lt; <span class="stringliteral">&quot;Adding Trace #&quot;</span> &lt;&lt; g_var.g_traceCount &lt;&lt; <span class="stringliteral">&quot;(Addr: &quot;</span> &lt;&lt; TRACE_CodeCacheAddress(trace) &lt;&lt; <span class="stringliteral">&quot;) to code cache with size &quot;</span> &lt;&lt; TRACE_CodeCacheSize(trace) &lt;&lt; <span class="stringliteral">&quot; Bytes.\n&quot;</span>;
<a name="l00191"></a>00191     <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_CC ) std::cout &lt;&lt; <span class="stringliteral">&quot;Total code cache size: &quot;</span> &lt;&lt; g_var.g_codeCacheSize/(1024*1024) &lt;&lt; <span class="stringliteral">&quot;MB.\n&quot;</span>;
<a name="l00192"></a>00192 }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 <span class="comment">// When notified by Pin that the cache is full, perform a flush and</span>
<a name="l00195"></a>00195 <span class="comment">// tell the user about it.</span>
<a name="l00196"></a>00196 VOID FlushOnFull(UINT32 trace_size, UINT32 stub_size)
<a name="l00197"></a>00197 {
<a name="l00198"></a>00198         g_var.g_flushes++;
<a name="l00199"></a>00199     <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_CC ) std::cout &lt;&lt; <span class="stringliteral">&quot;Trying to insert trace size &quot;</span> &lt;&lt; trace_size &lt;&lt; <span class="stringliteral">&quot; and exit stub size &quot;</span> &lt;&lt; stub_size &lt;&lt; <span class="stringliteral">&quot;.\n&quot;</span>;
<a name="l00200"></a>00200         CODECACHE_FlushCache();
<a name="l00201"></a>00201         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_CC ) std::cout &lt;&lt; <span class="stringliteral">&quot;Code Cache Flushed at size &quot;</span> &lt;&lt; g_var.g_codeCacheSize/(1024*1024) &lt;&lt; <span class="stringliteral">&quot;MB! (Flush count: &quot;</span> &lt;&lt; g_var.g_flushes &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl;
<a name="l00202"></a>00202         g_var.g_codeCacheSize=0;
<a name="l00203"></a>00203 }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="keyword">static</span> VOID backEnd(<span class="keywordtype">void</span> *ptr) {
<a name="l00206"></a>00206         <span class="comment">// This is where the code backend will be called</span>
<a name="l00207"></a>00207         <span class="comment">// a shared buffer between the instruction analysis and this weill be present.</span>
<a name="l00208"></a>00208         <span class="comment">// the byffer will be accessed using locks on both the analysis routin and this routin.</span>
<a name="l00209"></a>00209         <span class="comment">// we use Pin locks as shown below.</span>
<a name="l00210"></a>00210         <span class="keywordflow">while</span> (!g_var.g_appEnd) { <span class="comment">//TODO fix this while loop</span>
<a name="l00211"></a>00211                 <span class="comment">//cout &lt;&lt;&quot;th2 waiting\n&quot;;</span>
<a name="l00212"></a>00212                 PIN_SemaphoreWait(&amp;semaphore0);
<a name="l00213"></a>00213                 <span class="comment">//if (!PIN_SemaphoreTimedWait(&amp;semaphore0,1200000)) {</span>
<a name="l00214"></a>00214                 <span class="comment">//      cout &lt;&lt; &quot;Semaphore timeout - backEnd()\n&quot;;</span>
<a name="l00215"></a>00215                 <span class="comment">//      break;</span>
<a name="l00216"></a>00216                 <span class="comment">//}</span>
<a name="l00217"></a>00217                 PIN_SemaphoreClear(&amp;semaphore0);
<a name="l00218"></a>00218                 <span class="comment">//cout &lt;&lt;&quot;th2 passing\n&quot;;</span>
<a name="l00219"></a>00219                 ADDRINT __pc = g_var.g_pc;
<a name="l00220"></a>00220                 BOOL taken = g_var.g_taken;
<a name="l00221"></a>00221                 ADDRINT tgt = g_var.g_tgt;
<a name="l00222"></a>00222                 ADDRINT fthru = g_var.g_fthru;
<a name="l00223"></a>00223                 g_var.g_pred_eip = PredictAndUpdate( __pc, taken, tgt, fthru );
<a name="l00224"></a>00224                 <span class="comment">//while (!g_var.g_insList.empty()) {</span>
<a name="l00225"></a>00225                 <span class="comment">//      cout &lt;&lt; g_var.g_insList.front();</span>
<a name="l00226"></a>00226                 <span class="comment">//      g_var.g_insList.pop_front();</span>
<a name="l00227"></a>00227                 <span class="comment">//}</span>
<a name="l00228"></a>00228                 <span class="keywordflow">if</span> (g_var.g_insList.size() &gt; 1000) {
<a name="l00229"></a>00229                         cout &lt;&lt; <span class="stringliteral">&quot;BACKEND\n&quot;</span>;
<a name="l00230"></a>00230                         bkEnd_run();
<a name="l00231"></a>00231                 }
<a name="l00232"></a>00232                 cout &lt;&lt; <span class="stringliteral">&quot;FRONTEND\n&quot;</span>;
<a name="l00233"></a>00233                 PIN_SemaphoreSet(&amp;semaphore1);
<a name="l00234"></a>00234         }
<a name="l00235"></a>00235         cout &lt;&lt; <span class="stringliteral">&quot;out of while becuase flags is : &quot;</span> &lt;&lt; g_var.g_appEnd &lt;&lt; endl;
<a name="l00236"></a>00236 }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 VOID runPARS(<span class="keywordtype">char</span>* cfgFile)
<a name="l00239"></a>00239 {
<a name="l00240"></a>00240     Init(cfgFile);
<a name="l00241"></a>00241 
<a name="l00242"></a>00242         <span class="comment">// Register a routine that gets called every time the trace is inserted</span>
<a name="l00243"></a>00243     CODECACHE_AddTraceInsertedFunction(countTrace, 0);
<a name="l00244"></a>00244         <span class="comment">// Register a routine that gets called every time the cache is full</span>
<a name="l00245"></a>00245         CODECACHE_AddFullCacheFunction(FlushOnFull, 0); 
<a name="l00246"></a>00246 
<a name="l00247"></a>00247         <span class="comment">//Handle pin-generated exceptions</span>
<a name="l00248"></a>00248         PIN_AddInternalExceptionHandler(handlePinException,NULL);
<a name="l00249"></a>00249         <span class="comment">//Handle application-generated exceptions</span>
<a name="l00250"></a>00250         PIN_InterceptSignal(SIGTRAP,signal_handler,NULL);
<a name="l00251"></a>00251         PIN_UnblockSignal(SIGTRAP,TRUE);
<a name="l00252"></a>00252         PIN_InterceptSignal(SIGILL,signal_handler,NULL);
<a name="l00253"></a>00253         PIN_UnblockSignal(SIGILL,TRUE);
<a name="l00254"></a>00254         PIN_InterceptSignal(SIGSEGV,signal_handler,NULL);
<a name="l00255"></a>00255         PIN_UnblockSignal(SIGSEGV,TRUE);
<a name="l00256"></a>00256         PIN_InterceptSignal(SIGFPE,signal_handler,NULL);
<a name="l00257"></a>00257         PIN_UnblockSignal(SIGFPE,TRUE);
<a name="l00258"></a>00258         PIN_InterceptSignal(SIGBUS,signal_handler,NULL);
<a name="l00259"></a>00259         PIN_UnblockSignal(SIGBUS,TRUE);
<a name="l00260"></a>00260         PIN_InterceptSignal(SIGABRT,signal_handler,NULL);
<a name="l00261"></a>00261         PIN_UnblockSignal(SIGABRT,TRUE);
<a name="l00262"></a>00262 
<a name="l00263"></a>00263         __outFile = fopen(<span class="stringliteral">&quot;junky&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l00264"></a>00264         uop_gen(__outFile, g_var);
<a name="l00265"></a>00265     INS_AddInstrumentFunction(Instruction, 0);
<a name="l00266"></a>00266     PIN_AddFiniFunction(Fini, 0);
<a name="l00267"></a>00267 
<a name="l00268"></a>00268     PIN_SpawnInternalThread(backEnd, rootThreadArg, 0, &amp;rootThreadUid);
<a name="l00269"></a>00269 
<a name="l00270"></a>00270         start_pars = clock();
<a name="l00271"></a>00271     <span class="comment">//return 0;</span>
<a name="l00272"></a>00272 }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 <span class="comment">/* ------------------------------------------------------------------ */</span>
<a name="l00275"></a>00275 <span class="comment">/* Initalization &amp; Clean Up                                           */</span>
<a name="l00276"></a>00276 <span class="comment">/* ------------------------------------------------------------------ */</span>
<a name="l00277"></a>00277 VOID parseConfig(<span class="keywordtype">char</span>* cfgFile) {
<a name="l00278"></a>00278         c_cfg = <span class="keyword">new</span> <a class="code" href="classconfig.html">config</a>(cfgFile);
<a name="l00279"></a>00279 }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 VOID Init(<span class="keywordtype">char</span>* cfgFile) 
<a name="l00282"></a>00282 {
<a name="l00283"></a>00283         parseConfig(cfgFile);
<a name="l00284"></a>00284         PIN_SemaphoreInit(&amp;semaphore0);
<a name="l00285"></a>00285         PIN_SemaphoreInit(&amp;semaphore1);
<a name="l00286"></a>00286         PIN_SemaphoreClear(&amp;semaphore0);
<a name="l00287"></a>00287         PIN_SemaphoreClear(&amp;semaphore1);
<a name="l00288"></a>00288     g_predictor = <span class="keyword">new</span> TournamentBP(2048, 2, 2048, 11, 8192, 13, 2, 8192, 2, 0);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290         <span class="comment">//initialize backend</span>
<a name="l00291"></a>00291         <span class="keywordtype">char</span> <span class="keyword">const</span> * dummy_argv[] = {<span class="stringliteral">&quot;TraceSim&quot;</span>, <span class="stringliteral">&quot;-o&quot;</span>, <span class="stringliteral">&quot;/scratch/tracesim/specint2006/results/ooo_listSch_dynBP_manyCache/401.bzip2.txt&quot;</span>, <span class="stringliteral">&quot;-i&quot;</span>, <span class="stringliteral">&quot;/scratch/tracesim/specint2006/bb_trace_archReg/401.bzip2.trace&quot;</span>, <span class="stringliteral">&quot;-c&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;-n&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>, <span class="stringliteral">&quot;-s&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;-y&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;-j&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;-w&quot;</span>, <span class="stringliteral">&quot;160&quot;</span>, <span class="stringliteral">&quot;-x&quot;</span>, <span class="stringliteral">&quot;/home/milad/esc_project/svn/memTraceMilad/TraceSim/results/bzip2/wbb_skip_static_count_bzip2.csv&quot;</span>, <span class="stringliteral">&quot;-e&quot;</span>, <span class="stringliteral">&quot;num_wbb_bypassed_in_scheduling_each_ins&quot;</span>, <span class="stringliteral">&quot;-z&quot;</span>, <span class="stringliteral">&quot;/home/milad/esc_project/svn/memTraceMilad/TraceSim/results/bzip2/branch_exe_count_map.csv&quot;</span>, NULL};
<a name="l00292"></a>00292         <span class="keywordtype">int</span> dummy_argc = <span class="keyword">sizeof</span>(dummy_argv) / <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*) - 1;
<a name="l00293"></a>00293         bkEnd_init (dummy_argc, dummy_argv, g_var); <span class="comment">//TODO fix this line</span>
<a name="l00294"></a>00294         bkEnd_heading (dummy_argc, dummy_argv); <span class="comment">//TODO fix this line</span>
<a name="l00295"></a>00295 }
<a name="l00296"></a>00296 
<a name="l00297"></a>00297 VOID Fini(INT32 code, VOID* v) 
<a name="l00298"></a>00298 {
<a name="l00299"></a>00299         stop_pars = clock();
<a name="l00300"></a>00300         g_var.g_appEnd = <span class="keyword">true</span>;
<a name="l00301"></a>00301         cout &lt;&lt; <span class="stringliteral">&quot;finishing&quot;</span> &lt;&lt; endl;
<a name="l00302"></a>00302         PIN_SemaphoreSet(&amp;semaphore0);
<a name="l00303"></a>00303         PIN_SemaphoreSet(&amp;semaphore1);
<a name="l00304"></a>00304         cout &lt;&lt; <span class="stringliteral">&quot;finished&quot;</span> &lt;&lt; endl;
<a name="l00305"></a>00305         <span class="keywordtype">double</span> exe_time = double(stop_pars-start_pars)/CLOCKS_PER_SEC;
<a name="l00306"></a>00306         <span class="keywordtype">double</span> ins_per_sec = double(g_var.insCount)/exe_time;
<a name="l00307"></a>00307         cout &lt;&lt; <span class="stringliteral">&quot;Execution Time Under Pin: &quot;</span> &lt;&lt; exe_time &lt;&lt; <span class="stringliteral">&quot; sec , Num Executed Ops: &quot;</span> &lt;&lt; g_var.insCount &lt;&lt; endl;
<a name="l00308"></a>00308         cout &lt;&lt; <span class="stringliteral">&quot;Instructions Executed Per Second Under Pin: &quot;</span> &lt;&lt; ins_per_sec &lt;&lt; endl;
<a name="l00309"></a>00309         cout &lt;&lt; <span class="stringliteral">&quot;Num traces generated: &quot;</span> &lt;&lt; g_var.g_traceCount &lt;&lt; <span class="stringliteral">&quot;; Code cach used for traces: &quot;</span> &lt;&lt; g_var.g_codeCacheSize/(1024*1024) &lt;&lt; <span class="stringliteral">&quot; MB; Code cache flush count: &quot;</span> &lt;&lt; g_var.g_flushes &lt;&lt; endl;
<a name="l00310"></a>00310         <span class="keyword">delete</span> g_predictor;
<a name="l00311"></a>00311         PIN_SemaphoreFini (&amp;semaphore0);
<a name="l00312"></a>00312         PIN_SemaphoreFini (&amp;semaphore1);
<a name="l00313"></a>00313 
<a name="l00314"></a>00314         <span class="comment">//finish backend</span>
<a name="l00315"></a>00315         bkEnd_finish ();
<a name="l00316"></a>00316 }
<a name="l00317"></a>00317 <span class="comment">/* ================================================================== */</span>
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 EXCEPT_HANDLING_RESULT handle(THREADID tid, EXCEPTION_INFO *pExceptInfo, PHYSICAL_CONTEXT *pPhysCtxt, VOID *v)
<a name="l00321"></a>00321 {
<a name="l00322"></a>00322         g_var.g_pintool_signal_count++;
<a name="l00323"></a>00323         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; <span class="stringliteral">&quot; pintool signal count = &quot;</span> &lt;&lt; dec &lt;&lt; g_var.g_pintool_signal_count &lt;&lt; std::endl;
<a name="l00324"></a>00324         longjmp(g_var.g_env,1);
<a name="l00325"></a>00325 }
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 <span class="keywordtype">void</span> read_mem_orig( ADDRINT eaddr, ADDRINT len )
<a name="l00328"></a>00328 {
<a name="l00329"></a>00329         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_WRITE_MEM ) std::cout &lt;&lt; <span class="stringliteral">&quot;  mem[&quot;</span> &lt;&lt; hex &lt;&lt; eaddr &lt;&lt; <span class="stringliteral">&quot; ] = &quot;</span>;
<a name="l00330"></a>00330         <span class="comment">//assert ( len &lt;= MAX_MEM_WRITE_LEN );</span>
<a name="l00331"></a>00331         g_var.g_invalid_size = <span class="keyword">false</span>;
<a name="l00332"></a>00332         <span class="keywordflow">if</span> (len &gt; MAX_MEM_WRITE_LEN) {
<a name="l00333"></a>00333                 <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; <span class="stringliteral">&quot; (invalid memory access size - read_mem_orig()) - &quot;</span> &lt;&lt; (int)len &lt;&lt; <span class="stringliteral">&quot;Bytes\n&quot;</span>;
<a name="l00334"></a>00334                 g_var.g_invalid_size = <span class="keyword">true</span>;
<a name="l00335"></a>00335                 <span class="keywordflow">return</span>;
<a name="l00336"></a>00336         }
<a name="l00337"></a>00337         g_var.g_last_len = len;
<a name="l00338"></a>00338         g_var.g_last_eaddr = eaddr;
<a name="l00339"></a>00339         g_var.g_invalid_addr = <span class="keyword">false</span>;
<a name="l00340"></a>00340 
<a name="l00341"></a>00341         THREADID tid=PIN_ThreadId();
<a name="l00342"></a>00342         <span class="keywordflow">if</span>( tid==INVALID_THREADID ) {
<a name="l00343"></a>00343                 std::cout &lt;&lt; <span class="stringliteral">&quot; could not get thread id\n&quot;</span>;
<a name="l00344"></a>00344                 exit(1);
<a name="l00345"></a>00345         }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347         PIN_TryStart(tid,handle,0);
<a name="l00348"></a>00348         <span class="keywordtype">int</span> val = setjmp(g_var.g_env);
<a name="l00349"></a>00349         <span class="keywordflow">if</span> (val) {
<a name="l00350"></a>00350                 <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; <span class="stringliteral">&quot; (invalid memory location - read_mem_orig())\n&quot;</span>;
<a name="l00351"></a>00351                 g_var.g_invalid_addr = <span class="keyword">true</span>;
<a name="l00352"></a>00352                 PIN_TryEnd(tid);
<a name="l00353"></a>00353                 <span class="keywordflow">return</span>;
<a name="l00354"></a>00354         }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356         <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i=len-1; i &gt;= 0; i-- ) {
<a name="l00357"></a>00357                 PIN_SafeCopy(&amp;g_store_buffer[i], (ADDRINT*)(eaddr+i), <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>));
<a name="l00358"></a>00358                 <span class="comment">//g_store_buffer[i] = *(((unsigned char*)eaddr)+i);</span>
<a name="l00359"></a>00359                 <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_WRITE_MEM ) std::cout &lt;&lt; hex &lt;&lt; (unsigned) g_store_buffer[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00360"></a>00360         }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362         PIN_TryEnd(tid);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364         g_log.save( eaddr, len, g_store_buffer );
<a name="l00365"></a>00365 
<a name="l00366"></a>00366         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_WRITE_MEM ) std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00367"></a>00367 }
<a name="l00368"></a>00368 
<a name="l00369"></a>00369 <span class="comment">/*</span>
<a name="l00370"></a>00370 <span class="comment">map&lt;ADDRINT,unsigned char&gt; g_specmem;</span>
<a name="l00371"></a>00371 <span class="comment"></span>
<a name="l00372"></a>00372 <span class="comment">void read_mem_new()</span>
<a name="l00373"></a>00373 <span class="comment">{</span>
<a name="l00374"></a>00374 <span class="comment">        if( g_var.g_invalid_addr ) return;</span>
<a name="l00375"></a>00375 <span class="comment">        if( g_var.g_debug_level &amp; DBG_WRITE_MEM ) std::cout &lt;&lt; &quot;  mem[&quot; &lt;&lt; hex &lt;&lt; g_var.g_last_eaddr &lt;&lt; &quot; ] = &quot;;</span>
<a name="l00376"></a>00376 <span class="comment"></span>
<a name="l00377"></a>00377 <span class="comment">        for( int i=g_var.g_last_len-1; i &gt;= 0; i-- ) {</span>
<a name="l00378"></a>00378 <span class="comment">                g_specmem[g_var.g_last_eaddr+i] = *(((unsigned char*)g_last_eaddr)+i);</span>
<a name="l00379"></a>00379 <span class="comment">                if( g_var.g_debug_level &amp; DBG_WRITE_MEM ) std::cout &lt;&lt; hex &lt;&lt; (unsigned) g_specmem[g_var.g_last_eaddr+i] &lt;&lt; &quot; &quot;;</span>
<a name="l00380"></a>00380 <span class="comment">        }</span>
<a name="l00381"></a>00381 <span class="comment"></span>
<a name="l00382"></a>00382 <span class="comment">        if( g_var.g_debug_level &amp; DBG_WRITE_MEM ) std::cout &lt;&lt; &quot;\n&quot;;</span>
<a name="l00383"></a>00383 <span class="comment">}</span>
<a name="l00384"></a>00384 <span class="comment"></span>
<a name="l00385"></a>00385 <span class="comment">void restore_mem_orig()</span>
<a name="l00386"></a>00386 <span class="comment">{</span>
<a name="l00387"></a>00387 <span class="comment">        if( g_var.g_invalid_addr ) return;</span>
<a name="l00388"></a>00388 <span class="comment">        if( g_var.g_debug_level &amp; DBG_RESTORE_MEM ) std::cout &lt;&lt; &quot;  restoring mem[&quot; &lt;&lt; hex &lt;&lt; g_var.g_last_eaddr &lt;&lt; &quot; ] = &quot;;</span>
<a name="l00389"></a>00389 <span class="comment"></span>
<a name="l00390"></a>00390 <span class="comment">        THREADID tid=PIN_ThreadId();</span>
<a name="l00391"></a>00391 <span class="comment">        if( tid==INVALID_THREADID ) {</span>
<a name="l00392"></a>00392 <span class="comment">                std::cout &lt;&lt; &quot; could not get thread id\n&quot;;</span>
<a name="l00393"></a>00393 <span class="comment">                exit(1);</span>
<a name="l00394"></a>00394 <span class="comment">        }</span>
<a name="l00395"></a>00395 <span class="comment"></span>
<a name="l00396"></a>00396 <span class="comment">        PIN_TryStart(tid,handle,0);</span>
<a name="l00397"></a>00397 <span class="comment">        int val = setjmp(g_var.g_env);</span>
<a name="l00398"></a>00398 <span class="comment">        if (val) {</span>
<a name="l00399"></a>00399 <span class="comment">                if( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; &quot; (invalid memory location - restore_mem_orig())\n&quot;;</span>
<a name="l00400"></a>00400 <span class="comment">                g_var.g_invalid_addr=true;</span>
<a name="l00401"></a>00401 <span class="comment">                PIN_TryEnd(tid);</span>
<a name="l00402"></a>00402 <span class="comment">                return;</span>
<a name="l00403"></a>00403 <span class="comment">        }</span>
<a name="l00404"></a>00404 <span class="comment"></span>
<a name="l00405"></a>00405 <span class="comment">        for( int i=g_var.g_last_len-1; i &gt;= 0; i-- ) {</span>
<a name="l00406"></a>00406 <span class="comment">                *(((unsigned char*)g_var.g_last_eaddr)+i) = g_store_buffer[i];</span>
<a name="l00407"></a>00407 <span class="comment">                if( g_var.g_debug_level &amp; DBG_RESTORE_MEM ) std::cout &lt;&lt; hex &lt;&lt; (unsigned) g_store_buffer[i] &lt;&lt; &quot; &quot;;</span>
<a name="l00408"></a>00408 <span class="comment">        }</span>
<a name="l00409"></a>00409 <span class="comment"></span>
<a name="l00410"></a>00410 <span class="comment">        PIN_TryEnd(tid);</span>
<a name="l00411"></a>00411 <span class="comment"></span>
<a name="l00412"></a>00412 <span class="comment">        if( g_var.g_debug_level &amp; DBG_RESTORE_MEM ) std::cout &lt;&lt; &quot;\n&quot;;</span>
<a name="l00413"></a>00413 <span class="comment">}</span>
<a name="l00414"></a>00414 <span class="comment">*/</span>
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 VOID GetMemWriteOrigValue( UINT32 uid, CONTEXT *c, ADDRINT eaddr, ADDRINT len )
<a name="l00417"></a>00417 {
<a name="l00418"></a>00418     <span class="keywordflow">if</span>( !g_var.g_enable_wp ) <span class="keywordflow">return</span>;
<a name="l00419"></a>00419     <span class="keywordflow">if</span>( g_var.g_enable_wp &amp;&amp; !g_var.g_wrong_path ) <span class="keywordflow">return</span>;
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 <span class="preprocessor">#ifdef G_I_INFO_EN</span>
<a name="l00422"></a>00422 <span class="preprocessor"></span>        assert(g_i_info.find(uid)!=g_i_info.end());
<a name="l00423"></a>00423         <span class="keyword">const</span> i_info &amp;i = g_i_info[uid];
<a name="l00424"></a>00424         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_WRITE_MEM ) std::cout &lt;&lt; <span class="stringliteral">&quot;EXEC wb &quot;</span> &lt;&lt; (g_var.g_wrong_path?<span class="stringliteral">&quot;*&quot;</span>:<span class="stringliteral">&quot; &quot;</span>) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; dec &lt;&lt; g_var.g_seqnum &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; hex &lt;&lt; i.pc &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; i.diss &lt;&lt; <span class="stringliteral">&quot; : &quot;</span>;
<a name="l00425"></a>00425 #endif
<a name="l00426"></a>00426         read_mem_orig(eaddr, len);
<a name="l00427"></a>00427         <span class="keywordflow">return</span>;
<a name="l00428"></a>00428 }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 VOID GetMemWriteNewValue( UINT32 uid, CONTEXT *c )
<a name="l00431"></a>00431 {
<a name="l00432"></a>00432     <span class="keywordflow">if</span>( !g_var.g_enable_wp ) <span class="keywordflow">return</span>;
<a name="l00433"></a>00433     <span class="keywordflow">if</span>( g_var.g_enable_wp &amp;&amp; !g_var.g_wrong_path ) <span class="keywordflow">return</span>;
<a name="l00434"></a>00434 
<a name="l00435"></a>00435 <span class="preprocessor">#ifdef G_I_INFO_EN</span>
<a name="l00436"></a>00436 <span class="preprocessor"></span>        assert(g_i_info.find(uid)!=g_i_info.end());
<a name="l00437"></a>00437         <span class="keyword">const</span> i_info &amp;i = g_i_info[uid];
<a name="l00438"></a>00438         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_WRITE_MEM ) std::cout &lt;&lt; <span class="stringliteral">&quot;EXEC wa &quot;</span> &lt;&lt; (g_var.g_wrong_path?<span class="stringliteral">&quot;*&quot;</span>:<span class="stringliteral">&quot; &quot;</span>) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; dec &lt;&lt; g_var.g_seqnum &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; hex &lt;&lt; i.pc &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; i.diss &lt;&lt; <span class="stringliteral">&quot; : &quot;</span>;
<a name="l00439"></a>00439 #endif
<a name="l00440"></a>00440 
<a name="l00441"></a>00441         <span class="comment">// TODO: bypass real memory?</span>
<a name="l00442"></a>00442         <span class="comment">// read_mem_new();</span>
<a name="l00443"></a>00443         <span class="comment">// restore_mem_orig();</span>
<a name="l00444"></a>00444         <span class="keywordflow">return</span>;
<a name="l00445"></a>00445 }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 VOID GetMemReadBypass( UINT32 uid, CONTEXT *c, ADDRINT eaddr, ADDRINT len )
<a name="l00448"></a>00448 {
<a name="l00449"></a>00449     <span class="keywordflow">if</span>( !g_var.g_enable_wp ) <span class="keywordflow">return</span>;
<a name="l00450"></a>00450     <span class="keywordflow">if</span>( g_var.g_enable_wp &amp;&amp; !g_var.g_wrong_path ) <span class="keywordflow">return</span>;
<a name="l00451"></a>00451 
<a name="l00452"></a>00452 <span class="preprocessor">#ifdef G_I_INFO_EN</span>
<a name="l00453"></a>00453 <span class="preprocessor"></span>        assert(g_i_info.find(uid)!=g_i_info.end());
<a name="l00454"></a>00454         <span class="keyword">const</span> i_info &amp;i = g_i_info[uid];
<a name="l00455"></a>00455         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_READ_MEM ) std::cout &lt;&lt; <span class="stringliteral">&quot;EXEC rb &quot;</span> &lt;&lt; (g_var.g_wrong_path?<span class="stringliteral">&quot;*&quot;</span>:<span class="stringliteral">&quot; &quot;</span>) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; dec &lt;&lt; g_var.g_seqnum &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; hex &lt;&lt; i.pc &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; i.diss &lt;&lt; <span class="stringliteral">&quot; : &quot;</span>;
<a name="l00456"></a>00456 #endif
<a name="l00457"></a>00457 
<a name="l00458"></a>00458         <span class="comment">// TODO: bypass real memory?</span>
<a name="l00459"></a>00459         <span class="keywordflow">return</span>;
<a name="l00460"></a>00460 }
<a name="l00461"></a>00461 
<a name="l00462"></a>00462 VOID HandleBranch( UINT32 uid, CONTEXT *c, BOOL taken, ADDRINT tgt, ADDRINT fthru, ADDRINT __pc, BOOL __has_ft)
<a name="l00463"></a>00463 {
<a name="l00464"></a>00464     <span class="keywordflow">if</span>( !g_var.g_enable_wp ) <span class="keywordflow">return</span>;
<a name="l00465"></a>00465     <span class="keywordflow">if</span>( g_var.g_enable_wp &amp;&amp; g_var.g_wrong_path ) <span class="keywordflow">return</span>;
<a name="l00466"></a>00466 <span class="preprocessor">#ifdef G_I_INFO_EN</span>
<a name="l00467"></a>00467 <span class="preprocessor"></span>        assert(g_i_info.find(uid)!=g_i_info.end());
<a name="l00468"></a>00468         <span class="comment">//const i_info &amp;i = g_i_info[uid];</span>
<a name="l00469"></a>00469 <span class="preprocessor">#endif</span>
<a name="l00470"></a>00470 <span class="preprocessor"></span>        <span class="keywordtype">bool</span> was_wp = g_var.g_wrong_path;
<a name="l00471"></a>00471 
<a name="l00472"></a>00472         ADDRINT pred_eip = tgt;
<a name="l00473"></a>00473         <span class="keywordflow">if</span>( __has_ft ) {
<a name="l00474"></a>00474                 g_var.g_pc = __pc;
<a name="l00475"></a>00475                 g_var.g_taken = taken;
<a name="l00476"></a>00476                 g_var.g_tgt = tgt;
<a name="l00477"></a>00477                 g_var.g_fthru = fthru;
<a name="l00478"></a>00478                 PIN_SemaphoreSet(&amp;semaphore0);
<a name="l00479"></a>00479                 <span class="comment">//cout &lt;&lt;&quot;th1 waiting\n&quot;;</span>
<a name="l00480"></a>00480                 PIN_SemaphoreWait(&amp;semaphore1); 
<a name="l00481"></a>00481                 PIN_SemaphoreClear(&amp;semaphore1);
<a name="l00482"></a>00482                 <span class="comment">//cout &lt;&lt;&quot;th1 passing\n&quot;;</span>
<a name="l00483"></a>00483                 pred_eip = g_var.g_pred_eip;
<a name="l00484"></a>00484         }
<a name="l00485"></a>00485         <span class="keywordflow">if</span>( g_var.g_wrong_path &amp;&amp; !was_wp ) {
<a name="l00486"></a>00486                 g_var.g_wrong_path_number++;
<a name="l00487"></a>00487                 <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; <span class="stringliteral">&quot;  *** transitioning to wrong path ***\n&quot;</span>;
<a name="l00488"></a>00488                 <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; <span class="stringliteral">&quot;  wrong path number = &quot;</span> &lt;&lt; dec &lt;&lt; g_var.g_wrong_path_number &lt;&lt; std::endl;
<a name="l00489"></a>00489                 PIN_SaveContext(c,&amp;g_var.g_context);
<a name="l00490"></a>00490         }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492         ADDRINT eip = taken?tgt:fthru;
<a name="l00493"></a>00493         <span class="keywordflow">if</span>( eip != pred_eip ) {
<a name="l00494"></a>00494                 assert( g_var.g_wrong_path );
<a name="l00495"></a>00495                 <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; <span class="stringliteral">&quot;  *** forcing PIN to change control flow ***\n&quot;</span>;
<a name="l00496"></a>00496                 <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; <span class="stringliteral">&quot;      predicted EIP = &quot;</span> &lt;&lt; hex &lt;&lt; pred_eip &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00497"></a>00497                 <span class="keywordflow">if</span>( g_var.g_enable_wp ) {
<a name="l00498"></a>00498                         PIN_SetContextReg(c,REG_INST_PTR, pred_eip);
<a name="l00499"></a>00499                         g_var.g_context_call_depth=0;
<a name="l00500"></a>00500                         PIN_ExecuteAt(c);
<a name="l00501"></a>00501                 }
<a name="l00502"></a>00502         }
<a name="l00503"></a>00503         <span class="keywordflow">return</span>;
<a name="l00504"></a>00504 }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 VOID HandleSyscall( UINT32 uid, CONTEXT *c )
<a name="l00507"></a>00507 {
<a name="l00508"></a>00508     <span class="keywordflow">if</span>( !g_var.g_enable_wp ) <span class="keywordflow">return</span>;
<a name="l00509"></a>00509 <span class="preprocessor">#ifdef G_I_INFO_EN</span>
<a name="l00510"></a>00510 <span class="preprocessor"></span>        assert(g_i_info.find(uid)!=g_i_info.end());
<a name="l00511"></a>00511         <span class="keyword">const</span> i_info &amp;i = g_i_info[uid];
<a name="l00512"></a>00512         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_EXEC ) std::cout &lt;&lt; <span class="stringliteral">&quot;EXEC hs &quot;</span> &lt;&lt; (g_var.g_wrong_path?<span class="stringliteral">&quot;*&quot;</span>:<span class="stringliteral">&quot; &quot;</span>) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; dec &lt;&lt; g_var.g_seqnum &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; hex &lt;&lt; i.pc &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; i.diss &lt;&lt; <span class="stringliteral">&quot; : &quot;</span>;
<a name="l00513"></a>00513 #endif
<a name="l00514"></a>00514         <span class="keywordflow">if</span>( g_var.g_wrong_path ) {
<a name="l00515"></a>00515             <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_SPEC ) std::cout &lt;&lt; <span class="stringliteral">&quot; *** detected system call on wrong path ***\n&quot;</span>;
<a name="l00516"></a>00516                 g_var.g_spec_syscall = <span class="keyword">true</span>;    
<a name="l00517"></a>00517         }
<a name="l00518"></a>00518 }
<a name="l00519"></a>00519 
<a name="l00520"></a>00520 <span class="keyword">inline</span> BOOL simpointMode() {
<a name="l00521"></a>00521         <span class="keyword">static</span> <span class="keywordtype">int</span> simpCount=0; 
<a name="l00522"></a>00522         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> next_simp=c_cfg-&gt;_simpoint.begin()-&gt;first; 
<a name="l00523"></a>00523         <span class="keywordflow">if</span> (g_var.g_enable_simpoint &amp;&amp; !g_var.g_wrong_path) {
<a name="l00524"></a>00524                 <span class="keywordflow">if</span> (g_var.g_inSimpoint) {
<a name="l00525"></a>00525                         g_var.g_simpInsCnt++;
<a name="l00526"></a>00526                         <span class="keywordflow">if</span> (g_var.g_simpInsCnt &gt;= SIMP_WINDOW_SIZE) {
<a name="l00527"></a>00527                                 cout &lt;&lt; <span class="stringliteral">&quot;*** Simpoint end\n\n&quot;</span>;
<a name="l00528"></a>00528                                 g_var.g_inSimpoint = <span class="keyword">false</span>;
<a name="l00529"></a>00529                                 g_var.g_enable_wp = <span class="keyword">false</span>;
<a name="l00530"></a>00530                                 g_var.g_simpInsCnt = 0;
<a name="l00531"></a>00531                                 PIN_RemoveInstrumentation();
<a name="l00532"></a>00532                                 g_var.g_enable_instrumentation = <span class="keyword">false</span>;
<a name="l00533"></a>00533                         }
<a name="l00534"></a>00534                 } <span class="keywordflow">else</span> {
<a name="l00535"></a>00535                         <span class="keywordflow">if</span> (next_simp == g_var.g_insCountRightPath) {
<a name="l00536"></a>00536                                 g_var.g_inSimpoint = <span class="keyword">true</span>;
<a name="l00537"></a>00537                                 g_var.g_enable_wp = <span class="keyword">true</span>;
<a name="l00538"></a>00538                                 g_var.g_simpInsCnt = 0;
<a name="l00539"></a>00539                                 g_var.g_enable_instrumentation = <span class="keyword">true</span>;
<a name="l00540"></a>00540                                 c_cfg-&gt;_simpoint.erase(next_simp);
<a name="l00541"></a>00541                                 next_simp = c_cfg-&gt;_simpoint.begin()-&gt;first;
<a name="l00542"></a>00542                                 cout &lt;&lt; <span class="stringliteral">&quot;\n*** Simpoint #&quot;</span> &lt;&lt; ++simpCount &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; g_var.g_insCountRightPath &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00543"></a>00543                                 cout &lt;&lt; <span class="stringliteral">&quot;*** Next Simpoint is: #&quot;</span> &lt;&lt; next_simp &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00544"></a>00544                         }
<a name="l00545"></a>00545                 }
<a name="l00546"></a>00546         }
<a name="l00547"></a>00547         <span class="keywordflow">return</span> g_var.g_inSimpoint;
<a name="l00548"></a>00548 }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="comment">// Counts the number of dynamic instructions (wrong-path instructions included)</span>
<a name="l00551"></a>00551 VOID doCount()
<a name="l00552"></a>00552 {
<a name="l00553"></a>00553         g_var.insCount++; <span class="comment">/*total ins count: wrong and right path*/</span>
<a name="l00554"></a>00554         <span class="keywordflow">if</span> (!g_var.g_wrong_path) g_var.g_insCountRightPath++;
<a name="l00555"></a>00555         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> countRem = g_var.insCount%BILLION;
<a name="l00556"></a>00556         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> countQ = g_var.insCount/MILLION;
<a name="l00557"></a>00557         <span class="keyword">static</span> clock_t past = 0.0;
<a name="l00558"></a>00558         <span class="keyword">static</span> clock_t now = double(clock())/CLOCKS_PER_SEC;
<a name="l00559"></a>00559         simpointMode();
<a name="l00560"></a>00560         <span class="keywordflow">if</span> (countRem == 0) {
<a name="l00561"></a>00561             now = double(clock())/CLOCKS_PER_SEC;
<a name="l00562"></a>00562                 cout &lt;&lt; countQ &lt;&lt; <span class="stringliteral">&quot; million passed at &quot;</span> &lt;&lt; double(clock())/CLOCKS_PER_SEC &lt;&lt; <span class="stringliteral">&quot; seconds. (Diff Time: &quot;</span> &lt;&lt; now-past &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;
<a name="l00563"></a>00563                 cout &lt;&lt; <span class="stringliteral">&quot;  correct path ins count: &quot;</span> &lt;&lt; g_var.g_insCountRightPath &lt;&lt; <span class="stringliteral">&quot;(fraction: &quot;</span> &lt;&lt; double(g_var.g_insCountRightPath)/double(g_var.insCount) &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;
<a name="l00564"></a>00564                 cout &lt;&lt; <span class="stringliteral">&quot;  wrong path ins count: &quot;</span> &lt;&lt; g_var.g_total_wrong_path_count &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00565"></a>00565                 cout &lt;&lt; <span class="stringliteral">&quot;  wrong path count: &quot;</span> &lt;&lt; g_var.g_wrong_path_number &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00566"></a>00566                 cout &lt;&lt; <span class="stringliteral">&quot;  trace count: &quot;</span> &lt;&lt; g_var.g_traceCount &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00567"></a>00567                 cout &lt;&lt; <span class="stringliteral">&quot;  app signal count: &quot;</span> &lt;&lt; g_var.g_app_signal_count &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00568"></a>00568                 cout &lt;&lt; <span class="stringliteral">&quot;  pin signal count: &quot;</span> &lt;&lt; g_var.g_pin_signal_count &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00569"></a>00569                 cout &lt;&lt; <span class="stringliteral">&quot;  out of mem count: &quot;</span> &lt;&lt; g_var.g_flushes &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00570"></a>00570                 cout &lt;&lt; <span class="stringliteral">&quot;  recovery count: &quot;</span> &lt;&lt; g_var.g_recovery_count &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00571"></a>00571                 cout &lt;&lt; <span class="stringliteral">&quot;  code cache flush count: &quot;</span> &lt;&lt; g_var.g_flushes &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00572"></a>00572                 cout &lt;&lt; <span class="stringliteral">&quot;  avg wrong-path length: &quot;</span> &lt;&lt; double(g_var.g_total_wrong_path_count)/double(g_var.g_wrong_path_number) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00573"></a>00573                 cout &lt;&lt; <span class="stringliteral">&quot;  code cache size (MB): &quot;</span> &lt;&lt; double(g_var.g_codeCacheSize)/(1024.0*1024.0) &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;
<a name="l00574"></a>00574                 past = now;
<a name="l00575"></a>00575         }
<a name="l00576"></a>00576 }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 <span class="comment">// Add instruction to the instruction buffer</span>
<a name="l00579"></a>00579 VOID insertInsBuff() {
<a name="l00580"></a>00580         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_INSBUF) std::cout &lt;&lt; g_var.g_ins;
<a name="l00581"></a>00581         g_var.g_insList.push_back(g_var.g_ins);
<a name="l00582"></a>00582 }
<a name="l00583"></a>00583 
<a name="l00584"></a>00584 <span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> imgInsCallCount_=0;
<a name="l00585"></a>00585 VOID doImpCallCount_(BOOL isCall)
<a name="l00586"></a>00586 {
<a name="l00587"></a>00587         <span class="keywordflow">if</span> (isCall)
<a name="l00588"></a>00588                 imgInsCallCount_++;
<a name="l00589"></a>00589         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> countRem = g_var.insCount%BILLION;
<a name="l00590"></a>00590         <span class="keywordflow">if</span> (countRem == 0) {
<a name="l00591"></a>00591                 cout &lt;&lt; <span class="stringliteral">&quot;(CALL_) :&quot;</span> &lt;&lt; imgInsCallCount_ &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00592"></a>00592         }
<a name="l00593"></a>00593 }
<a name="l00594"></a>00594 
<a name="l00595"></a>00595 <span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> imgInsMemCount_=0;
<a name="l00596"></a>00596 VOID doImpMemCount_(UINT32 isMem)
<a name="l00597"></a>00597 {
<a name="l00598"></a>00598         <span class="keywordflow">if</span> (isMem &gt; 0)
<a name="l00599"></a>00599                 imgInsMemCount_++;
<a name="l00600"></a>00600         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> countRem = g_var.insCount%BILLION;
<a name="l00601"></a>00601         <span class="keywordflow">if</span> (countRem == 0) {
<a name="l00602"></a>00602                 cout &lt;&lt; <span class="stringliteral">&quot;(MEM_) :&quot;</span> &lt;&lt; imgInsMemCount_ &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00603"></a>00603         }
<a name="l00604"></a>00604 }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 VOID Instruction(INS ins, VOID* v) 
<a name="l00607"></a>00607 {
<a name="l00608"></a>00608         ADDRINT pc = INS_Address(ins);
<a name="l00609"></a>00609         <span class="keywordtype">string</span> diss =  INS_Disassemble(ins);
<a name="l00610"></a>00610         <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> uid=0;
<a name="l00611"></a>00611         ++uid;
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 <span class="preprocessor">#ifdef G_I_INFO_EN</span>
<a name="l00614"></a>00614 <span class="preprocessor"></span>        OPCODE opcode = INS_Opcode(ins);
<a name="l00615"></a>00615         <span class="keywordtype">bool</span> is_call = INS_IsCall(ins);
<a name="l00616"></a>00616         <span class="keywordtype">bool</span> is_ret = INS_IsRet(ins);
<a name="l00617"></a>00617         <span class="keywordtype">bool</span> has_ft = INS_HasFallThrough(ins);
<a name="l00618"></a>00618         g_i_info[uid] = i_info(pc,opcode,diss,is_call,is_ret,has_ft);
<a name="l00619"></a>00619         <span class="keywordflow">if</span> (uid==0) g_i_info[0] = i_info(pc,opcode,diss,is_call,is_ret,has_ft);
<a name="l00620"></a>00620 <span class="preprocessor">#endif</span>
<a name="l00621"></a>00621 <span class="preprocessor"></span>        
<a name="l00622"></a>00622         INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) insertInsBuff,
<a name="l00623"></a>00623                 IARG_END);
<a name="l00624"></a>00624         INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) doCount,
<a name="l00625"></a>00625                 IARG_END);
<a name="l00626"></a>00626         INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) doImpMemCount_,
<a name="l00627"></a>00627                 IARG_UINT32, INS_MemoryOperandCount(ins),
<a name="l00628"></a>00628                 IARG_END);
<a name="l00629"></a>00629         INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) doImpCallCount_,
<a name="l00630"></a>00630                 IARG_BOOL, INS_IsCall(ins),
<a name="l00631"></a>00631                 IARG_END);
<a name="l00632"></a>00632         
<a name="l00633"></a>00633         <span class="keywordflow">if</span> (g_var.g_enable_instrumentation) {
<a name="l00634"></a>00634                 <span class="comment">//cout &lt;&lt; g_var.g_insCountRightPath &lt;&lt; &quot; instrumentation enabled\n&quot;;</span>
<a name="l00635"></a>00635                 <span class="keywordflow">if</span>( INS_IsMemoryWrite(ins) ) {
<a name="l00636"></a>00636                         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_INS) std::cout &lt;&lt; <span class="stringliteral">&quot;INS  &quot;</span> &lt;&lt; hex &lt;&lt; pc &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; diss &lt;&lt; <span class="stringliteral">&quot; [mem write]\n&quot;</span>;
<a name="l00637"></a>00637                         INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) GetMemWriteOrigValue,
<a name="l00638"></a>00638                                         IARG_UINT32, uid,
<a name="l00639"></a>00639                                         IARG_CONTEXT,
<a name="l00640"></a>00640                                         IARG_MEMORYWRITE_EA,
<a name="l00641"></a>00641                                         IARG_MEMORYWRITE_SIZE,
<a name="l00642"></a>00642                                         IARG_END);
<a name="l00643"></a>00643                         <span class="comment">/*</span>
<a name="l00644"></a>00644 <span class="comment">                        if( INS_IsCall(ins) || INS_IsProcedureCall(ins) ) {</span>
<a name="l00645"></a>00645 <span class="comment">                                        INS_InsertCall(ins, IPOINT_TAKEN_BRANCH, (AFUNPTR) GetMemWriteNewValue,</span>
<a name="l00646"></a>00646 <span class="comment">                                                        IARG_UINT32, uid,</span>
<a name="l00647"></a>00647 <span class="comment">                                                        IARG_CONTEXT,</span>
<a name="l00648"></a>00648 <span class="comment">                                                        IARG_END);</span>
<a name="l00649"></a>00649 <span class="comment">                        } else {</span>
<a name="l00650"></a>00650 <span class="comment">                                        INS_InsertCall(ins, IPOINT_AFTER, (AFUNPTR) GetMemWriteNewValue,</span>
<a name="l00651"></a>00651 <span class="comment">                                                        IARG_UINT32, uid,</span>
<a name="l00652"></a>00652 <span class="comment">                                                        IARG_CONTEXT,</span>
<a name="l00653"></a>00653 <span class="comment">                                                        IARG_END);</span>
<a name="l00654"></a>00654 <span class="comment">                        }</span>
<a name="l00655"></a>00655 <span class="comment">                        */</span>
<a name="l00656"></a>00656                 }
<a name="l00657"></a>00657                 <span class="comment">/*</span>
<a name="l00658"></a>00658 <span class="comment">                if( INS_IsMemoryRead(ins) ) {</span>
<a name="l00659"></a>00659 <span class="comment">                        if( g_var.g_debug_level &amp; DBG_INS) std::cout &lt;&lt; &quot;INS  &quot; &lt;&lt; hex &lt;&lt; pc &lt;&lt; &quot; &quot; &lt;&lt; diss &lt;&lt; &quot; [mem read]\n&quot;;</span>
<a name="l00660"></a>00660 <span class="comment">                        INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) GetMemReadBypass,</span>
<a name="l00661"></a>00661 <span class="comment">                                        IARG_UINT32, uid,</span>
<a name="l00662"></a>00662 <span class="comment">                                        IARG_CONTEXT,</span>
<a name="l00663"></a>00663 <span class="comment">                                        IARG_MEMORYREAD_EA,</span>
<a name="l00664"></a>00664 <span class="comment">                                        IARG_MEMORYREAD_SIZE,</span>
<a name="l00665"></a>00665 <span class="comment">                                        IARG_END);</span>
<a name="l00666"></a>00666 <span class="comment">                }</span>
<a name="l00667"></a>00667 <span class="comment">                */</span>
<a name="l00668"></a>00668                 
<a name="l00669"></a>00669                 <span class="keywordflow">if</span>( INS_IsBranch(ins) ) {
<a name="l00670"></a>00670                         <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_INS) std::cout &lt;&lt; <span class="stringliteral">&quot;INS  &quot;</span> &lt;&lt; hex &lt;&lt; pc &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; diss &lt;&lt; <span class="stringliteral">&quot; [branch]\n&quot;</span>;
<a name="l00671"></a>00671                         INS_InsertCall(ins, IPOINT_TAKEN_BRANCH, (AFUNPTR) HandleBranch,
<a name="l00672"></a>00672                                         IARG_UINT32, uid,
<a name="l00673"></a>00673                                         IARG_CONTEXT,
<a name="l00674"></a>00674                                         IARG_BRANCH_TAKEN,
<a name="l00675"></a>00675                                         IARG_BRANCH_TARGET_ADDR, 
<a name="l00676"></a>00676                                         IARG_FALLTHROUGH_ADDR,
<a name="l00677"></a>00677                                         IARG_ADDRINT, INS_Address(ins),
<a name="l00678"></a>00678                                         IARG_BOOL, INS_HasFallThrough(ins),
<a name="l00679"></a>00679                                         IARG_END);
<a name="l00680"></a>00680                 
<a name="l00681"></a>00681                 }
<a name="l00682"></a>00682                 
<a name="l00683"></a>00683                 <span class="keywordflow">if</span>( INS_IsSyscall(ins) ) {
<a name="l00684"></a>00684                         INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) HandleSyscall,
<a name="l00685"></a>00685                                         IARG_UINT32, uid,
<a name="l00686"></a>00686                                         IARG_CONTEXT,
<a name="l00687"></a>00687                                         IARG_END);
<a name="l00688"></a>00688                 
<a name="l00689"></a>00689                 }
<a name="l00690"></a>00690         
<a name="l00691"></a>00691                 INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) HandleInst,
<a name="l00692"></a>00692                         IARG_UINT32, uid,
<a name="l00693"></a>00693                         IARG_BOOL, INS_IsCall(ins),
<a name="l00694"></a>00694                         IARG_BOOL, INS_IsRet(ins),
<a name="l00695"></a>00695                         IARG_BOOL, INS_IsFarRet(ins),
<a name="l00696"></a>00696                         IARG_END);
<a name="l00697"></a>00697         }
<a name="l00698"></a>00698         <span class="keywordflow">return</span>;
<a name="l00699"></a>00699 }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701 <span class="comment">/* ------------------------------------------------------------------ */</span>
<a name="l00702"></a>00702 <span class="comment">/* Branch Predictor                                                   */</span>
<a name="l00703"></a>00703 <span class="comment">/* ------------------------------------------------------------------ */</span>
<a name="l00704"></a>00704 ADDRINT PredictAndUpdate(ADDRINT __pc, INT32 __taken, ADDRINT tgt, ADDRINT fthru)
<a name="l00705"></a>00705 {
<a name="l00706"></a>00706     <span class="keywordtype">bool</span> taken = __taken;
<a name="l00707"></a>00707     ADDRINT pc = __pc;
<a name="l00708"></a>00708     <span class="keywordtype">void</span> *bp_hist = NULL;
<a name="l00709"></a>00709     <span class="keywordtype">bool</span> pred = g_predictor-&gt;lookup(pc, bp_hist);
<a name="l00710"></a>00710     <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_BP ) std::cout &lt;&lt; <span class="stringliteral">&quot;  prediction = &quot;</span> &lt;&lt; (pred?<span class="stringliteral">&quot;T&quot;</span>:<span class="stringliteral">&quot;N&quot;</span>);
<a name="l00711"></a>00711         <span class="keywordflow">if</span> (!g_var.g_wrong_path) {
<a name="l00712"></a>00712                 <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_BP ) std::cout &lt;&lt; <span class="stringliteral">&quot;, actual = &quot;</span> &lt;&lt; (taken?<span class="stringliteral">&quot;T&quot;</span>:<span class="stringliteral">&quot;N&quot;</span>) &lt;&lt; <span class="stringliteral">&quot; : &quot;</span>; 
<a name="l00713"></a>00713                 <span class="keywordflow">if</span>(pred != taken) {
<a name="l00714"></a>00714                     <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_BP ) std::cout &lt;&lt; <span class="stringliteral">&quot;mispredicted!\n&quot;</span>;
<a name="l00715"></a>00715                         g_var.g_wrong_path = <span class="keyword">true</span>;
<a name="l00716"></a>00716                         printf(<span class="stringliteral">&quot;\nSTART OF WRONG PATH\n&quot;</span>);
<a name="l00717"></a>00717                         fprintf(__outFile, <span class="stringliteral">&quot;\nSTART OF WRONG PATH\n&quot;</span>);
<a name="l00718"></a>00718                 } <span class="keywordflow">else</span> {
<a name="l00719"></a>00719                     <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_BP ) std::cout &lt;&lt; <span class="stringliteral">&quot;correct prediction\n&quot;</span>;
<a name="l00720"></a>00720                 }
<a name="l00721"></a>00721                 g_predictor-&gt;update(pc, taken, bp_hist, <span class="keyword">false</span>);
<a name="l00722"></a>00722         } <span class="keywordflow">else</span> {
<a name="l00723"></a>00723                 <span class="keywordflow">if</span>( g_var.g_debug_level &amp; DBG_BP ) std::cout &lt;&lt; <span class="stringliteral">&quot; on wrong path\n&quot;</span>;
<a name="l00724"></a>00724         }
<a name="l00725"></a>00725     <span class="keywordflow">return</span>  pred ? tgt : fthru;
<a name="l00726"></a>00726 }
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sun Mar 30 2014 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
