\subsubsection{Basicblock Reorder Buffer (BBROB)}
\label{sec:bb_rob}

Contrary to the OoO execution model where the program order is tracked at
instruction granularity through the reorder buffer (ROB), in this design, we only
track program order at basic-block granularity. BBROB is a content addressable
memory array (CAM) with only 16 entries (~10x smaller than ROB size in OoO) that
enables issuing, committing, and squashing basic-blocks as a whole in one cycle
(per basic-block). The smaller size of BBROB compared to a ROB enables
significant energy savings.

BBROB is marked complete when all its operations are completed. Complete
operands increment the completion counter in their BBROB entry. Once the counter
reaches the expected BB size, the BB is marked complete. BBE can commit up to
one BB per cycle, allowing bulk commit using one port to the table. At commit,
    the global write operands in the BB will be marked non-speculative.

%Discussion on what is held on each BBROB entry: BBID, number of completed
%basic-block instructions, total number of instructions in the BB that need to
%complete, valid bit, mis-speculation bit, global physical register writes.

%Discussion on how basic-block entry updates the GRF upon commit through its
%global physical register writes (its GRF write register(s) go from speculative
%to architectural).

%After the decode stage, a BB entry is reserved in BBROB, and when all
%instructions in a basic-block are completed and the basic-block reaches the head
%of the BBROB, the basic-block is committed as a whole in one cycle. Upon a branch
%mis-speculation event (either branch or memory), younger basic-blocks are flushed
%in one cycle. (TODO: talk more about the squash process here)
