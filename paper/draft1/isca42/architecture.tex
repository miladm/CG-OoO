\section{Compiler structure}
\label{sec:arch}

In this section, we discuss the compiler passes used to construct BBE program
binary as well as the micro-architectural blocks designed to support BBE.

We run binary translation on the x86 ISA to generate the program control flow.
Once basic-blocks are identified, a number of elements in each BB must be set;
special basic-block header (\texttt{Head}) instructions must be inserted, an
energy-aware register allocation model is run, and a pass of instruction
scheduling is done to generate the optimal static schedule for each basic-block.
In this work, a basic-block is defined to end with a \texttt{br}, \texttt{jmp},
   \texttt{call}, or \texttt{return}. It is also terminated when the
   the basic-block reaches 16 instructions. %TODO specify how rare is this

Two register allocation passes are done on the compiler to generate instruction
operands. The first pass finds the register operands live beyond the boundaries
of the basic-block, and the second pass allocates registers live only within the
basic-block boundaries. The former is a global register and the latter is a
local register. The motivation to build separate register operands is to avoid
register renaming on short-lived registers and instead store them in statically
managed, small and energy efficient register files. As discussed later, we find
the energy difference between accessing a physical register file and a local
register to be about 14x. To further save energy, for cases with a global DEF
followed by one or more global USE of the same physical register, a copy of the
operand is stored locally for the USE operation(s). When more then one operand
in a basic-block reads from a global register, a \texttt{MOV loc, glb}
operation is inserted prior to the reads to bring the operation to the local
register space prior to the readers. With these assumptions, global read and
write operands within each basic-block access the global register file once.

At runtime, the decoder stage identifies the beginning of a new basic-block by
the special {\it{Header}} instruction. As shown in Figure~\ref{fig:header_ins}
Header contains 1) the instruction address of the branch instruction in the BB
(if any) and 2) the global ready architectural register read operands. BR ADDR
is used to lookup the BPU to find the next basic-block. It is stored in Header
to 1) initiate fetch of the next speculative BB early, and 2) to enable BPU
access {\it{after}} instruction decode, when Head is detected, but branch is
potentially not yet fetched so that {\it{only}} Head instructions access BPU
rather than all fetched instructions. Read register operands are removed from
their original operands and compressed into Head to 1) enable renaming bypass by
all instructions except Head, and 2) shorten the frontend pipeline depth.
\texttt{Head2} is an extension to \texttt{Head} for BB's with more than three
global operands. %TODO how often?

%TODO discuss instruction scheduling

\begin{figure}
	\centering
	\includegraphics[width=1.0\columnwidth]{fig/header_ins.pdf} 
    \caption{\texttt{Head} and \texttt{Head2} instructions represent BB
        header information. \texttt{Head2} is only used for basic-blocks with
            more than three global read operands. BR ADDR represents the address
            offset of the branch operation at the end of the BB. V bits specify
            how many of the register operands are valid and whether BR ADDR
            holds a valid entry.}
	\label{fig:header_ins}
\end{figure}

\section{Microarchitecture}

%Coarse grain execution exposes energy saving opportunities in most pipeline
%stages. In this section we discuss the flow of basicblocks through different
%pipeline stages and elaborate on how energy is saved in each stage.

Figure~\ref{fig:bb_arch} shows the basic-block execution micro-architecture. The
hardware units distinguishing BBE from OoO are Basic-block Window (BB Window),
         Local Register File (LRF), Basic-block Re-order Buffer (BB-ROB), the
         Register Rename bypass line, basic-block scheduler, and the branch
         Prediction lookup line coming out from the BB Scheduler rather than
         instruction scheduler. 

provide an example of the execution here.  it should contain a code with
multiple BB's with local/global registers, header ins.  It should show flow of
BB in a 2-wide machine. provide execution schedule, update and issue register
activity. instruction issue logic information.

\input{cpu_frontend}

\begin{figure}
	\centering
	\includegraphics[width=1.0\columnwidth]{fig/bb_architecture.pdf} 
	\caption{Basicblock execution microarchitecture}
	\label{fig:bb_arch}
\end{figure}


\begin{figure*}
	\centering
	\includegraphics[width=\textwidth]{fig/pipeline.pdf} 
	\caption{Basicblock execution pipeline}
	\label{fig:pipeline}
\end{figure*}


\input{cpu_backend}

%\input{scheduling}

\input{speculation}

%TODO discuss how large basicblocks are partitioned.
%TODO Talk about exception handling here.
